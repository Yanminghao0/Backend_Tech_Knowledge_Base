# Mapperä»£ç†æºç è§£æ

> æ·±å…¥åˆ†æMyBatis Mapperæ¥å£ä»£ç†æœºåˆ¶ï¼Œç†è§£æ¥å£æ–¹æ³•å¦‚ä½•æ‰§è¡ŒSQL

---

## ğŸ“š ç›®å½•

1. [æ•´ä½“æ¶æ„](#1-æ•´ä½“æ¶æ„)
2. [MapperRegistryæ³¨å†Œä¸­å¿ƒ](#2-mapperregistryæ³¨å†Œä¸­å¿ƒ)
3. [MapperProxyFactoryä»£ç†å·¥å‚](#3-mapperproxyfactoryä»£ç†å·¥å‚)
4. [MapperProxyä»£ç†ç±»](#4-mapperproxyä»£ç†ç±»)
5. [MapperMethodæ–¹æ³•æ‰§è¡Œ](#5-mappermethodæ–¹æ³•æ‰§è¡Œ)
6. [å‚æ•°å¤„ç†](#6-å‚æ•°å¤„ç†)
7. [æµç¨‹å›¾è§£](#7-æµç¨‹å›¾è§£)
8. [é¢è¯•è¦ç‚¹](#8-é¢è¯•è¦ç‚¹)

---

## 1. æ•´ä½“æ¶æ„

### 1.1 Mapperä»£ç†æ ¸å¿ƒç±»

```
Mapperä»£ç†ç›¸å…³ç±»ï¼š

MapperRegistry          # Mapperæ³¨å†Œä¸­å¿ƒï¼Œç®¡ç†æ‰€æœ‰Mapper
    â”‚
    â–¼
MapperProxyFactory<T>   # Mapperä»£ç†å·¥å‚ï¼Œåˆ›å»ºä»£ç†å®ä¾‹
    â”‚
    â–¼
MapperProxy<T>          # Mapperä»£ç†ç±»ï¼Œå®ç°InvocationHandler
    â”‚
    â–¼
MapperMethod            # Mapperæ–¹æ³•ï¼Œå°è£…SQLæ‰§è¡Œé€»è¾‘
    â”‚
    â”œâ”€â”€ SqlCommand      # SQLå‘½ä»¤ï¼ˆç±»å‹ã€IDï¼‰
    â””â”€â”€ MethodSignature # æ–¹æ³•ç­¾åï¼ˆè¿”å›ç±»å‹ã€å‚æ•°ç­‰ï¼‰
```

### 1.2 ä»£ç†åˆ›å»ºæµç¨‹

```
sqlSession.getMapper(UserMapper.class)
                â”‚
                â–¼
    Configuration.getMapper()
                â”‚
                â–¼
    MapperRegistry.getMapper()
                â”‚
                â–¼
    MapperProxyFactory.newInstance()
                â”‚
                â–¼
    Proxy.newProxyInstance()
                â”‚
                â–¼
    è¿”å› UserMapper ä»£ç†å¯¹è±¡
```


---

## 2. MapperRegistryæ³¨å†Œä¸­å¿ƒ

### 2.1 æ ¸å¿ƒå±æ€§å’Œæ–¹æ³•

```java
/**
 * MapperRegistryï¼šMapperæ³¨å†Œä¸­å¿ƒ
 * ç®¡ç†æ‰€æœ‰Mapperæ¥å£å’Œå¯¹åº”çš„ä»£ç†å·¥å‚
 */
public class MapperRegistry {
    
    // å…¨å±€é…ç½®
    private final Configuration config;
    
    // å·²æ³¨å†Œçš„Mapperï¼šæ¥å£ç±»å‹ -> ä»£ç†å·¥å‚
    private final Map<Class<?>, MapperProxyFactory<?>> knownMappers = new HashMap<>();
    
    public MapperRegistry(Configuration config) {
        this.config = config;
    }
    
    /**
     * è·å–Mapperä»£ç†å®ä¾‹
     */
    @SuppressWarnings("unchecked")
    public <T> T getMapper(Class<T> type, SqlSession sqlSession) {
        // 1. è·å–ä»£ç†å·¥å‚
        final MapperProxyFactory<T> mapperProxyFactory = 
            (MapperProxyFactory<T>) knownMappers.get(type);
        if (mapperProxyFactory == null) {
            throw new BindingException("Type " + type + " is not known to the MapperRegistry.");
        }
        try {
            // 2. åˆ›å»ºä»£ç†å®ä¾‹
            return mapperProxyFactory.newInstance(sqlSession);
        } catch (Exception e) {
            throw new BindingException("Error getting mapper instance. Cause: " + e, e);
        }
    }
    
    /**
     * åˆ¤æ–­æ˜¯å¦å·²æ³¨å†Œ
     */
    public <T> boolean hasMapper(Class<T> type) {
        return knownMappers.containsKey(type);
    }
    
    /**
     * æ³¨å†ŒMapperæ¥å£
     */
    public <T> void addMapper(Class<T> type) {
        // å¿…é¡»æ˜¯æ¥å£
        if (type.isInterface()) {
            if (hasMapper(type)) {
                throw new BindingException("Type " + type + " is already known to the MapperRegistry.");
            }
            boolean loadCompleted = false;
            try {
                // åˆ›å»ºä»£ç†å·¥å‚å¹¶æ³¨å†Œ
                knownMappers.put(type, new MapperProxyFactory<>(type));
                // è§£æMapperæ¥å£ä¸Šçš„æ³¨è§£
                MapperAnnotationBuilder parser = new MapperAnnotationBuilder(config, type);
                parser.parse();
                loadCompleted = true;
            } finally {
                if (!loadCompleted) {
                    knownMappers.remove(type);
                }
            }
        }
    }
    
    /**
     * æ‰¹é‡æ·»åŠ Mapperï¼ˆæ‰«æåŒ…ï¼‰
     */
    public void addMappers(String packageName, Class<?> superType) {
        ResolverUtil<Class<?>> resolverUtil = new ResolverUtil<>();
        resolverUtil.find(new ResolverUtil.IsA(superType), packageName);
        Set<Class<? extends Class<?>>> mapperSet = resolverUtil.getClasses();
        for (Class<?> mapperClass : mapperSet) {
            addMapper(mapperClass);
        }
    }
}
```

---

## 3. MapperProxyFactoryä»£ç†å·¥å‚

### 3.1 å·¥å‚ç±»æºç 

```java
/**
 * MapperProxyFactoryï¼šMapperä»£ç†å·¥å‚
 * è´Ÿè´£åˆ›å»ºMapperæ¥å£çš„ä»£ç†å®ä¾‹
 */
public class MapperProxyFactory<T> {
    
    // Mapperæ¥å£ç±»å‹
    private final Class<T> mapperInterface;
    
    // æ–¹æ³•ç¼“å­˜ï¼šMethod -> MapperMethod
    private final Map<Method, MapperMethod> methodCache = new ConcurrentHashMap<>();
    
    public MapperProxyFactory(Class<T> mapperInterface) {
        this.mapperInterface = mapperInterface;
    }
    
    public Class<T> getMapperInterface() {
        return mapperInterface;
    }
    
    public Map<Method, MapperMethod> getMethodCache() {
        return methodCache;
    }
    
    /**
     * åˆ›å»ºä»£ç†å®ä¾‹ï¼ˆä½¿ç”¨å·²æœ‰çš„SqlSessionï¼‰
     */
    @SuppressWarnings("unchecked")
    protected T newInstance(MapperProxy<T> mapperProxy) {
        // ä½¿ç”¨JDKåŠ¨æ€ä»£ç†åˆ›å»ºå®ä¾‹
        return (T) Proxy.newProxyInstance(
            mapperInterface.getClassLoader(),
            new Class[] { mapperInterface },
            mapperProxy
        );
    }
    
    /**
     * åˆ›å»ºä»£ç†å®ä¾‹
     */
    public T newInstance(SqlSession sqlSession) {
        // 1. åˆ›å»ºMapperProxyï¼ˆInvocationHandlerï¼‰
        final MapperProxy<T> mapperProxy = new MapperProxy<>(
            sqlSession, mapperInterface, methodCache);
        // 2. åˆ›å»ºä»£ç†å®ä¾‹
        return newInstance(mapperProxy);
    }
}
```

---

## 4. MapperProxyä»£ç†ç±»

### 4.1 ä»£ç†ç±»æºç 

```java
/**
 * MapperProxyï¼šMapperä»£ç†ç±»
 * å®ç°InvocationHandlerï¼Œæ‹¦æˆªMapperæ¥å£æ–¹æ³•è°ƒç”¨
 */
public class MapperProxy<T> implements InvocationHandler, Serializable {
    
    private static final long serialVersionUID = -6424540398559729838L;
    
    // SqlSession
    private final SqlSession sqlSession;
    
    // Mapperæ¥å£ç±»å‹
    private final Class<T> mapperInterface;
    
    // æ–¹æ³•ç¼“å­˜
    private final Map<Method, MapperMethod> methodCache;
    
    public MapperProxy(SqlSession sqlSession, Class<T> mapperInterface,
            Map<Method, MapperMethod> methodCache) {
        this.sqlSession = sqlSession;
        this.mapperInterface = mapperInterface;
        this.methodCache = methodCache;
    }
    
    /**
     * ä»£ç†æ–¹æ³•è°ƒç”¨
     */
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        try {
            // 1. Objectç±»çš„æ–¹æ³•ç›´æ¥è°ƒç”¨
            if (Object.class.equals(method.getDeclaringClass())) {
                return method.invoke(this, args);
            }
            // 2. æ¥å£é»˜è®¤æ–¹æ³•ï¼ˆJava 8+ï¼‰
            else if (method.isDefault()) {
                return invokeDefaultMethod(proxy, method, args);
            }
        } catch (Throwable t) {
            throw ExceptionUtil.unwrapThrowable(t);
        }
        // 3. Mapperæ¥å£æ–¹æ³•ï¼šè·å–MapperMethodå¹¶æ‰§è¡Œ
        final MapperMethod mapperMethod = cachedMapperMethod(method);
        return mapperMethod.execute(sqlSession, args);
    }
    
    /**
     * è·å–ç¼“å­˜çš„MapperMethod
     */
    private MapperMethod cachedMapperMethod(Method method) {
        return methodCache.computeIfAbsent(method, 
            k -> new MapperMethod(mapperInterface, method, sqlSession.getConfiguration()));
    }
    
    /**
     * è°ƒç”¨æ¥å£é»˜è®¤æ–¹æ³•
     */
    private Object invokeDefaultMethod(Object proxy, Method method, Object[] args)
            throws Throwable {
        final Constructor<MethodHandles.Lookup> constructor = 
            MethodHandles.Lookup.class.getDeclaredConstructor(Class.class, int.class);
        if (!constructor.isAccessible()) {
            constructor.setAccessible(true);
        }
        final Class<?> declaringClass = method.getDeclaringClass();
        return constructor
            .newInstance(declaringClass, 
                MethodHandles.Lookup.PRIVATE | MethodHandles.Lookup.PROTECTED |
                MethodHandles.Lookup.PACKAGE | MethodHandles.Lookup.PUBLIC)
            .unreflectSpecial(method, declaringClass)
            .bindTo(proxy)
            .invokeWithArguments(args);
    }
}
```

---

## 5. MapperMethodæ–¹æ³•æ‰§è¡Œ

### 5.1 MapperMethodæ ¸å¿ƒç»“æ„

```java
/**
 * MapperMethodï¼šå°è£…Mapperæ–¹æ³•çš„æ‰§è¡Œé€»è¾‘
 */
public class MapperMethod {
    
    // SQLå‘½ä»¤ä¿¡æ¯
    private final SqlCommand command;
    
    // æ–¹æ³•ç­¾åä¿¡æ¯
    private final MethodSignature method;
    
    public MapperMethod(Class<?> mapperInterface, Method method, Configuration config) {
        this.command = new SqlCommand(config, mapperInterface, method);
        this.method = new MethodSignature(config, mapperInterface, method);
    }
    
    /**
     * æ‰§è¡Œæ–¹æ³•
     */
    public Object execute(SqlSession sqlSession, Object[] args) {
        Object result;
        switch (command.getType()) {
            case INSERT: {
                Object param = method.convertArgsToSqlCommandParam(args);
                result = rowCountResult(sqlSession.insert(command.getName(), param));
                break;
            }
            case UPDATE: {
                Object param = method.convertArgsToSqlCommandParam(args);
                result = rowCountResult(sqlSession.update(command.getName(), param));
                break;
            }
            case DELETE: {
                Object param = method.convertArgsToSqlCommandParam(args);
                result = rowCountResult(sqlSession.delete(command.getName(), param));
                break;
            }
            case SELECT:
                if (method.returnsVoid() && method.hasResultHandler()) {
                    // è¿”å›voidï¼Œä½¿ç”¨ResultHandler
                    executeWithResultHandler(sqlSession, args);
                    result = null;
                } else if (method.returnsMany()) {
                    // è¿”å›é›†åˆ
                    result = executeForMany(sqlSession, args);
                } else if (method.returnsMap()) {
                    // è¿”å›Map
                    result = executeForMap(sqlSession, args);
                } else if (method.returnsCursor()) {
                    // è¿”å›æ¸¸æ ‡
                    result = executeForCursor(sqlSession, args);
                } else {
                    // è¿”å›å•ä¸ªå¯¹è±¡
                    Object param = method.convertArgsToSqlCommandParam(args);
                    result = sqlSession.selectOne(command.getName(), param);
                    if (method.returnsOptional() && 
                        (result == null || !method.getReturnType().equals(result.getClass()))) {
                        result = Optional.ofNullable(result);
                    }
                }
                break;
            case FLUSH:
                result = sqlSession.flushStatements();
                break;
            default:
                throw new BindingException("Unknown execution method for: " + command.getName());
        }
        // å¤„ç†è¿”å›å€¼ä¸ºnullä½†æ–¹æ³•è¿”å›åŸºæœ¬ç±»å‹çš„æƒ…å†µ
        if (result == null && method.getReturnType().isPrimitive() && !method.returnsVoid()) {
            throw new BindingException("Mapper method '" + command.getName() +
                "' attempted to return null from a method with a primitive return type (" +
                method.getReturnType() + ").");
        }
        return result;
    }
}
```

### 5.2 SqlCommandå†…éƒ¨ç±»

```java
/**
 * SqlCommandï¼šSQLå‘½ä»¤ä¿¡æ¯
 */
public static class SqlCommand {
    
    // MappedStatementçš„IDï¼ˆnamespace.idï¼‰
    private final String name;
    
    // SQLç±»å‹ï¼ˆINSERT/UPDATE/DELETE/SELECT/FLUSHï¼‰
    private final SqlCommandType type;
    
    public SqlCommand(Configuration configuration, Class<?> mapperInterface, Method method) {
        final String methodName = method.getName();
        final Class<?> declaringClass = method.getDeclaringClass();
        // è§£æMappedStatement
        MappedStatement ms = resolveMappedStatement(configuration, mapperInterface, 
            methodName, declaringClass);
        if (ms == null) {
            if (method.getAnnotation(Flush.class) != null) {
                name = null;
                type = SqlCommandType.FLUSH;
            } else {
                throw new BindingException("Invalid bound statement (not found): " +
                    mapperInterface.getName() + "." + methodName);
            }
        } else {
            name = ms.getId();
            type = ms.getSqlCommandType();
            if (type == SqlCommandType.UNKNOWN) {
                throw new BindingException("Unknown execution method for: " + name);
            }
        }
    }
    
    /**
     * è§£æMappedStatement
     */
    private MappedStatement resolveMappedStatement(Configuration configuration,
            Class<?> mapperInterface, String methodName, Class<?> declaringClass) {
        // æ„å»ºstatementIdï¼šæ¥å£å…¨é™å®šå.æ–¹æ³•å
        String statementId = mapperInterface.getName() + "." + methodName;
        if (configuration.hasStatement(statementId)) {
            return configuration.getMappedStatement(statementId);
        } else if (mapperInterface.equals(declaringClass)) {
            return null;
        }
        // é€’å½’æŸ¥æ‰¾çˆ¶æ¥å£
        for (Class<?> superInterface : mapperInterface.getInterfaces()) {
            if (declaringClass.isAssignableFrom(superInterface)) {
                MappedStatement ms = resolveMappedStatement(configuration, 
                    superInterface, methodName, declaringClass);
                if (ms != null) {
                    return ms;
                }
            }
        }
        return null;
    }
}
```

### 5.3 MethodSignatureå†…éƒ¨ç±»

```java
/**
 * MethodSignatureï¼šæ–¹æ³•ç­¾åä¿¡æ¯
 */
public static class MethodSignature {
    
    private final boolean returnsMany;      // è¿”å›é›†åˆ
    private final boolean returnsMap;       // è¿”å›Map
    private final boolean returnsVoid;      // è¿”å›void
    private final boolean returnsCursor;    // è¿”å›Cursor
    private final boolean returnsOptional;  // è¿”å›Optional
    private final Class<?> returnType;      // è¿”å›ç±»å‹
    private final String mapKey;            // @MapKeyæ³¨è§£å€¼
    private final Integer resultHandlerIndex;  // ResultHandlerå‚æ•°ä½ç½®
    private final Integer rowBoundsIndex;      // RowBoundså‚æ•°ä½ç½®
    private final ParamNameResolver paramNameResolver;  // å‚æ•°åè§£æå™¨
    
    public MethodSignature(Configuration configuration, Class<?> mapperInterface, Method method) {
        // è§£æè¿”å›ç±»å‹
        Type resolvedReturnType = TypeParameterResolver.resolveReturnType(method, mapperInterface);
        if (resolvedReturnType instanceof Class<?>) {
            this.returnType = (Class<?>) resolvedReturnType;
        } else if (resolvedReturnType instanceof ParameterizedType) {
            this.returnType = (Class<?>) ((ParameterizedType) resolvedReturnType).getRawType();
        } else {
            this.returnType = method.getReturnType();
        }
        
        this.returnsVoid = void.class.equals(this.returnType);
        this.returnsMany = configuration.getObjectFactory().isCollection(this.returnType) ||
            this.returnType.isArray();
        this.returnsCursor = Cursor.class.equals(this.returnType);
        this.returnsOptional = Optional.class.equals(this.returnType);
        this.mapKey = getMapKey(method);
        this.returnsMap = this.mapKey != null;
        this.rowBoundsIndex = getUniqueParamIndex(method, RowBounds.class);
        this.resultHandlerIndex = getUniqueParamIndex(method, ResultHandler.class);
        this.paramNameResolver = new ParamNameResolver(configuration, method);
    }
    
    /**
     * è½¬æ¢å‚æ•°ä¸ºSQLå‘½ä»¤å‚æ•°
     */
    public Object convertArgsToSqlCommandParam(Object[] args) {
        return paramNameResolver.getNamedParams(args);
    }
}
```


---

## 6. å‚æ•°å¤„ç†

### 6.1 ParamNameResolverå‚æ•°è§£æå™¨

```java
/**
 * ParamNameResolverï¼šå‚æ•°åè§£æå™¨
 * è§£ææ–¹æ³•å‚æ•°ï¼Œæ”¯æŒ@Paramæ³¨è§£
 */
public class ParamNameResolver {
    
    public static final String GENERIC_NAME_PREFIX = "param";
    
    // å‚æ•°ç´¢å¼• -> å‚æ•°å
    private final SortedMap<Integer, String> names;
    
    private boolean hasParamAnnotation;
    
    public ParamNameResolver(Configuration config, Method method) {
        final Class<?>[] paramTypes = method.getParameterTypes();
        final Annotation[][] paramAnnotations = method.getParameterAnnotations();
        final SortedMap<Integer, String> map = new TreeMap<>();
        int paramCount = paramAnnotations.length;
        
        for (int paramIndex = 0; paramIndex < paramCount; paramIndex++) {
            // è·³è¿‡ç‰¹æ®Šå‚æ•°ï¼ˆRowBoundsã€ResultHandlerï¼‰
            if (isSpecialParameter(paramTypes[paramIndex])) {
                continue;
            }
            String name = null;
            // æŸ¥æ‰¾@Paramæ³¨è§£
            for (Annotation annotation : paramAnnotations[paramIndex]) {
                if (annotation instanceof Param) {
                    hasParamAnnotation = true;
                    name = ((Param) annotation).value();
                    break;
                }
            }
            if (name == null) {
                // ä½¿ç”¨å‚æ•°åï¼ˆéœ€è¦ç¼–è¯‘æ—¶ä¿ç•™å‚æ•°åï¼‰
                if (config.isUseActualParamName()) {
                    name = getActualParamName(method, paramIndex);
                }
                if (name == null) {
                    // ä½¿ç”¨ç´¢å¼•ä½œä¸ºåç§°
                    name = String.valueOf(map.size());
                }
            }
            map.put(paramIndex, name);
        }
        names = Collections.unmodifiableSortedMap(map);
    }
    
    /**
     * è·å–å‘½åå‚æ•°
     */
    public Object getNamedParams(Object[] args) {
        final int paramCount = names.size();
        if (args == null || paramCount == 0) {
            return null;
        }
        // å•ä¸ªå‚æ•°ä¸”æ— @Paramæ³¨è§£
        else if (!hasParamAnnotation && paramCount == 1) {
            return args[names.firstKey()];
        }
        // å¤šä¸ªå‚æ•°æˆ–æœ‰@Paramæ³¨è§£
        else {
            final Map<String, Object> param = new ParamMap<>();
            int i = 0;
            for (Map.Entry<Integer, String> entry : names.entrySet()) {
                // ä½¿ç”¨@ParamæŒ‡å®šçš„åç§°æˆ–é»˜è®¤åç§°
                param.put(entry.getValue(), args[entry.getKey()]);
                // åŒæ—¶æ·»åŠ param1, param2...
                final String genericParamName = GENERIC_NAME_PREFIX + (i + 1);
                if (!names.containsValue(genericParamName)) {
                    param.put(genericParamName, args[entry.getKey()]);
                }
                i++;
            }
            return param;
        }
    }
}
```

### 6.2 å‚æ•°å¤„ç†ç¤ºä¾‹

```java
/**
 * å‚æ•°å¤„ç†ç¤ºä¾‹
 */
public interface UserMapper {
    
    // å•ä¸ªå‚æ•°ï¼Œæ— @Param
    // SQLä¸­ä½¿ç”¨ï¼š#{id} æˆ– #{param1}
    User selectById(Long id);
    
    // å•ä¸ªå‚æ•°ï¼Œæœ‰@Param
    // SQLä¸­ä½¿ç”¨ï¼š#{userId} æˆ– #{param1}
    User selectByUserId(@Param("userId") Long id);
    
    // å¤šä¸ªå‚æ•°ï¼Œæ— @Param
    // SQLä¸­ä½¿ç”¨ï¼š#{param1}, #{param2} æˆ– #{0}, #{1}
    User selectByNameAndAge(String name, Integer age);
    
    // å¤šä¸ªå‚æ•°ï¼Œæœ‰@Param
    // SQLä¸­ä½¿ç”¨ï¼š#{name}, #{age} æˆ– #{param1}, #{param2}
    User selectByCondition(@Param("name") String name, @Param("age") Integer age);
    
    // å¯¹è±¡å‚æ•°
    // SQLä¸­ä½¿ç”¨ï¼š#{name}, #{age}ï¼ˆå¯¹è±¡å±æ€§åï¼‰
    int insert(User user);
    
    // Mapå‚æ•°
    // SQLä¸­ä½¿ç”¨ï¼š#{key}ï¼ˆMapçš„keyï¼‰
    List<User> selectByMap(Map<String, Object> params);
    
    // é›†åˆå‚æ•°
    // SQLä¸­ä½¿ç”¨ï¼šcollection, list, array
    List<User> selectByIds(@Param("ids") List<Long> ids);
}
```

---

## 7. æµç¨‹å›¾è§£

### 7.1 Mapperä»£ç†åˆ›å»ºæµç¨‹

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                Mapperä»£ç†åˆ›å»ºæµç¨‹                            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

sqlSession.getMapper(UserMapper.class)
                â”‚
                â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Configuration.getMapper(type, sqlSession)                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                â”‚
                â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ MapperRegistry.getMapper(type, sqlSession)               â”‚
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚ â”‚ 1. ä»knownMappersè·å–MapperProxyFactory             â”‚ â”‚
â”‚ â”‚ 2. è°ƒç”¨factory.newInstance(sqlSession)              â”‚ â”‚
â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                â”‚
                â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ MapperProxyFactory.newInstance(sqlSession)               â”‚
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚ â”‚ 1. åˆ›å»ºMapperProxy(sqlSession, interface, cache)    â”‚ â”‚
â”‚ â”‚ 2. Proxy.newProxyInstance(loader, interfaces, proxy)â”‚ â”‚
â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                â”‚
                â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ è¿”å› UserMapper ä»£ç†å¯¹è±¡                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 7.2 Mapperæ–¹æ³•æ‰§è¡Œæµç¨‹

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                Mapperæ–¹æ³•æ‰§è¡Œæµç¨‹                            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

userMapper.selectById(1L)
                â”‚
                â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ MapperProxy.invoke(proxy, method, args)                  â”‚
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚ â”‚ 1. åˆ¤æ–­æ˜¯å¦Objectæ–¹æ³• â†’ ç›´æ¥è°ƒç”¨                     â”‚ â”‚
â”‚ â”‚ 2. åˆ¤æ–­æ˜¯å¦defaultæ–¹æ³• â†’ è°ƒç”¨é»˜è®¤å®ç°                â”‚ â”‚
â”‚ â”‚ 3. è·å–ç¼“å­˜çš„MapperMethod                           â”‚ â”‚
â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                â”‚
                â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ MapperMethod.execute(sqlSession, args)                   â”‚
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚ â”‚ 1. æ ¹æ®SqlCommand.typeåˆ¤æ–­æ“ä½œç±»å‹                   â”‚ â”‚
â”‚ â”‚ 2. è½¬æ¢å‚æ•°ï¼šconvertArgsToSqlCommandParam            â”‚ â”‚
â”‚ â”‚ 3. è°ƒç”¨SqlSessionå¯¹åº”æ–¹æ³•                           â”‚ â”‚
â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                â”‚
                â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ SqlSession.selectOne("namespace.selectById", param)      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                â”‚
                â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Executor.query() â†’ æ‰§è¡ŒSQL â†’ è¿”å›ç»“æœ                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 8. é¢è¯•è¦ç‚¹

### 8.1 é«˜é¢‘é¢è¯•é¢˜

```
Q1: Mapperæ¥å£æ²¡æœ‰å®ç°ç±»ï¼Œä¸ºä»€ä¹ˆèƒ½æ‰§è¡ŒSQLï¼Ÿ
A: MyBatisä½¿ç”¨JDKåŠ¨æ€ä»£ç†ä¸ºMapperæ¥å£åˆ›å»ºä»£ç†å¯¹è±¡ï¼š
   1. MapperProxyFactoryåˆ›å»ºMapperProxyï¼ˆInvocationHandlerï¼‰
   2. Proxy.newProxyInstanceåˆ›å»ºä»£ç†å®ä¾‹
   3. è°ƒç”¨æ–¹æ³•æ—¶ï¼ŒMapperProxy.invokeæ‹¦æˆª
   4. æ ¹æ®æ–¹æ³•åæ‰¾åˆ°å¯¹åº”çš„MappedStatement
   5. è°ƒç”¨SqlSessionæ‰§è¡ŒSQL

Q2: Mapperæ¥å£æ–¹æ³•èƒ½é‡è½½å—ï¼Ÿ
A: ä¸èƒ½ã€‚å› ä¸ºMyBatisé€šè¿‡"æ¥å£å…¨é™å®šå.æ–¹æ³•å"å®šä½MappedStatementï¼Œ
   é‡è½½æ–¹æ³•ä¼šå¯¼è‡´IDå†²çªã€‚

Q3: Mapperæ¥å£çš„å·¥ä½œåŸç†ï¼Ÿ
A: 1. å¯åŠ¨æ—¶æ‰«æMapperæ¥å£ï¼Œæ³¨å†Œåˆ°MapperRegistry
   2. ä¸ºæ¯ä¸ªæ¥å£åˆ›å»ºMapperProxyFactory
   3. getMapperæ—¶åˆ›å»ºä»£ç†å®ä¾‹
   4. æ–¹æ³•è°ƒç”¨æ—¶é€šè¿‡MapperMethodæ‰§è¡ŒSQL

Q4: @Paramæ³¨è§£çš„ä½œç”¨ï¼Ÿ
A: æŒ‡å®šå‚æ•°åç§°ï¼Œåœ¨SQLä¸­é€šè¿‡#{name}å¼•ç”¨ï¼š
   - å•å‚æ•°æ— @Paramï¼šç›´æ¥ä½¿ç”¨#{ä»»æ„å}
   - å¤šå‚æ•°æ— @Paramï¼šä½¿ç”¨#{param1}ã€#{param2}
   - æœ‰@Paramï¼šä½¿ç”¨#{æŒ‡å®šåç§°}

Q5: Mapperæ–¹æ³•çš„è¿”å›å€¼ç±»å‹æœ‰å“ªäº›ï¼Ÿ
A: - å•ä¸ªå¯¹è±¡ï¼šselectOne
   - Listé›†åˆï¼šselectList
   - Mapï¼šselectMapï¼ˆéœ€è¦@MapKeyï¼‰
   - Cursorï¼šæ¸¸æ ‡æŸ¥è¯¢
   - Optionalï¼šå¯é€‰å€¼
   - voidï¼šé…åˆResultHandlerä½¿ç”¨
   - int/longï¼šæ›´æ–°æ“ä½œè¿”å›å½±å“è¡Œæ•°
```

### 8.2 ä½¿ç”¨ç¤ºä¾‹

```java
/**
 * Mapperæ¥å£å®šä¹‰ç¤ºä¾‹
 */
@Mapper
public interface UserMapper {
    
    // åŸºæœ¬æŸ¥è¯¢
    @Select("SELECT * FROM user WHERE id = #{id}")
    User selectById(Long id);
    
    // å¤šå‚æ•°æŸ¥è¯¢
    @Select("SELECT * FROM user WHERE name = #{name} AND age = #{age}")
    List<User> selectByNameAndAge(@Param("name") String name, @Param("age") Integer age);
    
    // è¿”å›Map
    @MapKey("id")
    @Select("SELECT * FROM user")
    Map<Long, User> selectAllAsMap();
    
    // è¿”å›Optional
    @Select("SELECT * FROM user WHERE id = #{id}")
    Optional<User> findById(Long id);
    
    // æ’å…¥å¹¶è¿”å›è‡ªå¢ID
    @Insert("INSERT INTO user(name, age) VALUES(#{name}, #{age})")
    @Options(useGeneratedKeys = true, keyProperty = "id")
    int insert(User user);
    
    // æ‰¹é‡æ’å…¥
    @Insert("<script>" +
            "INSERT INTO user(name, age) VALUES " +
            "<foreach collection='list' item='user' separator=','>" +
            "(#{user.name}, #{user.age})" +
            "</foreach>" +
            "</script>")
    int batchInsert(@Param("list") List<User> users);
    
    // åŠ¨æ€SQL
    @Select("<script>" +
            "SELECT * FROM user WHERE 1=1" +
            "<if test='name != null'> AND name = #{name}</if>" +
            "<if test='age != null'> AND age = #{age}</if>" +
            "</script>")
    List<User> selectByCondition(@Param("name") String name, @Param("age") Integer age);
}
```

---

## ğŸ“š æ€»ç»“

### æ ¸å¿ƒè¦ç‚¹

1. **ä»£ç†æœºåˆ¶**ï¼šJDKåŠ¨æ€ä»£ç†ï¼ŒMapperProxyå®ç°InvocationHandler
2. **æ–¹æ³•æ˜ å°„**ï¼šæ¥å£å…¨é™å®šå.æ–¹æ³•å â†’ MappedStatement
3. **å‚æ•°å¤„ç†**ï¼šParamNameResolverè§£æ@Paramæ³¨è§£
4. **æ–¹æ³•ç¼“å­˜**ï¼šMapperMethodç¼“å­˜åœ¨MapperProxyFactoryä¸­

### æ ¸å¿ƒç±»èŒè´£

| ç±»å | èŒè´£ |
|------|------|
| MapperRegistry | ç®¡ç†æ‰€æœ‰Mapperæ¥å£ |
| MapperProxyFactory | åˆ›å»ºä»£ç†å®ä¾‹ |
| MapperProxy | æ‹¦æˆªæ–¹æ³•è°ƒç”¨ |
| MapperMethod | æ‰§è¡ŒSQLé€»è¾‘ |
| ParamNameResolver | è§£æå‚æ•° |

---

*æœ€åæ›´æ–°ï¼š2025-12-28*

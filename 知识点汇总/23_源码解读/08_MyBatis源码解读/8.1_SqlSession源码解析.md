# SqlSessionæºç è§£æ

> æ·±å…¥åˆ†æMyBatisæ ¸å¿ƒä¼šè¯æœºåˆ¶ï¼ŒæŒæ¡SQLæ‰§è¡Œçš„å®Œæ•´æµç¨‹

---

## ğŸ“š ç›®å½•

1. [æ•´ä½“æ¶æ„](#1-æ•´ä½“æ¶æ„)
2. [SqlSessionæ¥å£](#2-sqlsessionæ¥å£)
3. [DefaultSqlSessionæºç ](#3-defaultsqlsessionæºç )
4. [Executoræ‰§è¡Œå™¨](#4-executoræ‰§è¡Œå™¨)
5. [ä¸€çº§ç¼“å­˜](#5-ä¸€çº§ç¼“å­˜)
6. [äº‹åŠ¡ç®¡ç†](#6-äº‹åŠ¡ç®¡ç†)
7. [æµç¨‹å›¾è§£](#7-æµç¨‹å›¾è§£)
8. [é¢è¯•è¦ç‚¹](#8-é¢è¯•è¦ç‚¹)

---

## 1. æ•´ä½“æ¶æ„

### 1.1 SqlSessionåœ¨MyBatisä¸­çš„ä½ç½®

```
MyBatisæ ¸å¿ƒç»„ä»¶ï¼š

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     Application                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                           â”‚
                           â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   SqlSessionFactory                         â”‚
â”‚                   (åˆ›å»ºSqlSession)                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                           â”‚
                           â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      SqlSession                             â”‚
â”‚              (æ‰§è¡ŒSQLã€ç®¡ç†äº‹åŠ¡ã€è·å–Mapper)                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                           â”‚
              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
              â”‚            â”‚            â”‚
              â–¼            â–¼            â–¼
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚ Executor â”‚ â”‚  Mapper  â”‚ â”‚Transactionâ”‚
        â”‚ (æ‰§è¡Œå™¨) â”‚ â”‚  (ä»£ç†)  â”‚ â”‚  (äº‹åŠ¡)  â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              â”‚
              â–¼
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚ StatementHandler â†’ ParameterHandler  â”‚
        â”‚        â†“                             â”‚
        â”‚   ResultSetHandler                   â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 1.2 æ ¸å¿ƒç±»å…³ç³»

```
SqlSession (æ¥å£)
â”œâ”€â”€ DefaultSqlSession (é»˜è®¤å®ç°)
â””â”€â”€ SqlSessionManager (çº¿ç¨‹å®‰å…¨åŒ…è£…)

SqlSessionFactory (æ¥å£)
â””â”€â”€ DefaultSqlSessionFactory (é»˜è®¤å®ç°)

Executor (æ¥å£)
â”œâ”€â”€ BaseExecutor (æŠ½è±¡åŸºç±»)
â”‚   â”œâ”€â”€ SimpleExecutor (ç®€å•æ‰§è¡Œå™¨)
â”‚   â”œâ”€â”€ ReuseExecutor (é‡ç”¨æ‰§è¡Œå™¨)
â”‚   â””â”€â”€ BatchExecutor (æ‰¹é‡æ‰§è¡Œå™¨)
â””â”€â”€ CachingExecutor (äºŒçº§ç¼“å­˜æ‰§è¡Œå™¨ï¼Œè£…é¥°å™¨)
```


---

## 2. SqlSessionæ¥å£

### 2.1 æ¥å£å®šä¹‰

```java
/**
 * SqlSessionï¼šMyBatisçš„æ ¸å¿ƒæ¥å£
 * 
 * èŒè´£ï¼š
 * 1. æ‰§è¡ŒSQLè¯­å¥ï¼ˆselect/insert/update/deleteï¼‰
 * 2. è·å–Mapperæ¥å£ä»£ç†
 * 3. ç®¡ç†äº‹åŠ¡ï¼ˆcommit/rollbackï¼‰
 * 4. ç®¡ç†ä¸€çº§ç¼“å­˜
 */
public interface SqlSession extends Closeable {
    
    // ========== æŸ¥è¯¢æ–¹æ³• ==========
    
    /**
     * æŸ¥è¯¢å•æ¡è®°å½•
     */
    <T> T selectOne(String statement);
    <T> T selectOne(String statement, Object parameter);
    
    /**
     * æŸ¥è¯¢å¤šæ¡è®°å½•
     */
    <E> List<E> selectList(String statement);
    <E> List<E> selectList(String statement, Object parameter);
    <E> List<E> selectList(String statement, Object parameter, RowBounds rowBounds);
    
    /**
     * æŸ¥è¯¢è¿”å›Map
     */
    <K, V> Map<K, V> selectMap(String statement, String mapKey);
    <K, V> Map<K, V> selectMap(String statement, Object parameter, String mapKey);
    
    /**
     * æŸ¥è¯¢è¿”å›æ¸¸æ ‡ï¼ˆå¤§æ•°æ®é‡ï¼‰
     */
    <T> Cursor<T> selectCursor(String statement);
    <T> Cursor<T> selectCursor(String statement, Object parameter);
    
    /**
     * æŸ¥è¯¢ä½¿ç”¨ResultHandlerå¤„ç†
     */
    void select(String statement, Object parameter, ResultHandler handler);
    
    // ========== æ›´æ–°æ–¹æ³• ==========
    
    int insert(String statement);
    int insert(String statement, Object parameter);
    
    int update(String statement);
    int update(String statement, Object parameter);
    
    int delete(String statement);
    int delete(String statement, Object parameter);
    
    // ========== äº‹åŠ¡æ–¹æ³• ==========
    
    void commit();
    void commit(boolean force);
    
    void rollback();
    void rollback(boolean force);
    
    // ========== å…¶ä»–æ–¹æ³• ==========
    
    /**
     * è·å–Mapperæ¥å£ä»£ç†
     */
    <T> T getMapper(Class<T> type);
    
    /**
     * è·å–Configuration
     */
    Configuration getConfiguration();
    
    /**
     * è·å–æ•°æ®åº“è¿æ¥
     */
    Connection getConnection();
    
    /**
     * æ¸…ç©ºä¸€çº§ç¼“å­˜
     */
    void clearCache();
    
    /**
     * å…³é—­SqlSession
     */
    void close();
}
```

---

## 3. DefaultSqlSessionæºç 

### 3.1 æ ¸å¿ƒå±æ€§

```java
public class DefaultSqlSession implements SqlSession {
    
    /**
     * å…¨å±€é…ç½®
     */
    private final Configuration configuration;
    
    /**
     * æ‰§è¡Œå™¨ï¼ˆçœŸæ­£æ‰§è¡ŒSQLçš„ç»„ä»¶ï¼‰
     */
    private final Executor executor;
    
    /**
     * æ˜¯å¦è‡ªåŠ¨æäº¤
     */
    private final boolean autoCommit;
    
    /**
     * æ˜¯å¦æœ‰è„æ•°æ®ï¼ˆæ‰§è¡Œè¿‡æ›´æ–°æ“ä½œï¼‰
     */
    private boolean dirty;
    
    /**
     * æ¸¸æ ‡åˆ—è¡¨ï¼ˆç”¨äºå…³é—­æ—¶æ¸…ç†ï¼‰
     */
    private List<Cursor<?>> cursorList;
    
    public DefaultSqlSession(Configuration configuration, Executor executor, 
            boolean autoCommit) {
        this.configuration = configuration;
        this.executor = executor;
        this.dirty = false;
        this.autoCommit = autoCommit;
    }
}
```

### 3.2 selectOneæ–¹æ³•

```java
/**
 * æŸ¥è¯¢å•æ¡è®°å½•
 */
@Override
public <T> T selectOne(String statement, Object parameter) {
    // è°ƒç”¨selectListï¼ŒæœŸæœ›è¿”å›ä¸€æ¡æˆ–é›¶æ¡
    List<T> list = this.selectList(statement, parameter);
    if (list.size() == 1) {
        return list.get(0);
    } else if (list.size() > 1) {
        // è¿”å›å¤šæ¡æ—¶æŠ›å‡ºå¼‚å¸¸
        throw new TooManyResultsException(
            "Expected one result (or null) to be returned by selectOne(), " +
            "but found: " + list.size());
    } else {
        return null;
    }
}
```

### 3.3 selectListæ–¹æ³•

```java
/**
 * æŸ¥è¯¢å¤šæ¡è®°å½•
 */
@Override
public <E> List<E> selectList(String statement, Object parameter, RowBounds rowBounds) {
    try {
        // 1. ä»Configurationè·å–MappedStatement
        MappedStatement ms = configuration.getMappedStatement(statement);
        
        // 2. è°ƒç”¨Executoræ‰§è¡ŒæŸ¥è¯¢
        return executor.query(ms, wrapCollection(parameter), rowBounds, 
            Executor.NO_RESULT_HANDLER);
    } catch (Exception e) {
        throw ExceptionFactory.wrapException(
            "Error querying database. Cause: " + e, e);
    } finally {
        ErrorContext.instance().reset();
    }
}

/**
 * åŒ…è£…é›†åˆå‚æ•°
 */
private Object wrapCollection(final Object object) {
    if (object instanceof Collection) {
        StrictMap<Object> map = new StrictMap<>();
        map.put("collection", object);
        if (object instanceof List) {
            map.put("list", object);
        }
        return map;
    } else if (object != null && object.getClass().isArray()) {
        StrictMap<Object> map = new StrictMap<>();
        map.put("array", object);
        return map;
    }
    return object;
}
```

### 3.4 insert/update/deleteæ–¹æ³•

```java
/**
 * æ’å…¥
 */
@Override
public int insert(String statement, Object parameter) {
    return update(statement, parameter);
}

/**
 * åˆ é™¤
 */
@Override
public int delete(String statement, Object parameter) {
    return update(statement, parameter);
}

/**
 * æ›´æ–°ï¼ˆinsert/update/deleteéƒ½è°ƒç”¨æ­¤æ–¹æ³•ï¼‰
 */
@Override
public int update(String statement, Object parameter) {
    try {
        // æ ‡è®°æœ‰è„æ•°æ®
        dirty = true;
        // è·å–MappedStatement
        MappedStatement ms = configuration.getMappedStatement(statement);
        // è°ƒç”¨Executoræ‰§è¡Œæ›´æ–°
        return executor.update(ms, wrapCollection(parameter));
    } catch (Exception e) {
        throw ExceptionFactory.wrapException(
            "Error updating database. Cause: " + e, e);
    } finally {
        ErrorContext.instance().reset();
    }
}
```

### 3.5 getMapperæ–¹æ³•

```java
/**
 * è·å–Mapperæ¥å£ä»£ç†
 */
@Override
public <T> T getMapper(Class<T> type) {
    // å§”æ‰˜ç»™Configuration
    return configuration.getMapper(type, this);
}

// Configurationä¸­çš„å®ç°
public <T> T getMapper(Class<T> type, SqlSession sqlSession) {
    // å§”æ‰˜ç»™MapperRegistry
    return mapperRegistry.getMapper(type, sqlSession);
}

// MapperRegistryä¸­çš„å®ç°
public <T> T getMapper(Class<T> type, SqlSession sqlSession) {
    // è·å–MapperProxyFactory
    final MapperProxyFactory<T> mapperProxyFactory = 
        (MapperProxyFactory<T>) knownMappers.get(type);
    if (mapperProxyFactory == null) {
        throw new BindingException("Type " + type + " is not known to the MapperRegistry.");
    }
    try {
        // åˆ›å»ºä»£ç†å®ä¾‹
        return mapperProxyFactory.newInstance(sqlSession);
    } catch (Exception e) {
        throw new BindingException("Error getting mapper instance. Cause: " + e, e);
    }
}
```

### 3.6 äº‹åŠ¡æ–¹æ³•

```java
/**
 * æäº¤äº‹åŠ¡
 */
@Override
public void commit(boolean force) {
    try {
        // è°ƒç”¨Executoræäº¤
        executor.commit(isCommitOrRollbackRequired(force));
        dirty = false;
    } catch (Exception e) {
        throw ExceptionFactory.wrapException(
            "Error committing transaction. Cause: " + e, e);
    } finally {
        ErrorContext.instance().reset();
    }
}

/**
 * å›æ»šäº‹åŠ¡
 */
@Override
public void rollback(boolean force) {
    try {
        // è°ƒç”¨Executorå›æ»š
        executor.rollback(isCommitOrRollbackRequired(force));
        dirty = false;
    } catch (Exception e) {
        throw ExceptionFactory.wrapException(
            "Error rolling back transaction. Cause: " + e, e);
    } finally {
        ErrorContext.instance().reset();
    }
}

/**
 * åˆ¤æ–­æ˜¯å¦éœ€è¦æäº¤æˆ–å›æ»š
 */
private boolean isCommitOrRollbackRequired(boolean force) {
    return (!autoCommit && dirty) || force;
}

/**
 * å…³é—­SqlSession
 */
@Override
public void close() {
    try {
        // å…³é—­Executor
        executor.close(isCommitOrRollbackRequired(false));
        // å…³é—­æ¸¸æ ‡
        closeCursors();
        dirty = false;
    } finally {
        ErrorContext.instance().reset();
    }
}
```


---

## 4. Executoræ‰§è¡Œå™¨

### 4.1 Executoræ¥å£

```java
/**
 * Executorï¼šSQLæ‰§è¡Œå™¨æ¥å£
 */
public interface Executor {
    
    ResultHandler NO_RESULT_HANDLER = null;
    
    // æ›´æ–°æ“ä½œ
    int update(MappedStatement ms, Object parameter) throws SQLException;
    
    // æŸ¥è¯¢æ“ä½œ
    <E> List<E> query(MappedStatement ms, Object parameter, RowBounds rowBounds,
        ResultHandler resultHandler) throws SQLException;
    
    <E> List<E> query(MappedStatement ms, Object parameter, RowBounds rowBounds,
        ResultHandler resultHandler, CacheKey cacheKey, BoundSql boundSql) throws SQLException;
    
    // æ¸¸æ ‡æŸ¥è¯¢
    <E> Cursor<E> queryCursor(MappedStatement ms, Object parameter, 
        RowBounds rowBounds) throws SQLException;
    
    // æ‰¹é‡åˆ·æ–°
    List<BatchResult> flushStatements() throws SQLException;
    
    // äº‹åŠ¡æ“ä½œ
    void commit(boolean required) throws SQLException;
    void rollback(boolean required) throws SQLException;
    
    // ç¼“å­˜æ“ä½œ
    CacheKey createCacheKey(MappedStatement ms, Object parameterObject, 
        RowBounds rowBounds, BoundSql boundSql);
    boolean isCached(MappedStatement ms, CacheKey key);
    void clearLocalCache();
    
    // å»¶è¿ŸåŠ è½½
    void deferLoad(MappedStatement ms, MetaObject resultObject, String property,
        CacheKey key, Class<?> targetType);
    
    // è·å–äº‹åŠ¡
    Transaction getTransaction();
    
    // å…³é—­
    void close(boolean forceRollback);
    boolean isClosed();
}
```

### 4.2 BaseExecutoræŠ½è±¡åŸºç±»

```java
/**
 * BaseExecutorï¼šæ‰§è¡Œå™¨åŸºç±»
 * å®ç°ä¸€çº§ç¼“å­˜å’Œäº‹åŠ¡ç®¡ç†
 */
public abstract class BaseExecutor implements Executor {
    
    protected Transaction transaction;
    protected Executor wrapper;
    protected ConcurrentLinkedQueue<DeferredLoad> deferredLoads;
    
    // ä¸€çº§ç¼“å­˜ï¼ˆæœ¬åœ°ç¼“å­˜ï¼‰
    protected PerpetualCache localCache;
    protected PerpetualCache localOutputParameterCache;
    
    protected Configuration configuration;
    protected int queryStack;
    private boolean closed;
    
    /**
     * æŸ¥è¯¢æ–¹æ³•ï¼ˆæ¨¡æ¿æ–¹æ³•ï¼‰
     */
    @Override
    public <E> List<E> query(MappedStatement ms, Object parameter, RowBounds rowBounds,
            ResultHandler resultHandler) throws SQLException {
        // 1. è·å–BoundSql
        BoundSql boundSql = ms.getBoundSql(parameter);
        // 2. åˆ›å»ºç¼“å­˜Key
        CacheKey key = createCacheKey(ms, parameter, rowBounds, boundSql);
        // 3. æ‰§è¡ŒæŸ¥è¯¢
        return query(ms, parameter, rowBounds, resultHandler, key, boundSql);
    }
    
    @Override
    public <E> List<E> query(MappedStatement ms, Object parameter, RowBounds rowBounds,
            ResultHandler resultHandler, CacheKey key, BoundSql boundSql) throws SQLException {
        ErrorContext.instance().resource(ms.getResource())
            .activity("executing a query").object(ms.getId());
        if (closed) {
            throw new ExecutorException("Executor was closed.");
        }
        
        // 1. å¦‚æœéœ€è¦æ¸…ç©ºç¼“å­˜ï¼ˆflushCache=trueï¼‰
        if (queryStack == 0 && ms.isFlushCacheRequired()) {
            clearLocalCache();
        }
        
        List<E> list;
        try {
            queryStack++;
            // 2. å…ˆä»ä¸€çº§ç¼“å­˜è·å–
            list = resultHandler == null ? 
                (List<E>) localCache.getObject(key) : null;
            if (list != null) {
                // ç¼“å­˜å‘½ä¸­ï¼Œå¤„ç†å­˜å‚¨è¿‡ç¨‹çš„è¾“å‡ºå‚æ•°
                handleLocallyCachedOutputParameters(ms, key, parameter, boundSql);
            } else {
                // 3. ç¼“å­˜æœªå‘½ä¸­ï¼ŒæŸ¥è¯¢æ•°æ®åº“
                list = queryFromDatabase(ms, parameter, rowBounds, 
                    resultHandler, key, boundSql);
            }
        } finally {
            queryStack--;
        }
        
        // 4. å¤„ç†å»¶è¿ŸåŠ è½½
        if (queryStack == 0) {
            for (DeferredLoad deferredLoad : deferredLoads) {
                deferredLoad.load();
            }
            deferredLoads.clear();
            // å¦‚æœç¼“å­˜ä½œç”¨åŸŸæ˜¯STATEMENTï¼Œæ¸…ç©ºç¼“å­˜
            if (configuration.getLocalCacheScope() == LocalCacheScope.STATEMENT) {
                clearLocalCache();
            }
        }
        return list;
    }
    
    /**
     * ä»æ•°æ®åº“æŸ¥è¯¢
     */
    private <E> List<E> queryFromDatabase(MappedStatement ms, Object parameter,
            RowBounds rowBounds, ResultHandler resultHandler, CacheKey key,
            BoundSql boundSql) throws SQLException {
        List<E> list;
        // 1. å…ˆæ”¾å…¥å ä½ç¬¦ï¼ˆè§£å†³å¾ªç¯ä¾èµ–ï¼‰
        localCache.putObject(key, EXECUTION_PLACEHOLDER);
        try {
            // 2. æ‰§è¡ŒæŸ¥è¯¢ï¼ˆå­ç±»å®ç°ï¼‰
            list = doQuery(ms, parameter, rowBounds, resultHandler, boundSql);
        } finally {
            // 3. ç§»é™¤å ä½ç¬¦
            localCache.removeObject(key);
        }
        // 4. æ”¾å…¥ç¼“å­˜
        localCache.putObject(key, list);
        // 5. å¤„ç†å­˜å‚¨è¿‡ç¨‹è¾“å‡ºå‚æ•°
        if (ms.getStatementType() == StatementType.CALLABLE) {
            localOutputParameterCache.putObject(key, parameter);
        }
        return list;
    }
    
    /**
     * æ›´æ–°æ–¹æ³•
     */
    @Override
    public int update(MappedStatement ms, Object parameter) throws SQLException {
        ErrorContext.instance().resource(ms.getResource())
            .activity("executing an update").object(ms.getId());
        if (closed) {
            throw new ExecutorException("Executor was closed.");
        }
        // æ›´æ–°å‰æ¸…ç©ºä¸€çº§ç¼“å­˜
        clearLocalCache();
        // æ‰§è¡Œæ›´æ–°ï¼ˆå­ç±»å®ç°ï¼‰
        return doUpdate(ms, parameter);
    }
    
    // å­ç±»å®ç°çš„æŠ½è±¡æ–¹æ³•
    protected abstract int doUpdate(MappedStatement ms, Object parameter) throws SQLException;
    protected abstract <E> List<E> doQuery(MappedStatement ms, Object parameter,
        RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql) throws SQLException;
}
```

### 4.3 SimpleExecutorç®€å•æ‰§è¡Œå™¨

```java
/**
 * SimpleExecutorï¼šç®€å•æ‰§è¡Œå™¨
 * æ¯æ¬¡æ‰§è¡Œéƒ½åˆ›å»ºæ–°çš„Statement
 */
public class SimpleExecutor extends BaseExecutor {
    
    @Override
    public int doUpdate(MappedStatement ms, Object parameter) throws SQLException {
        Statement stmt = null;
        try {
            Configuration configuration = ms.getConfiguration();
            // 1. åˆ›å»ºStatementHandler
            StatementHandler handler = configuration.newStatementHandler(
                this, ms, parameter, RowBounds.DEFAULT, null, null);
            // 2. å‡†å¤‡Statement
            stmt = prepareStatement(handler, ms.getStatementLog());
            // 3. æ‰§è¡Œæ›´æ–°
            return handler.update(stmt);
        } finally {
            closeStatement(stmt);
        }
    }
    
    @Override
    public <E> List<E> doQuery(MappedStatement ms, Object parameter, RowBounds rowBounds,
            ResultHandler resultHandler, BoundSql boundSql) throws SQLException {
        Statement stmt = null;
        try {
            Configuration configuration = ms.getConfiguration();
            // 1. åˆ›å»ºStatementHandler
            StatementHandler handler = configuration.newStatementHandler(
                wrapper, ms, parameter, rowBounds, resultHandler, boundSql);
            // 2. å‡†å¤‡Statement
            stmt = prepareStatement(handler, ms.getStatementLog());
            // 3. æ‰§è¡ŒæŸ¥è¯¢
            return handler.query(stmt, resultHandler);
        } finally {
            closeStatement(stmt);
        }
    }
    
    /**
     * å‡†å¤‡Statement
     */
    private Statement prepareStatement(StatementHandler handler, Log statementLog) 
            throws SQLException {
        Statement stmt;
        // è·å–æ•°æ®åº“è¿æ¥
        Connection connection = getConnection(statementLog);
        // åˆ›å»ºStatement
        stmt = handler.prepare(connection, transaction.getTimeout());
        // è®¾ç½®å‚æ•°
        handler.parameterize(stmt);
        return stmt;
    }
}
```

### 4.4 ReuseExecutoré‡ç”¨æ‰§è¡Œå™¨

```java
/**
 * ReuseExecutorï¼šé‡ç”¨æ‰§è¡Œå™¨
 * é‡ç”¨PreparedStatement
 */
public class ReuseExecutor extends BaseExecutor {
    
    // Statementç¼“å­˜ï¼šSQL -> Statement
    private final Map<String, Statement> statementMap = new HashMap<>();
    
    @Override
    public int doUpdate(MappedStatement ms, Object parameter) throws SQLException {
        Configuration configuration = ms.getConfiguration();
        StatementHandler handler = configuration.newStatementHandler(
            this, ms, parameter, RowBounds.DEFAULT, null, null);
        // è·å–æˆ–åˆ›å»ºStatement
        Statement stmt = prepareStatement(handler, ms.getStatementLog());
        return handler.update(stmt);
    }
    
    private Statement prepareStatement(StatementHandler handler, Log statementLog) 
            throws SQLException {
        Statement stmt;
        BoundSql boundSql = handler.getBoundSql();
        String sql = boundSql.getSql();
        // æ£€æŸ¥æ˜¯å¦æœ‰ç¼“å­˜çš„Statement
        if (hasStatementFor(sql)) {
            stmt = getStatement(sql);
            applyTransactionTimeout(stmt);
        } else {
            Connection connection = getConnection(statementLog);
            stmt = handler.prepare(connection, transaction.getTimeout());
            // ç¼“å­˜Statement
            putStatement(sql, stmt);
        }
        handler.parameterize(stmt);
        return stmt;
    }
    
    private boolean hasStatementFor(String sql) {
        try {
            return statementMap.containsKey(sql) && 
                !statementMap.get(sql).getConnection().isClosed();
        } catch (SQLException e) {
            return false;
        }
    }
}
```

### 4.5 BatchExecutoræ‰¹é‡æ‰§è¡Œå™¨

```java
/**
 * BatchExecutorï¼šæ‰¹é‡æ‰§è¡Œå™¨
 * æ‰¹é‡æ‰§è¡Œæ›´æ–°æ“ä½œ
 */
public class BatchExecutor extends BaseExecutor {
    
    public static final int BATCH_UPDATE_RETURN_VALUE = Integer.MIN_VALUE + 1002;
    
    private final List<Statement> statementList = new ArrayList<>();
    private final List<BatchResult> batchResultList = new ArrayList<>();
    private String currentSql;
    private MappedStatement currentStatement;
    
    @Override
    public int doUpdate(MappedStatement ms, Object parameterObject) throws SQLException {
        final Configuration configuration = ms.getConfiguration();
        final StatementHandler handler = configuration.newStatementHandler(
            this, ms, parameterObject, RowBounds.DEFAULT, null, null);
        final BoundSql boundSql = handler.getBoundSql();
        final String sql = boundSql.getSql();
        final Statement stmt;
        
        // å¦‚æœSQLå’ŒMappedStatementç›¸åŒï¼Œå¤ç”¨Statement
        if (sql.equals(currentSql) && ms.equals(currentStatement)) {
            int last = statementList.size() - 1;
            stmt = statementList.get(last);
            applyTransactionTimeout(stmt);
            handler.parameterize(stmt);
            BatchResult batchResult = batchResultList.get(last);
            batchResult.addParameterObject(parameterObject);
        } else {
            // åˆ›å»ºæ–°çš„Statement
            Connection connection = getConnection(ms.getStatementLog());
            stmt = handler.prepare(connection, transaction.getTimeout());
            handler.parameterize(stmt);
            currentSql = sql;
            currentStatement = ms;
            statementList.add(stmt);
            batchResultList.add(new BatchResult(ms, sql, parameterObject));
        }
        // æ·»åŠ åˆ°æ‰¹é‡
        handler.batch(stmt);
        return BATCH_UPDATE_RETURN_VALUE;
    }
    
    @Override
    public List<BatchResult> doFlushStatements(boolean isRollback) throws SQLException {
        try {
            List<BatchResult> results = new ArrayList<>();
            if (isRollback) {
                return Collections.emptyList();
            }
            // æ‰§è¡Œæ‰€æœ‰æ‰¹é‡æ“ä½œ
            for (int i = 0, n = statementList.size(); i < n; i++) {
                Statement stmt = statementList.get(i);
                BatchResult batchResult = batchResultList.get(i);
                try {
                    // æ‰§è¡Œæ‰¹é‡
                    batchResult.setUpdateCounts(stmt.executeBatch());
                    // ...
                } catch (BatchUpdateException e) {
                    // å¤„ç†æ‰¹é‡å¼‚å¸¸
                }
                results.add(batchResult);
            }
            return results;
        } finally {
            // æ¸…ç†
            for (Statement stmt : statementList) {
                closeStatement(stmt);
            }
            currentSql = null;
            statementList.clear();
            batchResultList.clear();
        }
    }
}
```


---

## 5. ä¸€çº§ç¼“å­˜

### 5.1 ä¸€çº§ç¼“å­˜åŸç†

```java
/**
 * ä¸€çº§ç¼“å­˜ï¼ˆæœ¬åœ°ç¼“å­˜ï¼‰
 * 
 * ç‰¹ç‚¹ï¼š
 * 1. SqlSessionçº§åˆ«ï¼ŒåŒä¸€SqlSessionå…±äº«
 * 2. é»˜è®¤å¼€å¯ï¼Œæ— æ³•å…³é—­
 * 3. æ‰§è¡Œupdate/insert/deleteä¼šæ¸…ç©º
 * 4. è°ƒç”¨clearCache()ä¼šæ¸…ç©º
 * 5. SqlSessionå…³é—­åå¤±æ•ˆ
 */
public class PerpetualCache implements Cache {
    
    private final String id;
    private final Map<Object, Object> cache = new HashMap<>();
    
    public PerpetualCache(String id) {
        this.id = id;
    }
    
    @Override
    public void putObject(Object key, Object value) {
        cache.put(key, value);
    }
    
    @Override
    public Object getObject(Object key) {
        return cache.get(key);
    }
    
    @Override
    public Object removeObject(Object key) {
        return cache.remove(key);
    }
    
    @Override
    public void clear() {
        cache.clear();
    }
    
    @Override
    public int getSize() {
        return cache.size();
    }
}
```

### 5.2 CacheKeyç¼“å­˜é”®

```java
/**
 * CacheKeyï¼šç¼“å­˜é”®
 * 
 * ç»„æˆéƒ¨åˆ†ï¼š
 * 1. MappedStatementçš„id
 * 2. åˆ†é¡µå‚æ•°ï¼ˆoffsetã€limitï¼‰
 * 3. SQLè¯­å¥
 * 4. å‚æ•°å€¼
 * 5. ç¯å¢ƒid
 */
public class CacheKey implements Cloneable, Serializable {
    
    private static final int DEFAULT_MULTIPLIER = 37;
    private static final int DEFAULT_HASHCODE = 17;
    
    private final int multiplier;
    private int hashcode;
    private long checksum;
    private int count;
    private List<Object> updateList;
    
    public CacheKey() {
        this.hashcode = DEFAULT_HASHCODE;
        this.multiplier = DEFAULT_MULTIPLIER;
        this.count = 0;
        this.updateList = new ArrayList<>();
    }
    
    /**
     * æ›´æ–°CacheKey
     */
    public void update(Object object) {
        int baseHashCode = object == null ? 1 : 
            ArrayUtil.hashCode(object);
        count++;
        checksum += baseHashCode;
        baseHashCode *= count;
        hashcode = multiplier * hashcode + baseHashCode;
        updateList.add(object);
    }
    
    @Override
    public boolean equals(Object object) {
        if (this == object) {
            return true;
        }
        if (!(object instanceof CacheKey)) {
            return false;
        }
        final CacheKey cacheKey = (CacheKey) object;
        if (hashcode != cacheKey.hashcode) {
            return false;
        }
        if (checksum != cacheKey.checksum) {
            return false;
        }
        if (count != cacheKey.count) {
            return false;
        }
        // é€ä¸ªæ¯”è¾ƒupdateListä¸­çš„å…ƒç´ 
        for (int i = 0; i < updateList.size(); i++) {
            Object thisObject = updateList.get(i);
            Object thatObject = cacheKey.updateList.get(i);
            if (!ArrayUtil.equals(thisObject, thatObject)) {
                return false;
            }
        }
        return true;
    }
}

// BaseExecutorä¸­åˆ›å»ºCacheKey
@Override
public CacheKey createCacheKey(MappedStatement ms, Object parameterObject,
        RowBounds rowBounds, BoundSql boundSql) {
    CacheKey cacheKey = new CacheKey();
    // 1. MappedStatementçš„id
    cacheKey.update(ms.getId());
    // 2. åˆ†é¡µå‚æ•°
    cacheKey.update(rowBounds.getOffset());
    cacheKey.update(rowBounds.getLimit());
    // 3. SQLè¯­å¥
    cacheKey.update(boundSql.getSql());
    // 4. å‚æ•°å€¼
    List<ParameterMapping> parameterMappings = boundSql.getParameterMappings();
    TypeHandlerRegistry typeHandlerRegistry = ms.getConfiguration().getTypeHandlerRegistry();
    for (ParameterMapping parameterMapping : parameterMappings) {
        if (parameterMapping.getMode() != ParameterMode.OUT) {
            Object value;
            String propertyName = parameterMapping.getProperty();
            // è·å–å‚æ•°å€¼
            if (boundSql.hasAdditionalParameter(propertyName)) {
                value = boundSql.getAdditionalParameter(propertyName);
            } else if (parameterObject == null) {
                value = null;
            } else if (typeHandlerRegistry.hasTypeHandler(parameterObject.getClass())) {
                value = parameterObject;
            } else {
                MetaObject metaObject = configuration.newMetaObject(parameterObject);
                value = metaObject.getValue(propertyName);
            }
            cacheKey.update(value);
        }
    }
    // 5. ç¯å¢ƒid
    if (configuration.getEnvironment() != null) {
        cacheKey.update(configuration.getEnvironment().getId());
    }
    return cacheKey;
}
```

### 5.3 ä¸€çº§ç¼“å­˜ä½œç”¨åŸŸ

```java
/**
 * ä¸€çº§ç¼“å­˜ä½œç”¨åŸŸ
 */
public enum LocalCacheScope {
    SESSION,    // SqlSessionçº§åˆ«ï¼ˆé»˜è®¤ï¼‰
    STATEMENT   // Statementçº§åˆ«ï¼ˆæ¯æ¬¡æŸ¥è¯¢åæ¸…ç©ºï¼‰
}

// é…ç½®æ–¹å¼
// mybatis-config.xml
<settings>
    <setting name="localCacheScope" value="STATEMENT"/>
</settings>

// application.yml
mybatis:
  configuration:
    local-cache-scope: statement
```

---

## 6. äº‹åŠ¡ç®¡ç†

### 6.1 Transactionæ¥å£

```java
/**
 * Transactionï¼šäº‹åŠ¡æ¥å£
 */
public interface Transaction {
    
    /**
     * è·å–æ•°æ®åº“è¿æ¥
     */
    Connection getConnection() throws SQLException;
    
    /**
     * æäº¤äº‹åŠ¡
     */
    void commit() throws SQLException;
    
    /**
     * å›æ»šäº‹åŠ¡
     */
    void rollback() throws SQLException;
    
    /**
     * å…³é—­è¿æ¥
     */
    void close() throws SQLException;
    
    /**
     * è·å–è¶…æ—¶æ—¶é—´
     */
    Integer getTimeout() throws SQLException;
}
```

### 6.2 JdbcTransactionå®ç°

```java
/**
 * JdbcTransactionï¼šJDBCäº‹åŠ¡å®ç°
 */
public class JdbcTransaction implements Transaction {
    
    protected Connection connection;
    protected DataSource dataSource;
    protected TransactionIsolationLevel level;
    protected boolean autoCommit;
    
    @Override
    public Connection getConnection() throws SQLException {
        if (connection == null) {
            openConnection();
        }
        return connection;
    }
    
    protected void openConnection() throws SQLException {
        connection = dataSource.getConnection();
        if (level != null) {
            connection.setTransactionIsolation(level.getLevel());
        }
        setDesiredAutoCommit(autoCommit);
    }
    
    @Override
    public void commit() throws SQLException {
        if (connection != null && !connection.getAutoCommit()) {
            connection.commit();
        }
    }
    
    @Override
    public void rollback() throws SQLException {
        if (connection != null && !connection.getAutoCommit()) {
            connection.rollback();
        }
    }
    
    @Override
    public void close() throws SQLException {
        if (connection != null) {
            resetAutoCommit();
            connection.close();
        }
    }
}
```

---

## 7. æµç¨‹å›¾è§£

### 7.1 SqlSessionæ‰§è¡ŒæŸ¥è¯¢æµç¨‹

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                SqlSession æŸ¥è¯¢æ‰§è¡Œæµç¨‹                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

sqlSession.selectList("namespace.id", parameter)
                           â”‚
                           â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 1. è·å–MappedStatement                                   â”‚
â”‚    ms = configuration.getMappedStatement(statement)      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                           â”‚
                           â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 2. è°ƒç”¨Executor.query()                                  â”‚
â”‚    executor.query(ms, parameter, rowBounds, handler)     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                           â”‚
                           â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 3. åˆ›å»ºCacheKey                                          â”‚
â”‚    key = createCacheKey(ms, parameter, rowBounds, sql)   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                           â”‚
                           â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 4. æŸ¥è¯¢ä¸€çº§ç¼“å­˜                                            â”‚
â”‚    list = localCache.getObject(key)                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                           â”‚
              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
              â”‚ å‘½ä¸­                    â”‚ æœªå‘½ä¸­
              â–¼                         â–¼
       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
       â”‚  è¿”å›ç¼“å­˜ç»“æœ  â”‚      â”‚ 5. æŸ¥è¯¢æ•°æ®åº“              â”‚
       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â”‚    queryFromDatabase()   â”‚
                             â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                        â”‚
                                        â–¼
                             â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                             â”‚ 6. åˆ›å»ºStatementHandler   â”‚
                             â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                        â”‚
                                        â–¼
                             â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                             â”‚ 7. å‡†å¤‡Statement          â”‚
                             â”‚    è®¾ç½®å‚æ•°                â”‚
                             â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                        â”‚
                                        â–¼
                             â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                             â”‚ 8. æ‰§è¡ŒSQL                â”‚
                             â”‚    stmt.execute()        â”‚
                             â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                        â”‚
                                        â–¼
                             â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                             â”‚ 9. å¤„ç†ç»“æœé›†            â”‚
                             â”‚    ResultSetHandler      â”‚
                             â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                        â”‚
                                        â–¼
                             â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                             â”‚ 10. æ”¾å…¥ä¸€çº§ç¼“å­˜         â”‚
                             â”‚     localCache.put()     â”‚
                             â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                        â”‚
                                        â–¼
                             â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                             â”‚ 11. è¿”å›ç»“æœ             â”‚
                             â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 8. é¢è¯•è¦ç‚¹

### 8.1 é«˜é¢‘é¢è¯•é¢˜

```
Q1: SqlSessionæ˜¯çº¿ç¨‹å®‰å…¨çš„å—ï¼Ÿ
A: ä¸æ˜¯ã€‚DefaultSqlSessionä¸æ˜¯çº¿ç¨‹å®‰å…¨çš„ï¼Œæ¯ä¸ªçº¿ç¨‹åº”è¯¥æœ‰è‡ªå·±çš„SqlSessionå®ä¾‹ã€‚
   åœ¨Springä¸­ï¼ŒSqlSessionTemplateæ˜¯çº¿ç¨‹å®‰å…¨çš„ï¼Œå®ƒä½¿ç”¨åŠ¨æ€ä»£ç†ä¸ºæ¯ä¸ªæ–¹æ³•è°ƒç”¨
   åˆ›å»ºæ–°çš„SqlSessionã€‚

Q2: ä¸€çº§ç¼“å­˜çš„ä½œç”¨åŸŸï¼Ÿ
A: SqlSessionçº§åˆ«ã€‚åŒä¸€ä¸ªSqlSessionä¸­ï¼Œç›¸åŒçš„æŸ¥è¯¢ä¼šå‘½ä¸­ç¼“å­˜ã€‚
   å¯ä»¥é…ç½®ä¸ºSTATEMENTçº§åˆ«ï¼Œæ¯æ¬¡æŸ¥è¯¢åæ¸…ç©ºç¼“å­˜ã€‚

Q3: ä»€ä¹ˆæƒ…å†µä¸‹ä¸€çº§ç¼“å­˜ä¼šå¤±æ•ˆï¼Ÿ
A: 1. æ‰§è¡Œupdate/insert/deleteæ“ä½œ
   2. è°ƒç”¨clearCache()æ–¹æ³•
   3. SqlSessionå…³é—­
   4. é…ç½®localCacheScope=STATEMENT
   5. ä¸åŒçš„SqlSession

Q4: Executoræœ‰å“ªäº›ç±»å‹ï¼Ÿ
A: - SimpleExecutorï¼šæ¯æ¬¡åˆ›å»ºæ–°çš„Statement
   - ReuseExecutorï¼šé‡ç”¨PreparedStatement
   - BatchExecutorï¼šæ‰¹é‡æ‰§è¡Œæ›´æ–°æ“ä½œ
   - CachingExecutorï¼šäºŒçº§ç¼“å­˜è£…é¥°å™¨

Q5: SqlSessionçš„ä¸»è¦æ–¹æ³•ï¼Ÿ
A: - selectOne/selectList/selectMapï¼šæŸ¥è¯¢
   - insert/update/deleteï¼šæ›´æ–°
   - commit/rollbackï¼šäº‹ getMapperï¼šè·å–Mapperä»£ç†
   - clearCacheï¼šæ¸…ç©ºç¼“å­˜
   - closeï¼šå…³é—­ä¼šè¯
```

### 8.2 ä½¿ç”¨ç¤ºä¾‹

```java
/**
 * SqlSessionä½¿ç”¨ç¤ºä¾‹
 */
public class SqlSessionDemo {
    
    public void basicUsage() {
        SqlSessionFactory factory = ...; // è·å–å·¥å‚
        
        // æ–¹å¼1ï¼šæ‰‹åŠ¨ç®¡ç†SqlSession
        try (SqlSession session = factory.openSession()) {
            // ç›´æ¥æ‰§è¡ŒSQL
            User user = session.selectOne("com.example.mapper.UserMapper.selectById", 1);
            
            // è·å–Mapperä»£ç†
            UserMapper mapper = session.getMapper(UserMapper.class);
            User user2 = mapper.selectById(1);
            
            // æäº¤äº‹åŠ¡
            session.commit();
        }
        
        // æ–¹å¼2ï¼šè‡ªåŠ¨æäº¤
        try (SqlSession session = factory.openSession(true)) {
            // è‡ªåŠ¨æäº¤ï¼Œæ— éœ€æ‰‹åŠ¨commit
            session.insert("insertUser", user);
        }
        
        // æ–¹å¼3ï¼šæŒ‡å®šæ‰§è¡Œå™¨ç±»å‹
        try (SqlSession session = factory.openSession(ExecutorType.BATCH)) {
            // æ‰¹é‡æ‰§è¡Œ
            for (User user : users) {
                session.insert("insertUser", user);
            }
            session.flushStatements(); // åˆ·æ–°æ‰¹é‡
            session.commit();
        }
    }
}
```

---

## ğŸ“š æ€»ç»“

ç‚¹

1. **SqlSessionèŒè´£**ï¼šæ‰§è¡ŒSQLã€ç®¡ç†äº‹åŠ¡ã€è·å–Mapperã€ç®¡ç†ç¼“å­˜
2. **Executorç±»å‹**ï¼šSimpleã€Reuseã€Batchã€Caching
3. **ä¸€çº§ç¼“å­˜**ï¼šSqlSessionçº§åˆ«ï¼Œé»˜è®¤å¼€å¯
4. **çº¿ç¨‹å®‰å…¨**ï¼šDefaultSqlSessionéçº¿ç¨‹å®‰å…¨

### æ‰§è¡Œå™¨é€‰æ‹©

| æ‰§è¡Œå™¨ | ç‰¹ç‚¹ | é€‚ç”¨åœºæ™¯ |
|--------|------|----------|
| SimpleExecutor | æ¯æ¬¡æ–°å»ºStatement | é»˜è®¤ï¼Œé€šç”¨åœºæ™¯ |
| ReuseExecutor | é‡ç”¨Statement | é‡å¤SQLè¾ƒå¤š |
| BatchExecutor | æ‰¹é‡æ‰§è¡Œ | æ‰¹é‡æ’å…¥/æ›´æ–° |

---

*æœ€åæ›´æ–°ï¼š2025-12-28*

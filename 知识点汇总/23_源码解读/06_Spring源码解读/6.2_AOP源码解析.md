# AOPæºç è§£æ

> ğŸ’¡ æ·±å…¥ç†è§£Spring AOPçš„å®ç°åŸç†ï¼Œä»åŠ¨æ€ä»£ç†åˆ°åˆ‡é¢ç»‡å…¥

---

## ğŸ“‹ ç›®å½•

- [1. AOPæ¦‚è¿°](#1-aopæ¦‚è¿°)
- [2. æ ¸å¿ƒæ¦‚å¿µ](#2-æ ¸å¿ƒæ¦‚å¿µ)
- [3. ä»£ç†åˆ›å»ºæµç¨‹](#3-ä»£ç†åˆ›å»ºæµç¨‹)
- [4. JDKåŠ¨æ€ä»£ç†](#4-jdkåŠ¨æ€ä»£ç†)
- [5. CGLIBä»£ç†](#5-cglibä»£ç†)
- [6. æ‹¦æˆªå™¨é“¾æ‰§è¡Œ](#6-æ‹¦æˆªå™¨é“¾æ‰§è¡Œ)
- [7. é¢è¯•è¦ç‚¹](#7-é¢è¯•è¦ç‚¹)

---

## 1. AOPæ¦‚è¿°

### 1.1 ä»€ä¹ˆæ˜¯AOP

#### ğŸ¯ é¢å‘åˆ‡é¢ç¼–ç¨‹ï¼ˆAspect-Oriented Programmingï¼‰
```
æ ¸å¿ƒæ€æƒ³ï¼š
- å°†æ¨ªåˆ‡å…³æ³¨ç‚¹ä»ä¸šåŠ¡é€»è¾‘ä¸­åˆ†ç¦»
- é€šè¿‡é¢„ç¼–è¯‘æˆ–è¿è¡Œæ—¶åŠ¨æ€ä»£ç†å®ç°
- ä¸ä¿®æ”¹æºä»£ç çš„æƒ…å†µä¸‹å¢å¼ºåŠŸèƒ½

å…¸å‹åº”ç”¨åœºæ™¯ï¼š
- æ—¥å¿—è®°å½•
- æ€§èƒ½ç›‘æ§
- äº‹åŠ¡ç®¡ç†
- æƒé™æ§åˆ¶
- å¼‚å¸¸å¤„ç†
```

### 1.2 Spring AOP vs AspectJ

```
Spring AOPï¼š
- åŸºäºåŠ¨æ€ä»£ç†å®ç°
- åªæ”¯æŒæ–¹æ³•çº§åˆ«çš„åˆ‡å…¥
- è¿è¡Œæ—¶ç»‡å…¥
- é…ç½®ç®€å•ï¼Œå­¦ä¹ æˆæœ¬ä½

AspectJï¼š
- åŸºäºå­—èŠ‚ç æ“ä½œ
- æ”¯æŒå­—æ®µã€æ„é€ å™¨ã€é™æ€æ–¹æ³•ç­‰
- ç¼–è¯‘æ—¶/åŠ è½½æ—¶ç»‡å…¥
- åŠŸèƒ½æ›´å¼ºå¤§ï¼Œä½†æ›´å¤æ‚
```

---

## 2. æ ¸å¿ƒæ¦‚å¿µ

### 2.1 AOPæœ¯è¯­

```java
// åˆ‡é¢ï¼ˆAspectï¼‰ï¼šæ¨ªåˆ‡å…³æ³¨ç‚¹çš„æ¨¡å—åŒ–
@Aspect
@Component
public class LogAspect {
    
    // åˆ‡å…¥ç‚¹ï¼ˆPointcutï¼‰ï¼šå®šä¹‰åœ¨å“ªäº›è¿æ¥ç‚¹åº”ç”¨é€šçŸ¥
    @Pointcut("execution(* com.example.service.*.*(..))")
    public void servicePointcut() {}
    
    // é€šçŸ¥ï¼ˆAdviceï¼‰ï¼šåœ¨åˆ‡å…¥ç‚¹æ‰§è¡Œçš„åŠ¨ä½œ
    // å‰ç½®é€šçŸ¥
    @Before("servicePointcut()")
    public void before(JoinPoint jp) {
        System.out.println("æ–¹æ³•æ‰§è¡Œå‰: " + jp.getSignature());
    }
    
    // åç½®é€šçŸ¥
    @After("servicePointcut()")
    public void after(JoinPoint jp) {
        System.out.println("æ–¹æ³•æ‰§è¡Œå: " + jp.getSignature());
    }
    
    // è¿”å›é€šçŸ¥
    @AfterReturning(pointcut = "servicePointcut()", returning = "result")
    public void afterReturning(JoinPoint jp, Object result) {
        System.out.println("æ–¹æ³•è¿”å›: " + result);
    }
    
    // å¼‚å¸¸é€šçŸ¥
    @AfterThrowing(pointcut = "servicePointcut()", throwing = "ex")
    public void afterThrowing(JoinPoint jp, Exception ex) {
        System.out.println("æ–¹æ³•å¼‚å¸¸: " + ex.getMessage());
    }
    
    // ç¯ç»•é€šçŸ¥
    @Around("servicePointcut()")
    public Object around(ProceedingJoinPoint pjp) throws Throwable {
        System.out.println("ç¯ç»•å‰");
        Object result = pjp.proceed();
        System.out.println("ç¯ç»•å");
        return result;
    }
}
```

### 2.2 æ ¸å¿ƒæ¥å£

```java
// AopProxyï¼šAOPä»£ç†æ¥å£
public interface AopProxy {
    Object getProxy();
    Object getProxy(ClassLoader classLoader);
}

// Advisorï¼šåˆ‡é¢ = åˆ‡å…¥ç‚¹ + é€šçŸ¥
public interface Advisor {
    Advice getAdvice();
}

// PointcutAdvisorï¼šå¸¦åˆ‡å…¥ç‚¹çš„åˆ‡é¢
public interface PointcutAdvisor extends Advisor {
    Pointcut getPointcut();
}

// MethodInterceptorï¼šæ–¹æ³•æ‹¦æˆªå™¨
public interface MethodInterceptor extends Interceptor {
    Object invoke(MethodInvocation invocation) throws Throwable;
}
```

---

## 3. ä»£ç†åˆ›å»ºæµç¨‹

### 3.1 å…¥å£ï¼š@EnableAspectJAutoProxy

```java
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Import(AspectJAutoProxyRegistrar.class)
public @interface EnableAspectJAutoProxy {
    // æ˜¯å¦ä½¿ç”¨CGLIBä»£ç†
    boolean proxyTargetClass() default false;
    // æ˜¯å¦æš´éœ²ä»£ç†å¯¹è±¡
    boolean exposeProxy() default false;
}

// AspectJAutoProxyRegistraræ³¨å†ŒAnnotationAwareAspectJAutoProxyCreator
class AspectJAutoProxyRegistrar implements ImportBeanDefinitionRegistrar {
    @Override
    public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata,
            BeanDefinitionRegistry registry) {
        // æ³¨å†ŒAnnotationAwareAspectJAutoProxyCreator
        AopConfigUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(registry);
    }
}
```

### 3.2 ä»£ç†åˆ›å»ºå™¨ç»§æ‰¿ä½“ç³»

```
AbstractAutoProxyCreatorï¼ˆæ ¸å¿ƒæŠ½è±¡ç±»ï¼‰
â”œâ”€â”€ BeanNameAutoProxyCreator
â”œâ”€â”€ AbstractAdvisorAutoProxyCreator
â”‚   â”œâ”€â”€ DefaultAdvisorAutoProxyCreator
â”‚   â””â”€â”€ AspectJAwareAdvisorAutoProxyCreator
â”‚       â””â”€â”€ AnnotationAwareAspectJAutoProxyCreatorï¼ˆæœ€å¸¸ç”¨ï¼‰
```

### 3.3 ä»£ç†åˆ›å»ºæ—¶æœº

```java
// AbstractAutoProxyCreatorå®ç°äº†BeanPostProcessor
public abstract class AbstractAutoProxyCreator implements BeanPostProcessor {
    
    // åœ¨Beanåˆå§‹åŒ–ååˆ›å»ºä»£ç†
    @Override
    public Object postProcessAfterInitialization(Object bean, String beanName) {
        if (bean != null) {
            Object cacheKey = getCacheKey(bean.getClass(), beanName);
            if (this.earlyProxyReferences.remove(cacheKey) != bean) {
                return wrapIfNecessary(bean, beanName, cacheKey);
            }
        }
        return bean;
    }
    
    // åˆ¤æ–­æ˜¯å¦éœ€è¦ä»£ç†ï¼Œå¦‚æœéœ€è¦åˆ™åˆ›å»ºä»£ç†
    protected Object wrapIfNecessary(Object bean, String beanName, Object cacheKey) {
        // å·²ç»å¤„ç†è¿‡
        if (this.advisedBeans.containsKey(cacheKey)) {
            return bean;
        }
        
        // åŸºç¡€è®¾æ–½ç±»ä¸ä»£ç†
        if (isInfrastructureClass(bean.getClass()) || 
            shouldSkip(bean.getClass(), beanName)) {
            this.advisedBeans.put(cacheKey, Boolean.FALSE);
            return bean;
        }
        
        // è·å–é€‚ç”¨äºè¯¥Beançš„Advisor
        Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(
            bean.getClass(), beanName, null);
        
        if (specificInterceptors != DO_NOT_PROXY) {
            this.advisedBeans.put(cacheKey, Boolean.TRUE);
            // åˆ›å»ºä»£ç†
            Object proxy = createProxy(bean.getClass(), beanName, 
                specificInterceptors, new SingletonTargetSource(bean));
            this.proxyTypes.put(cacheKey, proxy.getClass());
            return proxy;
        }
        
        this.advisedBeans.put(cacheKey, Boolean.FALSE);
        return bean;
    }
}
```


### 3.4 createProxyæµç¨‹

```java
protected Object createProxy(Class<?> beanClass, String beanName,
        Object[] specificInterceptors, TargetSource targetSource) {
    
    // 1. åˆ›å»ºProxyFactory
    ProxyFactory proxyFactory = new ProxyFactory();
    proxyFactory.copyFrom(this);
    
    // 2. å†³å®šæ˜¯å¦ä½¿ç”¨CGLIB
    if (!proxyFactory.isProxyTargetClass()) {
        if (shouldProxyTargetClass(beanClass, beanName)) {
            proxyFactory.setProxyTargetClass(true);
        } else {
            // è¯„ä¼°ä»£ç†æ¥å£
            evaluateProxyInterfaces(beanClass, proxyFactory);
        }
    }
    
    // 3. æ„å»ºAdvisoræ•°ç»„
    Advisor[] advisors = buildAdvisors(beanName, specificInterceptors);
    proxyFactory.addAdvisors(advisors);
    proxyFactory.setTargetSource(targetSource);
    
    // 4. è‡ªå®šä¹‰ProxyFactory
    customizeProxyFactory(proxyFactory);
    
    // 5. åˆ›å»ºä»£ç†
    return proxyFactory.getProxy(getProxyClassLoader());
}
```

### 3.5 ProxyFactoryåˆ›å»ºä»£ç†

```java
// ProxyFactory.getProxy()
public Object getProxy(ClassLoader classLoader) {
    return createAopProxy().getProxy(classLoader);
}

// ProxyCreatorSupport.createAopProxy()
protected final synchronized AopProxy createAopProxy() {
    return getAopProxyFactory().createAopProxy(this);
}

// DefaultAopProxyFactory.createAopProxy() - é€‰æ‹©ä»£ç†æ–¹å¼
@Override
public AopProxy createAopProxy(AdvisedSupport config) {
    // åˆ¤æ–­ä½¿ç”¨JDKè¿˜æ˜¯CGLIB
    if (config.isOptimize() || config.isProxyTargetClass() || 
        hasNoUserSuppliedProxyInterfaces(config)) {
        Class<?> targetClass = config.getTargetClass();
        if (targetClass == null) {
            throw new AopConfigException("...");
        }
        // ç›®æ ‡ç±»æ˜¯æ¥å£æˆ–ä»£ç†ç±»ï¼Œä½¿ç”¨JDKä»£ç†
        if (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) {
            return new JdkDynamicAopProxy(config);
        }
        // å¦åˆ™ä½¿ç”¨CGLIB
        return new ObjenesisCglibAopProxy(config);
    } else {
        // é»˜è®¤ä½¿ç”¨JDKä»£ç†
        return new JdkDynamicAopProxy(config);
    }
}
```

---

## 4. JDKåŠ¨æ€ä»£ç†

### 4.1 JdkDynamicAopProxyå®ç°

```java
final class JdkDynamicAopProxy implements AopProxy, InvocationHandler {
    
    private final AdvisedSupport advised;
    
    public JdkDynamicAopProxy(AdvisedSupport config) {
        this.advised = config;
    }
    
    @Override
    public Object getProxy(ClassLoader classLoader) {
        // è·å–ä»£ç†æ¥å£
        Class<?>[] proxiedInterfaces = AopProxyUtils.completeProxiedInterfaces(
            this.advised, true);
        // åˆ›å»ºJDKä»£ç†
        return Proxy.newProxyInstance(classLoader, proxiedInterfaces, this);
    }
    
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        Object oldProxy = null;
        boolean setProxyContext = false;
        
        TargetSource targetSource = this.advised.getTargetSource();
        Object target = null;
        
        try {
            // equalsæ–¹æ³•å¤„ç†
            if (method.equals(Object.class.getMethod("equals", Object.class))) {
                return equals(args[0]);
            }
            // hashCodeæ–¹æ³•å¤„ç†
            if (method.equals(Object.class.getMethod("hashCode"))) {
                return hashCode();
            }
            
            Object retVal;
            
            // æ˜¯å¦æš´éœ²ä»£ç†
            if (this.advised.exposeProxy) {
                oldProxy = AopContext.setCurrentProxy(proxy);
                setProxyContext = true;
            }
            
            target = targetSource.getTarget();
            Class<?> targetClass = (target != null ? target.getClass() : null);
            
            // è·å–æ‹¦æˆªå™¨é“¾
            List<Object> chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(
                method, targetClass);
            
            if (chain.isEmpty()) {
                // æ²¡æœ‰æ‹¦æˆªå™¨ï¼Œç›´æ¥è°ƒç”¨ç›®æ ‡æ–¹æ³•
                Object[] argsToUse = AopProxyUtils.adaptArgumentsIfNecessary(method, args);
                retVal = AopUtils.invokeJoinpointUsingReflection(target, method, argsToUse);
            } else {
                // åˆ›å»ºMethodInvocationå¹¶æ‰§è¡Œ
                MethodInvocation invocation = new ReflectiveMethodInvocation(
                    proxy, target, method, args, targetClass, chain);
                retVal = invocation.proceed();
            }
            
            return retVal;
        } finally {
            if (target != null && !targetSource.isStatic()) {
                targetSource.releaseTarget(target);
            }
            if (setProxyContext) {
                AopContext.setCurrentProxy(oldProxy);
            }
        }
    }
}
```

### 4.2 JDKä»£ç†åŸç†

```java
// JDKåŠ¨æ€ä»£ç†ç¤ºä¾‹
public class JdkProxyDemo {
    
    public static void main(String[] args) {
        UserService target = new UserServiceImpl();
        
        UserService proxy = (UserService) Proxy.newProxyInstance(
            target.getClass().getClassLoader(),
            target.getClass().getInterfaces(),
            new InvocationHandler() {
                @Override
                public Object invoke(Object proxy, Method method, Object[] args) 
                        throws Throwable {
                    System.out.println("Before: " + method.getName());
                    Object result = method.invoke(target, args);
                    System.out.println("After: " + method.getName());
                    return result;
                }
            }
        );
        
        proxy.save();
    }
}
```

---

## 5. CGLIBä»£ç†

### 5.1 CglibAopProxyå®ç°

```java
class CglibAopProxy implements AopProxy {
    
    private final AdvisedSupport advised;
    
    @Override
    public Object getProxy(ClassLoader classLoader) {
        Class<?> rootClass = this.advised.getTargetClass();
        Class<?> proxySuperClass = rootClass;
        
        // åˆ›å»ºEnhancer
        Enhancer enhancer = createEnhancer();
        enhancer.setSuperclass(proxySuperClass);
        enhancer.setInterfaces(AopProxyUtils.completeProxiedInterfaces(this.advised));
        enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE);
        enhancer.setStrategy(new ClassLoaderAwareGeneratorStrategy(classLoader));
        
        // è®¾ç½®å›è°ƒ
        Callback[] callbacks = getCallbacks(rootClass);
        Class<?>[] types = new Class<?>[callbacks.length];
        for (int x = 0; x < types.length; x++) {
            types[x] = callbacks[x].getClass();
        }
        enhancer.setCallbackFilter(new ProxyCallbackFilter(
            this.advised.getConfigurationOnlyCopy(), this.fixedInterceptorMap));
        enhancer.setCallbackTypes(types);
        
        // åˆ›å»ºä»£ç†
        return createProxyClassAndInstance(enhancer, callbacks);
    }
    
    private Callback[] getCallbacks(Class<?> rootClass) {
        // ä¸»è¦çš„AOPæ‹¦æˆªå™¨
        Callback aopInterceptor = new DynamicAdvisedInterceptor(this.advised);
        
        // å…¶ä»–å›è°ƒ...
        Callback[] callbacks = new Callback[] {
            aopInterceptor,  // AOPæ‹¦æˆª
            targetInterceptor,  // ç›´æ¥è°ƒç”¨ç›®æ ‡
            new SerializableNoOp(),  // æ— æ“ä½œ
            targetDispatcher,
            advisedDispatcher,
            new EqualsInterceptor(this.advised),
            new HashCodeInterceptor(this.advised)
        };
        
        return callbacks;
    }
}
```

### 5.2 DynamicAdvisedInterceptor

```java
private static class DynamicAdvisedInterceptor implements MethodInterceptor {
    
    private final AdvisedSupport advised;
    
    @Override
    public Object intercept(Object proxy, Method method, Object[] args, 
            MethodProxy methodProxy) throws Throwable {
        
        Object oldProxy = null;
        boolean setProxyContext = false;
        Object target = null;
        TargetSource targetSource = this.advised.getTargetSource();
        
        try {
            if (this.advised.exposeProxy) {
                oldProxy = AopContext.setCurrentProxy(proxy);
                setProxyContext = true;
            }
            
            target = targetSource.getTarget();
            Class<?> targetClass = (target != null ? target.getClass() : null);
            
            // è·å–æ‹¦æˆªå™¨é“¾
            List<Object> chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(
                method, targetClass);
            
            Object retVal;
            if (chain.isEmpty() && Modifier.isPublic(method.getModifiers())) {
                // ç›´æ¥è°ƒç”¨ç›®æ ‡æ–¹æ³•
                Object[] argsToUse = AopProxyUtils.adaptArgumentsIfNecessary(method, args);
                retVal = methodProxy.invoke(target, argsToUse);
            } else {
                // åˆ›å»ºCglibMethodInvocationå¹¶æ‰§è¡Œ
                retVal = new CglibMethodInvocation(proxy, target, method, args, 
                    targetClass, chain, methodProxy).proceed();
            }
            
            return retVal;
        } finally {
            if (target != null && !targetSource.isStatic()) {
                targetSource.releaseTarget(target);
            }
            if (setProxyContext) {
                AopContext.setCurrentProxy(oldProxy);
            }
        }
    }
}
```

### 5.3 CGLIBä»£ç†åŸç†

```java
// CGLIBä»£ç†ç¤ºä¾‹
public class CglibProxyDemo {
    
    public static void main(String[] args) {
        Enhancer enhancer = new Enhancer();
        enhancer.setSuperclass(UserServiceImpl.class);
        enhancer.setCallback(new MethodInterceptor() {
            @Override
            public Object intercept(Object obj, Method method, Object[] args, 
                    MethodProxy proxy) throws Throwable {
                System.out.println("Before: " + method.getName());
                Object result = proxy.invokeSuper(obj, args);
                System.out.println("After: " + method.getName());
                return result;
            }
        });
        
        UserServiceImpl proxy = (UserServiceImpl) enhancer.create();
        proxy.save();
    }
}
```

---

## 6. æ‹¦æˆªå™¨é“¾æ‰§è¡Œ

### 6.1 ReflectiveMethodInvocation

```java
public class ReflectiveMethodInvocation implements ProxyMethodInvocation {
    
    protected final Object proxy;
    protected final Object target;
    protected final Method method;
    protected Object[] arguments;
    private final Class<?> targetClass;
    protected final List<?> interceptorsAndDynamicMethodMatchers;
    private int currentInterceptorIndex = -1;
    
    @Override
    public Object proceed() throws Throwable {
        // æ‰€æœ‰æ‹¦æˆªå™¨æ‰§è¡Œå®Œæ¯•ï¼Œè°ƒç”¨ç›®æ ‡æ–¹æ³•
        if (this.currentInterceptorIndex == 
            this.interceptorsAndDynamicMethodMatchers.size() - 1) {
            return invokeJoinpoint();
        }
        
        // è·å–ä¸‹ä¸€ä¸ªæ‹¦æˆªå™¨
        Object interceptorOrInterceptionAdvice = 
            this.interceptorsAndDynamicMethodMatchers.get(++this.currentInterceptorIndex);
        
        if (interceptorOrInterceptionAdvice instanceof InterceptorAndDynamicMethodMatcher) {
            // åŠ¨æ€åŒ¹é…
            InterceptorAndDynamicMethodMatcher dm = 
                (InterceptorAndDynamicMethodMatcher) interceptorOrInterceptionAdvice;
            if (dm.methodMatcher.matches(this.method, targetClass, this.arguments)) {
                return dm.interceptor.invoke(this);
            } else {
                // ä¸åŒ¹é…ï¼Œè·³è¿‡
                return proceed();
            }
        } else {
            // æ™®é€šæ‹¦æˆªå™¨ï¼Œç›´æ¥è°ƒç”¨
            return ((MethodInterceptor) interceptorOrInterceptionAdvice).invoke(this);
        }
    }
    
    protected Object invokeJoinpoint() throws Throwable {
        return AopUtils.invokeJoinpointUsingReflection(this.target, this.method, 
            this.arguments);
    }
}
```

### 6.2 æ‹¦æˆªå™¨é“¾æ‰§è¡Œæµç¨‹

```
æ‹¦æˆªå™¨é“¾æ‰§è¡Œé¡ºåºï¼ˆä»¥@Aroundã€@Beforeã€@Afterä¸ºä¾‹ï¼‰ï¼š

1. ExposeInvocationInterceptor.invoke()
   â””â”€â”€ æš´éœ²MethodInvocationåˆ°ThreadLocal

2. AspectJAroundAdvice.invoke()
   â””â”€â”€ æ‰§è¡Œ@Aroundå‰åŠéƒ¨åˆ†
   
3. MethodBeforeAdviceInterceptor.invoke()
   â””â”€â”€ æ‰§è¡Œ@Before
   
4. AspectJAfterAdvice.invoke()
   â””â”€â”€ try-finallyç»“æ„
   
5. AfterReturningAdviceInterceptor.invoke()
   â””â”€â”€ æ‰§è¡Œ@AfterReturning
   
6. ç›®æ ‡æ–¹æ³•æ‰§è¡Œ

7. è¿”å›æ—¶ä¾æ¬¡æ‰§è¡Œåç½®é€»è¾‘
```

### 6.3 å„ç§Adviceçš„æ‹¦æˆªå™¨å®ç°

```java
// @Before -> MethodBeforeAdviceInterceptor
public class MethodBeforeAdviceInterceptor implements MethodInterceptor {
    private final MethodBeforeAdvice advice;
    
    @Override
    public Object invoke(MethodInvocation mi) throws Throwable {
        // å…ˆæ‰§è¡Œå‰ç½®é€šçŸ¥
        this.advice.before(mi.getMethod(), mi.getArguments(), mi.getThis());
        // å†æ‰§è¡Œä¸‹ä¸€ä¸ªæ‹¦æˆªå™¨
        return mi.proceed();
    }
}

// @After -> AspectJAfterAdvice
public class AspectJAfterAdvice implements MethodInterceptor {
    @Override
    public Object invoke(MethodInvocation mi) throws Throwable {
        try {
            return mi.proceed();
        } finally {
            // finallyä¸­æ‰§è¡Œåç½®é€šçŸ¥
            invokeAdviceMethod(getJoinPointMatch(), null, null);
        }
    }
}

// @AfterReturning -> AfterReturningAdviceInterceptor
public class AfterReturningAdviceInterceptor implements MethodInterceptor {
    private final AfterReturningAdvice advice;
    
    @Override
    public Object invoke(MethodInvocation mi) throws Throwable {
        Object retVal = mi.proceed();
        // æ­£å¸¸è¿”å›åæ‰§è¡Œ
        this.advice.afterReturning(retVal, mi.getMethod(), mi.getArguments(), mi.getThis());
        return retVal;
    }
}

// @AfterThrowing -> AspectJAfterThrowingAdvice
public class AspectJAfterThrowingAdvice implements MethodInterceptor {
    @Override
    public Object invoke(MethodInvocation mi) throws Throwable {
        try {
            return mi.proceed();
        } catch (Throwable ex) {
            // å¼‚å¸¸æ—¶æ‰§è¡Œ
            if (shouldInvokeOnThrowing(ex)) {
                invokeAdviceMethod(getJoinPointMatch(), null, ex);
            }
            throw ex;
        }
    }
}

// @Around -> AspectJAroundAdvice
public class AspectJAroundAdvice implements MethodInterceptor {
    @Override
    public Object invoke(MethodInvocation mi) throws Throwable {
        // ç›´æ¥è°ƒç”¨åˆ‡é¢æ–¹æ³•ï¼Œç”±åˆ‡é¢æ–¹æ³•æ§åˆ¶proceed
        return invokeAdviceMethod(this.pjp, jpm, null, null);
    }
}
```


---

## 7. é¢è¯•è¦ç‚¹

### 7.1 é«˜é¢‘é—®é¢˜

**Q1: Spring AOPæ˜¯å¦‚ä½•å®ç°çš„ï¼Ÿ**
```
Spring AOPåŸºäºåŠ¨æ€ä»£ç†å®ç°ï¼š
1. å¦‚æœç›®æ ‡ç±»å®ç°äº†æ¥å£ï¼Œé»˜è®¤ä½¿ç”¨JDKåŠ¨æ€ä»£ç†
2. å¦‚æœç›®æ ‡ç±»æ²¡æœ‰å®ç°æ¥å£ï¼Œä½¿ç”¨CGLIBä»£ç†
3. å¯ä»¥é€šè¿‡proxyTargetClass=trueå¼ºåˆ¶ä½¿ç”¨CGLIB

ä»£ç†åˆ›å»ºæ—¶æœºï¼š
- åœ¨Beanåˆå§‹åŒ–åï¼Œé€šè¿‡BeanPostProcessoråˆ›å»ºä»£ç†
- AbstractAutoProxyCreator.postProcessAfterInitialization()
```

**Q2: JDKåŠ¨æ€ä»£ç†å’ŒCGLIBçš„åŒºåˆ«ï¼Ÿ**
```
JDKåŠ¨æ€ä»£ç†ï¼š
- åŸºäºæ¥å£ä»£ç†
- ä½¿ç”¨åå°„è°ƒç”¨ç›®æ ‡æ–¹æ³•
- åªèƒ½ä»£ç†å®ç°äº†æ¥å£çš„ç±»
- ç”Ÿæˆçš„ä»£ç†ç±»ï¼š$Proxy0

CGLIBä»£ç†ï¼š
- åŸºäºç»§æ‰¿ä»£ç†
- ä½¿ç”¨å­—èŠ‚ç ç”Ÿæˆå­ç±»
- å¯ä»¥ä»£ç†æ²¡æœ‰æ¥å£çš„ç±»
- ä¸èƒ½ä»£ç†finalæ–¹æ³•
- ç”Ÿæˆçš„ä»£ç†ç±»ï¼šTarget$$EnhancerBySpringCGLIB$$xxx
```

**Q3: Spring AOPçš„æ‰§è¡Œé¡ºåºï¼Ÿ**
```
æ­£å¸¸æ‰§è¡Œï¼š
@Aroundå‰ â†’ @Before â†’ ç›®æ ‡æ–¹æ³• â†’ @AfterReturning â†’ @After â†’ @Aroundå

å¼‚å¸¸æ‰§è¡Œï¼š
@Aroundå‰ â†’ @Before â†’ ç›®æ ‡æ–¹æ³•(å¼‚å¸¸) â†’ @AfterThrowing â†’ @After

å¤šä¸ªåˆ‡é¢çš„é¡ºåºï¼š
- ä½¿ç”¨@Orderæ³¨è§£æ§åˆ¶
- æ•°å€¼è¶Šå°ä¼˜å…ˆçº§è¶Šé«˜
- è¿›å…¥æ—¶æŒ‰ä¼˜å…ˆçº§ä»é«˜åˆ°ä½
- é€€å‡ºæ—¶æŒ‰ä¼˜å…ˆçº§ä»ä½åˆ°é«˜
```

**Q4: ä¸ºä»€ä¹ˆåŒä¸€ä¸ªç±»ä¸­æ–¹æ³•è°ƒç”¨ä¸ä¼šè§¦å‘AOPï¼Ÿ**
```
åŸå› ï¼š
- AOPæ˜¯åŸºäºä»£ç†å®ç°çš„
- åŒä¸€ä¸ªç±»ä¸­çš„æ–¹æ³•è°ƒç”¨æ˜¯this.method()
- thisæŒ‡å‘çš„æ˜¯ç›®æ ‡å¯¹è±¡ï¼Œä¸æ˜¯ä»£ç†å¯¹è±¡
- æ‰€ä»¥ä¸ä¼šç»è¿‡ä»£ç†çš„æ‹¦æˆª

è§£å†³æ–¹æ¡ˆï¼š
1. æ³¨å…¥è‡ªå·±ï¼š@Autowired private UserService self;
2. ä½¿ç”¨AopContextï¼šAopContext.currentProxy()
3. æ‹†åˆ†åˆ°ä¸åŒçš„ç±»ä¸­
```

**Q5: @Transactionalå¤±æ•ˆçš„åœºæ™¯ï¼Ÿ**
```
1. æ–¹æ³•ä¸æ˜¯publicçš„
2. åŒä¸€ä¸ªç±»ä¸­æ–¹æ³•è°ƒç”¨
3. å¼‚å¸¸è¢«catchæ²¡æœ‰æŠ›å‡º
4. æŠ›å‡ºçš„æ˜¯éRuntimeException
5. æ•°æ®åº“ä¸æ”¯æŒäº‹åŠ¡
6. æ²¡æœ‰è¢«Springç®¡ç†
```

### 7.2 æ ¸å¿ƒç±»æ€»ç»“

```
ä»£ç†åˆ›å»ºï¼š
- AnnotationAwareAspectJAutoProxyCreatorï¼šè‡ªåŠ¨ä»£ç†åˆ›å»ºå™¨
- ProxyFactoryï¼šä»£ç†å·¥å‚
- DefaultAopProxyFactoryï¼šé€‰æ‹©ä»£ç†æ–¹å¼
- JdkDynamicAopProxyï¼šJDKä»£ç†å®ç°
- CglibAopProxyï¼šCGLIBä»£ç†å®ç°

åˆ‡é¢ç›¸å…³ï¼š
- Advisorï¼šåˆ‡é¢æ¥å£
- PointcutAdvisorï¼šå¸¦åˆ‡å…¥ç‚¹çš„åˆ‡é¢
- AspectJExpressionPointcutï¼šAspectJè¡¨è¾¾å¼åˆ‡å…¥ç‚¹

æ‹¦æˆªå™¨ï¼š
- MethodInterceptorï¼šæ–¹æ³•æ‹¦æˆªå™¨æ¥å£
- ReflectiveMethodInvocationï¼šåå°„æ–¹æ³•è°ƒç”¨
- ExposeInvocationInterceptorï¼šæš´éœ²è°ƒç”¨ä¸Šä¸‹æ–‡
```

### 7.3 ä»£ç†é€‰æ‹©ç­–ç•¥

```java
// DefaultAopProxyFactoryä¸­çš„é€‰æ‹©é€»è¾‘
public AopProxy createAopProxy(AdvisedSupport config) {
    // ä»¥ä¸‹æƒ…å†µä½¿ç”¨CGLIBï¼š
    // 1. optimize=trueï¼ˆä¼˜åŒ–ï¼‰
    // 2. proxyTargetClass=trueï¼ˆå¼ºåˆ¶CGLIBï¼‰
    // 3. æ²¡æœ‰ä»£ç†æ¥å£
    if (config.isOptimize() || config.isProxyTargetClass() || 
        hasNoUserSuppliedProxyInterfaces(config)) {
        
        Class<?> targetClass = config.getTargetClass();
        // ç›®æ ‡ç±»æ˜¯æ¥å£æˆ–å·²ç»æ˜¯ä»£ç†ç±»ï¼Œä½¿ç”¨JDK
        if (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) {
            return new JdkDynamicAopProxy(config);
        }
        // å¦åˆ™ä½¿ç”¨CGLIB
        return new ObjenesisCglibAopProxy(config);
    }
    // é»˜è®¤ä½¿ç”¨JDKä»£ç†
    return new JdkDynamicAopProxy(config);
}
```

---

## ğŸ“Š AOPæ‰§è¡Œæµç¨‹å›¾

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      å®¢æˆ·ç«¯è°ƒç”¨                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚
                              â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      ä»£ç†å¯¹è±¡                                â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚              JdkDynamicAopProxy.invoke()            â”‚   â”‚
â”‚  â”‚                        æˆ–                            â”‚   â”‚
â”‚  â”‚         CglibAopProxy.DynamicAdvisedInterceptor     â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚
                              â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   è·å–æ‹¦æˆªå™¨é“¾                               â”‚
â”‚         getInterceptorsAndDynamicInterceptionAdvice()       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚
                              â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              ReflectiveMethodInvocation.proceed()           â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚  æ‹¦æˆªå™¨1 â†’ æ‹¦æˆªå™¨2 â†’ ... â†’ æ‹¦æˆªå™¨N â†’ ç›®æ ‡æ–¹æ³•        â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚
                              â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      ç›®æ ‡å¯¹è±¡                                â”‚
â”‚                   target.method()                           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

**æ·±å…¥ç†è§£AOPï¼ŒæŒæ¡Springæ ¸å¿ƒï¼** ğŸš€

*æœ€åæ›´æ–°ï¼š2025-12-28*

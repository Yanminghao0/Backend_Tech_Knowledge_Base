# äº‹åŠ¡ç®¡ç†æºç è§£æ

> ğŸ’¡ æ·±å…¥ç†è§£Springäº‹åŠ¡ç®¡ç†çš„å®ç°åŸç†ï¼Œä»@Transactionalåˆ°äº‹åŠ¡ä¼ æ’­

---

## ğŸ“‹ ç›®å½•

- [1. äº‹åŠ¡æ¦‚è¿°](#1-äº‹åŠ¡æ¦‚è¿°)
- [2. æ ¸å¿ƒæ¥å£](#2-æ ¸å¿ƒæ¥å£)
- [3. @Transactionalè§£æ](#3-transactionalè§£æ)
- [4. äº‹åŠ¡æ‹¦æˆªå™¨](#4-äº‹åŠ¡æ‹¦æˆªå™¨)
- [5. äº‹åŠ¡ä¼ æ’­æœºåˆ¶](#5-äº‹åŠ¡ä¼ æ’­æœºåˆ¶)
- [6. äº‹åŠ¡åŒæ­¥ç®¡ç†](#6-äº‹åŠ¡åŒæ­¥ç®¡ç†)
- [7. é¢è¯•è¦ç‚¹](#7-é¢è¯•è¦ç‚¹)

---

## 1. äº‹åŠ¡æ¦‚è¿°

### 1.1 äº‹åŠ¡çš„ACIDç‰¹æ€§

```
A - Atomicityï¼ˆåŸå­æ€§ï¼‰
    äº‹åŠ¡æ˜¯ä¸å¯åˆ†å‰²çš„å·¥ä½œå•ä½ï¼Œè¦ä¹ˆå…¨éƒ¨æˆåŠŸï¼Œè¦ä¹ˆå…¨éƒ¨å¤±è´¥

C - Consistencyï¼ˆä¸€è‡´æ€§ï¼‰
    äº‹åŠ¡æ‰§è¡Œå‰åï¼Œæ•°æ®åº“ä»ä¸€ä¸ªä¸€è‡´æ€§çŠ¶æ€è½¬æ¢åˆ°å¦ä¸€ä¸ªä¸€è‡´æ€§çŠ¶æ€

I - Isolationï¼ˆéš”ç¦»æ€§ï¼‰
    å¤šä¸ªäº‹åŠ¡å¹¶å‘æ‰§è¡Œæ—¶ï¼Œä¸€ä¸ªäº‹åŠ¡çš„æ‰§è¡Œä¸åº”å½±å“å…¶ä»–äº‹åŠ¡

D - Durabilityï¼ˆæŒä¹…æ€§ï¼‰
    äº‹åŠ¡ä¸€æ—¦æäº¤ï¼Œå…¶ç»“æœå°±æ˜¯æ°¸ä¹…æ€§çš„
```

### 1.2 Springäº‹åŠ¡ç®¡ç†æ–¹å¼

```
ç¼–ç¨‹å¼äº‹åŠ¡ï¼š
- ä½¿ç”¨TransactionTemplate
- ä½¿ç”¨PlatformTransactionManager
- ä»£ç ä¾µå…¥æ€§å¼ºï¼Œçµæ´»æ€§é«˜

å£°æ˜å¼äº‹åŠ¡ï¼š
- ä½¿ç”¨@Transactionalæ³¨è§£
- åŸºäºAOPå®ç°
- ä»£ç ä¾µå…¥æ€§ä½ï¼Œä½¿ç”¨ç®€å•
```

---

## 2. æ ¸å¿ƒæ¥å£

### 2.1 PlatformTransactionManager

```java
// äº‹åŠ¡ç®¡ç†å™¨æ ¸å¿ƒæ¥å£
public interface PlatformTransactionManager extends TransactionManager {
    
    // è·å–äº‹åŠ¡
    TransactionStatus getTransaction(TransactionDefinition definition) 
        throws TransactionException;
    
    // æäº¤äº‹åŠ¡
    void commit(TransactionStatus status) throws TransactionException;
    
    // å›æ»šäº‹åŠ¡
    void rollback(TransactionStatus status) throws TransactionException;
}

// å¸¸ç”¨å®ç°ç±»
DataSourceTransactionManager  // JDBCäº‹åŠ¡
JpaTransactionManager         // JPAäº‹åŠ¡
HibernateTransactionManager   // Hibernateäº‹åŠ¡
JtaTransactionManager         // JTAåˆ†å¸ƒå¼äº‹åŠ¡
```

### 2.2 TransactionDefinition

```java
// äº‹åŠ¡å®šä¹‰æ¥å£
public interface TransactionDefinition {
    
    // ä¼ æ’­è¡Œä¸º
    int PROPAGATION_REQUIRED = 0;      // é»˜è®¤ï¼Œæœ‰åˆ™åŠ å…¥ï¼Œæ— åˆ™æ–°å»º
    int PROPAGATION_SUPPORTS = 1;      // æœ‰åˆ™åŠ å…¥ï¼Œæ— åˆ™éäº‹åŠ¡
    int PROPAGATION_MANDATORY = 2;     // å¿…é¡»æœ‰äº‹åŠ¡ï¼Œå¦åˆ™å¼‚å¸¸
    int PROPAGATION_REQUIRES_NEW = 3;  // æ€»æ˜¯æ–°å»ºäº‹åŠ¡
    int PROPAGATION_NOT_SUPPORTED = 4; // éäº‹åŠ¡æ‰§è¡Œ
    int PROPAGATION_NEVER = 5;         // å¿…é¡»éäº‹åŠ¡ï¼Œå¦åˆ™å¼‚å¸¸
    int PROPAGATION_NESTED = 6;        // åµŒå¥—äº‹åŠ¡
    
    // éš”ç¦»çº§åˆ«
    int ISOLATION_DEFAULT = -1;
    int ISOLATION_READ_UNCOMMITTED = 1;
    int ISOLATION_READ_COMMITTED = 2;
    int ISOLATION_REPEATABLE_READ = 4;
    int ISOLATION_SERIALIZABLE = 8;
    
    // è·å–ä¼ æ’­è¡Œä¸º
    int getPropagationBehavior();
    
    // è·å–éš”ç¦»çº§åˆ«
    int getIsolationLevel();
    
    // è·å–è¶…æ—¶æ—¶é—´
    int getTimeout();
    
    // æ˜¯å¦åªè¯»
    boolean isReadOnly();
    
    // è·å–äº‹åŠ¡åç§°
    String getName();
}
```

### 2.3 TransactionStatus

```java
// äº‹åŠ¡çŠ¶æ€æ¥å£
public interface TransactionStatus extends TransactionExecution, SavepointManager {
    
    // æ˜¯å¦æ˜¯æ–°äº‹åŠ¡
    boolean isNewTransaction();
    
    // æ˜¯å¦æœ‰ä¿å­˜ç‚¹
    boolean hasSavepoint();
    
    // è®¾ç½®å›æ»š
    void setRollbackOnly();
    
    // æ˜¯å¦å·²æ ‡è®°å›æ»š
    boolean isRollbackOnly();
    
    // æ˜¯å¦å·²å®Œæˆ
    boolean isCompleted();
}
```

---

## 3. @Transactionalè§£æ

### 3.1 @EnableTransactionManagement

```java
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Import(TransactionManagementConfigurationSelector.class)
public @interface EnableTransactionManagement {
    
    // æ˜¯å¦ä½¿ç”¨CGLIBä»£ç†
    boolean proxyTargetClass() default false;
    
    // é€šçŸ¥æ¨¡å¼ï¼šPROXYæˆ–ASPECTJ
    AdviceMode mode() default AdviceMode.PROXY;
    
    // é¡ºåº
    int order() default Ordered.LOWEST_PRECEDENCE;
}

// TransactionManagementConfigurationSelector
public class TransactionManagementConfigurationSelector 
        extends AdviceModeImportSelector<EnableTransactionManagement> {
    
    @Override
    protected String[] selectImports(AdviceMode adviceMode) {
        switch (adviceMode) {
            case PROXY:
                return new String[] {
                    AutoProxyRegistrar.class.getName(),
                    ProxyTransactionManagementConfiguration.class.getName()
                };
            case ASPECTJ:
                return new String[] {
                    TransactionManagementConfigUtils.TRANSACTION_ASPECT_CONFIGURATION_CLASS_NAME
                };
            default:
                return null;
        }
    }
}
```

### 3.2 ProxyTransactionManagementConfiguration

```java
@Configuration
public class ProxyTransactionManagementConfiguration 
        extends AbstractTransactionManagementConfiguration {
    
    // äº‹åŠ¡åˆ‡é¢
    @Bean
    @Role(BeanDefinition.ROLE_INFRASTRUCTURE)
    public BeanFactoryTransactionAttributeSourceAdvisor transactionAdvisor(
            TransactionAttributeSource transactionAttributeSource,
            TransactionInterceptor transactionInterceptor) {
        
        BeanFactoryTransactionAttributeSourceAdvisor advisor = 
            new BeanFactoryTransactionAttributeSourceAdvisor();
        advisor.setTransactionAttributeSource(transactionAttributeSource);
        advisor.setAdvice(transactionInterceptor);
        advisor.setOrder(this.enableTx.getNumber("order"));
        return advisor;
    }
    
    // äº‹åŠ¡å±æ€§æº
    @Bean
    @Role(BeanDefinition.ROLE_INFRASTRUCTURE)
    public TransactionAttributeSource transactionAttributeSource() {
        return new AnnotationTransactionAttributeSource();
    }
    
    // äº‹åŠ¡æ‹¦æˆªå™¨
    @Bean
    @Role(BeanDefinition.ROLE_INFRASTRUCTURE)
    public TransactionInterceptor transactionInterceptor(
            TransactionAttributeSource transactionAttributeSource) {
        
        TransactionInterceptor interceptor = new TransactionInterceptor();
        interceptor.setTransactionAttributeSource(transactionAttributeSource);
        if (this.txManager != null) {
            interceptor.setTransactionManager(this.txManager);
        }
        return interceptor;
    }
}
```

### 3.3 @Transactionalå±æ€§è§£æ

```java
// AnnotationTransactionAttributeSource
public class AnnotationTransactionAttributeSource 
        extends AbstractFallbackTransactionAttributeSource {
    
    private final Set<TransactionAnnotationParser> annotationParsers;
    
    public AnnotationTransactionAttributeSource() {
        this.annotationParsers = new LinkedHashSet<>(4);
        // Spring @Transactional
        this.annotationParsers.add(new SpringTransactionAnnotationParser());
        // JTA @Transactional
        this.annotationParsers.add(new JtaTransactionAnnotationParser());
        // EJB3 @TransactionAttribute
        this.annotationParsers.add(new Ejb3TransactionAnnotationParser());
    }
    
    @Override
    protected TransactionAttribute findTransactionAttribute(Class<?> clazz) {
        return determineTransactionAttribute(clazz);
    }
    
    @Override
    protected TransactionAttribute findTransactionAttribute(Method method) {
        return determineTransactionAttribute(method);
    }
    
    protected TransactionAttribute determineTransactionAttribute(AnnotatedElement element) {
        for (TransactionAnnotationParser parser : this.annotationParsers) {
            TransactionAttribute attr = parser.parseTransactionAnnotation(element);
            if (attr != null) {
                return attr;
            }
        }
        return null;
    }
}

// SpringTransactionAnnotationParser
public class SpringTransactionAnnotationParser implements TransactionAnnotationParser {
    
    @Override
    public TransactionAttribute parseTransactionAnnotation(AnnotatedElement element) {
        AnnotationAttributes attributes = AnnotatedElementUtils
            .findMergedAnnotationAttributes(element, Transactional.class, false, false);
        if (attributes != null) {
            return parseTransactionAnnotation(attributes);
        }
        return null;
    }
    
    protected TransactionAttribute parseTransactionAnnotation(AnnotationAttributes attributes) {
        RuleBasedTransactionAttribute rbta = new RuleBasedTransactionAttribute();
        
        // ä¼ æ’­è¡Œä¸º
        Propagation propagation = attributes.getEnum("propagation");
        rbta.setPropagationBehavior(propagation.value());
        
        // éš”ç¦»çº§åˆ«
        Isolation isolation = attributes.getEnum("isolation");
        rbta.setIsolationLevel(isolation.value());
        
        // è¶…æ—¶
        rbta.setTimeout(attributes.getNumber("timeout").intValue());
        
        // åªè¯»
        rbta.setReadOnly(attributes.getBoolean("readOnly"));
        
        // äº‹åŠ¡ç®¡ç†å™¨
        rbta.setQualifier(attributes.getString("value"));
        
        // å›æ»šè§„åˆ™
        List<RollbackRuleAttribute> rollbackRules = new ArrayList<>();
        for (Class<?> rbRule : attributes.getClassArray("rollbackFor")) {
            rollbackRules.add(new RollbackRuleAttribute(rbRule));
        }
        for (String rbRule : attributes.getStringArray("rollbackForClassName")) {
            rollbackRules.add(new RollbackRuleAttribute(rbRule));
        }
        for (Class<?> rbRule : attributes.getClassArray("noRollbackFor")) {
            rollbackRules.add(new NoRollbackRuleAttribute(rbRule));
        }
        for (String rbRule : attributes.getStringArray("noRollbackForClassName")) {
            rollbackRules.add(new NoRollbackRuleAttribute(rbRule));
        }
        rbta.setRollbackRules(rollbackRules);
        
        return rbta;
    }
}
```


---

## 4. äº‹åŠ¡æ‹¦æˆªå™¨

### 4.1 TransactionInterceptor

```java
public class TransactionInterceptor extends TransactionAspectSupport 
        implements MethodInterceptor {
    
    @Override
    public Object invoke(MethodInvocation invocation) throws Throwable {
        // è·å–ç›®æ ‡ç±»
        Class<?> targetClass = (invocation.getThis() != null ? 
            AopUtils.getTargetClass(invocation.getThis()) : null);
        
        // è°ƒç”¨çˆ¶ç±»çš„äº‹åŠ¡å¤„ç†æ–¹æ³•
        return invokeWithinTransaction(invocation.getMethod(), targetClass, 
            invocation::proceed);
    }
}
```

### 4.2 TransactionAspectSupportæ ¸å¿ƒé€»è¾‘

```java
public abstract class TransactionAspectSupport implements BeanFactoryAware {
    
    protected Object invokeWithinTransaction(Method method, Class<?> targetClass,
            final InvocationCallback invocation) throws Throwable {
        
        // 1. è·å–äº‹åŠ¡å±æ€§
        TransactionAttributeSource tas = getTransactionAttributeSource();
        final TransactionAttribute txAttr = (tas != null ? 
            tas.getTransactionAttribute(method, targetClass) : null);
        
        // 2. è·å–äº‹åŠ¡ç®¡ç†å™¨
        final TransactionManager tm = determineTransactionManager(txAttr);
        
        // 3. å“åº”å¼äº‹åŠ¡å¤„ç†ï¼ˆSpring 5.2+ï¼‰
        if (this.reactiveAdapterRegistry != null && tm instanceof ReactiveTransactionManager) {
            // å“åº”å¼äº‹åŠ¡å¤„ç†...
        }
        
        PlatformTransactionManager ptm = asPlatformTransactionManager(tm);
        final String joinpointIdentification = methodIdentification(method, targetClass, txAttr);
        
        // 4. å£°æ˜å¼äº‹åŠ¡å¤„ç†
        if (txAttr == null || !(ptm instanceof CallbackPreferringPlatformTransactionManager)) {
            // åˆ›å»ºäº‹åŠ¡
            TransactionInfo txInfo = createTransactionIfNecessary(ptm, txAttr, 
                joinpointIdentification);
            
            Object retVal;
            try {
                // æ‰§è¡Œç›®æ ‡æ–¹æ³•
                retVal = invocation.proceedWithInvocation();
            } catch (Throwable ex) {
                // å¼‚å¸¸å¤„ç†ï¼Œå†³å®šå›æ»šè¿˜æ˜¯æäº¤
                completeTransactionAfterThrowing(txInfo, ex);
                throw ex;
            } finally {
                // æ¸…ç†äº‹åŠ¡ä¿¡æ¯
                cleanupTransactionInfo(txInfo);
            }
            
            // æäº¤äº‹åŠ¡
            commitTransactionAfterReturning(txInfo);
            return retVal;
        }
        
        // 5. ç¼–ç¨‹å¼äº‹åŠ¡å¤„ç†
        else {
            // CallbackPreferringPlatformTransactionManagerå¤„ç†...
        }
    }
}
```

### 4.3 åˆ›å»ºäº‹åŠ¡

```java
protected TransactionInfo createTransactionIfNecessary(
        PlatformTransactionManager tm, TransactionAttribute txAttr, 
        final String joinpointIdentification) {
    
    // å¦‚æœæ²¡æœ‰åç§°ï¼Œä½¿ç”¨æ–¹æ³•æ ‡è¯†ä½œä¸ºäº‹åŠ¡åç§°
    if (txAttr != null && txAttr.getName() == null) {
        txAttr = new DelegatingTransactionAttribute(txAttr) {
            @Override
            public String getName() {
                return joinpointIdentification;
            }
        };
    }
    
    TransactionStatus status = null;
    if (txAttr != null) {
        if (tm != null) {
            // è·å–äº‹åŠ¡çŠ¶æ€
            status = tm.getTransaction(txAttr);
        }
    }
    
    // å‡†å¤‡äº‹åŠ¡ä¿¡æ¯
    return prepareTransactionInfo(tm, txAttr, joinpointIdentification, status);
}

// AbstractPlatformTransactionManager.getTransaction()
@Override
public final TransactionStatus getTransaction(TransactionDefinition definition) 
        throws TransactionException {
    
    // è·å–äº‹åŠ¡å®šä¹‰
    TransactionDefinition def = (definition != null ? definition : 
        TransactionDefinition.withDefaults());
    
    // è·å–äº‹åŠ¡å¯¹è±¡
    Object transaction = doGetTransaction();
    
    // æ˜¯å¦å­˜åœ¨äº‹åŠ¡
    if (isExistingTransaction(transaction)) {
        // å¤„ç†å·²å­˜åœ¨çš„äº‹åŠ¡
        return handleExistingTransaction(def, transaction, debugEnabled);
    }
    
    // æ£€æŸ¥è¶…æ—¶
    if (def.getTimeout() < TransactionDefinition.TIMEOUT_DEFAULT) {
        throw new InvalidTimeoutException("Invalid transaction timeout", def.getTimeout());
    }
    
    // æ ¹æ®ä¼ æ’­è¡Œä¸ºå¤„ç†
    if (def.getPropagationBehavior() == TransactionDefinition.PROPAGATION_MANDATORY) {
        throw new IllegalTransactionStateException(
            "No existing transaction found for transaction marked with propagation 'mandatory'");
    }
    else if (def.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRED ||
             def.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRES_NEW ||
             def.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NESTED) {
        // æŒ‚èµ·å½“å‰äº‹åŠ¡ï¼ˆå¦‚æœæœ‰ï¼‰
        SuspendedResourcesHolder suspendedResources = suspend(null);
        try {
            // å¼€å§‹æ–°äº‹åŠ¡
            return startTransaction(def, transaction, debugEnabled, suspendedResources);
        } catch (RuntimeException | Error ex) {
            resume(null, suspendedResources);
            throw ex;
        }
    }
    else {
        // åˆ›å»ºç©ºäº‹åŠ¡
        boolean newSynchronization = (getTransactionSynchronization() == SYNCHRONIZATION_ALWAYS);
        return prepareTransactionStatus(def, null, true, newSynchronization, debugEnabled, null);
    }
}
```

### 4.4 å¼‚å¸¸å¤„ç†ä¸å›æ»š

```java
protected void completeTransactionAfterThrowing(TransactionInfo txInfo, Throwable ex) {
    if (txInfo != null && txInfo.getTransactionStatus() != null) {
        // åˆ¤æ–­æ˜¯å¦éœ€è¦å›æ»š
        if (txInfo.transactionAttribute != null && 
            txInfo.transactionAttribute.rollbackOn(ex)) {
            try {
                // å›æ»šäº‹åŠ¡
                txInfo.getTransactionManager().rollback(txInfo.getTransactionStatus());
            } catch (TransactionSystemException ex2) {
                ex2.initApplicationException(ex);
                throw ex2;
            } catch (RuntimeException | Error ex2) {
                throw ex2;
            }
        } else {
            // ä¸å›æ»šï¼Œæäº¤äº‹åŠ¡
            try {
                txInfo.getTransactionManager().commit(txInfo.getTransactionStatus());
            } catch (TransactionSystemException ex2) {
                ex2.initApplicationException(ex);
                throw ex2;
            } catch (RuntimeException | Error ex2) {
                throw ex2;
            }
        }
    }
}

// RuleBasedTransactionAttribute.rollbackOn()
@Override
public boolean rollbackOn(Throwable ex) {
    RollbackRuleAttribute winner = null;
    int deepest = Integer.MAX_VALUE;
    
    // éå†å›æ»šè§„åˆ™
    if (this.rollbackRules != null) {
        for (RollbackRuleAttribute rule : this.rollbackRules) {
            int depth = rule.getDepth(ex);
            if (depth >= 0 && depth < deepest) {
                deepest = depth;
                winner = rule;
            }
        }
    }
    
    // å¦‚æœæ²¡æœ‰åŒ¹é…çš„è§„åˆ™ï¼Œä½¿ç”¨é»˜è®¤è§„åˆ™
    if (winner == null) {
        // é»˜è®¤ï¼šRuntimeExceptionå’ŒErrorå›æ»š
        return super.rollbackOn(ex);
    }
    
    // NoRollbackRuleAttributeä¸å›æ»š
    return !(winner instanceof NoRollbackRuleAttribute);
}
```

---

## 5. äº‹åŠ¡ä¼ æ’­æœºåˆ¶

### 5.1 ä¼ æ’­è¡Œä¸ºè¯¦è§£

```java
// ä¼ æ’­è¡Œä¸ºå¸¸é‡
public interface TransactionDefinition {
    
    // REQUIREDï¼šæœ‰äº‹åŠ¡åŠ å…¥ï¼Œæ²¡æœ‰æ–°å»ºï¼ˆé»˜è®¤ï¼‰
    int PROPAGATION_REQUIRED = 0;
    
    // SUPPORTSï¼šæœ‰äº‹åŠ¡åŠ å…¥ï¼Œæ²¡æœ‰éäº‹åŠ¡æ‰§è¡Œ
    int PROPAGATION_SUPPORTS = 1;
    
    // MANDATORYï¼šå¿…é¡»æœ‰äº‹åŠ¡ï¼Œå¦åˆ™æŠ›å¼‚å¸¸
    int PROPAGATION_MANDATORY = 2;
    
    // REQUIRES_NEWï¼šæ€»æ˜¯æ–°å»ºäº‹åŠ¡ï¼ŒæŒ‚èµ·å½“å‰äº‹åŠ¡
    int PROPAGATION_REQUIRES_NEW = 3;
    
    // NOT_SUPPORTEDï¼šéäº‹åŠ¡æ‰§è¡Œï¼ŒæŒ‚èµ·å½“å‰äº‹åŠ¡
    int PROPAGATION_NOT_SUPPORTED = 4;
    
    // NEVERï¼šéäº‹åŠ¡æ‰§è¡Œï¼Œæœ‰äº‹åŠ¡æŠ›å¼‚å¸¸
    int PROPAGATION_NEVER = 5;
    
    // NESTEDï¼šåµŒå¥—äº‹åŠ¡ï¼Œä½¿ç”¨ä¿å­˜ç‚¹
    int PROPAGATION_NESTED = 6;
}
```

### 5.2 å¤„ç†å·²å­˜åœ¨äº‹åŠ¡

```java
// AbstractPlatformTransactionManager.handleExistingTransaction()
private TransactionStatus handleExistingTransaction(
        TransactionDefinition definition, Object transaction, boolean debugEnabled)
        throws TransactionException {
    
    // NEVERï¼šæœ‰äº‹åŠ¡æŠ›å¼‚å¸¸
    if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NEVER) {
        throw new IllegalTransactionStateException(
            "Existing transaction found for transaction marked with propagation 'never'");
    }
    
    // NOT_SUPPORTEDï¼šæŒ‚èµ·å½“å‰äº‹åŠ¡ï¼Œéäº‹åŠ¡æ‰§è¡Œ
    if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NOT_SUPPORTED) {
        Object suspendedResources = suspend(transaction);
        boolean newSynchronization = (getTransactionSynchronization() == SYNCHRONIZATION_ALWAYS);
        return prepareTransactionStatus(definition, null, false, 
            newSynchronization, debugEnabled, suspendedResources);
    }
    
    // REQUIRES_NEWï¼šæŒ‚èµ·å½“å‰äº‹åŠ¡ï¼Œæ–°å»ºäº‹åŠ¡
    if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRES_NEW) {
        SuspendedResourcesHolder suspendedResources = suspend(transaction);
        try {
            return startTransaction(definition, transaction, debugEnabled, suspendedResources);
        } catch (RuntimeException | Error beginEx) {
            resumeAfterBeginException(transaction, suspendedResources, beginEx);
            throw beginEx;
        }
    }
    
    // NESTEDï¼šåµŒå¥—äº‹åŠ¡
    if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NESTED) {
        if (!isNestedTransactionAllowed()) {
            throw new NestedTransactionNotSupportedException(
                "Transaction manager does not allow nested transactions by default");
        }
        if (useSavepointForNestedTransaction()) {
            // ä½¿ç”¨ä¿å­˜ç‚¹å®ç°åµŒå¥—äº‹åŠ¡
            DefaultTransactionStatus status = prepareTransactionStatus(
                definition, transaction, false, false, debugEnabled, null);
            status.createAndHoldSavepoint();
            return status;
        } else {
            // JTAä½¿ç”¨åµŒå¥—begin/commit
            return startTransaction(definition, transaction, debugEnabled, null);
        }
    }
    
    // SUPPORTSã€REQUIREDã€MANDATORYï¼šåŠ å…¥å½“å‰äº‹åŠ¡
    boolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER);
    return prepareTransactionStatus(definition, transaction, false, 
        newSynchronization, debugEnabled, null);
}
```

### 5.3 ä¼ æ’­è¡Œä¸ºç¤ºä¾‹

```java
@Service
public class OrderService {
    
    @Autowired
    private StockService stockService;
    
    @Autowired
    private LogService logService;
    
    // å¤–å±‚äº‹åŠ¡
    @Transactional
    public void createOrder(Order order) {
        // 1. åˆ›å»ºè®¢å•
        orderDao.insert(order);
        
        // 2. æ‰£å‡åº“å­˜ï¼ˆREQUIREDï¼šåŠ å…¥å½“å‰äº‹åŠ¡ï¼‰
        stockService.deductStock(order.getProductId(), order.getQuantity());
        
        // 3. è®°å½•æ—¥å¿—ï¼ˆREQUIRES_NEWï¼šæ–°å»ºäº‹åŠ¡ï¼‰
        logService.log("åˆ›å»ºè®¢å•: " + order.getId());
    }
}

@Service
public class StockService {
    
    // REQUIREDï¼šåŠ å…¥å¤–å±‚äº‹åŠ¡ï¼Œä¸€èµ·æäº¤æˆ–å›æ»š
    @Transactional(propagation = Propagation.REQUIRED)
    public void deductStock(Long productId, int quantity) {
        stockDao.deduct(productId, quantity);
    }
}

@Service
public class LogService {
    
    // REQUIRES_NEWï¼šæ–°å»ºç‹¬ç«‹äº‹åŠ¡ï¼Œä¸å—å¤–å±‚äº‹åŠ¡å½±å“
    @Transactional(propagation = Propagation.REQUIRES_NEW)
    public void log(String message) {
        logDao.insert(message);
    }
}
```


---

## 6. äº‹åŠ¡åŒæ­¥ç®¡ç†

### 6.1 TransactionSynchronizationManager

```java
public abstract class TransactionSynchronizationManager {
    
    // å½“å‰çº¿ç¨‹ç»‘å®šçš„èµ„æºï¼ˆå¦‚æ•°æ®åº“è¿æ¥ï¼‰
    private static final ThreadLocal<Map<Object, Object>> resources = 
        new NamedThreadLocal<>("Transactional resources");
    
    // å½“å‰çº¿ç¨‹çš„äº‹åŠ¡åŒæ­¥å™¨
    private static final ThreadLocal<Set<TransactionSynchronization>> synchronizations = 
        new NamedThreadLocal<>("Transaction synchronizations");
    
    // å½“å‰äº‹åŠ¡åç§°
    private static final ThreadLocal<String> currentTransactionName = 
        new NamedThreadLocal<>("Current transaction name");
    
    // å½“å‰äº‹åŠ¡æ˜¯å¦åªè¯»
    private static final ThreadLocal<Boolean> currentTransactionReadOnly = 
        new NamedThreadLocal<>("Current transaction read-only status");
    
    // å½“å‰äº‹åŠ¡éš”ç¦»çº§åˆ«
    private static final ThreadLocal<Integer> currentTransactionIsolationLevel = 
        new NamedThreadLocal<>("Current transaction isolation level");
    
    // å½“å‰äº‹åŠ¡æ˜¯å¦æ¿€æ´»
    private static final ThreadLocal<Boolean> actualTransactionActive = 
        new NamedThreadLocal<>("Actual transaction active");
    
    // ç»‘å®šèµ„æº
    public static void bindResource(Object key, Object value) {
        Map<Object, Object> map = resources.get();
        if (map == null) {
            map = new HashMap<>();
            resources.set(map);
        }
        Object oldValue = map.put(key, value);
        if (oldValue != null) {
            throw new IllegalStateException("Already value bound to thread");
        }
    }
    
    // è·å–èµ„æº
    public static Object getResource(Object key) {
        Map<Object, Object> map = resources.get();
        if (map == null) {
            return null;
        }
        return map.get(key);
    }
    
    // è§£ç»‘èµ„æº
    public static Object unbindResource(Object key) {
        Map<Object, Object> map = resources.get();
        if (map == null) {
            return null;
        }
        Object value = map.remove(key);
        if (map.isEmpty()) {
            resources.remove();
        }
        return value;
    }
    
    // æ³¨å†Œäº‹åŠ¡åŒæ­¥å™¨
    public static void registerSynchronization(TransactionSynchronization synchronization) {
        Set<TransactionSynchronization> synchs = synchronizations.get();
        if (synchs == null) {
            throw new IllegalStateException("Transaction synchronization is not active");
        }
        synchs.add(synchronization);
    }
    
    // æ˜¯å¦æœ‰æ¿€æ´»çš„äº‹åŠ¡
    public static boolean isActualTransactionActive() {
        return (actualTransactionActive.get() != null);
    }
}
```

### 6.2 TransactionSynchronizationæ¥å£

```java
public interface TransactionSynchronization {
    
    int STATUS_COMMITTED = 0;
    int STATUS_ROLLED_BACK = 1;
    int STATUS_UNKNOWN = 2;
    
    // äº‹åŠ¡æŒ‚èµ·æ—¶è°ƒç”¨
    default void suspend() {}
    
    // äº‹åŠ¡æ¢å¤æ—¶è°ƒç”¨
    default void resume() {}
    
    // äº‹åŠ¡æäº¤å‰è°ƒç”¨
    default void beforeCommit(boolean readOnly) {}
    
    // äº‹åŠ¡å®Œæˆå‰è°ƒç”¨
    default void beforeCompletion() {}
    
    // äº‹åŠ¡æäº¤åè°ƒç”¨
    default void afterCommit() {}
    
    // äº‹åŠ¡å®Œæˆåè°ƒç”¨
    default void afterCompletion(int status) {}
}
```

### 6.3 äº‹åŠ¡åŒæ­¥ä½¿ç”¨ç¤ºä¾‹

```java
@Service
public class OrderService {
    
    @Transactional
    public void createOrder(Order order) {
        // ä¿å­˜è®¢å•
        orderDao.insert(order);
        
        // æ³¨å†Œäº‹åŠ¡åŒæ­¥å™¨ï¼Œåœ¨äº‹åŠ¡æäº¤åå‘é€æ¶ˆæ¯
        TransactionSynchronizationManager.registerSynchronization(
            new TransactionSynchronization() {
                @Override
                public void afterCommit() {
                    // äº‹åŠ¡æäº¤åå‘é€æ¶ˆæ¯
                    messageService.sendOrderCreatedMessage(order);
                }
                
                @Override
                public void afterCompletion(int status) {
                    if (status == STATUS_ROLLED_BACK) {
                        // äº‹åŠ¡å›æ»šåçš„å¤„ç†
                        log.warn("è®¢å•åˆ›å»ºäº‹åŠ¡å›æ»š: " + order.getId());
                    }
                }
            }
        );
    }
}
```

### 6.4 DataSourceTransactionManagerå®ç°

```java
public class DataSourceTransactionManager extends AbstractPlatformTransactionManager {
    
    private DataSource dataSource;
    
    @Override
    protected Object doGetTransaction() {
        DataSourceTransactionObject txObject = new DataSourceTransactionObject();
        txObject.setSavepointAllowed(isNestedTransactionAllowed());
        // ä»ThreadLocalè·å–è¿æ¥
        ConnectionHolder conHolder = (ConnectionHolder) 
            TransactionSynchronizationManager.getResource(obtainDataSource());
        txObject.setConnectionHolder(conHolder, false);
        return txObject;
    }
    
    @Override
    protected void doBegin(Object transaction, TransactionDefinition definition) {
        DataSourceTransactionObject txObject = (DataSourceTransactionObject) transaction;
        Connection con = null;
        
        try {
            if (!txObject.hasConnectionHolder()) {
                // è·å–æ–°è¿æ¥
                Connection newCon = obtainDataSource().getConnection();
                txObject.setConnectionHolder(new ConnectionHolder(newCon), true);
            }
            
            txObject.getConnectionHolder().setSynchronizedWithTransaction(true);
            con = txObject.getConnectionHolder().getConnection();
            
            // è®¾ç½®éš”ç¦»çº§åˆ«
            Integer previousIsolationLevel = DataSourceUtils.prepareConnectionForTransaction(
                con, definition);
            txObject.setPreviousIsolationLevel(previousIsolationLevel);
            txObject.setReadOnly(definition.isReadOnly());
            
            // å…³é—­è‡ªåŠ¨æäº¤
            if (con.getAutoCommit()) {
                txObject.setMustRestoreAutoCommit(true);
                con.setAutoCommit(false);
            }
            
            // è®¾ç½®è¶…æ—¶
            int timeout = determineTimeout(definition);
            if (timeout != TransactionDefinition.TIMEOUT_DEFAULT) {
                txObject.getConnectionHolder().setTimeoutInSeconds(timeout);
            }
            
            // ç»‘å®šè¿æ¥åˆ°ThreadLocal
            if (txObject.isNewConnectionHolder()) {
                TransactionSynchronizationManager.bindResource(
                    obtainDataSource(), txObject.getConnectionHolder());
            }
        } catch (Throwable ex) {
            if (txObject.isNewConnectionHolder()) {
                DataSourceUtils.releaseConnection(con, obtainDataSource());
                txObject.setConnectionHolder(null, false);
            }
            throw new CannotCreateTransactionException("Could not open JDBC Connection", ex);
        }
    }
    
    @Override
    protected void doCommit(DefaultTransactionStatus status) {
        DataSourceTransactionObject txObject = 
            (DataSourceTransactionObject) status.getTransaction();
        Connection con = txObject.getConnectionHolder().getConnection();
        try {
            con.commit();
        } catch (SQLException ex) {
            throw new TransactionSystemException("Could not commit JDBC transaction", ex);
        }
    }
    
    @Override
    protected void doRollback(DefaultTransactionStatus status) {
        DataSourceTransactionObject txObject = 
            (DataSourceTransactionObject) status.getTransaction();
        Connection con = txObject.getConnectionHolder().getConnection();
        try {
            con.rollback();
        } catch (SQLException ex) {
            throw new TransactionSystemException("Could not roll back JDBC transaction", ex);
        }
    }
}
```

---

## 7. é¢è¯•è¦ç‚¹

### 7.1 é«˜é¢‘é—®é¢˜

**Q1: Springäº‹åŠ¡çš„å®ç°åŸç†ï¼Ÿ**
```
1. åŸºäºAOPå®ç°
   - @EnableTransactionManagementå¼€å¯äº‹åŠ¡
   - æ³¨å†ŒTransactionInterceptoræ‹¦æˆªå™¨
   - åœ¨æ–¹æ³•æ‰§è¡Œå‰åè¿›è¡Œäº‹åŠ¡ç®¡ç†

2. æ ¸å¿ƒæµç¨‹
   - è§£æ@Transactionalè·å–äº‹åŠ¡å±æ€§
   - è·å–äº‹åŠ¡ç®¡ç†å™¨
   - åˆ›å»ºäº‹åŠ¡ï¼ˆgetTransactionï¼‰
   - æ‰§è¡Œä¸šåŠ¡æ–¹æ³•
   - æ ¹æ®æ‰§è¡Œç»“æœæäº¤æˆ–å›æ»š
```

**Q2: Springäº‹åŠ¡ä¼ æ’­è¡Œä¸ºæœ‰å“ªäº›ï¼Ÿ**
```
REQUIREDï¼ˆé»˜è®¤ï¼‰ï¼šæœ‰äº‹åŠ¡åŠ å…¥ï¼Œæ²¡æœ‰æ–°å»º
REQUIRES_NEWï¼šæ€»æ˜¯æ–°å»ºäº‹åŠ¡ï¼ŒæŒ‚èµ·å½“å‰äº‹åŠ¡
NESTEDï¼šåµŒå¥—äº‹åŠ¡ï¼Œä½¿ç”¨ä¿å­˜ç‚¹
SUPPORTSï¼šæœ‰äº‹åŠ¡åŠ å…¥ï¼Œæ²¡æœ‰éäº‹åŠ¡æ‰§è¡Œ
NOT_SUPPORTEDï¼šéäº‹åŠ¡æ‰§è¡Œï¼ŒæŒ‚èµ·å½“å‰äº‹åŠ¡
MANDATORYï¼šå¿…é¡»æœ‰äº‹åŠ¡ï¼Œå¦åˆ™å¼‚å¸¸
NEVERï¼šå¿…é¡»éäº‹åŠ¡ï¼Œæœ‰äº‹åŠ¡å¼‚å¸¸
```

**Q3: @Transactionalå¤±æ•ˆçš„åœºæ™¯ï¼Ÿ**
```
1. æ–¹æ³•ä¸æ˜¯publicçš„
   - Spring AOPåªèƒ½ä»£ç†publicæ–¹æ³•

2. åŒä¸€ä¸ªç±»ä¸­æ–¹æ³•è°ƒç”¨
   - thisè°ƒç”¨ä¸ç»è¿‡ä»£ç†

3. å¼‚å¸¸è¢«catchæ²¡æœ‰æŠ›å‡º
   - äº‹åŠ¡æ‹¦æˆªå™¨æ•è·ä¸åˆ°å¼‚å¸¸

4. æŠ›å‡ºçš„æ˜¯éRuntimeException
   - é»˜è®¤åªå¯¹RuntimeExceptionå›æ»š

5. æ•°æ®åº“ä¸æ”¯æŒäº‹åŠ¡
   - å¦‚MyISAMå¼•æ“

6. æ²¡æœ‰è¢«Springç®¡ç†
   - ç±»æ²¡æœ‰åŠ @Serviceç­‰æ³¨è§£

7. å¤šçº¿ç¨‹è°ƒç”¨
   - äº‹åŠ¡ä¿¡æ¯å­˜åœ¨ThreadLocalä¸­
```

**Q4: REQUIREDå’ŒREQUIRES_NEWçš„åŒºåˆ«ï¼Ÿ**
```
REQUIREDï¼š
- å¦‚æœå½“å‰æœ‰äº‹åŠ¡ï¼ŒåŠ å…¥å½“å‰äº‹åŠ¡
- å¦‚æœå½“å‰æ²¡æœ‰äº‹åŠ¡ï¼Œæ–°å»ºäº‹åŠ¡
- å†…å¤–å±‚æ˜¯åŒä¸€ä¸ªäº‹åŠ¡ï¼Œä¸€èµ·æäº¤æˆ–å›æ»š

REQUIRES_NEWï¼š
- æ€»æ˜¯æ–°å»ºä¸€ä¸ªäº‹åŠ¡
- å¦‚æœå½“å‰æœ‰äº‹åŠ¡ï¼ŒæŒ‚èµ·å½“å‰äº‹åŠ¡
- å†…å¤–å±‚æ˜¯ç‹¬ç«‹çš„äº‹åŠ¡
- å†…å±‚äº‹åŠ¡æäº¤åï¼Œå¤–å±‚å›æ»šä¸å½±å“å†…å±‚
```

**Q5: NESTEDå’ŒREQUIRES_NEWçš„åŒºåˆ«ï¼Ÿ**
```
NESTEDï¼š
- åµŒå¥—äº‹åŠ¡ï¼Œä½¿ç”¨ä¿å­˜ç‚¹
- å†…å±‚å›æ»šåªå›æ»šåˆ°ä¿å­˜ç‚¹
- å¤–å±‚å›æ»šä¼šå¯¼è‡´å†…å±‚ä¹Ÿå›æ»š
- å…±ç”¨åŒä¸€ä¸ªæ•°æ®åº“è¿æ¥

REQUIRES_NEWï¼š
- å®Œå…¨ç‹¬ç«‹çš„æ–°äº‹åŠ¡
- å†…å¤–å±‚äº’ä¸å½±å“
- ä½¿ç”¨ä¸åŒçš„æ•°æ®åº“è¿æ¥
```

### 7.2 æ ¸å¿ƒç±»æ€»ç»“

```
äº‹åŠ¡ç®¡ç†å™¨ï¼š
- PlatformTransactionManagerï¼šäº‹åŠ¡ç®¡ç†å™¨æ¥å£
- DataSourceTransactionManagerï¼šJDBCäº‹åŠ¡ç®¡ç†å™¨
- JpaTransactionManagerï¼šJPAäº‹åŠ¡ç®¡ç†å™¨

äº‹åŠ¡æ‹¦æˆªï¼š
- TransactionInterceptorï¼šäº‹åŠ¡æ‹¦æˆªå™¨
- TransactionAspectSupportï¼šäº‹åŠ¡åˆ‡é¢æ”¯æŒ
- BeanFactoryTransactionAttributeSourceAdvisorï¼šäº‹åŠ¡åˆ‡é¢

äº‹åŠ¡å±æ€§ï¼š
- TransactionDefinitionï¼šäº‹åŠ¡å®šä¹‰
- TransactionAttributeï¼šäº‹åŠ¡å±æ€§
- TransactionStatusï¼šäº‹åŠ¡çŠ¶æ€

äº‹åŠ¡åŒæ­¥ï¼š
- TransactionSynchronizationManagerï¼šäº‹åŠ¡åŒæ­¥ç®¡ç†å™¨
- TransactionSynchronizationï¼šäº‹åŠ¡åŒæ­¥æ¥å£
```

---

## ğŸ“Š äº‹åŠ¡æ‰§è¡Œæµç¨‹å›¾

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    @Transactionalæ–¹æ³•è°ƒç”¨                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚
                              â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              TransactionInterceptor.invoke()                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚
                              â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚           invokeWithinTransaction()                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚  1. è·å–äº‹åŠ¡å±æ€§ï¼ˆTransactionAttributeï¼‰             â”‚   â”‚
â”‚  â”‚  2. è·å–äº‹åŠ¡ç®¡ç†å™¨ï¼ˆTransactionManagerï¼‰             â”‚   â”‚
â”‚  â”‚  3. åˆ›å»ºäº‹åŠ¡ï¼ˆcreateTransactionIfNecessaryï¼‰         â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚
                              â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    æ‰§è¡Œç›®æ ‡æ–¹æ³•                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚
              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
              â–¼                               â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚       æ­£å¸¸è¿”å›           â”‚     â”‚       æŠ›å‡ºå¼‚å¸¸           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              â”‚                               â”‚
              â–¼                               â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  commitTransaction()    â”‚     â”‚  rollbackOn(ex)?        â”‚
â”‚  æäº¤äº‹åŠ¡               â”‚     â”‚  åˆ¤æ–­æ˜¯å¦å›æ»š            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                              â”‚
                              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                              â–¼                               â–¼
                â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                â”‚  rollbackTransaction()  â”‚     â”‚  commitTransaction()    â”‚
                â”‚  å›æ»šäº‹åŠ¡               â”‚     â”‚  æäº¤äº‹åŠ¡               â”‚
                â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

**æ·±å…¥ç†è§£äº‹åŠ¡ï¼ŒæŒæ¡Springæ ¸å¿ƒï¼** ğŸš€

*æœ€åæ›´æ–°ï¼š2025-12-28*

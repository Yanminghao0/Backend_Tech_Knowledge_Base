# ApplicationListeneræºç è§£æ

> ğŸ’¡ æ·±å…¥ç†è§£Springäº‹ä»¶æœºåˆ¶ï¼ŒæŒæ¡è§‚å¯Ÿè€…æ¨¡å¼åœ¨æ¡†æ¶ä¸­çš„åº”ç”¨

---

## ğŸ“š ç›®å½•

1. [äº‹ä»¶æœºåˆ¶æ¦‚è¿°](#1-äº‹ä»¶æœºåˆ¶æ¦‚è¿°)
2. [æ ¸å¿ƒç»„ä»¶](#2-æ ¸å¿ƒç»„ä»¶)
3. [äº‹ä»¶å‘å¸ƒæµç¨‹](#3-äº‹ä»¶å‘å¸ƒæµç¨‹)
4. [ç›‘å¬å™¨æ³¨å†Œæœºåˆ¶](#4-ç›‘å¬å™¨æ³¨å†Œæœºåˆ¶)
5. [å¼‚æ­¥äº‹ä»¶å¤„ç†](#5-å¼‚æ­¥äº‹ä»¶å¤„ç†)
6. [è‡ªå®šä¹‰äº‹ä»¶å¼€å‘](#6-è‡ªå®šä¹‰äº‹ä»¶å¼€å‘)
7. [é¢è¯•è¦ç‚¹](#7-é¢è¯•è¦ç‚¹)

---

## 1. äº‹ä»¶æœºåˆ¶æ¦‚è¿°

### 1.1 Springäº‹ä»¶æ¨¡å‹

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  Springäº‹ä»¶æ¨¡å‹                              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    å‘å¸ƒäº‹ä»¶    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚   äº‹ä»¶æº     â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶â”‚ ApplicationContext  â”‚    â”‚
â”‚  â”‚ (Publisher) â”‚               â”‚ (EventMulticaster)  â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜               â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”‚                                           â”‚                â”‚
â”‚                                           â”‚ å¹¿æ’­äº‹ä»¶        â”‚
â”‚                                           â–¼                â”‚
â”‚                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚                    â”‚                                  â”‚    â”‚
â”‚         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”‚    â”‚
â”‚         â–¼                   â–¼                 â–¼      â”‚    â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚ Listener1   â”‚    â”‚ Listener2   â”‚    â”‚ Listener3   â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”‚                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 1.2 æ ¸å¿ƒè§’è‰²

```java
// 1. äº‹ä»¶ - ApplicationEvent
public abstract class ApplicationEvent extends EventObject {
    private final long timestamp;
    
    public ApplicationEvent(Object source) {
        super(source);
        this.timestamp = System.currentTimeMillis();
    }
}

// 2. ç›‘å¬å™¨ - ApplicationListener
@FunctionalInterface
public interface ApplicationListener<E extends ApplicationEvent> 
        extends EventListener {
    void onApplicationEvent(E event);
}

// 3. äº‹ä»¶å‘å¸ƒå™¨ - ApplicationEventPublisher
@FunctionalInterface
public interface ApplicationEventPublisher {
    void publishEvent(ApplicationEvent event);
    default void publishEvent(Object event) { ... }
}

// 4. äº‹ä»¶å¹¿æ’­å™¨ - ApplicationEventMulticaster
public interface ApplicationEventMulticaster {
    void addApplicationListener(ApplicationListener<?> listener);
    void removeApplicationListener(ApplicationListener<?> listener);
    void multicastEvent(ApplicationEvent event);
}
```


---

## 2. æ ¸å¿ƒç»„ä»¶

### 2.1 ApplicationEventäº‹ä»¶ä½“ç³»

```java
/**
 * äº‹ä»¶åŸºç±»
 */
public abstract class ApplicationEvent extends EventObject {
    
    private static final long serialVersionUID = 7099057708183571937L;
    
    /** äº‹ä»¶å‘ç”Ÿæ—¶é—´æˆ³ */
    private final long timestamp;
    
    public ApplicationEvent(Object source) {
        super(source);
        this.timestamp = System.currentTimeMillis();
    }
    
    public final long getTimestamp() {
        return this.timestamp;
    }
}

/**
 * Springå†…ç½®äº‹ä»¶
 */
public abstract class ApplicationContextEvent extends ApplicationEvent {
    
    public ApplicationContextEvent(ApplicationContext source) {
        super(source);
    }
    
    public final ApplicationContext getApplicationContext() {
        return (ApplicationContext) getSource();
    }
}

// å®¹å™¨åˆ·æ–°å®Œæˆäº‹ä»¶
public class ContextRefreshedEvent extends ApplicationContextEvent { }

// å®¹å™¨å¯åŠ¨äº‹ä»¶
public class ContextStartedEvent extends ApplicationContextEvent { }

// å®¹å™¨åœæ­¢äº‹ä»¶
public class ContextStoppedEvent extends ApplicationContextEvent { }

// å®¹å™¨å…³é—­äº‹ä»¶
public class ContextClosedEvent extends ApplicationContextEvent { }
```

### 2.2 ApplicationListeneræ¥å£

```java
/**
 * äº‹ä»¶ç›‘å¬å™¨æ¥å£
 */
@FunctionalInterface
public interface ApplicationListener<E extends ApplicationEvent> 
        extends EventListener {
    
    /**
     * å¤„ç†äº‹ä»¶
     * @param event äº‹ä»¶å¯¹è±¡
     */
    void onApplicationEvent(E event);
    
    /**
     * åˆ›å»ºæ”¯æŒæ³›å‹çš„ç›‘å¬å™¨
     */
    static <T> ApplicationListener<PayloadApplicationEvent<T>> forPayload(
            Consumer<T> consumer) {
        return event -> consumer.accept(event.getPayload());
    }
}

/**
 * æ™ºèƒ½ç›‘å¬å™¨æ¥å£
 * æ”¯æŒäº‹ä»¶ç±»å‹åˆ¤æ–­
 */
public interface SmartApplicationListener 
        extends ApplicationListener<ApplicationEvent>, Ordered {
    
    /**
     * æ˜¯å¦æ”¯æŒè¯¥äº‹ä»¶ç±»å‹
     */
    boolean supportsEventType(Class<? extends ApplicationEvent> eventType);
    
    /**
     * æ˜¯å¦æ”¯æŒè¯¥äº‹ä»¶æºç±»å‹
     */
    default boolean supportsSourceType(@Nullable Class<?> sourceType) {
        return true;
    }
    
    /**
     * ç›‘å¬å™¨ä¼˜å…ˆçº§
     */
    @Override
    default int getOrder() {
        return LOWEST_PRECEDENCE;
    }
}

/**
 * æ³›å‹ç›‘å¬å™¨æ¥å£
 */
public interface GenericApplicationListener 
        extends SmartApplicationListener {
    
    /**
     * æ˜¯å¦æ”¯æŒè¯¥äº‹ä»¶ç±»å‹ï¼ˆä½¿ç”¨ResolvableTypeï¼‰
     */
    boolean supportsEventType(ResolvableType eventType);
    
    @Override
    default boolean supportsEventType(Class<? extends ApplicationEvent> eventType) {
        return supportsEventType(ResolvableType.forClass(eventType));
    }
}
```

### 2.3 ApplicationEventMulticasterå¹¿æ’­å™¨

```java
/**
 * äº‹ä»¶å¹¿æ’­å™¨æ¥å£
 */
public interface ApplicationEventMulticaster {
    
    /**
     * æ·»åŠ ç›‘å¬å™¨
     */
    void addApplicationListener(ApplicationListener<?> listener);
    
    /**
     * æ·»åŠ ç›‘å¬å™¨Beanåç§°
     */
    void addApplicationListenerBean(String listenerBeanName);
    
    /**
     * ç§»é™¤ç›‘å¬å™¨
     */
    void removeApplicationListener(ApplicationListener<?> listener);
    
    /**
     * ç§»é™¤ç›‘å¬å™¨Beanåç§°
     */
    void removeApplicationListenerBean(String listenerBeanName);
    
    /**
     * ç§»é™¤æ‰€æœ‰ç›‘å¬å™¨
     */
    void removeAllListeners();
    
    /**
     * ğŸ”¥ å¹¿æ’­äº‹ä»¶
     */
    void multicastEvent(ApplicationEvent event);
    
    /**
     * å¹¿æ’­äº‹ä»¶ï¼ˆå¸¦ç±»å‹ä¿¡æ¯ï¼‰
     */
    void multicastEvent(ApplicationEvent event, @Nullable ResolvableType eventType);
}

/**
 * ç®€å•äº‹ä»¶å¹¿æ’­å™¨å®ç°
 */
public class SimpleApplicationEventMulticaster 
        extends AbstractApplicationEventMulticaster {
    
    // å¼‚æ­¥æ‰§è¡Œå™¨
    @Nullable
    private Executor taskExecutor;
    
    // é”™è¯¯å¤„ç†å™¨
    @Nullable
    private ErrorHandler errorHandler;
    
    /**
     * ğŸ”¥ å¹¿æ’­äº‹ä»¶æ ¸å¿ƒæ–¹æ³•
     */
    @Override
    public void multicastEvent(final ApplicationEvent event, 
            @Nullable ResolvableType eventType) {
        
        ResolvableType type = (eventType != null ? eventType : 
            resolveDefaultEventType(event));
        
        Executor executor = getTaskExecutor();
        
        // è·å–åŒ¹é…çš„ç›‘å¬å™¨
        for (ApplicationListener<?> listener : getApplicationListeners(event, type)) {
            if (executor != null) {
                // ğŸ”¥ å¼‚æ­¥æ‰§è¡Œ
                executor.execute(() -> invokeListener(listener, event));
            } else {
                // ğŸ”¥ åŒæ­¥æ‰§è¡Œ
                invokeListener(listener, event);
            }
        }
    }
    
    /**
     * è°ƒç”¨ç›‘å¬å™¨
     */
    protected void invokeListener(ApplicationListener<?> listener, 
            ApplicationEvent event) {
        ErrorHandler errorHandler = getErrorHandler();
        if (errorHandler != null) {
            try {
                doInvokeListener(listener, event);
            } catch (Throwable err) {
                errorHandler.handleError(err);
            }
        } else {
            doInvokeListener(listener, event);
        }
    }
    
    @SuppressWarnings({"rawtypes", "unchecked"})
    private void doInvokeListener(ApplicationListener listener, ApplicationEvent event) {
        try {
            listener.onApplicationEvent(event);
        } catch (ClassCastException ex) {
            // ç±»å‹ä¸åŒ¹é…ï¼Œå¿½ç•¥
            String msg = ex.getMessage();
            if (msg == null || matchesClassCastMessage(msg, event.getClass())) {
                // å¯èƒ½æ˜¯Lambdaè¡¨è¾¾å¼çš„æ³›å‹æ“¦é™¤é—®é¢˜
                Log logger = LogFactory.getLog(getClass());
                if (logger.isTraceEnabled()) {
                    logger.trace("Non-matching event type for listener: " + listener, ex);
                }
            } else {
                throw ex;
            }
        }
    }
}
```

### 2.4 AbstractApplicationEventMulticaster

```java
/**
 * æŠ½è±¡äº‹ä»¶å¹¿æ’­å™¨
 * ç®¡ç†ç›‘å¬å™¨é›†åˆ
 */
public abstract class AbstractApplicationEventMulticaster 
        implements ApplicationEventMulticaster, BeanClassLoaderAware, BeanFactoryAware {
    
    // ç›‘å¬å™¨æ£€ç´¢å™¨
    private final DefaultListenerRetriever defaultRetriever = new DefaultListenerRetriever();
    
    // ç›‘å¬å™¨ç¼“å­˜
    final Map<ListenerCacheKey, CachedListenerRetriever> retrieverCache = 
        new ConcurrentHashMap<>(64);
    
    @Nullable
    private ClassLoader beanClassLoader;
    
    @Nullable
    private ConfigurableBeanFactory beanFactory;
    
    /**
     * æ·»åŠ ç›‘å¬å™¨
     */
    @Override
    public void addApplicationListener(ApplicationListener<?> listener) {
        synchronized (this.defaultRetriever) {
            // å¦‚æœå·²ç»æ˜¯ä»£ç†ï¼Œå…ˆç§»é™¤åŸå§‹å¯¹è±¡
            Object singletonTarget = AopProxyUtils.getSingletonTarget(listener);
            if (singletonTarget instanceof ApplicationListener) {
                this.defaultRetriever.applicationListeners.remove(singletonTarget);
            }
            this.defaultRetriever.applicationListeners.add(listener);
            this.retrieverCache.clear();
        }
    }
    
    /**
     * ğŸ”¥ è·å–åŒ¹é…çš„ç›‘å¬å™¨
     */
    protected Collection<ApplicationListener<?>> getApplicationListeners(
            ApplicationEvent event, ResolvableType eventType) {
        
        Object source = event.getSource();
        Class<?> sourceType = (source != null ? source.getClass() : null);
        ListenerCacheKey cacheKey = new ListenerCacheKey(eventType, sourceType);
        
        // ä»ç¼“å­˜è·å–
        CachedListenerRetriever newRetriever = null;
        CachedListenerRetriever existingRetriever = this.retrieverCache.get(cacheKey);
        
        if (existingRetriever == null) {
            // å¯èƒ½éœ€è¦è¿‡æ»¤ï¼Œåˆ›å»ºæ–°çš„æ£€ç´¢å™¨
            if (this.beanClassLoader == null ||
                    (ClassUtils.isCacheSafe(event.getClass(), this.beanClassLoader) &&
                     (sourceType == null || 
                      ClassUtils.isCacheSafe(sourceType, this.beanClassLoader)))) {
                newRetriever = new CachedListenerRetriever();
                existingRetriever = this.retrieverCache.putIfAbsent(cacheKey, newRetriever);
                if (existingRetriever != null) {
                    newRetriever = null;
                }
            }
        }
        
        if (existingRetriever != null) {
            Collection<ApplicationListener<?>> result = existingRetriever.getApplicationListeners();
            if (result != null) {
                return result;
            }
        }
        
        // ğŸ”¥ æ£€ç´¢åŒ¹é…çš„ç›‘å¬å™¨
        return retrieveApplicationListeners(eventType, sourceType, newRetriever);
    }
    
    /**
     * æ£€ç´¢åŒ¹é…çš„ç›‘å¬å™¨
     */
    private Collection<ApplicationListener<?>> retrieveApplicationListeners(
            ResolvableType eventType, @Nullable Class<?> sourceType,
            @Nullable CachedListenerRetriever retriever) {
        
        List<ApplicationListener<?>> allListeners = new ArrayList<>();
        Set<ApplicationListener<?>> filteredListeners = (retriever != null ? 
            new LinkedHashSet<>() : null);
        Set<String> filteredListenerBeans = (retriever != null ? 
            new LinkedHashSet<>() : null);
        
        Set<ApplicationListener<?>> listeners;
        Set<String> listenerBeans;
        
        synchronized (this.defaultRetriever) {
            listeners = new LinkedHashSet<>(this.defaultRetriever.applicationListeners);
            listenerBeans = new LinkedHashSet<>(this.defaultRetriever.applicationListenerBeans);
        }
        
        // è¿‡æ»¤ç›‘å¬å™¨å®ä¾‹
        for (ApplicationListener<?> listener : listeners) {
            if (supportsEvent(listener, eventType, sourceType)) {
                if (retriever != null) {
                    filteredListeners.add(listener);
                }
                allListeners.add(listener);
            }
        }
        
        // è¿‡æ»¤ç›‘å¬å™¨Bean
        if (!listenerBeans.isEmpty()) {
            ConfigurableBeanFactory beanFactory = getBeanFactory();
            for (String listenerBeanName : listenerBeans) {
                try {
                    if (supportsEvent(beanFactory, listenerBeanName, eventType)) {
                        ApplicationListener<?> listener = 
                            beanFactory.getBean(listenerBeanName, ApplicationListener.class);
                        if (!allListeners.contains(listener) && 
                                supportsEvent(listener, eventType, sourceType)) {
                            if (retriever != null) {
                                if (beanFactory.isSingleton(listenerBeanName)) {
                                    filteredListeners.add(listener);
                                } else {
                                    filteredListenerBeans.add(listenerBeanName);
                                }
                            }
                            allListeners.add(listener);
                        }
                    }
                } catch (NoSuchBeanDefinitionException ex) {
                    // å¿½ç•¥
                }
            }
        }
        
        // æ’åº
        AnnotationAwareOrderComparator.sort(allListeners);
        
        // ç¼“å­˜ç»“æœ
        if (retriever != null) {
            if (filteredListenerBeans.isEmpty()) {
                retriever.applicationListeners = new LinkedHashSet<>(allListeners);
                retriever.applicationListenerBeans = filteredListenerBeans;
            } else {
                retriever.applicationListeners = filteredListeners;
                retriever.applicationListenerBeans = filteredListenerBeans;
            }
        }
        
        return allListeners;
    }
    
    /**
     * åˆ¤æ–­ç›‘å¬å™¨æ˜¯å¦æ”¯æŒè¯¥äº‹ä»¶
     */
    protected boolean supportsEvent(ApplicationListener<?> listener,
            ResolvableType eventType, @Nullable Class<?> sourceType) {
        
        GenericApplicationListener smartListener = (listener instanceof GenericApplicationListener ?
            (GenericApplicationListener) listener : 
            new GenericApplicationListenerAdapter(listener));
        
        return (smartListener.supportsEventType(eventType) && 
                smartListener.supportsSourceType(sourceType));
    }
}
```


---

## 3. äº‹ä»¶å‘å¸ƒæµç¨‹

### 3.1 AbstractApplicationContextå‘å¸ƒäº‹ä»¶

```java
/**
 * AbstractApplicationContextä¸­çš„äº‹ä»¶å‘å¸ƒ
 */
public abstract class AbstractApplicationContext 
        implements ConfigurableApplicationContext {
    
    // äº‹ä»¶å¹¿æ’­å™¨
    @Nullable
    private ApplicationEventMulticaster applicationEventMulticaster;
    
    // æ—©æœŸäº‹ä»¶ï¼ˆå®¹å™¨æœªå®Œå…¨åˆå§‹åŒ–æ—¶å‘å¸ƒçš„äº‹ä»¶ï¼‰
    @Nullable
    private Set<ApplicationEvent> earlyApplicationEvents;
    
    /**
     * ğŸ”¥ å‘å¸ƒäº‹ä»¶
     */
    @Override
    public void publishEvent(ApplicationEvent event) {
        publishEvent(event, null);
    }
    
    @Override
    public void publishEvent(Object event) {
        publishEvent(event, null);
    }
    
    /**
     * å‘å¸ƒäº‹ä»¶æ ¸å¿ƒæ–¹æ³•
     */
    protected void publishEvent(Object event, @Nullable ResolvableType eventType) {
        Assert.notNull(event, "Event must not be null");
        
        // 1. åŒ…è£…äº‹ä»¶
        ApplicationEvent applicationEvent;
        if (event instanceof ApplicationEvent) {
            applicationEvent = (ApplicationEvent) event;
        } else {
            // éApplicationEventåŒ…è£…ä¸ºPayloadApplicationEvent
            applicationEvent = new PayloadApplicationEvent<>(this, event);
            if (eventType == null) {
                eventType = ((PayloadApplicationEvent<?>) applicationEvent).getResolvableType();
            }
        }
        
        // 2. å‘å¸ƒäº‹ä»¶
        if (this.earlyApplicationEvents != null) {
            // å®¹å™¨æœªå®Œå…¨åˆå§‹åŒ–ï¼Œå…ˆå­˜å‚¨æ—©æœŸäº‹ä»¶
            this.earlyApplicationEvents.add(applicationEvent);
        } else {
            // ğŸ”¥ é€šè¿‡å¹¿æ’­å™¨å‘å¸ƒäº‹ä»¶
            getApplicationEventMulticaster().multicastEvent(applicationEvent, eventType);
        }
        
        // 3. å‘çˆ¶å®¹å™¨å‘å¸ƒäº‹ä»¶
        if (this.parent != null) {
            if (this.parent instanceof AbstractApplicationContext) {
                ((AbstractApplicationContext) this.parent).publishEvent(event, eventType);
            } else {
                this.parent.publishEvent(event);
            }
        }
    }
    
    /**
     * è·å–äº‹ä»¶å¹¿æ’­å™¨
     */
    ApplicationEventMulticaster getApplicationEventMulticaster() throws IllegalStateException {
        if (this.applicationEventMulticaster == null) {
            throw new IllegalStateException("ApplicationEventMulticaster not initialized");
        }
        return this.applicationEventMulticaster;
    }
}
```

### 3.2 äº‹ä»¶å‘å¸ƒæµç¨‹å›¾

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  äº‹ä»¶å‘å¸ƒæµç¨‹                                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                             â”‚
â”‚  applicationContext.publishEvent(event)                    â”‚
â”‚         â”‚                                                   â”‚
â”‚         â–¼                                                   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                   â”‚
â”‚  â”‚ 1. åŒ…è£…äº‹ä»¶                          â”‚                   â”‚
â”‚  â”‚    - ApplicationEventç›´æ¥ä½¿ç”¨        â”‚                   â”‚
â”‚  â”‚    - å…¶ä»–å¯¹è±¡åŒ…è£…ä¸ºPayloadEvent      â”‚                   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                   â”‚
â”‚         â”‚                                                   â”‚
â”‚         â–¼                                                   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                   â”‚
â”‚  â”‚ 2. æ£€æŸ¥å®¹å™¨çŠ¶æ€                      â”‚                   â”‚
â”‚  â”‚    - æœªåˆå§‹åŒ–ï¼šå­˜å…¥earlyEvents       â”‚                   â”‚
â”‚  â”‚    - å·²åˆå§‹åŒ–ï¼šå¹¿æ’­äº‹ä»¶              â”‚                   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                   â”‚
â”‚         â”‚                                                   â”‚
â”‚         â–¼                                                   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                   â”‚
â”‚  â”‚ 3. ApplicationEventMulticaster      â”‚                   â”‚
â”‚  â”‚    .multicastEvent()                â”‚                   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                   â”‚
â”‚         â”‚                                                   â”‚
â”‚         â–¼                                                   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                   â”‚
â”‚  â”‚ 4. è·å–åŒ¹é…çš„ç›‘å¬å™¨                  â”‚                   â”‚
â”‚  â”‚    - æ ¹æ®äº‹ä»¶ç±»å‹è¿‡æ»¤                â”‚                   â”‚
â”‚  â”‚    - æ ¹æ®æºç±»å‹è¿‡æ»¤                  â”‚                   â”‚
â”‚  â”‚    - æŒ‰Orderæ’åº                    â”‚                   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                   â”‚
â”‚         â”‚                                                   â”‚
â”‚         â–¼                                                   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                   â”‚
â”‚  â”‚ 5. è°ƒç”¨ç›‘å¬å™¨                        â”‚                   â”‚
â”‚  â”‚    - åŒæ­¥ï¼šç›´æ¥è°ƒç”¨                  â”‚                   â”‚
â”‚  â”‚    - å¼‚æ­¥ï¼šæäº¤åˆ°çº¿ç¨‹æ±               â”‚                   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                   â”‚
â”‚         â”‚                                                   â”‚
â”‚         â–¼                                                   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                   â”‚
â”‚  â”‚ 6. å‘çˆ¶å®¹å™¨å‘å¸ƒ                      â”‚                   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                   â”‚
â”‚                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 4. ç›‘å¬å™¨æ³¨å†Œæœºåˆ¶

### 4.1 å®¹å™¨å¯åŠ¨æ—¶æ³¨å†Œ

```java
/**
 * AbstractApplicationContext.refresh()ä¸­æ³¨å†Œç›‘å¬å™¨
 */
@Override
public void refresh() throws BeansException, IllegalStateException {
    // ...
    
    // åˆå§‹åŒ–äº‹ä»¶å¹¿æ’­å™¨
    initApplicationEventMulticaster();
    
    // ...
    
    // ğŸ”¥ æ³¨å†Œç›‘å¬å™¨
    registerListeners();
    
    // ...
    
    // å®Œæˆåˆ·æ–°ï¼Œå‘å¸ƒContextRefreshedEvent
    finishRefresh();
}

/**
 * åˆå§‹åŒ–äº‹ä»¶å¹¿æ’­å™¨
 */
protected void initApplicationEventMulticaster() {
    ConfigurableListableBeanFactory beanFactory = getBeanFactory();
    
    // æ£€æŸ¥æ˜¯å¦æœ‰è‡ªå®šä¹‰çš„å¹¿æ’­å™¨
    if (beanFactory.containsLocalBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME)) {
        this.applicationEventMulticaster = beanFactory.getBean(
            APPLICATION_EVENT_MULTICASTER_BEAN_NAME, ApplicationEventMulticaster.class);
    } else {
        // ä½¿ç”¨é»˜è®¤çš„SimpleApplicationEventMulticaster
        this.applicationEventMulticaster = new SimpleApplicationEventMulticaster(beanFactory);
        beanFactory.registerSingleton(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, 
            this.applicationEventMulticaster);
    }
}

/**
 * æ³¨å†Œç›‘å¬å™¨
 */
protected void registerListeners() {
    // 1. æ³¨å†Œé™æ€æŒ‡å®šçš„ç›‘å¬å™¨
    for (ApplicationListener<?> listener : getApplicationListeners()) {
        getApplicationEventMulticaster().addApplicationListener(listener);
    }
    
    // 2. æ³¨å†ŒBeanå½¢å¼çš„ç›‘å¬å™¨ï¼ˆå»¶è¿ŸåŠ è½½ï¼‰
    String[] listenerBeanNames = getBeanNamesForType(ApplicationListener.class, true, false);
    for (String listenerBeanName : listenerBeanNames) {
        getApplicationEventMulticaster().addApplicationListenerBean(listenerBeanName);
    }
    
    // 3. å‘å¸ƒæ—©æœŸäº‹ä»¶
    Set<ApplicationEvent> earlyEventsToProcess = this.earlyApplicationEvents;
    this.earlyApplicationEvents = null;
    if (!CollectionUtils.isEmpty(earlyEventsToProcess)) {
        for (ApplicationEvent earlyEvent : earlyEventsToProcess) {
            getApplicationEventMulticaster().multicastEvent(earlyEvent);
        }
    }
}
```

### 4.2 @EventListeneræ³¨è§£å¤„ç†

```java
/**
 * EventListenerMethodProcessor
 * å¤„ç†@EventListeneræ³¨è§£
 */
public class EventListenerMethodProcessor 
        implements SmartInitializingSingleton, ApplicationContextAware, BeanFactoryPostProcessor {
    
    @Nullable
    private ConfigurableApplicationContext applicationContext;
    
    @Nullable
    private ConfigurableListableBeanFactory beanFactory;
    
    // äº‹ä»¶ç›‘å¬å™¨å·¥å‚
    private final EventListenerFactory eventListenerFactory = new DefaultEventListenerFactory();
    
    /**
     * æ‰€æœ‰å•ä¾‹Beanåˆå§‹åŒ–å®Œæˆåè°ƒç”¨
     */
    @Override
    public void afterSingletonsInstantiated() {
        ConfigurableListableBeanFactory beanFactory = this.beanFactory;
        
        String[] beanNames = beanFactory.getBeanNamesForType(Object.class);
        
        for (String beanName : beanNames) {
            if (!ScopedProxyUtils.isScopedTarget(beanName)) {
                Class<?> type = null;
                try {
                    type = AutoProxyUtils.determineTargetClass(beanFactory, beanName);
                } catch (Throwable ex) {
                    // å¿½ç•¥
                }
                
                if (type != null) {
                    if (ScopedObject.class.isAssignableFrom(type)) {
                        try {
                            Class<?> targetClass = AutoProxyUtils.determineTargetClass(
                                beanFactory, ScopedProxyUtils.getTargetBeanName(beanName));
                            if (targetClass != null) {
                                type = targetClass;
                            }
                        } catch (Throwable ex) {
                            // å¿½ç•¥
                        }
                    }
                    try {
                        // ğŸ”¥ å¤„ç†Beanä¸­çš„@EventListeneræ–¹æ³•
                        processBean(beanName, type);
                    } catch (Throwable ex) {
                        throw new BeanInitializationException("...", ex);
                    }
                }
            }
        }
    }
    
    /**
     * å¤„ç†Beanä¸­çš„@EventListeneræ–¹æ³•
     */
    private void processBean(String beanName, Class<?> targetType) {
        if (!this.nonAnnotatedClasses.contains(targetType) &&
                AnnotationUtils.isCandidateClass(targetType, EventListener.class)) {
            
            Map<Method, EventListener> annotatedMethods = null;
            try {
                // æŸ¥æ‰¾@EventListeneræ³¨è§£çš„æ–¹æ³•
                annotatedMethods = MethodIntrospector.selectMethods(targetType,
                    (MethodIntrospector.MetadataLookup<EventListener>) method ->
                        AnnotatedElementUtils.findMergedAnnotation(method, EventListener.class));
            } catch (Throwable ex) {
                // å¿½ç•¥
            }
            
            if (CollectionUtils.isEmpty(annotatedMethods)) {
                this.nonAnnotatedClasses.add(targetType);
            } else {
                ConfigurableApplicationContext context = this.applicationContext;
                
                for (Method method : annotatedMethods.keySet()) {
                    // ğŸ”¥ åˆ›å»ºApplicationListeneré€‚é…å™¨
                    ApplicationListener<?> applicationListener =
                        this.eventListenerFactory.createApplicationListener(beanName, targetType, method);
                    
                    if (applicationListener instanceof ApplicationListenerMethodAdapter) {
                        ((ApplicationListenerMethodAdapter) applicationListener)
                            .init(context, this.evaluator);
                    }
                    
                    // ğŸ”¥ æ³¨å†Œç›‘å¬å™¨
                    context.addApplicationListener(applicationListener);
                }
            }
        }
    }
}

/**
 * @EventListeneræ–¹æ³•é€‚é…å™¨
 */
public class ApplicationListenerMethodAdapter 
        implements GenericApplicationListener {
    
    private final String beanName;
    private final Method method;
    private final Method targetMethod;
    private final AnnotatedElementKey methodKey;
    private final List<ResolvableType> declaredEventTypes;
    
    @Override
    public void onApplicationEvent(ApplicationEvent event) {
        processEvent(event);
    }
    
    public void processEvent(ApplicationEvent event) {
        Object[] args = resolveArguments(event);
        if (shouldHandle(event, args)) {
            // ğŸ”¥ è°ƒç”¨ç›®æ ‡æ–¹æ³•
            Object result = doInvoke(args);
            if (result != null) {
                // å¦‚æœè¿”å›å€¼ä¹Ÿæ˜¯äº‹ä»¶ï¼Œç»§ç»­å‘å¸ƒ
                handleResult(result);
            }
        }
    }
    
    @Nullable
    protected Object doInvoke(Object... args) {
        Object bean = getTargetBean();
        ReflectionUtils.makeAccessible(this.method);
        try {
            return this.method.invoke(bean, args);
        } catch (Exception ex) {
            throw new RuntimeException(ex);
        }
    }
}
```

---

## 5. å¼‚æ­¥äº‹ä»¶å¤„ç†

### 5.1 é…ç½®å¼‚æ­¥æ‰§è¡Œå™¨

```java
/**
 * é…ç½®å¼‚æ­¥äº‹ä»¶å¤„ç†
 */
@Configuration
public class AsyncEventConfig {
    
    @Bean(name = AbstractApplicationContext.APPLICATION_EVENT_MULTICASTER_BEAN_NAME)
    public ApplicationEventMulticaster applicationEventMulticaster() {
        SimpleApplicationEventMulticaster multicaster = new SimpleApplicationEventMulticaster();
        
        // ğŸ”¥ è®¾ç½®å¼‚æ­¥æ‰§è¡Œå™¨
        multicaster.setTaskExecutor(asyncExecutor());
        
        // è®¾ç½®é”™è¯¯å¤„ç†å™¨
        multicaster.setErrorHandler(TaskUtils.LOG_AND_SUPPRESS_ERROR_HANDLER);
        
        return multicaster;
    }
    
    @Bean
    public Executor asyncExecutor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(5);
        executor.setMaxPoolSize(10);
        executor.setQueueCapacity(100);
        executor.setThreadNamePrefix("event-");
        executor.initialize();
        return executor;
    }
}
```

### 5.2 @Async + @EventListener

```java
/**
 * ä½¿ç”¨@Asyncå®ç°å¼‚æ­¥äº‹ä»¶å¤„ç†
 */
@Component
public class AsyncEventListener {
    
    /**
     * å¼‚æ­¥å¤„ç†äº‹ä»¶
     */
    @Async
    @EventListener
    public void handleUserCreatedEvent(UserCreatedEvent event) {
        // å¼‚æ­¥æ‰§è¡Œ
        System.out.println("Thread: " + Thread.currentThread().getName());
        System.out.println("Handling user created: " + event.getUser().getName());
    }
}

/**
 * å¯ç”¨å¼‚æ­¥æ”¯æŒ
 */
@Configuration
@EnableAsync
public class AsyncConfig implements AsyncConfigurer {
    
    @Override
    public Executor getAsyncExecutor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(5);
        executor.setMaxPoolSize(10);
        executor.setQueueCapacity(100);
        executor.setThreadNamePrefix("async-");
        executor.initialize();
        return executor;
    }
    
    @Override
    public AsyncUncaughtExceptionHandler getAsyncUncaughtExceptionHandler() {
        return (ex, method, params) -> {
            System.err.println("Async error in " + method.getName() + ": " + ex.getMessage());
        };
    }
}
```

---

## 6. è‡ªå®šä¹‰äº‹ä»¶å¼€å‘

### 6.1 å®šä¹‰äº‹ä»¶

```java
/**
 * è‡ªå®šä¹‰äº‹ä»¶ - ç”¨æˆ·æ³¨å†Œäº‹ä»¶
 */
public class UserRegisteredEvent extends ApplicationEvent {
    
    private final User user;
    
    public UserRegisteredEvent(Object source, User user) {
        super(source);
        this.user = user;
    }
    
    public User getUser() {
        return user;
    }
}

/**
 * æ³›å‹äº‹ä»¶
 */
public class EntityEvent<T> extends ApplicationEvent {
    
    private final T entity;
    private final EventType type;
    
    public enum EventType {
        CREATED, UPDATED, DELETED
    }
    
    public EntityEvent(Object source, T entity, EventType type) {
        super(source);
        this.entity = entity;
        this.type = type;
    }
    
    public T getEntity() {
        return entity;
    }
    
    public EventType getType() {
        return type;
    }
}
```

### 6.2 å‘å¸ƒäº‹ä»¶

```java
@Service
public class UserService {
    
    @Autowired
    private ApplicationEventPublisher eventPublisher;
    
    @Autowired
    private UserRepository userRepository;
    
    public User register(UserDTO dto) {
        // 1. ä¿å­˜ç”¨æˆ·
        User user = new User(dto.getName(), dto.getEmail());
        userRepository.save(user);
        
        // 2. ğŸ”¥ å‘å¸ƒäº‹ä»¶
        eventPublisher.publishEvent(new UserRegisteredEvent(this, user));
        
        return user;
    }
}
```

### 6.3 ç›‘å¬äº‹ä»¶

```java
/**
 * æ–¹å¼1ï¼šå®ç°ApplicationListeneræ¥å£
 */
@Component
public class UserRegisteredListener implements ApplicationListener<UserRegisteredEvent> {
    
    @Override
    public void onApplicationEvent(UserRegisteredEvent event) {
        User user = event.getUser();
        System.out.println("User registered: " + user.getName());
        // å‘é€æ¬¢è¿é‚®ä»¶ç­‰
    }
}

/**
 * æ–¹å¼2ï¼šä½¿ç”¨@EventListeneræ³¨è§£
 */
@Component
public class UserEventHandler {
    
    @EventListener
    public void handleUserRegistered(UserRegisteredEvent event) {
        System.out.println("Handling user registered: " + event.getUser().getName());
    }
    
    /**
     * æ¡ä»¶ç›‘å¬
     */
    @EventListener(condition = "#event.user.vip")
    public void handleVipUserRegistered(UserRegisteredEvent event) {
        System.out.println("VIP user registered: " + event.getUser().getName());
    }
    
    /**
     * ç›‘å¬å¤šä¸ªäº‹ä»¶ç±»å‹
     */
    @EventListener({UserRegisteredEvent.class, UserUpdatedEvent.class})
    public void handleUserEvent(ApplicationEvent event) {
        System.out.println("User event: " + event.getClass().getSimpleName());
    }
    
    /**
     * è¿”å›å€¼ä½œä¸ºæ–°äº‹ä»¶å‘å¸ƒ
     */
    @EventListener
    public UserWelcomedEvent handleAndPublish(UserRegisteredEvent event) {
        // å¤„ç†åè¿”å›æ–°äº‹ä»¶
        return new UserWelcomedEvent(this, event.getUser());
    }
}

/**
 * æ–¹å¼3ï¼šä½¿ç”¨SmartApplicationListener
 */
@Component
public class SmartUserListener implements SmartApplicationListener {
    
    @Override
    public boolean supportsEventType(Class<? extends ApplicationEvent> eventType) {
        return UserRegisteredEvent.class.isAssignableFrom(eventType);
    }
    
    @Override
    public boolean supportsSourceType(Class<?> sourceType) {
        return UserService.class.isAssignableFrom(sourceType);
    }
    
    @Override
    public int getOrder() {
        return 0;  // ä¼˜å…ˆçº§
    }
    
    @Override
    public void onApplicationEvent(ApplicationEvent event) {
        UserRegisteredEvent userEvent = (UserRegisteredEvent) event;
        System.out.println("Smart listener: " + userEvent.getUser().getName());
    }
}
```

---

## 7. é¢è¯•è¦ç‚¹

### 7.1 é«˜é¢‘é¢è¯•é¢˜

#### Q1: Springäº‹ä»¶æœºåˆ¶çš„åŸç†ï¼Ÿ

```
ç­”æ¡ˆè¦ç‚¹ï¼š
1. åŸºäºè§‚å¯Ÿè€…æ¨¡å¼å®ç°
2. æ ¸å¿ƒç»„ä»¶ï¼šEventã€Listenerã€Publisherã€Multicaster
3. ApplicationContextå®ç°äº†ApplicationEventPublisheræ¥å£
4. SimpleApplicationEventMulticasterè´Ÿè´£å¹¿æ’­äº‹ä»¶
5. æ”¯æŒåŒæ­¥å’Œå¼‚æ­¥ä¸¤ç§æ¨¡å¼

æ‰§è¡Œæµç¨‹ï¼š
1. è°ƒç”¨publishEvent()å‘å¸ƒäº‹ä»¶
2. äº‹ä»¶å¹¿æ’­å™¨è·å–åŒ¹é…çš„ç›‘å¬å™¨
3. æŒ‰é¡ºåºè°ƒç”¨ç›‘å¬å™¨çš„onApplicationEvent()
4. å‘çˆ¶å®¹å™¨ä¼ æ’­äº‹ä»¶
```

#### Q2: @EventListenerå’ŒApplicationListenerçš„åŒºåˆ«ï¼Ÿ

```
ApplicationListenerï¼š
- å®ç°æ¥å£æ–¹å¼
- ä¸€ä¸ªç±»åªèƒ½ç›‘å¬ä¸€ç§äº‹ä»¶
- éœ€è¦æ³¨å†Œä¸ºBean

@EventListenerï¼š
- æ³¨è§£æ–¹å¼ï¼Œæ›´çµæ´»
- ä¸€ä¸ªç±»å¯ä»¥æœ‰å¤šä¸ªç›‘å¬æ–¹æ³•
- æ”¯æŒæ¡ä»¶è¡¨è¾¾å¼
- æ”¯æŒè¿”å›å€¼ä½œä¸ºæ–°äº‹ä»¶
- åº•å±‚é€šè¿‡ApplicationListenerMethodAdapteré€‚é…

æ¨èä½¿ç”¨@EventListenerï¼Œæ›´ç®€æ´çµæ´»
```

#### Q3: å¦‚ä½•å®ç°å¼‚æ­¥äº‹ä»¶å¤„ç†ï¼Ÿ

```java
// æ–¹å¼1ï¼šé…ç½®å…¨å±€å¼‚æ­¥æ‰§è¡Œå™¨
@Bean
public ApplicationEventMulticaster applicationEventMulticaster() {
    SimpleApplicationEventMulticaster multicaster = new SimpleApplicationEventMulticaster();
    multicaster.setTaskExecutor(asyncExecutor());
    return multicaster;
}

// æ–¹å¼2ï¼š@Async + @EventListener
@Async
@EventListener
public void handleEvent(MyEvent event) {
    // å¼‚æ­¥æ‰§è¡Œ
}

// æ–¹å¼3ï¼šæ‰‹åŠ¨æäº¤åˆ°çº¿ç¨‹æ± 
@EventListener
public void handleEvent(MyEvent event) {
    executor.submit(() -> {
        // å¼‚æ­¥å¤„ç†
    });
}
```

### 7.2 çŸ¥è¯†ç‚¹æ€»ç»“

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              Springäº‹ä»¶æœºåˆ¶æ€»ç»“                              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                             â”‚
â”‚  æ ¸å¿ƒç»„ä»¶ï¼š                                                  â”‚
â”‚  â”œâ”€â”€ ApplicationEvent: äº‹ä»¶åŸºç±»                             â”‚
â”‚  â”œâ”€â”€ ApplicationListener: ç›‘å¬å™¨æ¥å£                        â”‚
â”‚  â”œâ”€â”€ ApplicationEventPublisher: äº‹ä»¶å‘å¸ƒå™¨                  â”‚
â”‚  â””â”€â”€ ApplicationEventMulticaster: äº‹ä»¶å¹¿æ’­å™¨                â”‚
â”‚                                                             â”‚
â”‚  å†…ç½®äº‹ä»¶ï¼š                                                  â”‚
â”‚  â”œâ”€â”€ ContextRefreshedEvent: å®¹å™¨åˆ·æ–°å®Œæˆ                    â”‚
â”‚  â”œâ”€â”€ ContextStartedEvent: å®¹å™¨å¯åŠ¨                          â”‚
â”‚  â”œâ”€â”€ ContextStoppedEvent: å®¹å™¨åœæ­¢                          â”‚
â”‚  â””â”€â”€ ContextClosedEvent: å®¹å™¨å…³é—­                           â”‚
â”‚                                                             â”‚
â”‚  ç›‘å¬æ–¹å¼ï¼š                                                  â”‚
â”‚  â”œâ”€â”€ å®ç°ApplicationListeneræ¥å£                            â”‚
â”‚  â”œâ”€â”€ ä½¿ç”¨@EventListeneræ³¨è§£                                 â”‚
â”‚  â””â”€â”€ å®ç°SmartApplicationListeneræ¥å£                       â”‚
â”‚                                                             â”‚
â”‚  å¼‚æ­¥å¤„ç†ï¼š                                                  â”‚
â”‚  â”œâ”€â”€ é…ç½®TaskExecutor                                       â”‚
â”‚  â””â”€â”€ @Async + @EventListener                               â”‚
â”‚                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ“š å‚è€ƒèµ„æ–™

- [Springå®˜æ–¹æ–‡æ¡£ - Application Events](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#context-functionality-events)
- [Springæºç  - ApplicationEventMulticaster](https://github.com/spring-projects/spring-framework)

---

**æŒæ¡Springäº‹ä»¶æœºåˆ¶ï¼Œå®ç°ä¼˜é›…çš„è§£è€¦è®¾è®¡ï¼** ğŸš€

*æœ€åæ›´æ–°ï¼š2025-12-28*

# HashMapæºç è§£æ

> JDK8 HashMapå®ç°åŸç†æ·±åº¦è§£æ

## ğŸ“‹ ç›®å½•
- [æ•´ä½“ç»“æ„](#æ•´ä½“ç»“æ„)
- [æ ¸å¿ƒå±æ€§](#æ ¸å¿ƒå±æ€§)
- [hashè®¡ç®—](#hashè®¡ç®—)
- [putæ“ä½œ](#putæ“ä½œ)
- [getæ“ä½œ](#getæ“ä½œ)
- [æ‰©å®¹æœºåˆ¶](#æ‰©å®¹æœºåˆ¶)
- [çº¢é»‘æ ‘](#çº¢é»‘æ ‘)
- [é¢è¯•è¦ç‚¹](#é¢è¯•è¦ç‚¹)

---

## æ•´ä½“ç»“æ„

### JDK7 vs JDK8

```
JDK7 HashMapï¼š
  - æ•°ç»„ + é“¾è¡¨
  - å¤´æ’æ³•ï¼ˆå¹¶å‘æ—¶å¯èƒ½æ­»å¾ªç¯ï¼‰
  - æ‰©å®¹æ—¶é‡æ–°è®¡ç®—hash

JDK8 HashMapï¼š
  - æ•°ç»„ + é“¾è¡¨ + çº¢é»‘æ ‘
  - å°¾æ’æ³•ï¼ˆè§£å†³æ­»å¾ªç¯ï¼‰
  - æ‰©å®¹æ—¶ä½è¿ç®—ä¼˜åŒ–
  - é“¾è¡¨é•¿åº¦>=8è½¬çº¢é»‘æ ‘
```

### æ•°æ®ç»“æ„

```java
public class HashMap<K,V> {
    
    // æ•°ç»„ï¼ˆæ¡¶ï¼‰
    transient Node<K,V>[] table;
    
    // å…ƒç´ æ•°é‡
    transient int size;
    
    // ä¿®æ”¹æ¬¡æ•°ï¼ˆfail-fastï¼‰
    transient int modCount;
    
    // æ‰©å®¹é˜ˆå€¼ = capacity * loadFactor
    int threshold;
    
    // è´Ÿè½½å› å­
    final float loadFactor;
}

// é“¾è¡¨èŠ‚ç‚¹
static class Node<K,V> implements Map.Entry<K,V> {
    final int hash;
    final K key;
    V value;
    Node<K,V> next;
}

// çº¢é»‘æ ‘èŠ‚ç‚¹
static final class TreeNode<K,V> extends LinkedHashMap.Entry<K,V> {
    TreeNode<K,V> parent;
    TreeNode<K,V> left;
    TreeNode<K,V> right;
    TreeNode<K,V> prev;
    boolean red;
}
```

---

## æ ¸å¿ƒå±æ€§

### é‡è¦å¸¸é‡

```java
// é»˜è®¤åˆå§‹å®¹é‡ï¼š16
static final int DEFAULT_INITIAL_CAPACITY = 1 << 4;

// æœ€å¤§å®¹é‡ï¼š2^30
static final int MAXIMUM_CAPACITY = 1 << 30;

// é»˜è®¤è´Ÿè½½å› å­ï¼š0.75
static final float DEFAULT_LOAD_FACTOR = 0.75f;

// é“¾è¡¨è½¬çº¢é»‘æ ‘é˜ˆå€¼ï¼š8
static final int TREEIFY_THRESHOLD = 8;

// çº¢é»‘æ ‘è½¬é“¾è¡¨é˜ˆå€¼ï¼š6
static final int UNTREEIFY_THRESHOLD = 6;

// æ ‘åŒ–çš„æœ€å°æ•°ç»„é•¿åº¦ï¼š64
static final int MIN_TREEIFY_CAPACITY = 64;
```

### ä¸ºä»€ä¹ˆæ˜¯è¿™äº›å€¼ï¼Ÿ

```
1. é»˜è®¤å®¹é‡16ï¼š
   - 2çš„å¹‚æ¬¡æ–¹ï¼Œä¾¿äºä½è¿ç®—
   - å¤ªå°é¢‘ç¹æ‰©å®¹ï¼Œå¤ªå¤§æµªè´¹ç©ºé—´

2. è´Ÿè½½å› å­0.75ï¼š
   - æ—¶é—´å’Œç©ºé—´çš„å¹³è¡¡
   - å¤ªå°ï¼šç©ºé—´æµªè´¹
   - å¤ªå¤§ï¼šå†²çªå¢å¤šï¼ŒæŸ¥è¯¢å˜æ…¢

3. æ ‘åŒ–é˜ˆå€¼8ï¼š
   - æ³Šæ¾åˆ†å¸ƒï¼šé“¾è¡¨é•¿åº¦è¾¾åˆ°8çš„æ¦‚ç‡æä½ï¼ˆ0.00000006ï¼‰
   - çº¢é»‘æ ‘æŸ¥è¯¢O(logn)ï¼Œé“¾è¡¨O(n)
   - 8æ˜¯å¹³è¡¡ç‚¹

4. é€€åŒ–é˜ˆå€¼6ï¼š
   - é¿å…é¢‘ç¹è½¬æ¢
   - 6å’Œ8ä¹‹é—´æœ‰ç¼“å†²
```

---

## hashè®¡ç®—

### hashæ–¹æ³•

```java
static final int hash(Object key) {
    int h;
    // keyä¸ºnullè¿”å›0ï¼Œå¦åˆ™é«˜16ä½å¼‚æˆ–ä½16ä½
    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
}

/**
 * ä¸ºä»€ä¹ˆè¦é«˜16ä½å¼‚æˆ–ä½16ä½ï¼Ÿ
 * 
 * æ‰°åŠ¨å‡½æ•°ï¼šè®©hashå€¼æ›´åˆ†æ•£
 * 
 * å‡è®¾hashCode = 0b 1111 1111 1111 1111 0000 0000 0000 0001
 * 
 * æ•°ç»„é•¿åº¦n = 16ï¼Œè®¡ç®—ç´¢å¼•ï¼š(n-1) & hash
 * n-1 = 15 = 0b 0000 0000 0000 0000 0000 0000 0000 1111
 * 
 * åªæœ‰ä½4ä½å‚ä¸è¿ç®—ï¼Œé«˜ä½å®Œå…¨æ²¡ç”¨ï¼
 * 
 * å¼‚æˆ–åï¼š
 * h >>> 16 = 0b 0000 0000 0000 0000 1111 1111 1111 1111
 * h ^ (h >>> 16) = é«˜ä½ä¹Ÿå‚ä¸è¿ç®—
 * 
 * å‡å°‘å†²çªï¼Œåˆ†å¸ƒæ›´å‡åŒ€
 */
```

### ç´¢å¼•è®¡ç®—

```java
// è®¡ç®—æ•°ç»„ç´¢å¼•
int index = (n - 1) & hash;

/**
 * ä¸ºä»€ä¹ˆç”¨ & è€Œä¸æ˜¯ %ï¼Ÿ
 * 
 * å½“næ˜¯2çš„å¹‚æ¬¡æ–¹æ—¶ï¼š
 * hash % n == hash & (n - 1)
 * 
 * ä½è¿ç®—æ¯”å–æ¨¡å¿«å¾—å¤š
 * 
 * ç¤ºä¾‹ï¼šn = 16
 * n - 1 = 15 = 0b 1111
 * hash & 15 = hashçš„ä½4ä½
 * 
 * è¿™å°±æ˜¯ä¸ºä»€ä¹ˆå®¹é‡å¿…é¡»æ˜¯2çš„å¹‚æ¬¡æ–¹
 */
```

---

## putæ“ä½œ

### putValæºç 

```java
public V put(K key, V value) {
    return putVal(hash(key), key, value, false, true);
}

final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) {
    Node<K,V>[] tab; Node<K,V> p; int n, i;
    
    // 1. æ•°ç»„ä¸ºç©ºï¼Œåˆå§‹åŒ–
    if ((tab = table) == null || (n = tab.length) == 0)
        n = (tab = resize()).length;
    
    // 2. æ¡¶ä¸ºç©ºï¼Œç›´æ¥æ’å…¥
    if ((p = tab[i = (n - 1) & hash]) == null)
        tab[i] = newNode(hash, key, value, null);
    
    else {
        Node<K,V> e; K k;
        
        // 3. å¤´èŠ‚ç‚¹å°±æ˜¯ç›®æ ‡key
        if (p.hash == hash &&
            ((k = p.key) == key || (key != null && key.equals(k))))
            e = p;
        
        // 4. çº¢é»‘æ ‘
        else if (p instanceof TreeNode)
            e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);
        
        // 5. é“¾è¡¨
        else {
            for (int binCount = 0; ; ++binCount) {
                // åˆ°è¾¾é“¾è¡¨å°¾éƒ¨ï¼Œæ’å…¥æ–°èŠ‚ç‚¹
                if ((e = p.next) == null) {
                    p.next = newNode(hash, key, value, null);
                    // é“¾è¡¨é•¿åº¦>=8ï¼Œè½¬çº¢é»‘æ ‘
                    if (binCount >= TREEIFY_THRESHOLD - 1)
                        treeifyBin(tab, hash);
                    break;
                }
                // æ‰¾åˆ°ç›¸åŒkey
                if (e.hash == hash &&
                    ((k = e.key) == key || (key != null && key.equals(k))))
                    break;
                p = e;
            }
        }
        
        // 6. å­˜åœ¨ç›¸åŒkeyï¼Œæ›´æ–°value
        if (e != null) {
            V oldValue = e.value;
            if (!onlyIfAbsent || oldValue == null)
                e.value = value;
            afterNodeAccess(e);  // LinkedHashMapå›è°ƒ
            return oldValue;
        }
    }
    
    // 7. ä¿®æ”¹æ¬¡æ•°+1
    ++modCount;
    
    // 8. å…ƒç´ æ•°é‡+1ï¼Œæ£€æŸ¥æ˜¯å¦éœ€è¦æ‰©å®¹
    if (++size > threshold)
        resize();
    
    afterNodeInsertion(evict);  // LinkedHashMapå›è°ƒ
    return null;
}
```

### putæµç¨‹å›¾

```
put(key, value)
    â†“
hash = hash(key)
    â†“
tableä¸ºç©º? â†’ æ˜¯ â†’ resize()åˆå§‹åŒ–
    â†“ å¦
è®¡ç®—ç´¢å¼• i = (n-1) & hash
    â†“
tab[i]ä¸ºç©º? â†’ æ˜¯ â†’ ç›´æ¥æ’å…¥æ–°èŠ‚ç‚¹
    â†“ å¦
tab[i].key == key? â†’ æ˜¯ â†’ æ›´æ–°value
    â†“ å¦
tab[i]æ˜¯TreeNode? â†’ æ˜¯ â†’ putTreeVal()
    â†“ å¦
éå†é“¾è¡¨ï¼š
    â†“
æ‰¾åˆ°ç›¸åŒkey? â†’ æ˜¯ â†’ æ›´æ–°value
    â†“ å¦
åˆ°è¾¾å°¾éƒ¨ â†’ å°¾æ’æ–°èŠ‚ç‚¹
    â†“
é“¾è¡¨é•¿åº¦>=8? â†’ æ˜¯ â†’ treeifyBin()
    â†“
size > threshold? â†’ æ˜¯ â†’ resize()æ‰©å®¹
```

---

## getæ“ä½œ

### getNodeæºç 

```java
public V get(Object key) {
    Node<K,V> e;
    return (e = getNode(hash(key), key)) == null ? null : e.value;
}

final Node<K,V> getNode(int hash, Object key) {
    Node<K,V>[] tab; Node<K,V> first, e; int n; K k;
    
    // 1. æ•°ç»„ä¸ä¸ºç©ºä¸”æ¡¶ä¸ä¸ºç©º
    if ((tab = table) != null && (n = tab.length) > 0 &&
        (first = tab[(n - 1) & hash]) != null) {
        
        // 2. æ£€æŸ¥å¤´èŠ‚ç‚¹
        if (first.hash == hash &&
            ((k = first.key) == key || (key != null && key.equals(k))))
            return first;
        
        // 3. æœ‰åç»­èŠ‚ç‚¹
        if ((e = first.next) != null) {
            // çº¢é»‘æ ‘æŸ¥æ‰¾
            if (first instanceof TreeNode)
                return ((TreeNode<K,V>)first).getTreeNode(hash, key);
            
            // é“¾è¡¨éå†
            do {
                if (e.hash == hash &&
                    ((k = e.key) == key || (key != null && key.equals(k))))
                    return e;
            } while ((e = e.next) != null);
        }
    }
    return null;
}
```

---

## æ‰©å®¹æœºåˆ¶

### resizeæºç 

```java
final Node<K,V>[] resize() {
    Node<K,V>[] oldTab = table;
    int oldCap = (oldTab == null) ? 0 : oldTab.length;
    int oldThr = threshold;
    int newCap, newThr = 0;
    
    // 1. è®¡ç®—æ–°å®¹é‡å’Œæ–°é˜ˆå€¼
    if (oldCap > 0) {
        // è¶…è¿‡æœ€å¤§å®¹é‡ï¼Œä¸å†æ‰©å®¹
        if (oldCap >= MAXIMUM_CAPACITY) {
            threshold = Integer.MAX_VALUE;
            return oldTab;
        }
        // å®¹é‡ç¿»å€
        else if ((newCap = oldCap << 1) < MAXIMUM_CAPACITY &&
                 oldCap >= DEFAULT_INITIAL_CAPACITY)
            newThr = oldThr << 1;  // é˜ˆå€¼ç¿»å€
    }
    else if (oldThr > 0)
        newCap = oldThr;  // åˆå§‹å®¹é‡ = é˜ˆå€¼
    else {
        // é»˜è®¤åˆå§‹åŒ–
        newCap = DEFAULT_INITIAL_CAPACITY;
        newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);
    }
    
    if (newThr == 0) {
        float ft = (float)newCap * loadFactor;
        newThr = (newCap < MAXIMUM_CAPACITY && ft < (float)MAXIMUM_CAPACITY ?
                  (int)ft : Integer.MAX_VALUE);
    }
    threshold = newThr;
    
    // 2. åˆ›å»ºæ–°æ•°ç»„
    Node<K,V>[] newTab = (Node<K,V>[])new Node[newCap];
    table = newTab;
    
    // 3. è¿ç§»æ•°æ®
    if (oldTab != null) {
        for (int j = 0; j < oldCap; ++j) {
            Node<K,V> e;
            if ((e = oldTab[j]) != null) {
                oldTab[j] = null;  // help GC
                
                // åªæœ‰ä¸€ä¸ªèŠ‚ç‚¹
                if (e.next == null)
                    newTab[e.hash & (newCap - 1)] = e;
                
                // çº¢é»‘æ ‘
                else if (e instanceof TreeNode)
                    ((TreeNode<K,V>)e).split(this, newTab, j, oldCap);
                
                // é“¾è¡¨
                else {
                    // ä½ä½é“¾è¡¨ï¼ˆç´¢å¼•ä¸å˜ï¼‰
                    Node<K,V> loHead = null, loTail = null;
                    // é«˜ä½é“¾è¡¨ï¼ˆç´¢å¼•+oldCapï¼‰
                    Node<K,V> hiHead = null, hiTail = null;
                    Node<K,V> next;
                    
                    do {
                        next = e.next;
                        // åˆ¤æ–­é«˜ä½æ˜¯0è¿˜æ˜¯1
                        if ((e.hash & oldCap) == 0) {
                            if (loTail == null)
                                loHead = e;
                            else
                                loTail.next = e;
                            loTail = e;
                        }
                        else {
                            if (hiTail == null)
                                hiHead = e;
                            else
                                hiTail.next = e;
                            hiTail = e;
                        }
                    } while ((e = next) != null);
                    
                    // æ”¾åˆ°æ–°æ•°ç»„
                    if (loTail != null) {
                        loTail.next = null;
                        newTab[j] = loHead;
                    }
                    if (hiTail != null) {
                        hiTail.next = null;
                        newTab[j + oldCap] = hiHead;
                    }
                }
            }
        }
    }
    return newTab;
}
```

### æ‰©å®¹ä¼˜åŒ–ï¼ˆJDK8ï¼‰

```
JDK8æ‰©å®¹ä¼˜åŒ–ï¼š

æ—§å®¹é‡ï¼š16ï¼Œæ–°å®¹é‡ï¼š32
æ—§ç´¢å¼•è®¡ç®—ï¼šhash & 15 = hash & 0b01111
æ–°ç´¢å¼•è®¡ç®—ï¼šhash & 31 = hash & 0b11111

å…³é”®ï¼šåªéœ€çœ‹hashçš„ç¬¬5ä½ï¼ˆoldCapä½ç½®ï¼‰
  - ç¬¬5ä½æ˜¯0ï¼šæ–°ç´¢å¼• = æ—§ç´¢å¼•
  - ç¬¬5ä½æ˜¯1ï¼šæ–°ç´¢å¼• = æ—§ç´¢å¼• + 16

ç¤ºä¾‹ï¼š
hash = 0b...01010ï¼ˆç¬¬5ä½æ˜¯0ï¼‰
  æ—§ç´¢å¼•ï¼š01010 & 01111 = 01010 = 10
  æ–°ç´¢å¼•ï¼š01010 & 11111 = 01010 = 10ï¼ˆä¸å˜ï¼‰

hash = 0b...11010ï¼ˆç¬¬5ä½æ˜¯1ï¼‰
  æ—§ç´¢å¼•ï¼š11010 & 01111 = 01010 = 10
  æ–°ç´¢å¼•ï¼š11010 & 11111 = 11010 = 26 = 10 + 16

ä¼˜åŠ¿ï¼š
  - ä¸éœ€è¦é‡æ–°è®¡ç®—hash
  - åªéœ€åˆ¤æ–­ä¸€ä¸ªbit
  - é“¾è¡¨é¡ºåºä¸å˜ï¼ˆå°¾æ’æ³•ï¼‰
```

---

## çº¢é»‘æ ‘

### æ ‘åŒ–æ¡ä»¶

```java
/**
 * é“¾è¡¨è½¬çº¢é»‘æ ‘
 */
final void treeifyBin(Node<K,V>[] tab, int hash) {
    int n, index; Node<K,V> e;
    
    // æ•°ç»„é•¿åº¦<64ï¼Œä¼˜å…ˆæ‰©å®¹è€Œä¸æ˜¯æ ‘åŒ–
    if (tab == null || (n = tab.length) < MIN_TREEIFY_CAPACITY)
        resize();
    
    else if ((e = tab[index = (n - 1) & hash]) != null) {
        TreeNode<K,V> hd = null, tl = null;
        
        // é“¾è¡¨èŠ‚ç‚¹è½¬TreeNode
        do {
            TreeNode<K,V> p = replacementTreeNode(e, null);
            if (tl == null)
                hd = p;
            else {
                p.prev = tl;
                tl.next = p;
            }
            tl = p;
        } while ((e = e.next) != null);
        
        // æ„å»ºçº¢é»‘æ ‘
        if ((tab[index] = hd) != null)
            hd.treeify(tab);
    }
}

/**
 * æ ‘åŒ–æ¡ä»¶ï¼š
 * 1. é“¾è¡¨é•¿åº¦ >= 8
 * 2. æ•°ç»„é•¿åº¦ >= 64
 * 
 * å¦‚æœæ•°ç»„é•¿åº¦<64ï¼Œä¼˜å…ˆæ‰©å®¹
 * å› ä¸ºæ‰©å®¹å¯ä»¥å‡å°‘é“¾è¡¨é•¿åº¦
 */
```

### çº¢é»‘æ ‘ç‰¹æ€§

```
çº¢é»‘æ ‘ç‰¹æ€§ï¼š
1. èŠ‚ç‚¹æ˜¯çº¢è‰²æˆ–é»‘è‰²
2. æ ¹èŠ‚ç‚¹æ˜¯é»‘è‰²
3. å¶å­èŠ‚ç‚¹ï¼ˆNILï¼‰æ˜¯é»‘è‰²
4. çº¢è‰²èŠ‚ç‚¹çš„å­èŠ‚ç‚¹å¿…é¡»æ˜¯é»‘è‰²
5. ä»ä»»ä¸€èŠ‚ç‚¹åˆ°å¶å­çš„è·¯å¾„åŒ…å«ç›¸åŒæ•°é‡çš„é»‘è‰²èŠ‚ç‚¹

æ—¶é—´å¤æ‚åº¦ï¼š
  - æŸ¥æ‰¾ï¼šO(log n)
  - æ’å…¥ï¼šO(log n)
  - åˆ é™¤ï¼šO(log n)

vs é“¾è¡¨ï¼š
  - é“¾è¡¨æŸ¥æ‰¾ï¼šO(n)
  - å½“n=8æ—¶ï¼Œçº¢é»‘æ ‘æŸ¥æ‰¾çº¦3æ¬¡ï¼Œé“¾è¡¨8æ¬¡
```

---

## é¢è¯•è¦ç‚¹

### 1. HashMapçš„putæµç¨‹

```
Q: HashMapçš„putæµç¨‹æ˜¯ä»€ä¹ˆï¼Ÿ

A:
1. è®¡ç®—hashï¼šhash(key) = hashCode ^ (hashCode >>> 16)
2. æ•°ç»„ä¸ºç©ºåˆ™åˆå§‹åŒ–
3. è®¡ç®—ç´¢å¼•ï¼š(n-1) & hash
4. æ¡¶ä¸ºç©ºç›´æ¥æ’å…¥
5. æ¡¶ä¸ä¸ºç©ºï¼š
   - keyç›¸åŒï¼šæ›´æ–°value
   - çº¢é»‘æ ‘ï¼šputTreeVal
   - é“¾è¡¨ï¼šå°¾æ’ï¼Œé•¿åº¦>=8åˆ™æ ‘åŒ–
6. size > thresholdåˆ™æ‰©å®¹
```

### 2. ä¸ºä»€ä¹ˆå®¹é‡æ˜¯2çš„å¹‚æ¬¡æ–¹

```
Q: HashMapå®¹é‡ä¸ºä»€ä¹ˆå¿…é¡»æ˜¯2çš„å¹‚æ¬¡æ–¹ï¼Ÿ

A:
1. ç´¢å¼•è®¡ç®—ä¼˜åŒ–ï¼š
   - hash % n == hash & (n-1)ï¼ˆå½“næ˜¯2çš„å¹‚ï¼‰
   - ä½è¿ç®—æ¯”å–æ¨¡å¿«

2. æ‰©å®¹ä¼˜åŒ–ï¼š
   - æ–°ç´¢å¼• = æ—§ç´¢å¼• æˆ– æ—§ç´¢å¼•+æ—§å®¹é‡
   - åªéœ€åˆ¤æ–­ä¸€ä¸ªbit

3. åˆ†å¸ƒå‡åŒ€ï¼š
   - n-1çš„äºŒè¿›åˆ¶å…¨æ˜¯1
   - hashçš„æ¯ä¸€ä½éƒ½å‚ä¸è¿ç®—
```

### 3. ä¸ºä»€ä¹ˆè´Ÿè½½å› å­æ˜¯0.75

```
Q: ä¸ºä»€ä¹ˆé»˜è®¤è´Ÿè½½å› å­æ˜¯0.75ï¼Ÿ

A:
æ—¶é—´å’Œç©ºé—´çš„å¹³è¡¡ï¼š

è´Ÿè½½å› å­å¤ªå°ï¼ˆå¦‚0.5ï¼‰ï¼š
  - ç©ºé—´åˆ©ç”¨ç‡ä½
  - é¢‘ç¹æ‰©å®¹

è´Ÿè½½å› å­å¤ªå¤§ï¼ˆå¦‚1.0ï¼‰ï¼š
  - å†²çªå¢å¤š
  - é“¾è¡¨å˜é•¿
  - æŸ¥è¯¢å˜æ…¢

0.75æ˜¯ç»éªŒå€¼ï¼š
  - æ³Šæ¾åˆ†å¸ƒä¸‹ï¼Œå†²çªæ¦‚ç‡è¾ƒä½
  - ç©ºé—´åˆ©ç”¨ç‡è¾ƒé«˜
```

### 4. ä¸ºä»€ä¹ˆé“¾è¡¨é•¿åº¦8è½¬çº¢é»‘æ ‘

```
Q: ä¸ºä»€ä¹ˆé“¾è¡¨é•¿åº¦è¾¾åˆ°8æ‰è½¬çº¢é»‘æ ‘ï¼Ÿ

A:
1. æ³Šæ¾åˆ†å¸ƒï¼š
   - è´Ÿè½½å› å­0.75æ—¶
   - é“¾è¡¨é•¿åº¦è¾¾åˆ°8çš„æ¦‚ç‡çº¦0.00000006
   - æå°æ¦‚ç‡äº‹ä»¶

2. çº¢é»‘æ ‘å¼€é”€ï¼š
   - TreeNodeå ç”¨ç©ºé—´æ˜¯Nodeçš„2å€
   - æ ‘åŒ–å’Œé€€åŒ–æœ‰å¼€é”€

3. æ€§èƒ½å¹³è¡¡ï¼š
   - é“¾è¡¨é•¿åº¦8æ—¶ï¼ŒæŸ¥æ‰¾çº¦8æ¬¡
   - çº¢é»‘æ ‘æŸ¥æ‰¾çº¦3æ¬¡ï¼ˆlog8ï¼‰
   - 8æ˜¯å¹³è¡¡ç‚¹
```

### 5. HashMapçº¿ç¨‹ä¸å®‰å…¨

```
Q: HashMapä¸ºä»€ä¹ˆçº¿ç¨‹ä¸å®‰å…¨ï¼Ÿ

A:
1. putæ—¶æ•°æ®è¦†ç›–ï¼š
   - ä¸¤ä¸ªçº¿ç¨‹åŒæ—¶put
   - è®¡ç®—åˆ°åŒä¸€ä¸ªæ¡¶
   - åè€…è¦†ç›–å‰è€…

2. æ‰©å®¹æ—¶æ•°æ®ä¸¢å¤±ï¼š
   - çº¿ç¨‹Aæ‰©å®¹ä¸­
   - çº¿ç¨‹B put
   - æ•°æ®å¯èƒ½ä¸¢å¤±

3. JDK7æ­»å¾ªç¯ï¼ˆå·²ä¿®å¤ï¼‰ï¼š
   - å¤´æ’æ³•
   - å¹¶å‘æ‰©å®¹å½¢æˆç¯å½¢é“¾è¡¨
   - getæ—¶æ­»å¾ªç¯

è§£å†³æ–¹æ¡ˆï¼š
  - Collections.synchronizedMap()
  - ConcurrentHashMapï¼ˆæ¨èï¼‰
```

### 6. HashMap vs Hashtable

```
Q: HashMapå’ŒHashtableçš„åŒºåˆ«ï¼Ÿ

A:
| å¯¹æ¯”é¡¹ | HashMap | Hashtable |
|--------|---------|-----------|
| çº¿ç¨‹å®‰å…¨ | å¦ | æ˜¯ï¼ˆsynchronizedï¼‰|
| null key | å…è®¸1ä¸ª | ä¸å…è®¸ |
| null value | å…è®¸å¤šä¸ª | ä¸å…è®¸ |
| åˆå§‹å®¹é‡ | 16 | 11 |
| æ‰©å®¹ | 2å€ | 2å€+1 |
| ç»§æ‰¿ | AbstractMap | Dictionary |
| è¿­ä»£å™¨ | fail-fast | fail-fast |

æ¨èï¼š
  - å•çº¿ç¨‹ï¼šHashMap
  - å¤šçº¿ç¨‹ï¼šConcurrentHashMap
  - Hashtableå·²è¿‡æ—¶
```

---

## ğŸ’¡ æ€»ç»“

```
HashMapæ ¸å¿ƒè¦ç‚¹ï¼š

1. æ•°æ®ç»“æ„ï¼š
   - æ•°ç»„ + é“¾è¡¨ + çº¢é»‘æ ‘
   - é“¾è¡¨é•¿åº¦>=8ä¸”æ•°ç»„>=64è½¬çº¢é»‘æ ‘

2. hashè®¡ç®—ï¼š
   - hash = hashCode ^ (hashCode >>> 16)
   - ç´¢å¼• = (n-1) & hash

3. æ‰©å®¹ï¼š
   - å®¹é‡ç¿»å€
   - é˜ˆå€¼ç¿»å€
   - é“¾è¡¨æ‹†åˆ†ï¼ˆé«˜ä½ä½ï¼‰

4. é‡è¦å‚æ•°ï¼š
   - é»˜è®¤å®¹é‡ï¼š16
   - è´Ÿè½½å› å­ï¼š0.75
   - æ ‘åŒ–é˜ˆå€¼ï¼š8
   - é€€åŒ–é˜ˆå€¼ï¼š6

5. çº¿ç¨‹ä¸å®‰å…¨ï¼š
   - å¹¶å‘putæ•°æ®è¦†ç›–
   - å¹¶å‘æ‰©å®¹æ•°æ®ä¸¢å¤±
```

---

*æœ€åæ›´æ–°ï¼š2025-12-28*

# HashSetæºç è§£æ

> åŸºäºHashMapå®ç°çš„æ— åºä¸é‡å¤é›†åˆ

## ğŸ“‹ ç›®å½•
- [æ•´ä½“ç»“æ„](#æ•´ä½“ç»“æ„)
- [æ ¸å¿ƒå±æ€§](#æ ¸å¿ƒå±æ€§)
- [æ„é€ æ–¹æ³•](#æ„é€ æ–¹æ³•)
- [æ·»åŠ å…ƒç´ ](#æ·»åŠ å…ƒç´ )
- [åˆ é™¤å…ƒç´ ](#åˆ é™¤å…ƒç´ )
- [æŸ¥è¯¢å…ƒç´ ](#æŸ¥è¯¢å…ƒç´ )
- [è¿­ä»£éå†](#è¿­ä»£éå†)
- [é¢è¯•è¦ç‚¹](#é¢è¯•è¦ç‚¹)

---

## æ•´ä½“ç»“æ„

### ç±»å®šä¹‰

```java
public class HashSet<E>
    extends AbstractSet<E>
    implements Set<E>, Cloneable, java.io.Serializable {
    
    // åº•å±‚ä½¿ç”¨HashMapå­˜å‚¨
    private transient HashMap<E,Object> map;
    
    // æ‰€æœ‰valueå…±ç”¨çš„è™šæ‹Ÿå¯¹è±¡
    private static final Object PRESENT = new Object();
}

/**
 * å…³é”®ç‚¹ï¼š
 * 1. HashSetåº•å±‚å°±æ˜¯HashMap
 * 2. å…ƒç´ ä½œä¸ºHashMapçš„keyå­˜å‚¨
 * 3. valueç»Ÿä¸€ä½¿ç”¨PRESENTå ä½
 * 4. åˆ©ç”¨HashMapçš„keyä¸é‡å¤ç‰¹æ€§å®ç°å»é‡
 */
```

### ç»§æ‰¿ä½“ç³»

```
Set<E>ï¼ˆæ¥å£ï¼‰
â””â”€â”€ AbstractSet<E>ï¼ˆæŠ½è±¡ç±»ï¼‰
    â””â”€â”€ HashSet<E>ï¼ˆå®ç°ç±»ï¼‰
        â””â”€â”€ LinkedHashSet<E>ï¼ˆæœ‰åºå­ç±»ï¼‰

ç‰¹ç‚¹ï¼š
- æ— åºï¼ˆä¸ä¿è¯æ’å…¥é¡ºåºï¼‰
- ä¸é‡å¤ï¼ˆåŸºäºhashCodeå’Œequalsï¼‰
- å…è®¸nullå…ƒç´ ï¼ˆæœ€å¤šä¸€ä¸ªï¼‰
- éçº¿ç¨‹å®‰å…¨
```

### ä¸HashMapçš„å…³ç³»

```
HashSetæ“ä½œ        â†’    HashMapæ“ä½œ
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
add(e)            â†’    map.put(e, PRESENT)
remove(e)         â†’    map.remove(e)
contains(e)       â†’    map.containsKey(e)
size()            â†’    map.size()
isEmpty()         â†’    map.isEmpty()
clear()           â†’    map.clear()
iterator()        â†’    map.keySet().iterator()
```

---

## æ ¸å¿ƒå±æ€§

```java
// åº•å±‚HashMapï¼Œå­˜å‚¨å®é™…æ•°æ®
private transient HashMap<E,Object> map;

// æ‰€æœ‰keyå¯¹åº”çš„valueï¼ŒèŠ‚çœå†…å­˜
// ä½¿ç”¨åŒä¸€ä¸ªå¯¹è±¡ä½œä¸ºå ä½ç¬¦
private static final Object PRESENT = new Object();

// åºåˆ—åŒ–ç‰ˆæœ¬å·
static final long serialVersionUID = -5024744406713321676L;
```

### ä¸ºä»€ä¹ˆç”¨PRESENTè€Œä¸æ˜¯null

```java
/**
 * åŸå› åˆ†æï¼š
 * 
 * 1. HashMapçš„putæ–¹æ³•è¿”å›å€¼ï¼š
 *    - å¦‚æœkeyä¸å­˜åœ¨ï¼Œè¿”å›null
 *    - å¦‚æœkeyå­˜åœ¨ï¼Œè¿”å›æ—§value
 * 
 * 2. å¦‚æœvalueç”¨nullï¼š
 *    - putè¿”å›nullæ—¶æ— æ³•åŒºåˆ†æ˜¯"æ–°å¢"è¿˜æ˜¯"å·²å­˜åœ¨ä¸”valueä¸ºnull"
 * 
 * 3. ä½¿ç”¨PRESENTï¼š
 *    - putè¿”å›null â†’ æ–°å¢æˆåŠŸ
 *    - putè¿”å›PRESENT â†’ keyå·²å­˜åœ¨
 */

// HashSet.add()çš„å®ç°
public boolean add(E e) {
    return map.put(e, PRESENT) == null;
    // è¿”å›nullè¯´æ˜æ˜¯æ–°keyï¼Œæ·»åŠ æˆåŠŸè¿”å›true
    // è¿”å›PRESENTè¯´æ˜keyå·²å­˜åœ¨ï¼Œè¿”å›false
}
```

---

## æ„é€ æ–¹æ³•

### æ— å‚æ„é€ 

```java
/**
 * åˆ›å»ºç©ºçš„HashSet
 * åº•å±‚HashMapé»˜è®¤å®¹é‡16ï¼Œè´Ÿè½½å› å­0.75
 */
public HashSet() {
    map = new HashMap<>();
}

// ä½¿ç”¨ç¤ºä¾‹
Set<String> set = new HashSet<>();
```

### æŒ‡å®šåˆå§‹å®¹é‡

```java
/**
 * æŒ‡å®šåˆå§‹å®¹é‡
 */
public HashSet(int initialCapacity) {
    map = new HashMap<>(initialCapacity);
}

/**
 * æŒ‡å®šåˆå§‹å®¹é‡å’Œè´Ÿè½½å› å­
 */
public HashSet(int initialCapacity, float loadFactor) {
    map = new HashMap<>(initialCapacity, loadFactor);
}

// ä½¿ç”¨ç¤ºä¾‹ï¼šé¢„ä¼°å­˜å‚¨1000ä¸ªå…ƒç´ 
// å®¹é‡ = 1000 / 0.75 â‰ˆ 1334ï¼Œå‘ä¸Šå–2çš„å¹‚æ¬¡ = 2048
Set<String> set = new HashSet<>(2048);
```

### ä»é›†åˆæ„é€ 

```java
/**
 * ä»å·²æœ‰é›†åˆåˆ›å»ºHashSet
 */
public HashSet(Collection<? extends E> c) {
    // è®¡ç®—åˆé€‚çš„åˆå§‹å®¹é‡
    // Math.max((int)(c.size()/.75f) + 1, 16)
    map = new HashMap<>(Math.max((int) (c.size()/.75f) + 1, 16));
    addAll(c);
}

// ä½¿ç”¨ç¤ºä¾‹ï¼šListå»é‡
List<String> list = Arrays.asList("a", "b", "a", "c");
Set<String> set = new HashSet<>(list);
// set = ["a", "b", "c"]
```

### LinkedHashSetä¸“ç”¨æ„é€ 

```java
/**
 * åŒ…çº§ç§æœ‰æ„é€ å™¨ï¼Œä¾›LinkedHashSetä½¿ç”¨
 * dummyå‚æ•°ä»…ç”¨äºåŒºåˆ†å…¶ä»–æ„é€ å™¨
 */
HashSet(int initialCapacity, float loadFactor, boolean dummy) {
    map = new LinkedHashMap<>(initialCapacity, loadFactor);
}

// LinkedHashSetç»§æ‰¿HashSetï¼Œä½¿ç”¨æ­¤æ„é€ å™¨
// åº•å±‚æ˜¯LinkedHashMapï¼Œä¿æŒæ’å…¥é¡ºåº
```

---

## æ·»åŠ å…ƒç´ 

### add(E e)

```java
/**
 * æ·»åŠ å…ƒç´ 
 * @return true-æ·»åŠ æˆåŠŸï¼ˆæ–°å…ƒç´ ï¼‰ï¼Œfalse-å…ƒç´ å·²å­˜åœ¨
 */
public boolean add(E e) {
    return map.put(e, PRESENT) == null;
}

/**
 * æ‰§è¡Œæµç¨‹ï¼š
 * 1. è°ƒç”¨HashMap.put(e, PRESENT)
 * 2. HashMapè®¡ç®—eçš„hashå€¼
 * 3. æ ¹æ®hashå®šä½æ¡¶ä½ç½®
 * 4. æ£€æŸ¥æ˜¯å¦å­˜åœ¨ç›¸åŒkeyï¼ˆhashCodeç›¸ç­‰ä¸”equalsä¸ºtrueï¼‰
 * 5. ä¸å­˜åœ¨åˆ™æ’å…¥ï¼Œè¿”å›null â†’ addè¿”å›true
 * 6. å­˜åœ¨åˆ™æ›´æ–°valueï¼ˆå®é™…valueä¸å˜ï¼‰ï¼Œè¿”å›æ—§value â†’ addè¿”å›false
 */

// ç¤ºä¾‹
Set<String> set = new HashSet<>();
set.add("apple");   // trueï¼Œæ–°å¢
set.add("banana");  // trueï¼Œæ–°å¢
set.add("apple");   // falseï¼Œå·²å­˜åœ¨
```

### å»é‡åŸç†

```java
/**
 * å»é‡ä¾èµ–ä¸¤ä¸ªæ–¹æ³•ï¼š
 * 1. hashCode() - è®¡ç®—å“ˆå¸Œå€¼ï¼Œå†³å®šå­˜å‚¨ä½ç½®
 * 2. equals() - åˆ¤æ–­æ˜¯å¦ç›¸ç­‰
 * 
 * åˆ¤æ–­æµç¨‹ï¼š
 * if (hash1 == hash2 && (key1 == key2 || key1.equals(key2))) {
 *     // è®¤ä¸ºæ˜¯åŒä¸€ä¸ªå…ƒç´ 
 * }
 */

// è‡ªå®šä¹‰å¯¹è±¡å¿…é¡»é‡å†™hashCodeå’Œequals
public class User {
    private String name;
    private int age;
    
    @Override
    public int hashCode() {
        return Objects.hash(name, age);
    }
    
    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null || getClass() != obj.getClass()) return false;
        User user = (User) obj;
        return age == user.age && Objects.equals(name, user.name);
    }
}

// ä½¿ç”¨
Set<User> users = new HashSet<>();
users.add(new User("Tom", 20));
users.add(new User("Tom", 20)); // ä¸ä¼šé‡å¤æ·»åŠ 
```

### addAll(Collection)

```java
/**
 * æ‰¹é‡æ·»åŠ å…ƒç´ 
 * @return true-é›†åˆå‘ç”Ÿå˜åŒ–
 */
public boolean addAll(Collection<? extends E> c) {
    boolean modified = false;
    for (E e : c) {
        if (add(e)) {
            modified = true;
        }
    }
    return modified;
}

// ç¤ºä¾‹ï¼šåˆå¹¶ä¸¤ä¸ªé›†åˆ
Set<String> set1 = new HashSet<>(Arrays.asList("a", "b"));
Set<String> set2 = new HashSet<>(Arrays.asList("b", "c"));
set1.addAll(set2);
// set1 = ["a", "b", "c"]
```

---

## åˆ é™¤å…ƒç´ 

### remove(Object o)

```java
/**
 * åˆ é™¤æŒ‡å®šå…ƒç´ 
 * @return true-åˆ é™¤æˆåŠŸï¼Œfalse-å…ƒç´ ä¸å­˜åœ¨
 */
public boolean remove(Object o) {
    return map.remove(o) == PRESENT;
}

/**
 * æ‰§è¡Œæµç¨‹ï¼š
 * 1. è°ƒç”¨HashMap.remove(o)
 * 2. è®¡ç®—oçš„hashå€¼
 * 3. å®šä½æ¡¶ä½ç½®
 * 4. æŸ¥æ‰¾å¹¶åˆ é™¤èŠ‚ç‚¹
 * 5. è¿”å›è¢«åˆ é™¤çš„valueï¼ˆPRESENTæˆ–nullï¼‰
 */

// ç¤ºä¾‹
Set<String> set = new HashSet<>(Arrays.asList("a", "b", "c"));
set.remove("b");  // true
set.remove("d");  // falseï¼Œä¸å­˜åœ¨
```

### removeAll(Collection)

```java
/**
 * åˆ é™¤é›†åˆä¸­åŒ…å«çš„æ‰€æœ‰å…ƒç´ ï¼ˆå·®é›†ï¼‰
 */
public boolean removeAll(Collection<?> c) {
    Objects.requireNonNull(c);
    boolean modified = false;
    
    // ä¼˜åŒ–ï¼šéå†è¾ƒå°çš„é›†åˆ
    if (size() > c.size()) {
        for (Object e : c) {
            modified |= remove(e);
        }
    } else {
        for (Iterator<?> i = iterator(); i.hasNext(); ) {
            if (c.contains(i.next())) {
                i.remove();
                modified = true;
            }
        }
    }
    return modified;
}

// ç¤ºä¾‹
Set<String> set = new HashSet<>(Arrays.asList("a", "b", "c", "d"));
set.removeAll(Arrays.asList("b", "c"));
// set = ["a", "d"]
```

### retainAll(Collection)

```java
/**
 * åªä¿ç•™é›†åˆä¸­åŒ…å«çš„å…ƒç´ ï¼ˆäº¤é›†ï¼‰
 */
public boolean retainAll(Collection<?> c) {
    Objects.requireNonNull(c);
    boolean modified = false;
    Iterator<E> it = iterator();
    while (it.hasNext()) {
        if (!c.contains(it.next())) {
            it.remove();
            modified = true;
        }
    }
    return modified;
}

// ç¤ºä¾‹
Set<String> set = new HashSet<>(Arrays.asList("a", "b", "c", "d"));
set.retainAll(Arrays.asList("b", "c", "e"));
// set = ["b", "c"]
```

### clear()

```java
/**
 * æ¸…ç©ºæ‰€æœ‰å…ƒç´ 
 */
public void clear() {
    map.clear();
}
```

---

## æŸ¥è¯¢å…ƒç´ 

### contains(Object o)

```java
/**
 * åˆ¤æ–­æ˜¯å¦åŒ…å«æŒ‡å®šå…ƒç´ 
 * æ—¶é—´å¤æ‚åº¦ï¼šO(1)
 */
public boolean contains(Object o) {
    return map.containsKey(o);
}

// ç¤ºä¾‹
Set<String> set = new HashSet<>(Arrays.asList("a", "b", "c"));
set.contains("b");  // true
set.contains("d");  // false
```

### size() / isEmpty()

```java
/**
 * è¿”å›å…ƒç´ æ•°é‡
 */
public int size() {
    return map.size();
}

/**
 * åˆ¤æ–­æ˜¯å¦ä¸ºç©º
 */
public boolean isEmpty() {
    return map.isEmpty();
}
```

---

## è¿­ä»£éå†

### iterator()

```java
/**
 * è¿”å›è¿­ä»£å™¨
 * å®é™…è¿”å›HashMapçš„keySetè¿­ä»£å™¨
 */
public Iterator<E> iterator() {
    return map.keySet().iterator();
}

// éå†æ–¹å¼1ï¼šå¢å¼ºforå¾ªç¯
for (String s : set) {
    System.out.println(s);
}

// éå†æ–¹å¼2ï¼šè¿­ä»£å™¨
Iterator<String> it = set.iterator();
while (it.hasNext()) {
    String s = it.next();
    if (s.equals("b")) {
        it.remove(); // å®‰å…¨åˆ é™¤
    }
}

// éå†æ–¹å¼3ï¼šforEachï¼ˆJava 8+ï¼‰
set.forEach(System.out::println);

// éå†æ–¹å¼4ï¼šStream
set.stream().filter(s -> s.length() > 1).forEach(System.out::println);
```

### Spliterator

```java
/**
 * è¿”å›å¯åˆ†å‰²è¿­ä»£å™¨ï¼ˆJava 8+ï¼‰
 * æ”¯æŒå¹¶è¡Œéå†
 */
public Spliterator<E> spliterator() {
    return new HashMap.KeySpliterator<>(map, 0, -1, 0, 0);
}

// å¹¶è¡Œå¤„ç†
set.parallelStream().forEach(System.out::println);
```

---

## é›†åˆè¿ç®—

### å¹¶é›†

```java
/**
 * å¹¶é›†ï¼šA âˆª B
 */
public static <E> Set<E> union(Set<E> a, Set<E> b) {
    Set<E> result = new HashSet<>(a);
    result.addAll(b);
    return result;
}

// ç¤ºä¾‹
Set<Integer> a = new HashSet<>(Arrays.asList(1, 2, 3));
Set<Integer> b = new HashSet<>(Arrays.asList(2, 3, 4));
Set<Integer> union = union(a, b);
// union = [1, 2, 3, 4]
```

### äº¤é›†

```java
/**
 * äº¤é›†ï¼šA âˆ© B
 */
public static <E> Set<E> intersection(Set<E> a, Set<E> b) {
    Set<E> result = new HashSet<>(a);
    result.retainAll(b);
    return result;
}

// ç¤ºä¾‹
Set<Integer> intersection = intersection(a, b);
// intersection = [2, 3]
```

### å·®é›†

```java
/**
 * å·®é›†ï¼šA - B
 */
public static <E> Set<E> difference(Set<E> a, Set<E> b) {
    Set<E> result = new HashSet<>(a);
    result.removeAll(b);
    return result;
}

// ç¤ºä¾‹
Set<Integer> difference = difference(a, b);
// difference = [1]
```

### å¯¹ç§°å·®é›†

```java
/**
 * å¯¹ç§°å·®é›†ï¼š(A - B) âˆª (B - A)
 */
public static <E> Set<E> symmetricDifference(Set<E> a, Set<E> b) {
    Set<E> result = new HashSet<>(a);
    for (E e : b) {
        if (!result.add(e)) {
            result.remove(e);
        }
    }
    return result;
}

// ç¤ºä¾‹
Set<Integer> symDiff = symmetricDifference(a, b);
// symDiff = [1, 4]
```

---

## é¢è¯•è¦ç‚¹

### 1. HashSetåº•å±‚å®ç°

```
Q: HashSetåº•å±‚æ˜¯å¦‚ä½•å®ç°çš„ï¼Ÿ

A:
HashSetåº•å±‚ä½¿ç”¨HashMapå®ç°ï¼š
- å…ƒç´ ä½œä¸ºHashMapçš„keyå­˜å‚¨
- valueç»Ÿä¸€ä½¿ç”¨PRESENTï¼ˆä¸€ä¸ªé™æ€Objectå¯¹è±¡ï¼‰
- åˆ©ç”¨HashMapçš„keyä¸é‡å¤ç‰¹æ€§å®ç°å»é‡

æ ¸å¿ƒä»£ç ï¼š
private transient HashMap<E,Object> map;
private static final Object PRESENT = new Object();

public boolean add(E e) {
    return map.put(e, PRESENT) == null;
}
```

### 2. HashSetå¦‚ä½•ä¿è¯ä¸é‡å¤

```
Q: HashSetå¦‚ä½•ä¿è¯å…ƒç´ ä¸é‡å¤ï¼Ÿ

A:
ä¾èµ–å…ƒç´ çš„hashCode()å’Œequals()æ–¹æ³•ï¼š

1. è®¡ç®—hashCodeç¡®å®šå­˜å‚¨ä½ç½®
2. å¦‚æœä½ç½®ä¸ºç©ºï¼Œç›´æ¥å­˜å‚¨
3. å¦‚æœä½ç½®ä¸ä¸ºç©ºï¼Œæ¯”è¾ƒhashCode
4. hashCodeç›¸åŒï¼Œå†è°ƒç”¨equalsæ¯”è¾ƒ
5. equalsè¿”å›trueï¼Œè®¤ä¸ºæ˜¯é‡å¤å…ƒç´ ï¼Œä¸å­˜å‚¨

åˆ¤æ–­æ¡ä»¶ï¼š
hash1 == hash2 && (key1 == key2 || key1.equals(key2))

æ³¨æ„ï¼š
- è‡ªå®šä¹‰å¯¹è±¡å¿…é¡»é‡å†™hashCodeå’Œequals
- ä¸¤ä¸ªæ–¹æ³•è¦ä¿æŒä¸€è‡´æ€§
```

### 3. HashSet vs HashMap

```
Q: HashSetå’ŒHashMapçš„åŒºåˆ«ï¼Ÿ

A:
| å¯¹æ¯”é¡¹ | HashSet | HashMap |
|--------|---------|---------|
| å®ç°æ¥å£ | Set | Map |
| å­˜å‚¨å†…å®¹ | å¯¹è±¡ | é”®å€¼å¯¹ |
| æ·»åŠ æ–¹æ³• | add(e) | put(k,v) |
| åº•å±‚å®ç° | HashMap | æ•°ç»„+é“¾è¡¨+çº¢é»‘æ ‘ |
| é‡å¤åˆ¤æ–­ | hashCode+equals | keyçš„hashCode+equals |

æœ¬è´¨ï¼šHashSetæ˜¯HashMapçš„ä¸€ä¸ªç‰¹ä¾‹ï¼Œåªä½¿ç”¨key
```

### 4. HashSet vs TreeSet

```
Q: HashSetå’ŒTreeSetçš„åŒºåˆ«ï¼Ÿ

A:
| å¯¹æ¯”é¡¹ | HashSet | TreeSet |
|--------|---------|---------|
| åº•å±‚ç»“æ„ | HashMap | TreeMapï¼ˆçº¢é»‘æ ‘ï¼‰ |
| æœ‰åºæ€§ | æ— åº | æœ‰åºï¼ˆè‡ªç„¶æ’åºæˆ–Comparatorï¼‰ |
| æ—¶é—´å¤æ‚åº¦ | O(1) | O(log n) |
| nullå…ƒç´  | å…è®¸ä¸€ä¸ª | ä¸å…è®¸ï¼ˆéœ€è¦æ¯”è¾ƒï¼‰ |
| çº¿ç¨‹å®‰å…¨ | å¦ | å¦ |

é€‰æ‹©å»ºè®®ï¼š
- éœ€è¦æ’åºï¼šTreeSet
- è¿½æ±‚æ€§èƒ½ï¼šHashSet
- éœ€è¦æ’å…¥é¡ºåºï¼šLinkedHashSet
```

### 5. HashSetçº¿ç¨‹å®‰å…¨

```
Q: HashSetçº¿ç¨‹å®‰å…¨å—ï¼Ÿå¦‚ä½•ä¿è¯çº¿ç¨‹å®‰å…¨ï¼Ÿ

A:
HashSetä¸æ˜¯çº¿ç¨‹å®‰å…¨çš„ã€‚

è§£å†³æ–¹æ¡ˆï¼š
1. Collections.synchronizedSet()
   Set<String> set = Collections.synchronizedSet(new HashSet<>());

2. CopyOnWriteArraySetï¼ˆè¯»å¤šå†™å°‘ï¼‰
   Set<String> set = new CopyOnWriteArraySet<>();

3. ConcurrentHashMap.newKeySet()ï¼ˆæ¨èï¼‰
   Set<String> set = ConcurrentHashMap.newKeySet();

4. æ‰‹åŠ¨åŠ é”
   synchronized (set) {
       set.add("a");
   }
```

### 6. ä¸ºä»€ä¹ˆPRESENTä¸ç”¨null

```
Q: HashSetçš„PRESENTä¸ºä»€ä¹ˆä¸ç”¨nullï¼Ÿ

A:
å› ä¸ºHashMap.put()çš„è¿”å›å€¼ï¼š
- keyä¸å­˜åœ¨æ—¶è¿”å›null
- keyå­˜åœ¨æ—¶è¿”å›æ—§value

å¦‚æœvalueç”¨nullï¼š
- putè¿”å›nullæ— æ³•åŒºåˆ†æ˜¯"æ–°å¢"è¿˜æ˜¯"å·²å­˜åœ¨"

ä½¿ç”¨PRESENTï¼š
- putè¿”å›null â†’ æ–°å¢æˆåŠŸ â†’ addè¿”å›true
- putè¿”å›PRESENT â†’ å·²å­˜åœ¨ â†’ addè¿”å›false

ä»£ç éªŒè¯ï¼š
public boolean add(E e) {
    return map.put(e, PRESENT) == null;
}
```

---

## ğŸ’¡ æ€»ç»“

```
HashSetæ ¸å¿ƒè¦ç‚¹ï¼š

1. åº•å±‚å®ç°ï¼š
   - åŸºäºHashMap
   - å…ƒç´ ä½œä¸ºkeyï¼Œvalueç”¨PRESENTå ä½
   - åˆ©ç”¨HashMapçš„keyä¸é‡å¤ç‰¹æ€§

2. ç‰¹ç‚¹ï¼š
   - æ— åº
   - ä¸é‡å¤
   - å…è®¸nullï¼ˆæœ€å¤šä¸€ä¸ªï¼‰
   - éçº¿ç¨‹å®‰å…¨

3. æ—¶é—´å¤æ‚åº¦ï¼š
   - add: O(1)
   - remove: O(1)
   - contains: O(1)

4. å»é‡åŸç†ï¼š
   - hashCode() + equals()
   - è‡ªå®šä¹‰å¯¹è±¡å¿…é¡»é‡å†™è¿™ä¸¤ä¸ªæ–¹æ³•

5. ä½¿ç”¨åœºæ™¯ï¼š
   - å»é‡
   - å¿«é€ŸæŸ¥æ‰¾
   - é›†åˆè¿ç®—ï¼ˆå¹¶é›†ã€äº¤é›†ã€å·®é›†ï¼‰
```

---

*æœ€åæ›´æ–°ï¼š2025-12-28*

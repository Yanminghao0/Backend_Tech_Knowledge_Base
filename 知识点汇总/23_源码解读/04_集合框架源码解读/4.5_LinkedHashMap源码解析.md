# LinkedHashMapæºç è§£æ

> æœ‰åºHashMapï¼Œæ”¯æŒæ’å…¥é¡ºåºå’Œè®¿é—®é¡ºåºï¼ŒLRUç¼“å­˜å®ç°åŸºç¡€

## ğŸ“‹ ç›®å½•
- [æ•´ä½“ç»“æ„](#æ•´ä½“ç»“æ„)
- [æ ¸å¿ƒå±æ€§](#æ ¸å¿ƒå±æ€§)
- [èŠ‚ç‚¹ç»“æ„](#èŠ‚ç‚¹ç»“æ„)
- [æ„é€ æ–¹æ³•](#æ„é€ æ–¹æ³•)
- [æ·»åŠ å…ƒç´ ](#æ·»åŠ å…ƒç´ )
- [è®¿é—®å…ƒç´ ](#è®¿é—®å…ƒç´ )
- [åˆ é™¤å…ƒç´ ](#åˆ é™¤å…ƒç´ )
- [LRUç¼“å­˜å®ç°](#lruç¼“å­˜å®ç°)
- [é¢è¯•è¦ç‚¹](#é¢è¯•è¦ç‚¹)

---

## æ•´ä½“ç»“æ„

### ç±»å®šä¹‰

```java
public class LinkedHashMap<K,V>
    extends HashMap<K,V>
    implements Map<K,V> {
    
    // åŒå‘é“¾è¡¨å¤´èŠ‚ç‚¹
    transient LinkedHashMap.Entry<K,V> head;
    
    // åŒå‘é“¾è¡¨å°¾èŠ‚ç‚¹
    transient LinkedHashMap.Entry<K,V> tail;
    
    // è¿­ä»£é¡ºåºï¼štrue-è®¿é—®é¡ºåºï¼Œfalse-æ’å…¥é¡ºåºï¼ˆé»˜è®¤ï¼‰
    final boolean accessOrder;
}

/**
 * å…³é”®ç‚¹ï¼š
 * 1. ç»§æ‰¿HashMapï¼Œå¤ç”¨HashMapçš„å­˜å‚¨ç»“æ„
 * 2. é¢å¤–ç»´æŠ¤ä¸€ä¸ªåŒå‘é“¾è¡¨ï¼Œè®°å½•é¡ºåº
 * 3. accessOrderæ§åˆ¶æ˜¯æ’å…¥é¡ºåºè¿˜æ˜¯è®¿é—®é¡ºåº
 */
```

### ç»§æ‰¿ä½“ç³»

```
HashMap<K,V>
â””â”€â”€ LinkedHashMap<K,V>

ç‰¹ç‚¹ï¼š
- æœ‰åºï¼ˆæ’å…¥é¡ºåºæˆ–è®¿é—®é¡ºåºï¼‰
- å…è®¸nullé”®å’Œnullå€¼
- éçº¿ç¨‹å®‰å…¨
- å¯ç”¨äºå®ç°LRUç¼“å­˜
```

### æ•°æ®ç»“æ„ç¤ºæ„å›¾

```
HashMapç»“æ„ï¼ˆæ•°ç»„+é“¾è¡¨/çº¢é»‘æ ‘ï¼‰ï¼š
â”Œâ”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”
â”‚ 0 â”‚ 1 â”‚ 2 â”‚ 3 â”‚ 4 â”‚ 5 â”‚ 6 â”‚ 7 â”‚
â””â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”˜
  â”‚       â”‚           â”‚
  â–¼       â–¼           â–¼
 [A]     [B]         [C]
  â”‚       â”‚
  â–¼       â–¼
 [D]     [E]

LinkedHashMapé¢å¤–çš„åŒå‘é“¾è¡¨ï¼š
head â†” [A] â†” [B] â†” [C] â†” [D] â†” [E] â†” tail
       (æŒ‰æ’å…¥é¡ºåºæˆ–è®¿é—®é¡ºåºæ’åˆ—)
```

---

## æ ¸å¿ƒå±æ€§

```java
/**
 * åŒå‘é“¾è¡¨å¤´èŠ‚ç‚¹ï¼ˆæœ€è€çš„å…ƒç´ ï¼‰
 */
transient LinkedHashMap.Entry<K,V> head;

/**
 * åŒå‘é“¾è¡¨å°¾èŠ‚ç‚¹ï¼ˆæœ€æ–°çš„å…ƒç´ ï¼‰
 */
transient LinkedHashMap.Entry<K,V> tail;

/**
 * è¿­ä»£é¡ºåºæ ‡å¿—
 * false: æ’å…¥é¡ºåºï¼ˆé»˜è®¤ï¼‰
 * true: è®¿é—®é¡ºåºï¼ˆç”¨äºLRUï¼‰
 */
final boolean accessOrder;
```

---

## èŠ‚ç‚¹ç»“æ„

### Entryå®šä¹‰

```java
/**
 * LinkedHashMapçš„èŠ‚ç‚¹ï¼Œç»§æ‰¿HashMap.Node
 * é¢å¤–å¢åŠ beforeå’ŒafteræŒ‡é’ˆå½¢æˆåŒå‘é“¾è¡¨
 */
static class Entry<K,V> extends HashMap.Node<K,V> {
    Entry<K,V> before;  // å‰é©±èŠ‚ç‚¹
    Entry<K,V> after;   // åç»§èŠ‚ç‚¹
    
    Entry(int hash, K key, V value, Node<K,V> next) {
        super(hash, key, value, next);
    }
}

/**
 * å¯¹æ¯”HashMap.Nodeï¼š
 * 
 * HashMap.Node:
 * - hash, key, value, nextï¼ˆå•é“¾è¡¨ï¼‰
 * 
 * LinkedHashMap.Entry:
 * - hash, key, value, nextï¼ˆç»§æ‰¿ï¼‰
 * - before, afterï¼ˆåŒå‘é“¾è¡¨ï¼‰
 */
```

### èŠ‚ç‚¹å…³ç³»ç¤ºæ„

```
HashMapä¸­çš„é“¾è¡¨å…³ç³»ï¼ˆnextæŒ‡é’ˆï¼‰ï¼š
bucket[i] â†’ Node1 â†’ Node2 â†’ Node3 â†’ null

LinkedHashMapä¸­çš„åŒå‘é“¾è¡¨å…³ç³»ï¼ˆbefore/afteræŒ‡é’ˆï¼‰ï¼š
head â†” Entry1 â†” Entry2 â†” Entry3 â†” tail

ä¸€ä¸ªEntryåŒæ—¶å­˜åœ¨äºï¼š
1. HashMapçš„æ¡¶é“¾è¡¨ä¸­ï¼ˆé€šè¿‡nextï¼‰
2. LinkedHashMapçš„åŒå‘é“¾è¡¨ä¸­ï¼ˆé€šè¿‡before/afterï¼‰
```

---

## æ„é€ æ–¹æ³•

### æ— å‚æ„é€ ï¼ˆæ’å…¥é¡ºåºï¼‰

```java
/**
 * åˆ›å»ºç©ºçš„LinkedHashMap
 * é»˜è®¤æ’å…¥é¡ºåº
 */
public LinkedHashMap() {
    super();
    accessOrder = false;
}

// ä½¿ç”¨ç¤ºä¾‹
Map<String, Integer> map = new LinkedHashMap<>();
map.put("a", 1);
map.put("b", 2);
map.put("c", 3);
// éå†é¡ºåºï¼ša, b, cï¼ˆæ’å…¥é¡ºåºï¼‰
```

### æŒ‡å®šå®¹é‡å’Œè´Ÿè½½å› å­

```java
public LinkedHashMap(int initialCapacity) {
    super(initialCapacity);
    accessOrder = false;
}

public LinkedHashMap(int initialCapacity, float loadFactor) {
    super(initialCapacity, loadFactor);
    accessOrder = false;
}
```

### æŒ‡å®šè®¿é—®é¡ºåºï¼ˆLRUå…³é”®ï¼‰

```java
/**
 * æŒ‡å®šè®¿é—®é¡ºåº
 * @param accessOrder true-è®¿é—®é¡ºåºï¼Œfalse-æ’å…¥é¡ºåº
 */
public LinkedHashMap(int initialCapacity,
                     float loadFactor,
                     boolean accessOrder) {
    super(initialCapacity, loadFactor);
    this.accessOrder = accessOrder;
}

// LRUç¼“å­˜ä½¿ç”¨ç¤ºä¾‹
Map<String, Integer> lruMap = new LinkedHashMap<>(16, 0.75f, true);
lruMap.put("a", 1);
lruMap.put("b", 2);
lruMap.put("c", 3);
lruMap.get("a");  // è®¿é—®aï¼Œaç§»åˆ°æœ«å°¾
// éå†é¡ºåºï¼šb, c, aï¼ˆè®¿é—®é¡ºåºï¼‰
```

### ä»Mapæ„é€ 

```java
public LinkedHashMap(Map<? extends K, ? extends V> m) {
    super();
    accessOrder = false;
    putMapEntries(m, false);
}
```

---

## æ·»åŠ å…ƒç´ 

### putæµç¨‹

```java
/**
 * LinkedHashMapæ²¡æœ‰é‡å†™putæ–¹æ³•
 * ä½¿ç”¨HashMapçš„putï¼Œä½†é‡å†™äº†ç›¸å…³å›è°ƒæ–¹æ³•
 */

// HashMap.put() ä¸­çš„å…³é”®ä»£ç 
final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) {
    // ... HashMapçš„puté€»è¾‘ ...
    
    // æ–°å»ºèŠ‚ç‚¹æ—¶è°ƒç”¨ï¼ˆLinkedHashMapé‡å†™ï¼‰
    tab[i] = newNode(hash, key, value, null);
    
    // putå®Œæˆåè°ƒç”¨ï¼ˆLinkedHashMapé‡å†™ï¼‰
    afterNodeInsertion(evict);
    
    // è®¿é—®èŠ‚ç‚¹åè°ƒç”¨ï¼ˆLinkedHashMapé‡å†™ï¼‰
    afterNodeAccess(e);
}
```

### newNode - åˆ›å»ºèŠ‚ç‚¹

```java
/**
 * é‡å†™newNodeï¼Œåˆ›å»ºLinkedHashMap.Entry
 * å¹¶å°†æ–°èŠ‚ç‚¹é“¾æ¥åˆ°åŒå‘é“¾è¡¨æœ«å°¾
 */
Node<K,V> newNode(int hash, K key, V value, Node<K,V> e) {
    LinkedHashMap.Entry<K,V> p =
        new LinkedHashMap.Entry<>(hash, key, value, e);
    linkNodeLast(p);  // é“¾æ¥åˆ°åŒå‘é“¾è¡¨æœ«å°¾
    return p;
}

/**
 * å°†èŠ‚ç‚¹é“¾æ¥åˆ°åŒå‘é“¾è¡¨æœ«å°¾
 */
private void linkNodeLast(LinkedHashMap.Entry<K,V> p) {
    LinkedHashMap.Entry<K,V> last = tail;
    tail = p;
    if (last == null) {
        head = p;
    } else {
        p.before = last;
        last.after = p;
    }
}

// ç¤ºæ„å›¾ï¼š
// æ·»åŠ å‰ï¼šhead â†” A â†” B â†” tail
// æ·»åŠ Cåï¼šhead â†” A â†” B â†” C â†” tail
```

### afterNodeInsertion - æ’å…¥åå›è°ƒ

```java
/**
 * æ’å…¥èŠ‚ç‚¹åçš„å›è°ƒ
 * å¯ç”¨äºå®ç°LRUç¼“å­˜çš„è‡ªåŠ¨æ·˜æ±°
 */
void afterNodeInsertion(boolean evict) {
    LinkedHashMap.Entry<K,V> first;
    // å¦‚æœéœ€è¦ç§»é™¤æœ€è€çš„å…ƒç´ 
    if (evict && (first = head) != null && removeEldestEntry(first)) {
        K key = first.key;
        removeNode(hash(key), key, null, false, true);
    }
}

/**
 * æ˜¯å¦ç§»é™¤æœ€è€çš„å…ƒç´ 
 * é»˜è®¤è¿”å›falseï¼Œå­ç±»å¯é‡å†™å®ç°LRU
 */
protected boolean removeEldestEntry(Map.Entry<K,V> eldest) {
    return false;
}
```

### afterNodeAccess - è®¿é—®åå›è°ƒ

```java
/**
 * è®¿é—®èŠ‚ç‚¹åçš„å›è°ƒ
 * å¦‚æœæ˜¯è®¿é—®é¡ºåºæ¨¡å¼ï¼Œå°†èŠ‚ç‚¹ç§»åˆ°æœ«å°¾
 */
void afterNodeAccess(Node<K,V> e) {
    LinkedHashMap.Entry<K,V> last;
    // è®¿é—®é¡ºåºæ¨¡å¼ && å½“å‰èŠ‚ç‚¹ä¸æ˜¯å°¾èŠ‚ç‚¹
    if (accessOrder && (last = tail) != e) {
        LinkedHashMap.Entry<K,V> p =
            (LinkedHashMap.Entry<K,V>)e, b = p.before, a = p.after;
        p.after = null;
        
        // å¤„ç†å‰é©±
        if (b == null)
            head = a;
        else
            b.after = a;
        
        // å¤„ç†åç»§
        if (a != null)
            a.before = b;
        else
            last = b;
        
        // ç§»åˆ°æœ«å°¾
        if (last == null)
            head = p;
        else {
            p.before = last;
            last.after = p;
        }
        tail = p;
        ++modCount;
    }
}

// ç¤ºæ„å›¾ï¼ˆè®¿é—®Bï¼‰ï¼š
// è®¿é—®å‰ï¼šhead â†” A â†” B â†” C â†” tail
// è®¿é—®åï¼šhead â†” A â†” C â†” B â†” tail
```

---

## è®¿é—®å…ƒç´ 

### getæ–¹æ³•

```java
/**
 * è·å–å…ƒç´ 
 * å¦‚æœæ˜¯è®¿é—®é¡ºåºæ¨¡å¼ï¼Œä¼šå°†è®¿é—®çš„èŠ‚ç‚¹ç§»åˆ°æœ«å°¾
 */
public V get(Object key) {
    Node<K,V> e;
    if ((e = getNode(hash(key), key)) == null)
        return null;
    if (accessOrder)
        afterNodeAccess(e);  // ç§»åˆ°æœ«å°¾
    return e.value;
}

// ç¤ºä¾‹ï¼ˆè®¿é—®é¡ºåºæ¨¡å¼ï¼‰
Map<String, Integer> map = new LinkedHashMap<>(16, 0.75f, true);
map.put("a", 1);
map.put("b", 2);
map.put("c", 3);
// é¡ºåºï¼ša, b, c

map.get("a");
// é¡ºåºï¼šb, c, aï¼ˆaè¢«è®¿é—®ï¼Œç§»åˆ°æœ«å°¾ï¼‰

map.get("b");
// é¡ºåºï¼šc, a, bï¼ˆbè¢«è®¿é—®ï¼Œç§»åˆ°æœ«å°¾ï¼‰
```

### getOrDefault

```java
public V getOrDefault(Object key, V defaultValue) {
    Node<K,V> e;
    if ((e = getNode(hash(key), key)) == null)
        return defaultValue;
    if (accessOrder)
        afterNodeAccess(e);
    return e.value;
}
```

---

## åˆ é™¤å…ƒç´ 

### afterNodeRemoval - åˆ é™¤åå›è°ƒ

```java
/**
 * åˆ é™¤èŠ‚ç‚¹åçš„å›è°ƒ
 * ä»åŒå‘é“¾è¡¨ä¸­ç§»é™¤èŠ‚ç‚¹
 */
void afterNodeRemoval(Node<K,V> e) {
    LinkedHashMap.Entry<K,V> p =
        (LinkedHashMap.Entry<K,V>)e, b = p.before, a = p.after;
    p.before = p.after = null;
    
    // å¤„ç†å‰é©±
    if (b == null)
        head = a;
    else
        b.after = a;
    
    // å¤„ç†åç»§
    if (a == null)
        tail = b;
    else
        a.before = b;
}

// ç¤ºæ„å›¾ï¼ˆåˆ é™¤Bï¼‰ï¼š
// åˆ é™¤å‰ï¼šhead â†” A â†” B â†” C â†” tail
// åˆ é™¤åï¼šhead â†” A â†” C â†” tail
```

---

## éå†æ“ä½œ

### è¿­ä»£å™¨

```java
/**
 * LinkedHashMapçš„è¿­ä»£å™¨
 * æŒ‰åŒå‘é“¾è¡¨é¡ºåºéå†ï¼Œè€Œä¸æ˜¯æŒ‰æ¡¶é¡ºåº
 */
abstract class LinkedHashIterator {
    LinkedHashMap.Entry<K,V> next;
    LinkedHashMap.Entry<K,V> current;
    int expectedModCount;
    
    LinkedHashIterator() {
        next = head;  // ä»å¤´èŠ‚ç‚¹å¼€å§‹
        expectedModCount = modCount;
        current = null;
    }
    
    public final boolean hasNext() {
        return next != null;
    }
    
    final LinkedHashMap.Entry<K,V> nextNode() {
        LinkedHashMap.Entry<K,V> e = next;
        if (modCount != expectedModCount)
            throw new ConcurrentModificationException();
        if (e == null)
            throw new NoSuchElementException();
        current = e;
        next = e.after;  // æ²¿ç€åŒå‘é“¾è¡¨éå†
        return e;
    }
}

// éå†ç¤ºä¾‹
for (Map.Entry<String, Integer> entry : map.entrySet()) {
    System.out.println(entry.getKey() + "=" + entry.getValue());
}
// æŒ‰æ’å…¥é¡ºåºæˆ–è®¿é—®é¡ºåºè¾“å‡º
```

---

## LRUç¼“å­˜å®ç°

### åŸºæœ¬LRUç¼“å­˜

```java
/**
 * åŸºäºLinkedHashMapå®ç°LRUç¼“å­˜
 */
public class LRUCache<K, V> extends LinkedHashMap<K, V> {
    private final int maxCapacity;
    
    public LRUCache(int maxCapacity) {
        // è®¿é—®é¡ºåºæ¨¡å¼
        super(maxCapacity, 0.75f, true);
        this.maxCapacity = maxCapacity;
    }
    
    /**
     * é‡å†™removeEldestEntry
     * å½“å…ƒç´ æ•°é‡è¶…è¿‡æœ€å¤§å®¹é‡æ—¶ï¼Œç§»é™¤æœ€è€çš„å…ƒç´ 
     */
    @Override
    protected boolean removeEldestEntry(Map.Entry<K, V> eldest) {
        return size() > maxCapacity;
    }
}

// ä½¿ç”¨ç¤ºä¾‹
LRUCache<String, Integer> cache = new LRUCache<>(3);
cache.put("a", 1);
cache.put("b", 2);
cache.put("c", 3);
// ç¼“å­˜ï¼ša, b, c

cache.get("a");
// ç¼“å­˜ï¼šb, c, aï¼ˆaè¢«è®¿é—®ï¼Œç§»åˆ°æœ«å°¾ï¼‰

cache.put("d", 4);
// ç¼“å­˜ï¼šc, a, dï¼ˆbæ˜¯æœ€è€çš„ï¼Œè¢«æ·˜æ±°ï¼‰
```

### çº¿ç¨‹å®‰å…¨çš„LRUç¼“å­˜

```java
/**
 * çº¿ç¨‹å®‰å…¨çš„LRUç¼“å­˜
 */
public class ConcurrentLRUCache<K, V> {
    private final int maxCapacity;
    private final LinkedHashMap<K, V> cache;
    private final ReentrantLock lock = new ReentrantLock();
    
    public ConcurrentLRUCache(int maxCapacity) {
        this.maxCapacity = maxCapacity;
        this.cache = new LinkedHashMap<K, V>(maxCapacity, 0.75f, true) {
            @Override
            protected boolean removeEldestEntry(Map.Entry<K, V> eldest) {
                return size() > ConcurrentLRUCache.this.maxCapacity;
            }
        };
    }
    
    public V get(K key) {
        lock.lock();
        try {
            return cache.get(key);
        } finally {
            lock.unlock();
        }
    }
    
    public void put(K key, V value) {
        lock.lock();
        try {
            cache.put(key, value);
        } finally {
            lock.unlock();
        }
    }
    
    public V remove(K key) {
        lock.lock();
        try {
            return cache.remove(key);
        } finally {
            lock.unlock();
        }
    }
    
    public int size() {
        lock.lock();
        try {
            return cache.size();
        } finally {
            lock.unlock();
        }
    }
}
```

### å¸¦è¿‡æœŸæ—¶é—´çš„LRUç¼“å­˜

```java
/**
 * å¸¦è¿‡æœŸæ—¶é—´çš„LRUç¼“å­˜
 */
public class ExpirableLRUCache<K, V> {
    private final int maxCapacity;
    private final long expireTime;
    private final LinkedHashMap<K, CacheEntry<V>> cache;
    
    static class CacheEntry<V> {
        V value;
        long createTime;
        
        CacheEntry(V value) {
            this.value = value;
            this.createTime = System.currentTimeMillis();
        }
        
        boolean isExpired(long expireTime) {
            return System.currentTimeMillis() - createTime > expireTime;
        }
    }
    
    public ExpirableLRUCache(int maxCapacity, long expireTimeMs) {
        this.maxCapacity = maxCapacity;
        this.expireTime = expireTimeMs;
        this.cache = new LinkedHashMap<K, CacheEntry<V>>(maxCapacity, 0.75f, true) {
            @Override
            protected boolean removeEldestEntry(Map.Entry<K, CacheEntry<V>> eldest) {
                return size() > ExpirableLRUCache.this.maxCapacity;
            }
        };
    }
    
    public V get(K key) {
        CacheEntry<V> entry = cache.get(key);
        if (entry == null) {
            return null;
        }
        if (entry.isExpired(expireTime)) {
            cache.remove(key);
            return null;
        }
        return entry.value;
    }
    
    public void put(K key, V value) {
        cache.put(key, new CacheEntry<>(value));
    }
}
```

---

## é¢è¯•è¦ç‚¹

### 1. LinkedHashMap vs HashMap

```
Q: LinkedHashMapå’ŒHashMapçš„åŒºåˆ«ï¼Ÿ

A:
| å¯¹æ¯”é¡¹ | HashMap | LinkedHashMap |
|--------|---------|---------------|
| æœ‰åºæ€§ | æ— åº | æœ‰åºï¼ˆæ’å…¥/è®¿é—®é¡ºåºï¼‰ |
| æ•°æ®ç»“æ„ | æ•°ç»„+é“¾è¡¨+çº¢é»‘æ ‘ | HashMap + åŒå‘é“¾è¡¨ |
| å†…å­˜å ç”¨ | è¾ƒå°‘ | è¾ƒå¤šï¼ˆé¢å¤–çš„before/afteræŒ‡é’ˆï¼‰ |
| æ€§èƒ½ | ç•¥å¿« | ç•¥æ…¢ï¼ˆç»´æŠ¤åŒå‘é“¾è¡¨ï¼‰ |
| åº”ç”¨åœºæ™¯ | æ™®é€šMap | éœ€è¦é¡ºåºã€LRUç¼“å­˜ |

LinkedHashMapç»§æ‰¿HashMapï¼Œé¢å¤–ç»´æŠ¤åŒå‘é“¾è¡¨è®°å½•é¡ºåº
```

### 2. å¦‚ä½•å®ç°LRUç¼“å­˜

```
Q: å¦‚ä½•ç”¨LinkedHashMapå®ç°LRUç¼“å­˜ï¼Ÿ

A:
ä¸¤ä¸ªå…³é”®ç‚¹ï¼š
1. æ„é€ æ—¶è®¾ç½®accessOrder=trueï¼ˆè®¿é—®é¡ºåºæ¨¡å¼ï¼‰
2. é‡å†™removeEldestEntryæ–¹æ³•

public class LRUCache<K, V> extends LinkedHashMap<K, V> {
    private final int maxCapacity;
    
    public LRUCache(int maxCapacity) {
        super(maxCapacity, 0.75f, true); // è®¿é—®é¡ºåº
        this.maxCapacity = maxCapacity;
    }
    
    @Override
    protected boolean removeEldestEntry(Map.Entry<K, V> eldest) {
        return size() > maxCapacity; // è¶…è¿‡å®¹é‡æ—¶ç§»é™¤æœ€è€å…ƒç´ 
    }
}

åŸç†ï¼š
- accessOrder=trueï¼šæ¯æ¬¡get/putéƒ½ä¼šå°†å…ƒç´ ç§»åˆ°æœ«å°¾
- æœ€è€çš„å…ƒç´ åœ¨headï¼Œæœ€æ–°çš„åœ¨tail
- è¶…è¿‡å®¹é‡æ—¶ç§»é™¤headå…ƒç´ 
```

### 3. accessOrderçš„ä½œç”¨

```
Q: LinkedHashMapçš„accessOrderå‚æ•°æœ‰ä»€ä¹ˆä½œç”¨ï¼Ÿ

A:
accessOrderæ§åˆ¶è¿­ä»£é¡ºåºï¼š

falseï¼ˆé»˜è®¤ï¼‰- æ’å…¥é¡ºåºï¼š
- å…ƒç´ æŒ‰putçš„é¡ºåºæ’åˆ—
- getæ“ä½œä¸æ”¹å˜é¡ºåº

true - è®¿é—®é¡ºåºï¼š
- æ¯æ¬¡get/putéƒ½ä¼šå°†å…ƒç´ ç§»åˆ°æœ«å°¾
- æœ€è¿‘è®¿é—®çš„åœ¨æœ«å°¾ï¼Œæœ€ä¹…æœªè®¿é—®çš„åœ¨å¤´éƒ¨
- ç”¨äºå®ç°LRUç¼“å­˜

ç¤ºä¾‹ï¼š
Map<String, Integer> map = new LinkedHashMap<>(16, 0.75f, true);
map.put("a", 1);
map.put("b", 2);
map.put("c", 3);
// é¡ºåºï¼ša, b, c

map.get("a");
// é¡ºåºï¼šb, c, aï¼ˆaç§»åˆ°æœ«å°¾ï¼‰
```

### 4. åŒå‘é“¾è¡¨çš„ä½œç”¨

```
Q: LinkedHashMapä¸ºä»€ä¹ˆè¦ç»´æŠ¤åŒå‘é“¾è¡¨ï¼Ÿ

A:
1. ä¿è¯éå†é¡ºåºï¼š
   - HashMapéå†æ˜¯æŒ‰æ¡¶é¡ºåºï¼Œä¸æ˜¯æ’å…¥é¡ºåº
   - åŒå‘é“¾è¡¨è®°å½•äº†æ’å…¥/è®¿é—®é¡ºåº

2. æ”¯æŒLRUï¼š
   - è®¿é—®é¡ºåºæ¨¡å¼ä¸‹ï¼Œéœ€è¦å¿«é€Ÿå°†èŠ‚ç‚¹ç§»åˆ°æœ«å°¾
   - åŒå‘é“¾è¡¨å¯ä»¥O(1)å®ŒæˆèŠ‚ç‚¹ç§»åŠ¨

3. é«˜æ•ˆåˆ é™¤ï¼š
   - åˆ é™¤èŠ‚ç‚¹æ—¶éœ€è¦ä¿®æ”¹å‰åèŠ‚ç‚¹çš„æŒ‡é’ˆ
   - åŒå‘é“¾è¡¨å¯ä»¥O(1)å®Œæˆ

ç»“æ„ï¼š
EntryåŒæ—¶å­˜åœ¨äºï¼š
- HashMapçš„æ¡¶é“¾è¡¨ï¼ˆnextæŒ‡é’ˆï¼‰
- LinkedHashMapçš„åŒå‘é“¾è¡¨ï¼ˆbefore/afteræŒ‡é’ˆï¼‰
```

### 5. removeEldestEntryæ–¹æ³•

```
Q: removeEldestEntryæ–¹æ³•ä»€ä¹ˆæ—¶å€™è¢«è°ƒç”¨ï¼Ÿ

A:
åœ¨æ¯æ¬¡putæ“ä½œåè¢«è°ƒç”¨ï¼š

void afterNodeInsertion(boolean evict) {
    LinkedHashMap.Entry<K,V> first;
    if (evict && (first = head) != null && removeEldestEntry(first)) {
        K key = first.key;
        removeNode(hash(key), key, null, false, true);
    }
}

é»˜è®¤è¿”å›falseï¼Œä¸åˆ é™¤ä»»ä½•å…ƒç´ ã€‚
é‡å†™æ­¤æ–¹æ³•å¯ä»¥å®ç°ï¼š
- LRUç¼“å­˜ï¼ˆè¶…è¿‡å®¹é‡æ—¶åˆ é™¤ï¼‰
- å®šæ—¶æ¸…ç†ï¼ˆæ ¹æ®æ—¶é—´åˆ¤æ–­ï¼‰
- æ¡ä»¶åˆ é™¤ï¼ˆæ ¹æ®ä¸šåŠ¡é€»è¾‘åˆ¤æ–­ï¼‰
```

---

## ğŸ’¡ æ€»ç»“

```
LinkedHashMapæ ¸å¿ƒè¦ç‚¹ï¼š

1. æ•°æ®ç»“æ„ï¼š
   - ç»§æ‰¿HashMap
   - é¢å¤–ç»´æŠ¤åŒå‘é“¾è¡¨
   - Entryå¢åŠ before/afteræŒ‡é’ˆ

2. ä¸¤ç§é¡ºåºæ¨¡å¼ï¼š
   - æ’å…¥é¡ºåºï¼ˆé»˜è®¤ï¼‰ï¼šaccessOrder=false
   - è®¿é—®é¡ºåºï¼šaccessOrder=true

3. å…³é”®å›è°ƒæ–¹æ³•ï¼š
   - afterNodeAccessï¼šè®¿é—®åç§»åˆ°æœ«å°¾
   - afterNodeInsertionï¼šæ’å…¥ååˆ¤æ–­æ˜¯å¦åˆ é™¤æœ€è€å…ƒç´ 
   - afterNodeRemovalï¼šåˆ é™¤åä»é“¾è¡¨ç§»é™¤

4. LRUç¼“å­˜å®ç°ï¼š
   - accessOrder=true
   - é‡å†™removeEldestEntry
   - è¶…è¿‡å®¹é‡æ—¶è¿”å›true

5. æ€§èƒ½ï¼š
   - æ¯”HashMapç•¥æ…¢ï¼ˆç»´æŠ¤åŒå‘é“¾è¡¨ï¼‰
   - å†…å­˜å ç”¨æ›´å¤šï¼ˆé¢å¤–æŒ‡é’ˆï¼‰
   - éå†æ›´å¿«ï¼ˆç›´æ¥éå†é“¾è¡¨ï¼‰

6. ä½¿ç”¨åœºæ™¯ï¼š
   - éœ€è¦ä¿æŒæ’å…¥é¡ºåº
   - å®ç°LRUç¼“å­˜
   - éœ€è¦æŒ‰è®¿é—®é¡ºåºéå†
```

---

*æœ€åæ›´æ–°ï¼š2025-12-28*

# TreeMapæºç è§£æ

> çº¢é»‘æ ‘å®ç°çš„æœ‰åºMapæ·±åº¦è§£æ

## ğŸ“‹ ç›®å½•
- [æ•´ä½“ç»“æ„](#æ•´ä½“ç»“æ„)
- [çº¢é»‘æ ‘åŸºç¡€](#çº¢é»‘æ ‘åŸºç¡€)
- [æ ¸å¿ƒå±æ€§](#æ ¸å¿ƒå±æ€§)
- [æ·»åŠ å…ƒç´ ](#æ·»åŠ å…ƒç´ )
- [åˆ é™¤å…ƒç´ ](#åˆ é™¤å…ƒç´ )
- [æŸ¥è¯¢å…ƒç´ ](#æŸ¥è¯¢å…ƒç´ )
- [éå†æ“ä½œ](#éå†æ“ä½œ)
- [é¢è¯•è¦ç‚¹](#é¢è¯•è¦ç‚¹)

---

## æ•´ä½“ç»“æ„

### ç±»å®šä¹‰

```java
public class TreeMap<K,V>
    extends AbstractMap<K,V>
    implements NavigableMap<K,V>, Cloneable, java.io.Serializable {
    
    // æ¯”è¾ƒå™¨ï¼ˆå¯é€‰ï¼‰
    private final Comparator<? super K> comparator;
    
    // æ ¹èŠ‚ç‚¹
    private transient Entry<K,V> root;
    
    // å…ƒç´ æ•°é‡
    private transient int size = 0;
    
    // ä¿®æ”¹æ¬¡æ•°
    private transient int modCount = 0;
}

/**
 * å…³é”®æ¥å£ï¼š
 * - NavigableMapï¼šå¯¼èˆªæ–¹æ³•ï¼ˆceilingã€floorã€higherã€lowerï¼‰
 * - SortedMapï¼šæœ‰åºMap
 * - Cloneableï¼šå¯å…‹éš†
 * - Serializableï¼šå¯åºåˆ—åŒ–
 */
```

### èŠ‚ç‚¹ç»“æ„

```java
/**
 * çº¢é»‘æ ‘èŠ‚ç‚¹
 */
static final class Entry<K,V> implements Map.Entry<K,V> {
    K key;
    V value;
    Entry<K,V> left;     // å·¦å­èŠ‚ç‚¹
    Entry<K,V> right;    // å³å­èŠ‚ç‚¹
    Entry<K,V> parent;   // çˆ¶èŠ‚ç‚¹
    boolean color = BLACK; // é¢œè‰²ï¼ˆé»˜è®¤é»‘è‰²ï¼‰
    
    Entry(K key, V value, Entry<K,V> parent) {
        this.key = key;
        this.value = value;
        this.parent = parent;
    }
}
```

### ç‰¹ç‚¹

```
TreeMapç‰¹ç‚¹ï¼š
1. åº•å±‚æ˜¯çº¢é»‘æ ‘
2. æœ‰åºï¼ˆæŒ‰keyæ’åºï¼‰
3. å¢åˆ æ”¹æŸ¥O(log n)
4. éçº¿ç¨‹å®‰å…¨
5. keyä¸èƒ½ä¸ºnullï¼ˆéœ€è¦æ¯”è¾ƒï¼‰
6. valueå¯ä»¥ä¸ºnull
7. æ”¯æŒèŒƒå›´æŸ¥è¯¢
```

---

## çº¢é»‘æ ‘åŸºç¡€

### çº¢é»‘æ ‘æ€§è´¨

```
çº¢é»‘æ ‘äº”å¤§æ€§è´¨ï¼š
1. æ¯ä¸ªèŠ‚ç‚¹æ˜¯çº¢è‰²æˆ–é»‘è‰²
2. æ ¹èŠ‚ç‚¹æ˜¯é»‘è‰²
3. å¶å­èŠ‚ç‚¹ï¼ˆNILï¼‰æ˜¯é»‘è‰²
4. çº¢è‰²èŠ‚ç‚¹çš„å­èŠ‚ç‚¹å¿…é¡»æ˜¯é»‘è‰²ï¼ˆä¸èƒ½æœ‰è¿ç»­çº¢èŠ‚ç‚¹ï¼‰
5. ä»ä»»ä¸€èŠ‚ç‚¹åˆ°å…¶å¶å­çš„æ‰€æœ‰è·¯å¾„åŒ…å«ç›¸åŒæ•°é‡çš„é»‘è‰²èŠ‚ç‚¹

è¿™äº›æ€§è´¨ä¿è¯ï¼šæœ€é•¿è·¯å¾„ä¸è¶…è¿‡æœ€çŸ­è·¯å¾„çš„2å€
æ—¶é—´å¤æ‚åº¦ï¼šO(log n)
```

### é¢œè‰²å®šä¹‰

```java
private static final boolean RED   = false;
private static final boolean BLACK = true;

// è·å–é¢œè‰²
private static <K,V> boolean colorOf(Entry<K,V> p) {
    return (p == null ? BLACK : p.color);
}

// è®¾ç½®é¢œè‰²
private static <K,V> void setColor(Entry<K,V> p, boolean c) {
    if (p != null)
        p.color = c;
}
```

### æ—‹è½¬æ“ä½œ

```java
/**
 * å·¦æ—‹ï¼šå°†å³å­èŠ‚ç‚¹æå‡ä¸ºçˆ¶èŠ‚ç‚¹
 * 
 *     p                 r
 *    / \               / \
 *   L   r    =>       p   R
 *      / \           / \
 *     M   R         L   M
 */
private void rotateLeft(Entry<K,V> p) {
    if (p != null) {
        Entry<K,V> r = p.right;
        p.right = r.left;
        if (r.left != null)
            r.left.parent = p;
        r.parent = p.parent;
        if (p.parent == null)
            root = r;
        else if (p.parent.left == p)
            p.parent.left = r;
        else
            p.parent.right = r;
        r.left = p;
        p.parent = r;
    }
}

/**
 * å³æ—‹ï¼šå°†å·¦å­èŠ‚ç‚¹æå‡ä¸ºçˆ¶èŠ‚ç‚¹
 * 
 *       p             l
 *      / \           / \
 *     l   R   =>    L   p
 *    / \               / \
 *   L   M             M   R
 */
private void rotateRight(Entry<K,V> p) {
    if (p != null) {
        Entry<K,V> l = p.left;
        p.left = l.right;
        if (l.right != null)
            l.right.parent = p;
        l.parent = p.parent;
        if (p.parent == null)
            root = l;
        else if (p.parent.right == p)
            p.parent.right = l;
        else
            p.parent.left = l;
        l.right = p;
        p.parent = l;
    }
}
```

---

## æ ¸å¿ƒå±æ€§

```java
// æ¯”è¾ƒå™¨ï¼ˆnullè¡¨ç¤ºä½¿ç”¨è‡ªç„¶æ’åºï¼‰
private final Comparator<? super K> comparator;

// æ ¹èŠ‚ç‚¹
private transient Entry<K,V> root;

// å…ƒç´ æ•°é‡
private transient int size = 0;

// ä¿®æ”¹æ¬¡æ•°ï¼ˆfail-fastï¼‰
private transient int modCount = 0;
```

---

## æ·»åŠ å…ƒç´ 

### put(K key, V value)

```java
public V put(K key, V value) {
    Entry<K,V> t = root;
    
    // 1. ç©ºæ ‘ï¼Œç›´æ¥ä½œä¸ºæ ¹èŠ‚ç‚¹
    if (t == null) {
        compare(key, key); // ç±»å‹æ£€æŸ¥
        root = new Entry<>(key, value, null);
        size = 1;
        modCount++;
        return null;
    }
    
    int cmp;
    Entry<K,V> parent;
    Comparator<? super K> cpr = comparator;
    
    // 2. æŸ¥æ‰¾æ’å…¥ä½ç½®
    if (cpr != null) {
        // ä½¿ç”¨è‡ªå®šä¹‰æ¯”è¾ƒå™¨
        do {
            parent = t;
            cmp = cpr.compare(key, t.key);
            if (cmp < 0)
                t = t.left;
            else if (cmp > 0)
                t = t.right;
            else
                return t.setValue(value); // keyå·²å­˜åœ¨ï¼Œæ›´æ–°value
        } while (t != null);
    } else {
        // ä½¿ç”¨è‡ªç„¶æ’åº
        if (key == null)
            throw new NullPointerException();
        @SuppressWarnings("unchecked")
        Comparable<? super K> k = (Comparable<? super K>) key;
        do {
            parent = t;
            cmp = k.compareTo(t.key);
            if (cmp < 0)
                t = t.left;
            else if (cmp > 0)
                t = t.right;
            else
                return t.setValue(value);
        } while (t != null);
    }
    
    // 3. åˆ›å»ºæ–°èŠ‚ç‚¹
    Entry<K,V> e = new Entry<>(key, value, parent);
    if (cmp < 0)
        parent.left = e;
    else
        parent.right = e;
    
    // 4. æ’å…¥åä¿®å¤çº¢é»‘æ ‘
    fixAfterInsertion(e);
    size++;
    modCount++;
    return null;
}
```

### æ’å…¥ä¿®å¤

```java
/**
 * æ’å…¥åä¿®å¤çº¢é»‘æ ‘å¹³è¡¡
 * æ–°æ’å…¥èŠ‚ç‚¹é»˜è®¤ä¸ºçº¢è‰²
 */
private void fixAfterInsertion(Entry<K,V> x) {
    x.color = RED;  // æ–°èŠ‚ç‚¹è®¾ä¸ºçº¢è‰²
    
    // çˆ¶èŠ‚ç‚¹ä¸ºçº¢è‰²æ—¶éœ€è¦ä¿®å¤
    while (x != null && x != root && x.parent.color == RED) {
        if (parentOf(x) == leftOf(parentOf(parentOf(x)))) {
            // çˆ¶èŠ‚ç‚¹æ˜¯ç¥–çˆ¶çš„å·¦å­èŠ‚ç‚¹
            Entry<K,V> y = rightOf(parentOf(parentOf(x))); // å”å”èŠ‚ç‚¹
            
            if (colorOf(y) == RED) {
                // Case 1: å”å”æ˜¯çº¢è‰²
                // çˆ¶å’Œå”å˜é»‘ï¼Œç¥–çˆ¶å˜çº¢ï¼Œç»§ç»­å‘ä¸Š
                setColor(parentOf(x), BLACK);
                setColor(y, BLACK);
                setColor(parentOf(parentOf(x)), RED);
                x = parentOf(parentOf(x));
            } else {
                if (x == rightOf(parentOf(x))) {
                    // Case 2: å”å”æ˜¯é»‘è‰²ï¼Œxæ˜¯å³å­èŠ‚ç‚¹
                    // å·¦æ—‹çˆ¶èŠ‚ç‚¹ï¼Œè½¬ä¸ºCase 3
                    x = parentOf(x);
                    rotateLeft(x);
                }
                // Case 3: å”å”æ˜¯é»‘è‰²ï¼Œxæ˜¯å·¦å­èŠ‚ç‚¹
                // çˆ¶å˜é»‘ï¼Œç¥–çˆ¶å˜çº¢ï¼Œå³æ—‹ç¥–çˆ¶
                setColor(parentOf(x), BLACK);
                setColor(parentOf(parentOf(x)), RED);
                rotateRight(parentOf(parentOf(x)));
            }
        } else {
            // çˆ¶èŠ‚ç‚¹æ˜¯ç¥–çˆ¶çš„å³å­èŠ‚ç‚¹ï¼ˆé•œåƒæ“ä½œï¼‰
            Entry<K,V> y = leftOf(parentOf(parentOf(x)));
            
            if (colorOf(y) == RED) {
                setColor(parentOf(x), BLACK);
                setColor(y, BLACK);
                setColor(parentOf(parentOf(x)), RED);
                x = parentOf(parentOf(x));
            } else {
                if (x == leftOf(parentOf(x))) {
                    x = parentOf(x);
                    rotateRight(x);
                }
                setColor(parentOf(x), BLACK);
                setColor(parentOf(parentOf(x)), RED);
                rotateLeft(parentOf(parentOf(x)));
            }
        }
    }
    root.color = BLACK;  // æ ¹èŠ‚ç‚¹å§‹ç»ˆä¸ºé»‘è‰²
}
```

### æ’å…¥ä¿®å¤ç¤ºæ„å›¾

```
Case 1: å”å”æ˜¯çº¢è‰²
        G(B)                G(R)
       /   \               /   \
     P(R)  U(R)   =>     P(B)  U(B)
     /                   /
   X(R)                X(R)
   
   ç»§ç»­å‘ä¸Šæ£€æŸ¥G

Case 2: å”å”æ˜¯é»‘è‰²ï¼ŒXæ˜¯å³å­èŠ‚ç‚¹
        G(B)                G(B)
       /   \               /   \
     P(R)  U(B)   =>     X(R)  U(B)
       \                 /
       X(R)            P(R)
       
   å·¦æ—‹Pï¼Œè½¬ä¸ºCase 3

Case 3: å”å”æ˜¯é»‘è‰²ï¼ŒXæ˜¯å·¦å­èŠ‚ç‚¹
        G(B)                P(B)
       /   \               /   \
     P(R)  U(B)   =>     X(R)  G(R)
     /                           \
   X(R)                         U(B)
   
   å³æ—‹Gï¼Œå®Œæˆ
```

---

## åˆ é™¤å…ƒç´ 

### remove(Object key)

```java
public V remove(Object key) {
    Entry<K,V> p = getEntry(key);
    if (p == null)
        return null;
    
    V oldValue = p.value;
    deleteEntry(p);
    return oldValue;
}

/**
 * åˆ é™¤èŠ‚ç‚¹
 */
private void deleteEntry(Entry<K,V> p) {
    modCount++;
    size--;
    
    // 1. å¦‚æœæœ‰ä¸¤ä¸ªå­èŠ‚ç‚¹ï¼Œç”¨åç»§èŠ‚ç‚¹æ›¿æ¢
    if (p.left != null && p.right != null) {
        Entry<K,V> s = successor(p);  // æ‰¾åç»§
        p.key = s.key;
        p.value = s.value;
        p = s;  // è½¬ä¸ºåˆ é™¤åç»§èŠ‚ç‚¹
    }
    
    // 2. è·å–æ›¿æ¢èŠ‚ç‚¹
    Entry<K,V> replacement = (p.left != null ? p.left : p.right);
    
    if (replacement != null) {
        // 3a. æœ‰ä¸€ä¸ªå­èŠ‚ç‚¹
        replacement.parent = p.parent;
        if (p.parent == null)
            root = replacement;
        else if (p == p.parent.left)
            p.parent.left = replacement;
        else
            p.parent.right = replacement;
        
        p.left = p.right = p.parent = null;
        
        // åˆ é™¤é»‘è‰²èŠ‚ç‚¹éœ€è¦ä¿®å¤
        if (p.color == BLACK)
            fixAfterDeletion(replacement);
    } else if (p.parent == null) {
        // 3b. åˆ é™¤æ ¹èŠ‚ç‚¹
        root = null;
    } else {
        // 3c. æ²¡æœ‰å­èŠ‚ç‚¹
        if (p.color == BLACK)
            fixAfterDeletion(p);
        
        if (p.parent != null) {
            if (p == p.parent.left)
                p.parent.left = null;
            else if (p == p.parent.right)
                p.parent.right = null;
            p.parent = null;
        }
    }
}
```

### åˆ é™¤ä¿®å¤

```java
/**
 * åˆ é™¤åä¿®å¤çº¢é»‘æ ‘å¹³è¡¡
 */
private void fixAfterDeletion(Entry<K,V> x) {
    while (x != root && colorOf(x) == BLACK) {
        if (x == leftOf(parentOf(x))) {
            Entry<K,V> sib = rightOf(parentOf(x)); // å…„å¼ŸèŠ‚ç‚¹
            
            if (colorOf(sib) == RED) {
                // Case 1: å…„å¼Ÿæ˜¯çº¢è‰²
                setColor(sib, BLACK);
                setColor(parentOf(x), RED);
                rotateLeft(parentOf(x));
                sib = rightOf(parentOf(x));
            }
            
            if (colorOf(leftOf(sib)) == BLACK &&
                colorOf(rightOf(sib)) == BLACK) {
                // Case 2: å…„å¼Ÿçš„ä¸¤ä¸ªå­èŠ‚ç‚¹éƒ½æ˜¯é»‘è‰²
                setColor(sib, RED);
                x = parentOf(x);
            } else {
                if (colorOf(rightOf(sib)) == BLACK) {
                    // Case 3: å…„å¼Ÿçš„å³å­èŠ‚ç‚¹æ˜¯é»‘è‰²
                    setColor(leftOf(sib), BLACK);
                    setColor(sib, RED);
                    rotateRight(sib);
                    sib = rightOf(parentOf(x));
                }
                // Case 4: å…„å¼Ÿçš„å³å­èŠ‚ç‚¹æ˜¯çº¢è‰²
                setColor(sib, colorOf(parentOf(x)));
                setColor(parentOf(x), BLACK);
                setColor(rightOf(sib), BLACK);
                rotateLeft(parentOf(x));
                x = root;
            }
        } else {
            // é•œåƒæ“ä½œ
            Entry<K,V> sib = leftOf(parentOf(x));
            
            if (colorOf(sib) == RED) {
                setColor(sib, BLACK);
                setColor(parentOf(x), RED);
                rotateRight(parentOf(x));
                sib = leftOf(parentOf(x));
            }
            
            if (colorOf(rightOf(sib)) == BLACK &&
                colorOf(leftOf(sib)) == BLACK) {
                setColor(sib, RED);
                x = parentOf(x);
            } else {
                if (colorOf(leftOf(sib)) == BLACK) {
                    setColor(rightOf(sib), BLACK);
                    setColor(sib, RED);
                    rotateLeft(sib);
                    sib = leftOf(parentOf(x));
                }
                setColor(sib, colorOf(parentOf(x)));
                setColor(parentOf(x), BLACK);
                setColor(leftOf(sib), BLACK);
                rotateRight(parentOf(x));
                x = root;
            }
        }
    }
    setColor(x, BLACK);
}
```

---

## æŸ¥è¯¢å…ƒç´ 

### get(Object key)

```java
public V get(Object key) {
    Entry<K,V> p = getEntry(key);
    return (p == null ? null : p.value);
}

/**
 * æŸ¥æ‰¾èŠ‚ç‚¹ O(log n)
 */
final Entry<K,V> getEntry(Object key) {
    if (comparator != null)
        return getEntryUsingComparator(key);
    
    if (key == null)
        throw new NullPointerException();
    
    @SuppressWarnings("unchecked")
    Comparable<? super K> k = (Comparable<? super K>) key;
    Entry<K,V> p = root;
    
    while (p != null) {
        int cmp = k.compareTo(p.key);
        if (cmp < 0)
            p = p.left;
        else if (cmp > 0)
            p = p.right;
        else
            return p;
    }
    return null;
}
```

### å¯¼èˆªæ–¹æ³•

```java
/**
 * è¿”å›å¤§äºç­‰äºkeyçš„æœ€å°é”®
 */
public K ceilingKey(K key) {
    return keyOrNull(getCeilingEntry(key));
}

/**
 * è¿”å›å°äºç­‰äºkeyçš„æœ€å¤§é”®
 */
public K floorKey(K key) {
    return keyOrNull(getFloorEntry(key));
}

/**
 * è¿”å›ä¸¥æ ¼å¤§äºkeyçš„æœ€å°é”®
 */
public K higherKey(K key) {
    return keyOrNull(getHigherEntry(key));
}

/**
 * è¿”å›ä¸¥æ ¼å°äºkeyçš„æœ€å¤§é”®
 */
public K lowerKey(K key) {
    return keyOrNull(getLowerEntry(key));
}

// ç¤ºä¾‹
TreeMap<Integer, String> map = new TreeMap<>();
map.put(1, "A");
map.put(3, "C");
map.put(5, "E");

map.ceilingKey(2);  // 3ï¼ˆ>=2çš„æœ€å°ï¼‰
map.floorKey(4);    // 3ï¼ˆ<=4çš„æœ€å¤§ï¼‰
map.higherKey(3);   // 5ï¼ˆ>3çš„æœ€å°ï¼‰
map.lowerKey(3);    // 1ï¼ˆ<3çš„æœ€å¤§ï¼‰
```

### èŒƒå›´æŸ¥è¯¢

```java
/**
 * è¿”å›å­Mapï¼ˆfromKeyåˆ°toKeyï¼‰
 */
public NavigableMap<K,V> subMap(K fromKey, boolean fromInclusive,
                                 K toKey, boolean toInclusive) {
    return new AscendingSubMap<>(this,
                                 false, fromKey, fromInclusive,
                                 false, toKey, toInclusive);
}

/**
 * è¿”å›å°äºtoKeyçš„å­Map
 */
public NavigableMap<K,V> headMap(K toKey, boolean inclusive) {
    return new AscendingSubMap<>(this,
                                 true, null, true,
                                 false, toKey, inclusive);
}

/**
 * è¿”å›å¤§äºç­‰äºfromKeyçš„å­Map
 */
public NavigableMap<K,V> tailMap(K fromKey, boolean inclusive) {
    return new AscendingSubMap<>(this,
                                 false, fromKey, inclusive,
                                 true, null, true);
}

// ç¤ºä¾‹
TreeMap<Integer, String> map = new TreeMap<>();
// å‡è®¾mapåŒ…å« {1,2,3,4,5}

map.subMap(2, 4);      // {2, 3}ï¼ˆä¸å«4ï¼‰
map.subMap(2, true, 4, true);  // {2, 3, 4}
map.headMap(3);        // {1, 2}
map.tailMap(3);        // {3, 4, 5}
```

---

## éå†æ“ä½œ

### ä¸­åºéå†ï¼ˆæœ‰åºï¼‰

```java
/**
 * è·å–åç»§èŠ‚ç‚¹ï¼ˆä¸­åºéå†çš„ä¸‹ä¸€ä¸ªï¼‰
 */
static <K,V> Entry<K,V> successor(Entry<K,V> t) {
    if (t == null)
        return null;
    else if (t.right != null) {
        // æœ‰å³å­æ ‘ï¼Œæ‰¾å³å­æ ‘çš„æœ€å·¦èŠ‚ç‚¹
        Entry<K,V> p = t.right;
        while (p.left != null)
            p = p.left;
        return p;
    } else {
        // æ²¡æœ‰å³å­æ ‘ï¼Œå‘ä¸Šæ‰¾ç¬¬ä¸€ä¸ª"å·¦æ‹"çš„ç¥–å…ˆ
        Entry<K,V> p = t.parent;
        Entry<K,V> ch = t;
        while (p != null && ch == p.right) {
            ch = p;
            p = p.parent;
        }
        return p;
    }
}

/**
 * è·å–å‰é©±èŠ‚ç‚¹
 */
static <K,V> Entry<K,V> predecessor(Entry<K,V> t) {
    if (t == null)
        return null;
    else if (t.left != null) {
        Entry<K,V> p = t.left;
        while (p.right != null)
            p = p.right;
        return p;
    } else {
        Entry<K,V> p = t.parent;
        Entry<K,V> ch = t;
        while (p != null && ch == p.left) {
            ch = p;
            p = p.parent;
        }
        return p;
    }
}
```

### éå†æ–¹å¼

```java
TreeMap<Integer, String> map = new TreeMap<>();
map.put(3, "C");
map.put(1, "A");
map.put(2, "B");

// 1. keySetéå†ï¼ˆæœ‰åºï¼‰
for (Integer key : map.keySet()) {
    System.out.println(key);  // 1, 2, 3
}

// 2. entrySetéå†
for (Map.Entry<Integer, String> entry : map.entrySet()) {
    System.out.println(entry.getKey() + "=" + entry.getValue());
}

// 3. é€†åºéå†
for (Integer key : map.descendingKeySet()) {
    System.out.println(key);  // 3, 2, 1
}

// 4. è·å–ç¬¬ä¸€ä¸ªå’Œæœ€åä¸€ä¸ª
map.firstKey();   // 1
map.lastKey();    // 3
map.firstEntry(); // 1=A
map.lastEntry();  // 3=C
```

---

## é¢è¯•è¦ç‚¹

### 1. TreeMap vs HashMap

```
Q: TreeMapå’ŒHashMapçš„åŒºåˆ«ï¼Ÿ

A:
| å¯¹æ¯”é¡¹ | HashMap | TreeMap |
|--------|---------|---------|
| åº•å±‚ç»“æ„ | æ•°ç»„+é“¾è¡¨+çº¢é»‘æ ‘ | çº¢é»‘æ ‘ |
| æœ‰åºæ€§ | æ— åº | æŒ‰keyæ’åº |
| æ—¶é—´å¤æ‚åº¦ | O(1)å¹³å‡ | O(log n) |
| null key | å…è®¸1ä¸ª | ä¸å…è®¸ |
| çº¿ç¨‹å®‰å…¨ | å¦ | å¦ |
| å®ç°æ¥å£ | Map | NavigableMap |

ä½¿ç”¨åœºæ™¯ï¼š
- éœ€è¦æ’åºï¼šTreeMap
- éœ€è¦èŒƒå›´æŸ¥è¯¢ï¼šTreeMap
- è¿½æ±‚æ€§èƒ½ï¼šHashMap
```

### 2. çº¢é»‘æ ‘ä¸ºä»€ä¹ˆé«˜æ•ˆ

```
Q: çº¢é»‘æ ‘ä¸ºä»€ä¹ˆèƒ½ä¿è¯O(log n)ï¼Ÿ

A:
çº¢é»‘æ ‘é€šè¿‡5æ¡æ€§è´¨ä¿è¯å¹³è¡¡ï¼š
1. æœ€é•¿è·¯å¾„ä¸è¶…è¿‡æœ€çŸ­è·¯å¾„çš„2å€
2. æ ‘é«˜åº¦æœ€å¤š2log(n+1)

ä¸AVLæ ‘å¯¹æ¯”ï¼š
- AVLæ ‘ï¼šä¸¥æ ¼å¹³è¡¡ï¼ŒæŸ¥è¯¢æ›´å¿«
- çº¢é»‘æ ‘ï¼šè¿‘ä¼¼å¹³è¡¡ï¼Œæ’å…¥åˆ é™¤æ›´å¿«

çº¢é»‘æ ‘ä¼˜åŠ¿ï¼š
- æ’å…¥åˆ é™¤æœ€å¤š3æ¬¡æ—‹è½¬
- å®ç°ç›¸å¯¹ç®€å•
- ç»¼åˆæ€§èƒ½æ›´å¥½
```

### 3. TreeMapçš„keyè¦æ±‚

```
Q: TreeMapçš„keyæœ‰ä»€ä¹ˆè¦æ±‚ï¼Ÿ

A:
ä¸¤ç§æ–¹å¼ä¹‹ä¸€ï¼š
1. keyå®ç°Comparableæ¥å£
   class Person implements Comparable<Person> {
       public int compareTo(Person o) { ... }
   }

2. æ„é€ æ—¶ä¼ å…¥Comparator
   new TreeMap<>(Comparator.comparing(Person::getAge));

æ³¨æ„ï¼š
- keyä¸èƒ½ä¸ºnullï¼ˆéœ€è¦æ¯”è¾ƒï¼‰
- æ¯”è¾ƒç»“æœä¸º0è¡¨ç¤ºç›¸åŒkey
- æ¯”è¾ƒé€»è¾‘è¦ä¸equalsä¸€è‡´
```

### 4. çº¢é»‘æ ‘æ’å…¥ä¿®å¤

```
Q: çº¢é»‘æ ‘æ’å…¥åä¸ºä»€ä¹ˆè¦ä¿®å¤ï¼Ÿæ€ä¹ˆä¿®å¤ï¼Ÿ

A:
ä¸ºä»€ä¹ˆä¿®å¤ï¼š
- æ–°èŠ‚ç‚¹é»˜è®¤çº¢è‰²
- å¯èƒ½è¿å"ä¸èƒ½æœ‰è¿ç»­çº¢èŠ‚ç‚¹"

ä¿®å¤æƒ…å†µï¼š
Case 1: å”å”çº¢è‰²
  - çˆ¶å’Œå”å˜é»‘ï¼Œç¥–çˆ¶å˜çº¢
  - ç»§ç»­å‘ä¸Šæ£€æŸ¥

Case 2: å”å”é»‘è‰²ï¼Œå½“å‰æ˜¯å³å­èŠ‚ç‚¹
  - å·¦æ—‹çˆ¶èŠ‚ç‚¹
  - è½¬ä¸ºCase 3

Case 3: å”å”é»‘è‰²ï¼Œå½“å‰æ˜¯å·¦å­èŠ‚ç‚¹
  - çˆ¶å˜é»‘ï¼Œç¥–çˆ¶å˜çº¢
  - å³æ—‹ç¥–çˆ¶

æœ€å¤šO(log n)æ¬¡é¢œè‰²å˜æ¢ï¼Œ2æ¬¡æ—‹è½¬
```

### 5. TreeMapçº¿ç¨‹å®‰å…¨

```
Q: TreeMapçº¿ç¨‹å®‰å…¨å—ï¼Ÿå¦‚ä½•ä¿è¯ï¼Ÿ

A:
TreeMapä¸æ˜¯çº¿ç¨‹å®‰å…¨çš„ã€‚

è§£å†³æ–¹æ¡ˆï¼š
1. Collections.synchronizedSortedMap()
   SortedMap<K,V> m = Collections.synchronizedSortedMap(new TreeMap<>());

2. ConcurrentSkipListMapï¼ˆæ¨èï¼‰
   ConcurrentNavigableMap<K,V> map = new ConcurrentSkipListMap<>();
   - åŸºäºè·³è¡¨å®ç°
   - æ”¯æŒå¹¶å‘
   - æœ‰åº

3. æ‰‹åŠ¨åŠ é”
   synchronized (map) {
       map.put(key, value);
   }
```

---

## ğŸ’¡ æ€»ç»“

```
TreeMapæ ¸å¿ƒè¦ç‚¹ï¼š

1. åº•å±‚ç»“æ„ï¼š
   - çº¢é»‘æ ‘ï¼ˆè‡ªå¹³è¡¡äºŒå‰æœç´¢æ ‘ï¼‰
   - ä¿è¯O(log n)æ“ä½œ

2. æœ‰åºæ€§ï¼š
   - æŒ‰keyæ’åº
   - æ”¯æŒè‡ªç„¶æ’åºå’Œè‡ªå®šä¹‰æ¯”è¾ƒå™¨

3. ç‰¹æ®ŠåŠŸèƒ½ï¼š
   - èŒƒå›´æŸ¥è¯¢ï¼ˆsubMapã€headMapã€tailMapï¼‰
   - å¯¼èˆªæ–¹æ³•ï¼ˆceilingã€floorã€higherã€lowerï¼‰
   - è·å–é¦–å°¾å…ƒç´ 

4. æ³¨æ„äº‹é¡¹ï¼š
   - keyä¸èƒ½ä¸ºnull
   - éçº¿ç¨‹å®‰å…¨
   - æ¯”è¾ƒé€»è¾‘è¦ä¸equalsä¸€è‡´

5. é€‚ç”¨åœºæ™¯ï¼š
   - éœ€è¦æœ‰åºéå†
   - éœ€è¦èŒƒå›´æŸ¥è¯¢
   - éœ€è¦è·å–æœ€å¤§æœ€å°å€¼
```

---

*æœ€åæ›´æ–°ï¼š2025-12-28*

# Dubbo SPIæœºåˆ¶æºç è§£æ

> ğŸ’¡ æ·±å…¥ç†è§£Dubboæ‰©å±•ç‚¹åŠ è½½æœºåˆ¶ï¼ŒæŒæ¡æ¡†æ¶å¯æ‰©å±•æ€§è®¾è®¡

---

## ğŸ“š ç›®å½•

1. [SPIæœºåˆ¶æ¦‚è¿°](#1-spiæœºåˆ¶æ¦‚è¿°)
2. [ExtensionLoaderæ ¸å¿ƒ](#2-extensionloaderæ ¸å¿ƒ)
3. [è‡ªé€‚åº”æ‰©å±•](#3-è‡ªé€‚åº”æ‰©å±•)
4. [æ‰©å±•ç‚¹è£…é¥°](#4-æ‰©å±•ç‚¹è£…é¥°)
5. [æ‰©å±•ç‚¹è‡ªåŠ¨æ³¨å…¥](#5-æ‰©å±•ç‚¹è‡ªåŠ¨æ³¨å…¥)
6. [å®æˆ˜åº”ç”¨](#6-å®æˆ˜åº”ç”¨)
7. [é¢è¯•è¦ç‚¹](#7-é¢è¯•è¦ç‚¹)

---

## 1. SPIæœºåˆ¶æ¦‚è¿°

### 1.1 Java SPI vs Dubbo SPI

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  SPIæœºåˆ¶å¯¹æ¯”                                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                             â”‚
â”‚  Java SPIï¼š                                                 â”‚
â”‚  â”œâ”€â”€ é…ç½®æ–‡ä»¶ï¼šMETA-INF/services/æ¥å£å…¨é™å®šå               â”‚
â”‚  â”œâ”€â”€ åŠ è½½æ–¹å¼ï¼šä¸€æ¬¡æ€§åŠ è½½æ‰€æœ‰å®ç°                           â”‚
â”‚  â”œâ”€â”€ è·å–æ–¹å¼ï¼šåªèƒ½éå†è·å–                                 â”‚
â”‚  â””â”€â”€ ç¼ºç‚¹ï¼šæ— æ³•æŒ‰éœ€åŠ è½½ï¼Œä¸æ”¯æŒIOC/AOP                      â”‚
â”‚                                                             â”‚
â”‚  Dubbo SPIï¼š                                                â”‚
â”‚  â”œâ”€â”€ é…ç½®æ–‡ä»¶ï¼šMETA-INF/dubbo/æ¥å£å…¨é™å®šå                  â”‚
â”‚  â”œâ”€â”€ åŠ è½½æ–¹å¼ï¼šæŒ‰éœ€åŠ è½½ï¼ˆæ‡’åŠ è½½ï¼‰                           â”‚
â”‚  â”œâ”€â”€ è·å–æ–¹å¼ï¼šæŒ‰åç§°è·å–                                   â”‚
â”‚  â”œâ”€â”€ æ”¯æŒIOCï¼šè‡ªåŠ¨æ³¨å…¥ä¾èµ–                                  â”‚
â”‚  â”œâ”€â”€ æ”¯æŒAOPï¼šWrapperè£…é¥°                                   â”‚
â”‚  â””â”€â”€ è‡ªé€‚åº”æ‰©å±•ï¼šè¿è¡Œæ—¶åŠ¨æ€é€‰æ‹©å®ç°                         â”‚
â”‚                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 1.2 é…ç½®æ–‡ä»¶æ ¼å¼

```properties
# META-INF/dubbo/org.apache.dubbo.rpc.Protocol
dubbo=org.apache.dubbo.rpc.protocol.dubbo.DubboProtocol
http=org.apache.dubbo.rpc.protocol.http.HttpProtocol
hessian=org.apache.dubbo.rpc.protocol.hessian.HessianProtocol
rmi=org.apache.dubbo.rpc.protocol.rmi.RmiProtocol

# æ ¼å¼ï¼šname=å®ç°ç±»å…¨é™å®šå
# æ”¯æŒæŒ‰åç§°è·å–æŒ‡å®šå®ç°
```

### 1.3 æ ¸å¿ƒæ³¨è§£

```java
/**
 * @SPI - æ ‡è®°æ‰©å±•ç‚¹æ¥å£
 */
@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.TYPE})
public @interface SPI {
    String value() default "";  // é»˜è®¤æ‰©å±•å
}

/**
 * @Adaptive - è‡ªé€‚åº”æ‰©å±•
 */
@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.TYPE, ElementType.METHOD})
public @interface Adaptive {
    String[] value() default {};  // ä»URLä¸­è·å–æ‰©å±•åçš„key
}

/**
 * @Activate - è‡ªåŠ¨æ¿€æ´»æ‰©å±•
 */
@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.TYPE, ElementType.METHOD})
public @interface Activate {
    String[] group() default {};     // åˆ†ç»„
    String[] value() default {};     // URLä¸­çš„key
    int order() default 0;           // æ’åº
}
```


---

## 2. ExtensionLoaderæ ¸å¿ƒ

### 2.1 ç±»ç»“æ„

```java
/**
 * ExtensionLoader - æ‰©å±•ç‚¹åŠ è½½å™¨
 * Dubbo SPIçš„æ ¸å¿ƒå®ç°
 */
public class ExtensionLoader<T> {
    
    // æ‰©å±•ç‚¹é…ç½®æ–‡ä»¶ç›®å½•
    private static final String SERVICES_DIRECTORY = "META-INF/services/";
    private static final String DUBBO_DIRECTORY = "META-INF/dubbo/";
    private static final String DUBBO_INTERNAL_DIRECTORY = "META-INF/dubbo/internal/";
    
    // ğŸ”¥ ExtensionLoaderç¼“å­˜ï¼ˆæ¯ä¸ªæ‰©å±•ç‚¹æ¥å£ä¸€ä¸ªLoaderï¼‰
    private static final ConcurrentMap<Class<?>, ExtensionLoader<?>> EXTENSION_LOADERS = 
        new ConcurrentHashMap<>();
    
    // ğŸ”¥ æ‰©å±•ç‚¹å®ä¾‹ç¼“å­˜
    private static final ConcurrentMap<Class<?>, Object> EXTENSION_INSTANCES = 
        new ConcurrentHashMap<>();
    
    // æ‰©å±•ç‚¹æ¥å£
    private final Class<?> type;
    
    // å¯¹è±¡å·¥å‚ï¼ˆç”¨äºIOCæ³¨å…¥ï¼‰
    private final ExtensionFactory objectFactory;
    
    // æ‰©å±•ååˆ°å®ç°ç±»çš„æ˜ å°„
    private final ConcurrentMap<String, Holder<Object>> cachedInstances = 
        new ConcurrentHashMap<>();
    
    // å®ç°ç±»åˆ°æ‰©å±•åçš„æ˜ å°„
    private final ConcurrentMap<Class<?>, String> cachedNames = new ConcurrentHashMap<>();
    
    // æ‰©å±•ååˆ°å®ç°ç±»Classçš„æ˜ å°„
    private volatile Map<String, Class<?>> cachedClasses;
    
    // è‡ªé€‚åº”æ‰©å±•å®ä¾‹
    private final Holder<Object> cachedAdaptiveInstance = new Holder<>();
    
    // è‡ªé€‚åº”æ‰©å±•ç±»
    private volatile Class<?> cachedAdaptiveClass = null;
    
    // é»˜è®¤æ‰©å±•å
    private String cachedDefaultName;
    
    // Wrapperç±»é›†åˆ
    private Set<Class<?>> cachedWrapperClasses;
}
```

### 2.2 è·å–ExtensionLoader

```java
/**
 * è·å–æ‰©å±•ç‚¹åŠ è½½å™¨
 */
public static <T> ExtensionLoader<T> getExtensionLoader(Class<T> type) {
    if (type == null) {
        throw new IllegalArgumentException("Extension type == null");
    }
    
    // å¿…é¡»æ˜¯æ¥å£
    if (!type.isInterface()) {
        throw new IllegalArgumentException("Extension type (" + type + ") is not an interface!");
    }
    
    // å¿…é¡»æœ‰@SPIæ³¨è§£
    if (!withExtensionAnnotation(type)) {
        throw new IllegalArgumentException("Extension type (" + type +
            ") is not an extension, because it is NOT annotated with @SPI!");
    }
    
    // ğŸ”¥ ä»ç¼“å­˜è·å–æˆ–åˆ›å»º
    ExtensionLoader<T> loader = (ExtensionLoader<T>) EXTENSION_LOADERS.get(type);
    if (loader == null) {
        EXTENSION_LOADERS.putIfAbsent(type, new ExtensionLoader<T>(type));
        loader = (ExtensionLoader<T>) EXTENSION_LOADERS.get(type);
    }
    return loader;
}

/**
 * ç§æœ‰æ„é€ å‡½æ•°
 */
private ExtensionLoader(Class<?> type) {
    this.type = type;
    // è·å–ExtensionFactoryç”¨äºIOCæ³¨å…¥
    objectFactory = (type == ExtensionFactory.class ? null :
        ExtensionLoader.getExtensionLoader(ExtensionFactory.class).getAdaptiveExtension());
}
```

### 2.3 è·å–æ‰©å±•å®ä¾‹

```java
/**
 * ğŸ”¥ æ ¹æ®åç§°è·å–æ‰©å±•å®ä¾‹
 */
public T getExtension(String name) {
    if (StringUtils.isEmpty(name)) {
        throw new IllegalArgumentException("Extension name == null");
    }
    
    // è·å–é»˜è®¤æ‰©å±•
    if ("true".equals(name)) {
        return getDefaultExtension();
    }
    
    // ä»ç¼“å­˜è·å–Holder
    final Holder<Object> holder = getOrCreateHolder(name);
    Object instance = holder.get();
    
    // åŒé‡æ£€æŸ¥é”
    if (instance == null) {
        synchronized (holder) {
            instance = holder.get();
            if (instance == null) {
                // ğŸ”¥ åˆ›å»ºæ‰©å±•å®ä¾‹
                instance = createExtension(name);
                holder.set(instance);
            }
        }
    }
    return (T) instance;
}

/**
 * ğŸ”¥ åˆ›å»ºæ‰©å±•å®ä¾‹
 */
private T createExtension(String name) {
    // 1. è·å–æ‰©å±•ç±»
    Class<?> clazz = getExtensionClasses().get(name);
    if (clazz == null) {
        throw findException(name);
    }
    
    try {
        // 2. ä»ç¼“å­˜è·å–æˆ–åˆ›å»ºå®ä¾‹
        T instance = (T) EXTENSION_INSTANCES.get(clazz);
        if (instance == null) {
            EXTENSION_INSTANCES.putIfAbsent(clazz, clazz.newInstance());
            instance = (T) EXTENSION_INSTANCES.get(clazz);
        }
        
        // 3. ğŸ”¥ IOCæ³¨å…¥ä¾èµ–
        injectExtension(instance);
        
        // 4. ğŸ”¥ Wrapperè£…é¥°
        Set<Class<?>> wrapperClasses = cachedWrapperClasses;
        if (CollectionUtils.isNotEmpty(wrapperClasses)) {
            for (Class<?> wrapperClass : wrapperClasses) {
                // åˆ›å»ºWrapperå®ä¾‹ï¼Œå°†åŸå®ä¾‹ä½œä¸ºæ„é€ å‚æ•°
                instance = injectExtension(
                    (T) wrapperClass.getConstructor(type).newInstance(instance));
            }
        }
        
        // 5. åˆå§‹åŒ–
        initExtension(instance);
        
        return instance;
        
    } catch (Throwable t) {
        throw new IllegalStateException("Extension instance (name: " + name + 
            ", class: " + type + ") couldn't be instantiated: " + t.getMessage(), t);
    }
}
```

### 2.4 åŠ è½½æ‰©å±•ç±»

```java
/**
 * è·å–æ‰€æœ‰æ‰©å±•ç±»
 */
private Map<String, Class<?>> getExtensionClasses() {
    Map<String, Class<?>> classes = cachedClasses;
    if (classes == null) {
        synchronized (cachedClasses) {
            classes = cachedClasses;
            if (classes == null) {
                // ğŸ”¥ åŠ è½½æ‰©å±•ç±»
                classes = loadExtensionClasses();
                cachedClasses = classes;
            }
        }
    }
    return classes;
}

/**
 * ğŸ”¥ åŠ è½½æ‰©å±•ç±»
 */
private Map<String, Class<?>> loadExtensionClasses() {
    // è·å–é»˜è®¤æ‰©å±•å
    cacheDefaultExtensionName();
    
    Map<String, Class<?>> extensionClasses = new HashMap<>();
    
    // ä»å¤šä¸ªç›®å½•åŠ è½½
    loadDirectory(extensionClasses, DUBBO_INTERNAL_DIRECTORY, type.getName());
    loadDirectory(extensionClasses, DUBBO_INTERNAL_DIRECTORY, type.getName().replace("org.apache", "com.alibaba"));
    loadDirectory(extensionClasses, DUBBO_DIRECTORY, type.getName());
    loadDirectory(extensionClasses, DUBBO_DIRECTORY, type.getName().replace("org.apache", "com.alibaba"));
    loadDirectory(extensionClasses, SERVICES_DIRECTORY, type.getName());
    loadDirectory(extensionClasses, SERVICES_DIRECTORY, type.getName().replace("org.apache", "com.alibaba"));
    
    return extensionClasses;
}

/**
 * ä»ç›®å½•åŠ è½½æ‰©å±•ç±»
 */
private void loadDirectory(Map<String, Class<?>> extensionClasses, String dir, String type) {
    String fileName = dir + type;
    try {
        Enumeration<java.net.URL> urls;
        ClassLoader classLoader = findClassLoader();
        
        if (classLoader != null) {
            urls = classLoader.getResources(fileName);
        } else {
            urls = ClassLoader.getSystemResources(fileName);
        }
        
        if (urls != null) {
            while (urls.hasMoreElements()) {
                java.net.URL resourceURL = urls.nextElement();
                // ğŸ”¥ åŠ è½½èµ„æºæ–‡ä»¶
                loadResource(extensionClasses, classLoader, resourceURL);
            }
        }
    } catch (Throwable t) {
        logger.error("Exception occurred when loading extension class (interface: " +
            type + ", description file: " + fileName + ").", t);
    }
}

/**
 * åŠ è½½èµ„æºæ–‡ä»¶
 */
private void loadResource(Map<String, Class<?>> extensionClasses, 
        ClassLoader classLoader, java.net.URL resourceURL) {
    try {
        try (BufferedReader reader = new BufferedReader(
                new InputStreamReader(resourceURL.openStream(), StandardCharsets.UTF_8))) {
            String line;
            while ((line = reader.readLine()) != null) {
                // å»é™¤æ³¨é‡Š
                final int ci = line.indexOf('#');
                if (ci >= 0) {
                    line = line.substring(0, ci);
                }
                line = line.trim();
                if (line.length() > 0) {
                    try {
                        String name = null;
                        int i = line.indexOf('=');
                        if (i > 0) {
                            // name=classæ ¼å¼
                            name = line.substring(0, i).trim();
                            line = line.substring(i + 1).trim();
                        }
                        if (line.length() > 0) {
                            // ğŸ”¥ åŠ è½½ç±»
                            loadClass(extensionClasses, resourceURL, 
                                Class.forName(line, true, classLoader), name);
                        }
                    } catch (Throwable t) {
                        // è®°å½•å¼‚å¸¸
                    }
                }
            }
        }
    } catch (Throwable t) {
        logger.error("Exception occurred when loading extension class...", t);
    }
}

/**
 * åŠ è½½ç±»å¹¶åˆ†ç±»
 */
private void loadClass(Map<String, Class<?>> extensionClasses, java.net.URL resourceURL,
        Class<?> clazz, String name) throws NoSuchMethodException {
    
    if (!type.isAssignableFrom(clazz)) {
        throw new IllegalStateException("...");
    }
    
    // ğŸ”¥ æ£€æŸ¥æ˜¯å¦æ˜¯è‡ªé€‚åº”æ‰©å±•ç±»
    if (clazz.isAnnotationPresent(Adaptive.class)) {
        cacheAdaptiveClass(clazz);
        
    // ğŸ”¥ æ£€æŸ¥æ˜¯å¦æ˜¯Wrapperç±»
    } else if (isWrapperClass(clazz)) {
        cacheWrapperClass(clazz);
        
    // æ™®é€šæ‰©å±•ç±»
    } else {
        clazz.getConstructor();
        if (StringUtils.isEmpty(name)) {
            name = findAnnotationName(clazz);
        }
        
        String[] names = NAME_SEPARATOR.split(name);
        if (ArrayUtils.isNotEmpty(names)) {
            // ç¼“å­˜@Activateæ³¨è§£
            cacheActivateClass(clazz, names[0]);
            for (String n : names) {
                cacheName(clazz, n);
                saveInExtensionClass(extensionClasses, clazz, n);
            }
        }
    }
}

/**
 * åˆ¤æ–­æ˜¯å¦æ˜¯Wrapperç±»
 * Wrapperç±»å¿…é¡»æœ‰ä¸€ä¸ªå‚æ•°ä¸ºæ‰©å±•ç‚¹æ¥å£çš„æ„é€ å‡½æ•°
 */
private boolean isWrapperClass(Class<?> clazz) {
    try {
        clazz.getConstructor(type);
        return true;
    } catch (NoSuchMethodException e) {
        return false;
    }
}
```

---

## 3. è‡ªé€‚åº”æ‰©å±•

### 3.1 @Adaptiveæ³¨è§£

```java
/**
 * è‡ªé€‚åº”æ‰©å±•ç¤ºä¾‹
 */
@SPI("dubbo")
public interface Protocol {
    
    int getDefaultPort();
    
    // ğŸ”¥ @Adaptiveæ ‡è®°çš„æ–¹æ³•ä¼šç”Ÿæˆè‡ªé€‚åº”ä»£ç†
    @Adaptive
    <T> Exporter<T> export(Invoker<T> invoker) throws RpcException;
    
    @Adaptive
    <T> Invoker<T> refer(Class<T> type, URL url) throws RpcException;
    
    void destroy();
}
```

### 3.2 è·å–è‡ªé€‚åº”æ‰©å±•

```java
/**
 * ğŸ”¥ è·å–è‡ªé€‚åº”æ‰©å±•å®ä¾‹
 */
public T getAdaptiveExtension() {
    Object instance = cachedAdaptiveInstance.get();
    if (instance == null) {
        if (createAdaptiveInstanceError != null) {
            throw new IllegalStateException("...");
        }
        
        synchronized (cachedAdaptiveInstance) {
            instance = cachedAdaptiveInstance.get();
            if (instance == null) {
                try {
                    // ğŸ”¥ åˆ›å»ºè‡ªé€‚åº”æ‰©å±•å®ä¾‹
                    instance = createAdaptiveExtension();
                    cachedAdaptiveInstance.set(instance);
                } catch (Throwable t) {
                    createAdaptiveInstanceError = t;
                    throw new IllegalStateException("...");
                }
            }
        }
    }
    return (T) instance;
}

/**
 * åˆ›å»ºè‡ªé€‚åº”æ‰©å±•å®ä¾‹
 */
private T createAdaptiveExtension() {
    try {
        // è·å–è‡ªé€‚åº”æ‰©å±•ç±»å¹¶å®ä¾‹åŒ–
        return injectExtension((T) getAdaptiveExtensionClass().newInstance());
    } catch (Exception e) {
        throw new IllegalStateException("...");
    }
}

/**
 * è·å–è‡ªé€‚åº”æ‰©å±•ç±»
 */
private Class<?> getAdaptiveExtensionClass() {
    getExtensionClasses();
    
    // å¦‚æœæœ‰@Adaptiveæ ‡è®°çš„ç±»ï¼Œç›´æ¥è¿”å›
    if (cachedAdaptiveClass != null) {
        return cachedAdaptiveClass;
    }
    
    // ğŸ”¥ åŠ¨æ€ç”Ÿæˆè‡ªé€‚åº”æ‰©å±•ç±»
    return cachedAdaptiveClass = createAdaptiveExtensionClass();
}

/**
 * ğŸ”¥ åŠ¨æ€ç”Ÿæˆè‡ªé€‚åº”æ‰©å±•ç±»
 */
private Class<?> createAdaptiveExtensionClass() {
    // ç”Ÿæˆä»£ç 
    String code = new AdaptiveClassCodeGenerator(type, cachedDefaultName).generate();
    
    // è·å–ç¼–è¯‘å™¨
    ClassLoader classLoader = findClassLoader();
    org.apache.dubbo.common.compiler.Compiler compiler = 
        ExtensionLoader.getExtensionLoader(org.apache.dubbo.common.compiler.Compiler.class)
            .getAdaptiveExtension();
    
    // ç¼–è¯‘ç”Ÿæˆç±»
    return compiler.compile(code, classLoader);
}
```

### 3.3 ç”Ÿæˆçš„è‡ªé€‚åº”ä»£ç ç¤ºä¾‹

```java
/**
 * è‡ªåŠ¨ç”Ÿæˆçš„Protocolè‡ªé€‚åº”æ‰©å±•ç±»
 */
public class Protocol$Adaptive implements Protocol {
    
    public int getDefaultPort() {
        throw new UnsupportedOperationException("...");
    }
    
    public void destroy() {
        throw new UnsupportedOperationException("...");
    }
    
    /**
     * ğŸ”¥ è‡ªé€‚åº”æ–¹æ³•å®ç°
     */
    public Exporter export(Invoker invoker) throws RpcException {
        if (invoker == null) {
            throw new IllegalArgumentException("...");
        }
        if (invoker.getUrl() == null) {
            throw new IllegalArgumentException("...");
        }
        
        URL url = invoker.getUrl();
        
        // ğŸ”¥ ä»URLè·å–æ‰©å±•åï¼Œé»˜è®¤dubbo
        String extName = (url.getProtocol() == null ? "dubbo" : url.getProtocol());
        
        if (extName == null) {
            throw new IllegalStateException("...");
        }
        
        // ğŸ”¥ æ ¹æ®æ‰©å±•åè·å–å…·ä½“å®ç°
        Protocol extension = ExtensionLoader.getExtensionLoader(Protocol.class)
            .getExtension(extName);
        
        return extension.export(invoker);
    }
    
    public Invoker refer(Class type, URL url) throws RpcException {
        if (url == null) {
            throw new IllegalArgumentException("...");
        }
        
        // ä»URLè·å–æ‰©å±•å
        String extName = (url.getProtocol() == null ? "dubbo" : url.getProtocol());
        
        if (extName == null) {
            throw new IllegalStateException("...");
        }
        
        // æ ¹æ®æ‰©å±•åè·å–å…·ä½“å®ç°
        Protocol extension = ExtensionLoader.getExtensionLoader(Protocol.class)
            .getExtension(extName);
        
        return extension.refer(type, url);
    }
}
```

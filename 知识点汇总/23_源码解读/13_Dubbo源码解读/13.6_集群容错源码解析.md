# Dubboé›†ç¾¤å®¹é”™æºç è§£æ

> ğŸ’¡ æ·±å…¥ç†è§£Dubboå¦‚ä½•å¤„ç†æœåŠ¡è°ƒç”¨å¤±è´¥å’Œé›†ç¾¤å®¹é”™ç­–ç•¥

---

## ğŸ“š ç›®å½•

1. [é›†ç¾¤å®¹é”™æ¦‚è¿°](#1-é›†ç¾¤å®¹é”™æ¦‚è¿°)
2. [Clusteræ¥å£è®¾è®¡](#2-clusteræ¥å£è®¾è®¡)
3. [FailoverCluster](#3-failovercluster)
4. [å…¶ä»–å®¹é”™ç­–ç•¥](#4-å…¶ä»–å®¹é”™ç­–ç•¥)
5. [DirectoryæœåŠ¡ç›®å½•](#5-directoryæœåŠ¡ç›®å½•)
6. [Routerè·¯ç”±è§„åˆ™](#6-routerè·¯ç”±è§„åˆ™)
7. [é¢è¯•è¦ç‚¹](#7-é¢è¯•è¦ç‚¹)

---

## 1. é›†ç¾¤å®¹é”™æ¦‚è¿°

### 1.1 æ•´ä½“æ¶æ„

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  Dubboé›†ç¾¤å®¹é”™æ¶æ„                           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                             â”‚
â”‚  Consumer                                                   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚  ClusterInvoker                                      â”‚   â”‚
â”‚  â”‚      â”‚                                               â”‚   â”‚
â”‚  â”‚      â–¼                                               â”‚   â”‚
â”‚  â”‚  Directory.list() â†’ Routerè¿‡æ»¤ â†’ LoadBalanceé€‰æ‹©     â”‚   â”‚
â”‚  â”‚      â”‚                                               â”‚   â”‚
â”‚  â”‚      â–¼                                               â”‚   â”‚
â”‚  â”‚  [Provider1, Provider2, Provider3]                   â”‚   â”‚
â”‚  â”‚      â”‚                                               â”‚   â”‚
â”‚  â”‚      â–¼                                               â”‚   â”‚
â”‚  â”‚  å®¹é”™ç­–ç•¥å¤„ç†ï¼š                                       â”‚   â”‚
â”‚  â”‚  â”œâ”€â”€ Failover: å¤±è´¥é‡è¯•å…¶ä»–èŠ‚ç‚¹                      â”‚   â”‚
â”‚  â”‚  â”œâ”€â”€ Failfast: å¿«é€Ÿå¤±è´¥                              â”‚   â”‚
â”‚  â”‚  â”œâ”€â”€ Failsafe: å¤±è´¥å®‰å…¨                              â”‚   â”‚
â”‚  â”‚  â”œâ”€â”€ Failback: å¤±è´¥è‡ªåŠ¨æ¢å¤                          â”‚   â”‚
â”‚  â”‚  â”œâ”€â”€ Forking: å¹¶è¡Œè°ƒç”¨                               â”‚   â”‚
â”‚  â”‚  â””â”€â”€ Broadcast: å¹¿æ’­è°ƒç”¨                             â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 1.2 å®¹é”™ç­–ç•¥å¯¹æ¯”

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  é›†ç¾¤å®¹é”™ç­–ç•¥å¯¹æ¯”                            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  ç­–ç•¥        â”‚ è¡Œä¸ºæè¿°              â”‚ é€‚ç”¨åœºæ™¯             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  failover   â”‚ å¤±è´¥è‡ªåŠ¨åˆ‡æ¢é‡è¯•      â”‚ è¯»æ“ä½œï¼ˆé»˜è®¤ï¼‰       â”‚
â”‚  failfast   â”‚ å¿«é€Ÿå¤±è´¥ï¼Œåªè°ƒä¸€æ¬¡    â”‚ å†™æ“ä½œ               â”‚
â”‚  failsafe   â”‚ å¤±è´¥å®‰å…¨ï¼Œå¿½ç•¥å¼‚å¸¸    â”‚ æ—¥å¿—è®°å½•             â”‚
â”‚  failback   â”‚ å¤±è´¥è‡ªåŠ¨æ¢å¤ï¼Œåå°é‡è¯•â”‚ æ¶ˆæ¯é€šçŸ¥             â”‚
â”‚  forking    â”‚ å¹¶è¡Œè°ƒç”¨å¤šä¸ª          â”‚ å®æ—¶æ€§è¦æ±‚é«˜         â”‚
â”‚  broadcast  â”‚ å¹¿æ’­è°ƒç”¨æ‰€æœ‰          â”‚ é€šçŸ¥æ‰€æœ‰æä¾›è€…       â”‚
â”‚  available  â”‚ è°ƒç”¨ç¬¬ä¸€ä¸ªå¯ç”¨        â”‚ æµ‹è¯•ç¯å¢ƒ             â”‚
â”‚  mergeable  â”‚ åˆ†ç»„èšåˆ              â”‚ èœå•æœåŠ¡             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 2. Clusteræ¥å£è®¾è®¡

### 2.1 Clusteræ¥å£

```java
/**
 * Cluster - é›†ç¾¤å®¹é”™æ¥å£
 */
@SPI(FailoverCluster.NAME)
public interface Cluster {
    
    /**
     * ğŸ”¥ å°†Directoryä¸­çš„å¤šä¸ªInvokeråˆå¹¶æˆä¸€ä¸ªClusterInvoker
     * @param directory æœåŠ¡ç›®å½•
     * @return é›†ç¾¤Invoker
     */
    @Adaptive
    <T> Invoker<T> join(Directory<T> directory) throws RpcException;
}
```

### 2.2 AbstractClusterInvoker

```java
/**
 * AbstractClusterInvoker - é›†ç¾¤InvokeræŠ½è±¡åŸºç±»
 */
public abstract class AbstractClusterInvoker<T> implements Invoker<T> {
    
    private static final Logger logger = LoggerFactory.getLogger(AbstractClusterInvoker.class);
    
    protected Directory<T> directory;
    protected boolean availablecheck;
    private AtomicBoolean destroyed = new AtomicBoolean(false);
    
    public AbstractClusterInvoker(Directory<T> directory) {
        this(directory, directory.getUrl());
    }
    
    public AbstractClusterInvoker(Directory<T> directory, URL url) {
        if (directory == null) {
            throw new IllegalArgumentException("service directory == null");
        }
        
        this.directory = directory;
        this.availablecheck = url.getParameter(CLUSTER_AVAILABLE_CHECK_KEY, 
            DEFAULT_CLUSTER_AVAILABLE_CHECK);
    }
    
    @Override
    public Class<T> getInterface() {
        return directory.getInterface();
    }
    
    @Override
    public URL getUrl() {
        return directory.getConsumerUrl();
    }
    
    @Override
    public boolean isAvailable() {
        Invoker<T> invoker = select(null, null, null, null);
        if (invoker != null) {
            return invoker.isAvailable();
        }
        return false;
    }
    
    @Override
    public void destroy() {
        if (destroyed.compareAndSet(false, true)) {
            directory.destroy();
        }
    }
    
    /**
     * ğŸ”¥ è°ƒç”¨å…¥å£
     */
    @Override
    public Result invoke(final Invocation invocation) throws RpcException {
        checkWhetherDestroyed();
        
        // ç»‘å®šattachmentsåˆ°invocation
        Map<String, Object> contextAttachments = RpcContext.getContext().getObjectAttachments();
        if (contextAttachments != null && contextAttachments.size() != 0) {
            ((RpcInvocation) invocation).addObjectAttachments(contextAttachments);
        }
        
        // ğŸ”¥ è·å–Invokeråˆ—è¡¨
        List<Invoker<T>> invokers = list(invocation);
        
        // ğŸ”¥ è·å–è´Ÿè½½å‡è¡¡å™¨
        LoadBalance loadbalance = initLoadBalance(invokers, invocation);
        
        RpcUtils.attachInvocationIdIfAsync(getUrl(), invocation);
        
        // ğŸ”¥ è°ƒç”¨å­ç±»å®ç°çš„å®¹é”™é€»è¾‘
        return doInvoke(invocation, invokers, loadbalance);
    }
    
    /**
     * å­ç±»å®ç°å…·ä½“çš„å®¹é”™é€»è¾‘
     */
    protected abstract Result doInvoke(Invocation invocation, 
        List<Invoker<T>> invokers, LoadBalance loadbalance) throws RpcException;
    
    /**
     * ğŸ”¥ è·å–Invokeråˆ—è¡¨
     */
    protected List<Invoker<T>> list(Invocation invocation) throws RpcException {
        return directory.list(invocation);
    }
    
    /**
     * ğŸ”¥ é€‰æ‹©Invoker
     */
    protected Invoker<T> select(LoadBalance loadbalance, Invocation invocation,
            List<Invoker<T>> invokers, List<Invoker<T>> selected) throws RpcException {
        
        if (CollectionUtils.isEmpty(invokers)) {
            return null;
        }
        
        String methodName = invocation == null ? ConstantUtils.ANY_VALUE : 
            invocation.getMethodName();
        
        // è·å–stickyé…ç½®
        boolean sticky = invokers.get(0).getUrl()
            .getMethodParameter(methodName, CLUSTER_STICKY_KEY, DEFAULT_CLUSTER_STICKY);
        
        // ğŸ”¥ ç²˜æ»è¿æ¥ï¼šä¼˜å…ˆé€‰æ‹©ä¸Šæ¬¡è°ƒç”¨çš„Invoker
        if (stickyInvoker != null && !invokers.contains(stickyInvoker)) {
            stickyInvoker = null;
        }
        
        if (sticky && stickyInvoker != null && 
                (selected == null || !selected.contains(stickyInvoker))) {
            if (availablecheck && stickyInvoker.isAvailable()) {
                return stickyInvoker;
            }
        }
        
        // ğŸ”¥ è´Ÿè½½å‡è¡¡é€‰æ‹©
        Invoker<T> invoker = doSelect(loadbalance, invocation, invokers, selected);
        
        if (sticky) {
            stickyInvoker = invoker;
        }
        
        return invoker;
    }
    
    private Invoker<T> doSelect(LoadBalance loadbalance, Invocation invocation,
            List<Invoker<T>> invokers, List<Invoker<T>> selected) throws RpcException {
        
        if (CollectionUtils.isEmpty(invokers)) {
            return null;
        }
        
        if (invokers.size() == 1) {
            return invokers.get(0);
        }
        
        Invoker<T> invoker = loadbalance.select(invokers, getUrl(), invocation);
        
        // ğŸ”¥ å¦‚æœé€‰ä¸­çš„Invokeråœ¨selectedä¸­æˆ–ä¸å¯ç”¨ï¼Œé‡æ–°é€‰æ‹©
        if ((selected != null && selected.contains(invoker))
                || (!invoker.isAvailable() && getUrl() != null && availablecheck)) {
            
            try {
                // é‡æ–°é€‰æ‹©
                Invoker<T> rInvoker = reselect(loadbalance, invocation, 
                    invokers, selected, availablecheck);
                if (rInvoker != null) {
                    invoker = rInvoker;
                }
            } catch (Throwable t) {
                logger.error("cluster reselect fail reason is : " + t.getMessage());
            }
        }
        
        return invoker;
    }
}
```

---

## 3. FailoverCluster

### 3.1 FailoverClusterå®ç°

```java
/**
 * FailoverCluster - å¤±è´¥è‡ªåŠ¨åˆ‡æ¢ï¼ˆé»˜è®¤ç­–ç•¥ï¼‰
 * å½“å‡ºç°å¤±è´¥ï¼Œé‡è¯•å…¶å®ƒæœåŠ¡å™¨
 */
public class FailoverCluster implements Cluster {
    
    public static final String NAME = "failover";
    
    @Override
    public <T> Invoker<T> join(Directory<T> directory) throws RpcException {
        return new FailoverClusterInvoker<>(directory);
    }
}
```

### 3.2 FailoverClusterInvoker

```java
/**
 * FailoverClusterInvoker - å¤±è´¥è‡ªåŠ¨åˆ‡æ¢Invoker
 */
public class FailoverClusterInvoker<T> extends AbstractClusterInvoker<T> {
    
    private static final Logger logger = LoggerFactory.getLogger(FailoverClusterInvoker.class);
    
    public FailoverClusterInvoker(Directory<T> directory) {
        super(directory);
    }
    
    @Override
    public Result doInvoke(Invocation invocation, final List<Invoker<T>> invokers,
            LoadBalance loadbalance) throws RpcException {
        
        List<Invoker<T>> copyInvokers = invokers;
        checkInvokers(copyInvokers, invocation);
        
        String methodName = RpcUtils.getMethodName(invocation);
        
        // ğŸ”¥ è·å–é‡è¯•æ¬¡æ•°
        int len = getUrl().getMethodParameter(methodName, RETRIES_KEY, DEFAULT_RETRIES) + 1;
        if (len <= 0) {
            len = 1;
        }
        
        // è®°å½•æœ€åä¸€æ¬¡è°ƒç”¨çš„å¼‚å¸¸
        RpcException le = null;
        
        // è®°å½•å·²è°ƒç”¨è¿‡çš„Invoker
        List<Invoker<T>> invoked = new ArrayList<>(copyInvokers.size());
        
        // è®°å½•è°ƒç”¨è¿‡çš„Provideråœ°å€
        Set<String> providers = new HashSet<>(len);
        
        // ğŸ”¥ é‡è¯•å¾ªç¯
        for (int i = 0; i < len; i++) {
            // é‡è¯•æ—¶é‡æ–°åˆ—ä¸¾ï¼Œé¿å…åœ¨é‡è¯•è¿‡ç¨‹ä¸­invokersåˆ—è¡¨å‘ç”Ÿäº†å˜åŒ–
            if (i > 0) {
                checkWhetherDestroyed();
                copyInvokers = list(invocation);
                // é‡æ–°æ£€æŸ¥ä¸€ä¸‹
                checkInvokers(copyInvokers, invocation);
            }
            
            // ğŸ”¥ è´Ÿè½½å‡è¡¡é€‰æ‹©Invoker
            Invoker<T> invoker = select(loadbalance, invocation, copyInvokers, invoked);
            invoked.add(invoker);
            
            RpcContext.getContext().setInvokers((List) invoked);
            
            try {
                // ğŸ”¥ æ‰§è¡Œè°ƒç”¨
                Result result = invoker.invoke(invocation);
                
                if (le != null && logger.isWarnEnabled()) {
                    logger.warn("Although retry the method " + methodName
                        + " in the service " + getInterface().getName()
                        + " was successful by the provider " + invoker.getUrl().getAddress()
                        + ", but there have been failed providers " + providers
                        + " (" + providers.size() + "/" + copyInvokers.size()
                        + ") from the registry " + directory.getUrl().getAddress()
                        + " on the consumer " + NetUtils.getLocalHost()
                        + " using the dubbo version " + Version.getVersion() + ". Last error is: "
                        + le.getMessage(), le);
                }
                
                return result;
                
            } catch (RpcException e) {
                // ğŸ”¥ ä¸šåŠ¡å¼‚å¸¸ç›´æ¥æŠ›å‡ºï¼Œä¸é‡è¯•
                if (e.isBiz()) {
                    throw e;
                }
                le = e;
            } catch (Throwable e) {
                le = new RpcException(e.getMessage(), e);
            } finally {
                providers.add(invoker.getUrl().getAddress());
            }
        }
        
        // ğŸ”¥ æ‰€æœ‰é‡è¯•éƒ½å¤±è´¥ï¼ŒæŠ›å‡ºå¼‚å¸¸
        throw new RpcException(le.getCode(), "Failed to invoke the method "
            + methodName + " in the service " + getInterface().getName()
            + ". Tried " + len + " times of the providers " + providers
            + " (" + providers.size() + "/" + copyInvokers.size()
            + ") from the registry " + directory.getUrl().getAddress()
            + " on the consumer " + NetUtils.getLocalHost() + " using the dubbo version "
            + Version.getVersion() + ". Last error is: "
            + le.getMessage(), le.getCause() != null ? le.getCause() : le);
    }
}
```

### 3.3 é‡è¯•æœºåˆ¶å›¾è§£

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  Failoveré‡è¯•æœºåˆ¶                            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                             â”‚
â”‚  Consumerè°ƒç”¨æµç¨‹ï¼š                                          â”‚
â”‚                                                             â”‚
â”‚  1. ç¬¬ä¸€æ¬¡è°ƒç”¨                                               â”‚
â”‚     â”œâ”€â”€ é€‰æ‹©Provider1                                       â”‚
â”‚     â”œâ”€â”€ è°ƒç”¨å¤±è´¥ï¼ˆç½‘ç»œå¼‚å¸¸ï¼‰                                 â”‚
â”‚     â””â”€â”€ è®°å½•åˆ°invokedåˆ—è¡¨                                   â”‚
â”‚                                                             â”‚
â”‚  2. ç¬¬äºŒæ¬¡é‡è¯•                                               â”‚
â”‚     â”œâ”€â”€ é‡æ–°è·å–Provideråˆ—è¡¨                                â”‚
â”‚     â”œâ”€â”€ æ’é™¤invokedä¸­çš„Provider1                            â”‚
â”‚     â”œâ”€â”€ é€‰æ‹©Provider2                                       â”‚
â”‚     â”œâ”€â”€ è°ƒç”¨å¤±è´¥ï¼ˆè¶…æ—¶ï¼‰                                     â”‚
â”‚     â””â”€â”€ è®°å½•åˆ°invokedåˆ—è¡¨                                   â”‚
â”‚                                                             â”‚
â”‚  3. ç¬¬ä¸‰æ¬¡é‡è¯•                                               â”‚
â”‚     â”œâ”€â”€ é‡æ–°è·å–Provideråˆ—è¡¨                                â”‚
â”‚     â”œâ”€â”€ æ’é™¤invokedä¸­çš„Provider1ã€Provider2                 â”‚
â”‚     â”œâ”€â”€ é€‰æ‹©Provider3                                       â”‚
â”‚     â”œâ”€â”€ è°ƒç”¨æˆåŠŸ                                             â”‚
â”‚     â””â”€â”€ è¿”å›ç»“æœ                                             â”‚
â”‚                                                             â”‚
â”‚  é…ç½®å‚æ•°ï¼š                                                  â”‚
â”‚  - retries: é‡è¯•æ¬¡æ•°ï¼ˆé»˜è®¤2æ¬¡ï¼‰                             â”‚
â”‚  - æ€»è°ƒç”¨æ¬¡æ•° = retries + 1                                 â”‚
â”‚                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 4. å…¶ä»–å®¹é”™ç­–ç•¥

### 4.1 FailfastCluster

```java
/**
 * FailfastCluster - å¿«é€Ÿå¤±è´¥
 * åªå‘èµ·ä¸€æ¬¡è°ƒç”¨ï¼Œå¤±è´¥ç«‹å³æŠ¥é”™
 */
public class FailfastCluster implements Cluster {
    
    public static final String NAME = "failfast";
    
    @Override
    public <T> Invoker<T> join(Directory<T> directory) throws RpcException {
        return new FailfastClusterInvoker<>(directory);
    }
}

/**
 * FailfastClusterInvoker - å¿«é€Ÿå¤±è´¥Invoker
 */
public class FailfastClusterInvoker<T> extends AbstractClusterInvoker<T> {
    
    public FailfastClusterInvoker(Directory<T> directory) {
        super(directory);
    }
    
    @Override
    public Result doInvoke(Invocation invocation, List<Invoker<T>> invokers,
            LoadBalance loadbalance) throws RpcException {
        
        checkInvokers(invokers, invocation);
        
        // ğŸ”¥ åªé€‰æ‹©ä¸€ä¸ªInvokerè°ƒç”¨
        Invoker<T> invoker = select(loadbalance, invocation, invokers, null);
        
        try {
            return invoker.invoke(invocation);
        } catch (Throwable e) {
            // ğŸ”¥ å¤±è´¥ç›´æ¥æŠ›å‡ºå¼‚å¸¸ï¼Œä¸é‡è¯•
            if (e instanceof RpcException && ((RpcException) e).isBiz()) {
                throw (RpcException) e;
            }
            throw new RpcException(e instanceof RpcException ? 
                ((RpcException) e).getCode() : 0,
                "Failfast invoke providers " + invoker.getUrl() + " " + 
                loadbalance.getClass().getSimpleName() + " select from all providers " +
                invokers + " for service " + getInterface().getName() + 
                " method " + invocation.getMethodName() + " on consumer " + 
                NetUtils.getLocalHost() + " use dubbo version " + Version.getVersion() +
                ", but no luck to perform the invocation. Last error is: " + e.getMessage(),
                e.getCause() != null ? e.getCause() : e);
        }
    }
}
```

### 4.2 FailsafeCluster

```java
/**
 * FailsafeCluster - å¤±è´¥å®‰å…¨
 * å‡ºç°å¼‚å¸¸æ—¶ï¼Œç›´æ¥å¿½ç•¥
 */
public class FailsafeCluster implements Cluster {
    
    public static final String NAME = "failsafe";
    
    @Override
    public <T> Invoker<T> join(Directory<T> directory) throws RpcException {
        return new FailsafeClusterInvoker<>(directory);
    }
}

/**
 * FailsafeClusterInvoker - å¤±è´¥å®‰å…¨Invoker
 */
public class FailsafeClusterInvoker<T> extends AbstractClusterInvoker<T> {
    
    private static final Logger logger = LoggerFactory.getLogger(FailsafeClusterInvoker.class);
    
    public FailsafeClusterInvoker(Directory<T> directory) {
        super(directory);
    }
    
    @Override
    public Result doInvoke(Invocation invocation, List<Invoker<T>> invokers,
            LoadBalance loadbalance) throws RpcException {
        
        try {
            checkInvokers(invokers, invocation);
            Invoker<T> invoker = select(loadbalance, invocation, invokers, null);
            return invoker.invoke(invocation);
            
        } catch (Throwable e) {
            // ğŸ”¥ å¤±è´¥å®‰å…¨ï¼šè®°å½•æ—¥å¿—ä½†ä¸æŠ›å‡ºå¼‚å¸¸
            logger.error("Failsafe ignore exception: " + e.getMessage(), e);
            
            // è¿”å›ç©ºç»“æœ
            return AsyncRpcResult.newDefaultAsyncResult(null, null, invocation);
        }
    }
}
```

### 4.3 FailbackCluster

```java
/**
 * FailbackCluster - å¤±è´¥è‡ªåŠ¨æ¢å¤
 * åå°è®°å½•å¤±è´¥è¯·æ±‚ï¼Œå®šæ—¶é‡å‘
 */
public class FailbackCluster implements Cluster {
    
    public static final String NAME = "failback";
    
    @Override
    public <T> Invoker<T> join(Directory<T> directory) throws RpcException {
        return new FailbackClusterInvoker<>(directory);
    }
}

/**
 * FailbackClusterInvoker - å¤±è´¥è‡ªåŠ¨æ¢å¤Invoker
 */
public class FailbackClusterInvoker<T> extends AbstractClusterInvoker<T> {
    
    private static final Logger logger = LoggerFactory.getLogger(FailbackClusterInvoker.class);
    
    private static final long RETRY_FAILED_PERIOD = 5;
    
    // ğŸ”¥ å¤±è´¥ä»»åŠ¡å®šæ—¶å™¨
    private final ScheduledExecutorService scheduledExecutorService = 
        Executors.newScheduledThreadPool(2, new NamedThreadFactory("failback-cluster-timer", true));
    
    // å¤±è´¥ä»»åŠ¡é›†åˆ
    private final ConcurrentMap<Invocation, AbstractClusterInvoker<?>> failed = 
        new ConcurrentHashMap<>();
    
    private volatile ScheduledFuture<?> retryFuture;
    
    public FailbackClusterInvoker(Directory<T> directory) {
        super(directory);
    }
    
    @Override
    public Result doInvoke(Invocation invocation, List<Invoker<T>> invokers,
            LoadBalance loadbalance) throws RpcException {
        
        Invoker<T> invoker = null;
        try {
            checkInvokers(invokers, invocation);
            invoker = select(loadbalance, invocation, invokers, null);
            return invoker.invoke(invocation);
            
        } catch (Throwable e) {
            logger.error("Failback to invoke method " + invocation.getMethodName() + 
                ", wait for retry in background. Ignored exception: " + 
                e.getMessage() + ", ", e);
            
            // ğŸ”¥ æ·»åŠ åˆ°å¤±è´¥ä»»åŠ¡ï¼Œåå°é‡è¯•
            addFailed(loadbalance, invocation, invokers, invoker);
            
            // ç«‹å³è¿”å›ç©ºç»“æœ
            return AsyncRpcResult.newDefaultAsyncResult(null, null, invocation);
        }
    }
    
    /**
     * ğŸ”¥ æ·»åŠ å¤±è´¥ä»»åŠ¡
     */
    private void addFailed(LoadBalance loadbalance, Invocation invocation,
            List<Invoker<T>> invokers, Invoker<T> lastInvoker) {
        
        if (retryFuture == null) {
            synchronized (this) {
                if (retryFuture == null) {
                    // ğŸ”¥ å¯åŠ¨å®šæ—¶é‡è¯•ä»»åŠ¡
                    retryFuture = scheduledExecutorService.scheduleWithFixedDelay(
                        new Runnable() {
                            @Override
                            public void run() {
                                try {
                                    retryFailed();
                                } catch (Throwable t) {
                                    logger.error("Unexpected error occur at collect statistic", t);
                                }
                            }
                        }, RETRY_FAILED_PERIOD, RETRY_FAILED_PERIOD, TimeUnit.SECONDS);
                }
            }
        }
        
        failed.put(invocation, this);
    }
    
    /**
     * ğŸ”¥ é‡è¯•å¤±è´¥çš„è°ƒç”¨
     */
    void retryFailed() {
        if (failed.size() == 0) {
            return;
        }
        
        for (Map.Entry<Invocation, AbstractClusterInvoker<?>> entry : new HashMap<>(failed).entrySet()) {
            Invocation invocation = entry.getKey();
            Invoker<?> invoker = entry.getValue();
            
            try {
                // é‡æ–°è°ƒç”¨
                invoker.invoke(invocation);
                // æˆåŠŸåç§»é™¤
                failed.remove(invocation);
            } catch (Throwable e) {
                logger.error("Failed retry to invoke method " + invocation.getMethodName() + 
                    ", waiting again.", e);
            }
        }
    }
}
```

### 4.4 ForkingCluster

```java
/**
 * ForkingCluster - å¹¶è¡Œè°ƒç”¨
 * åŒæ—¶è°ƒç”¨å¤šä¸ªæœåŠ¡å™¨ï¼Œåªè¦ä¸€ä¸ªæˆåŠŸå³è¿”å›
 */
public class ForkingCluster implements Cluster {
    
    public static final String NAME = "forking";
    
    @Override
    public <T> Invoker<T> join(Directory<T> directory) throws RpcException {
        return new ForkingClusterInvoker<>(directory);
    }
}

/**
 * ForkingClusterInvoker - å¹¶è¡Œè°ƒç”¨Invoker
 */
public class ForkingClusterInvoker<T> extends AbstractClusterInvoker<T> {
    
    private final ExecutorService executor = Executors.newCachedThreadPool(
        new NamedThreadFactory("forking-cluster-timer", true));
    
    public ForkingClusterInvoker(Directory<T> directory) {
        super(directory);
    }
    
    @Override
    public Result doInvoke(final Invocation invocation, List<Invoker<T>> invokers,
            LoadBalance loadbalance) throws RpcException {
        
        try {
            checkInvokers(invokers, invocation);
            final List<Invoker<T>> selected;
            
            // ğŸ”¥ è·å–å¹¶è¡Œè°ƒç”¨æ•°é‡
            final String methodName = RpcUtils.getMethodName(invocation);
            final int forks = getUrl().getMethodParameter(methodName, FORKS_KEY, DEFAULT_FORKS);
            final int timeout = getUrl().getMethodParameter(methodName, TIMEOUT_KEY, DEFAULT_TIMEOUT);
            
            if (forks <= 0 || forks >= invokers.size()) {
                selected = invokers;
            } else {
                selected = new ArrayList<>(forks);
                while (selected.size() < forks) {
                    Invoker<T> invoker = select(loadbalance, invocation, invokers, selected);
                    if (!selected.contains(invoker)) {
                        selected.add(invoker);
                    }
                }
            }
            
            RpcContext.getContext().setInvokers((List) selected);
            final AtomicInteger count = new AtomicInteger();
            final BlockingQueue<Object> ref = new LinkedBlockingQueue<>();
            
            // ğŸ”¥ å¹¶è¡Œè°ƒç”¨
            for (final Invoker<T> invoker : selected) {
                executor.execute(new Runnable() {
                    @Override
                    public void run() {
                        try {
                            Result result = invoker.invoke(invocation);
                            ref.offer(result);
                        } catch (Throwable e) {
                            int value = count.incrementAndGet();
                            if (value >= selected.size()) {
                                ref.offer(e);
                            }
                        }
                    }
                });
            }
            
            try {
                // ğŸ”¥ ç­‰å¾…ç¬¬ä¸€ä¸ªç»“æœ
                Object ret = ref.poll(timeout, TimeUnit.MILLISECONDS);
                if (ret instanceof Result) {
                    return (Result) ret;
                }
                throw new RpcException(ret instanceof Throwable ? (Throwable) ret : 
                    new RuntimeException("Failed to forking invoke provider " + selected + 
                    ", but no luck to perform the invocation. Last error is: " + ret));
                    
            } catch (InterruptedException e) {
                throw new RpcException("Failed to forking invoke provider " + selected + 
                    ", but no luck to perform the invocation. Last error is: " + e.getMessage(), e);
            }
            
        } finally {
            RpcContext.getContext().clearAttachments();
        }
    }
}
```

---

## 5. DirectoryæœåŠ¡ç›®å½•

### 5.1 Directoryæ¥å£

```java
/**
 * Directory - æœåŠ¡ç›®å½•æ¥å£
 * ç»´æŠ¤æœåŠ¡æä¾›è€…åˆ—è¡¨
 */
public interface Directory<T> extends Node {
    
    /**
     * è·å–æœåŠ¡æ¥å£
     */
    Class<T> getInterface();
    
    /**
     * ğŸ”¥ è·å–Invokeråˆ—è¡¨
     */
    List<Invoker<T>> list(Invocation invocation) throws RpcException;
    
    /**
     * è·å–æ‰€æœ‰Invoker
     */
    List<Invoker<T>> getAllInvokers();
    
    /**
     * è·å–æ¶ˆè´¹è€…URL
     */
    URL getConsumerUrl();
}
```

### 5.2 RegistryDirectory

```java
/**
 * RegistryDirectory - æ³¨å†Œä¸­å¿ƒç›®å½•
 * ä»æ³¨å†Œä¸­å¿ƒè·å–æœåŠ¡æä¾›è€…åˆ—è¡¨
 */
public class RegistryDirectory<T> extends AbstractDirectory<T> implements NotifyListener {
    
    private static final Logger logger = LoggerFactory.getLogger(RegistryDirectory.class);
    
    // ğŸ”¥ Invokerç¼“å­˜
    private volatile Map<String, Invoker<T>> urlInvokerMap;
    
    // ğŸ”¥ æ–¹æ³•åˆ°Invokeråˆ—è¡¨çš„æ˜ å°„
    private volatile Map<String, List<Invoker<T>>> methodInvokerMap;
    
    // ğŸ”¥ ç¼“å­˜çš„Invokeråˆ—è¡¨
    private volatile List<Invoker<T>> cachedInvokerUrls;
    
    private Registry registry;
    private Protocol protocol;
    private final String serviceKey;
    private final Class<T> serviceType;
    private final Map<String, String> queryMap;
    private final URL directoryUrl;
    private final boolean multiGroup;
    private volatile boolean forbidden = false;
    private boolean shouldRegister;
    private boolean shouldSimplified;
    
    public RegistryDirectory(Class<T> serviceType, URL url) {
        super(url);
        if (serviceType == null) {
            throw new IllegalArgumentException("service type is null.");
        }
        
        this.serviceType = serviceType;
        this.serviceKey = url.getServiceKey();
        this.queryMap = StringUtils.parseQueryString(url.getParameterAndDecoded(REFER_KEY));
        this.overrideDirectoryUrl = this.directoryUrl = turnRegistryUrlToConsumerUrl(url);
        String group = directoryUrl.getParameter(GROUP_KEY, "");
        this.multiGroup = group != null && (ANY_VALUE.equals(group) || group.contains(","));
    }
    
    @Override
    public Class<T> getInterface() {
        return serviceType;
    }
    
    /**
     * ğŸ”¥ è·å–Invokeråˆ—è¡¨
     */
    @Override
    public List<Invoker<T>> doList(Invocation invocation) {
        if (forbidden) {
            // æœåŠ¡æä¾›è€…ä¸º0ï¼ŒæŠ›å‡ºå¼‚å¸¸
            throw new RpcException(RpcException.FORBIDDEN_EXCEPTION, 
                "No provider available from registry " + 
                getUrl().getAddress() + " for service " + getConsumerUrl().getServiceKey() + 
                " on consumer " + NetUtils.getLocalHost() + 
                " use dubbo version " + Version.getVersion() + 
                ", please check status of providers(disabled, not registered or in blacklist).");
        }
        
        if (multiGroup) {
            return this.invokers == null ? Collections.emptyList() : this.invokers;
        }
        
        List<Invoker<T>> invokers = null;
        try {
            // ğŸ”¥ è·å–æ–¹æ³•çº§åˆ«çš„Invokeråˆ—è¡¨
            invokers = routerChain.route(getConsumerUrl(), invocation);
        } catch (Throwable t) {
            logger.error("Failed to execute router: " + getUrl() + ", cause: " + t.getMessage(), t);
        }
        
        return invokers == null ? Collections.emptyList() : invokers;
    }
    
    /**
     * ğŸ”¥ è®¢é˜…æœåŠ¡
     */
    public void subscribe(URL url) {
        setConsumerUrl(url);
        CONSUMER_CONFIGURATION_LISTENER.addNotifyListener(this);
        serviceConfigurationListener = new ReferenceConfigurationListener(this, url);
        registry.subscribe(url, this);
    }
    
    /**
     * ğŸ”¥ æ¥æ”¶æ³¨å†Œä¸­å¿ƒé€šçŸ¥
     */
    @Override
    public synchronized void notify(List<URL> urls) {
        Map<String, List<URL>> categoryUrls = urls.stream()
            .filter(Objects::nonNull)
            .filter(this::isValidCategory)
            .filter(this::isNotCompatibleFor26x)
            .collect(Collectors.groupingBy(this::judgeCategory));
        
        List<URL> configuratorURLs = categoryUrls.getOrDefault(CONFIGURATORS_CATEGORY, Collections.emptyList());
        this.configurators = Configurator.toConfigurators(configuratorURLs).orElse(this.configurators);
        
        List<URL> routerURLs = categoryUrls.getOrDefault(ROUTERS_CATEGORY, Collections.emptyList());
        toRouters(routerURLs).ifPresent(this::addRouters);
        
        // ğŸ”¥ åˆ·æ–°Invokeråˆ—è¡¨
        List<URL> invokerURLs = categoryUrls.getOrDefault(PROVIDERS_CATEGORY, Collections.emptyList());
        refreshOverrideAndInvoker(invokerURLs);
    }
    
    /**
     * ğŸ”¥ åˆ·æ–°Invokeråˆ—è¡¨
     */
    private void refreshInvoker(List<URL> invokerUrls) {
        Assert.notNull(invokerUrls, "invokerUrls should not be null");
        
        if (invokerUrls.size() == 1
                && invokerUrls.get(0) != null
                && EMPTY_PROTOCOL.equals(invokerUrls.get(0).getProtocol())) {
            // ç©ºåè®®ï¼Œç¦ç”¨æœåŠ¡
            this.forbidden = true;
            this.invokers = Collections.emptyList();
            routerChain.setInvokers(this.invokers);
            destroyAllInvokers();
        } else {
            this.forbidden = false;
            Map<String, Invoker<T>> oldUrlInvokerMap = this.urlInvokerMap;
            
            if (invokerUrls == Collections.<URL>emptyList()) {
                invokerUrls = new ArrayList<>();
            }
            
            if (invokerUrls.isEmpty() && this.cachedInvokerUrls != null) {
                invokerUrls.addAll(this.cachedInvokerUrls);
            } else {
                this.cachedInvokerUrls = new ArrayList<>(invokerUrls);
            }
            
            if (invokerUrls.isEmpty()) {
                return;
            }
            
            // ğŸ”¥ å°†URLè½¬æ¢ä¸ºInvoker
            Map<String, Invoker<T>> newUrlInvokerMap = toInvokers(invokerUrls);
            
            if (CollectionUtils.isEmptyMap(newUrlInvokerMap)) {
                logger.error(new IllegalStateException("urls to invokers error..."));
                return;
            }
            
            List<Invoker<T>> newInvokers = Collections.unmodifiableList(
                new ArrayList<>(newUrlInvokerMap.values()));
            
            // ğŸ”¥ æ›´æ–°æ–¹æ³•åˆ°Invokerçš„æ˜ å°„
            this.invokers = multiGroup ? toMergeInvokerList(newInvokers) : newInvokers;
            this.urlInvokerMap = newUrlInvokerMap;
            
            try {
                // ğŸ”¥ é”€æ¯ä¸å†ä½¿ç”¨çš„Invoker
                destroyUnusedInvokers(oldUrlInvokerMap, newUrlInvokerMap);
            } catch (Exception e) {
                logger.warn("destroyUnusedInvokers error. ", e);
            }
            
            // ğŸ”¥ é€šçŸ¥è·¯ç”±é“¾
            routerChain.setInvokers(this.invokers);
        }
    }
}
```

---

## 6. Routerè·¯ç”±è§„åˆ™

### 6.1 Routeræ¥å£

```java
/**
 * Router - è·¯ç”±è§„åˆ™æ¥å£
 */
public interface Router extends Comparable<Router> {
    
    int DEFAULT_PRIORITY = Integer.MAX_VALUE;
    
    /**
     * è·å–è·¯ç”±è§„åˆ™URL
     */
    URL getUrl();
    
    /**
     * ğŸ”¥ è·¯ç”±è¿‡æ»¤
     * @param invokers å€™é€‰Invokeråˆ—è¡¨
     * @param url æ¶ˆè´¹è€…URL
     * @param invocation è°ƒç”¨ä¿¡æ¯
     * @return è¿‡æ»¤åçš„Invokeråˆ—è¡¨
     */
    <T> List<Invoker<T>> route(List<Invoker<T>> invokers, URL url, Invocation invocation) 
        throws RpcException;
    
    /**
     * è·¯ç”±ä¼˜å…ˆçº§
     */
    default int getPriority() {
        return DEFAULT_PRIORITY;
    }
}
```

### 6.2 ConditionRouter

```java
/**
 * ConditionRouter - æ¡ä»¶è·¯ç”±
 * åŸºäºæ¡ä»¶è¡¨è¾¾å¼çš„è·¯ç”±è§„åˆ™
 */
public class ConditionRouter extends AbstractRouter {
    
    public static final String NAME = "condition";
    
    private static final Pattern ROUTE_PATTERN = Pattern.compile("([&!=,]*)\\s*([^&!=,\\s]+)");
    
    // ğŸ”¥ æ¶ˆè´¹è€…åŒ¹é…æ¡ä»¶
    private final Map<String, MatchPair> whenCondition;
    
    // ğŸ”¥ æä¾›è€…è¿‡æ»¤æ¡ä»¶
    private final Map<String, MatchPair> thenCondition;
    
    public ConditionRouter(URL url) {
        this.url = url;
        this.priority = url.getParameter(PRIORITY_KEY, DEFAULT_PRIORITY);
        this.force = url.getParameter(FORCE_KEY, false);
        this.enabled = url.getParameter(ENABLED_KEY, true);
        init(url.getParameterAndDecoded(RULE_KEY));
    }
    
    /**
     * ğŸ”¥ è§£æè·¯ç”±è§„åˆ™
     */
    public void init(String rule) {
        try {
            if (rule == null || rule.trim().length() == 0) {
                throw new IllegalArgumentException("Illegal route rule!");
            }
            rule = rule.replace("consumer.", "").replace("provider.", "");
            
            // ğŸ”¥ åˆ†å‰²whenå’Œthenæ¡ä»¶
            int i = rule.indexOf("=>");
            String whenRule = i < 0 ? null : rule.substring(0, i).trim();
            String thenRule = i < 0 ? rule.trim() : rule.substring(i + 2).trim();
            
            // ğŸ”¥ è§£æwhenæ¡ä»¶
            Map<String, MatchPair> when = StringUtils.isBlank(whenRule) || "true".equals(whenRule) 
                ? new HashMap<String, MatchPair>() : parseRule(whenRule);
            
            // ğŸ”¥ è§£æthenæ¡ä»¶
            Map<String, MatchPair> then = StringUtils.isBlank(thenRule) || "false".equals(thenRule) 
                ? null : parseRule(thenRule);
            
            this.whenCondition = when;
            this.thenCondition = then;
        } catch (ParseException e) {
            throw new IllegalStateException(e.getMessage(), e);
        }
    }
    
    @Override
    public <T> List<Invoker<T>> route(List<Invoker<T>> invokers, URL url, Invocation invocation)
            throws RpcException {
        
        if (!enabled) {
            return invokers;
        }
        
        if (CollectionUtils.isEmpty(invokers)) {
            return invokers;
        }
        
        try {
            // ğŸ”¥ åŒ¹é…whenæ¡ä»¶
            if (!matchWhen(url, invocation)) {
                return invokers;
            }
            
            List<Invoker<T>> result = new ArrayList<>();
            
            if (thenCondition == null) {
                logger.warn("The current consumer in the service blacklist...");
                return result;
            }
            
            // ğŸ”¥ è¿‡æ»¤ç¬¦åˆthenæ¡ä»¶çš„Invoker
            for (Invoker<T> invoker : invokers) {
                if (matchThen(invoker.getUrl(), url)) {
                    result.add(invoker);
                }
            }
            
            if (!result.isEmpty()) {
                return result;
            } else if (force) {
                logger.warn("The route result is empty and force execute...");
                return result;
            }
            
        } catch (Throwable t) {
            logger.error("Failed to execute condition router rule: " + getUrl() + 
                ", invokers: " + invokers + ", cause: " + t.getMessage(), t);
        }
        
        return invokers;
    }
    
    /**
     * ğŸ”¥ åŒ¹é…whenæ¡ä»¶
     */
    boolean matchWhen(URL url, Invocation invocation) {
        return CollectionUtils.isEmptyMap(whenCondition) || 
            matchCondition(whenCondition, url, null, invocation);
    }
    
    /**
     * ğŸ”¥ åŒ¹é…thenæ¡ä»¶
     */
    private boolean matchThen(URL url, URL param) {
        return CollectionUtils.isNotEmptyMap(thenCondition) && 
            matchCondition(thenCondition, url, param, null);
    }
}
```

### 6.3 è·¯ç”±è§„åˆ™ç¤ºä¾‹

```java
/**
 * è·¯ç”±è§„åˆ™ç¤ºä¾‹
 */
public class RouterExamples {
    
    // 1. æ’é™¤æŸä¸ªæä¾›è€…
    // host != 192.168.1.100
    
    // 2. ç™½åå•
    // host = 192.168.1.1,192.168.1.2
    
    // 3. è¯»å†™åˆ†ç¦»
    // method = find*,list*,get*,is* => host = 192.168.1.1,192.168.1.2
    // method != find*,list*,get*,is* => host = 192.168.1.3,192.168.1.4
    
    // 4. åº”ç”¨éš”ç¦»
    // application = app1 => host = 192.168.1.1,192.168.1.2
    // application = app2 => host = 192.168.1.3,192.168.1.4
    
    // 5. æœºæˆ¿éš”ç¦»
    // host = 192.168.1.* => host = 192.168.1.*
    // host = 192.168.2.* => host = 192.168.2.*
}
```

---

## 7. é¢è¯•è¦ç‚¹

### 7.1 é«˜é¢‘é¢è¯•é¢˜

#### Q1: Dubboæœ‰å“ªäº›é›†ç¾¤å®¹é”™ç­–ç•¥ï¼Ÿ

```
Dubboé›†ç¾¤å®¹é”™ç­–ç•¥ï¼š

1. Failoverï¼ˆé»˜è®¤ï¼‰
   - å¤±è´¥è‡ªåŠ¨åˆ‡æ¢é‡è¯•
   - é€‚ç”¨äºè¯»æ“ä½œ
   - å¯é…ç½®é‡è¯•æ¬¡æ•°

2. Failfast
   - å¿«é€Ÿå¤±è´¥ï¼Œåªè°ƒç”¨ä¸€æ¬¡
   - é€‚ç”¨äºå†™æ“ä½œ
   - é¿å…é‡å¤å†™å…¥

3. Failsafe
   - å¤±è´¥å®‰å…¨ï¼Œå¿½ç•¥å¼‚å¸¸
   - é€‚ç”¨äºæ—¥å¿—è®°å½•ç­‰
   - è¿”å›ç©ºç»“æœ

4. Failback
   - å¤±è´¥è‡ªåŠ¨æ¢å¤
   - åå°å®šæ—¶é‡è¯•
   - é€‚ç”¨äºæ¶ˆæ¯é€šçŸ¥

5. Forking
   - å¹¶è¡Œè°ƒç”¨å¤šä¸ªæä¾›è€…
   - åªè¦ä¸€ä¸ªæˆåŠŸå³è¿”å›
   - é€‚ç”¨äºå®æ—¶æ€§è¦æ±‚é«˜çš„åœºæ™¯

6. Broadcast
   - å¹¿æ’­è°ƒç”¨æ‰€æœ‰æä¾›è€…
   - é€‚ç”¨äºé€šçŸ¥æ‰€æœ‰æä¾›è€…
   - ä»»ä½•ä¸€ä¸ªæŠ¥é”™åˆ™æŠ¥é”™
```

#### Q2: Failoveré‡è¯•æœºåˆ¶çš„å®ç°åŸç†ï¼Ÿ

```java
/**
 * Failoveré‡è¯•æœºåˆ¶ï¼š
 * 
 * 1. è·å–é‡è¯•æ¬¡æ•°é…ç½®ï¼ˆé»˜è®¤2æ¬¡ï¼‰
 * 2. æ€»è°ƒç”¨æ¬¡æ•° = é‡è¯•æ¬¡æ•° + 1
 * 3. å¾ªç¯è°ƒç”¨ï¼š
 *    - è´Ÿè½½å‡è¡¡é€‰æ‹©Invoker
 *    - æ’é™¤å·²è°ƒç”¨è¿‡çš„Invoker
 *    - æ‰§è¡Œè°ƒç”¨
 *    - å¤±è´¥åˆ™è®°å½•å¼‚å¸¸ï¼Œç»§ç»­ä¸‹æ¬¡é‡è¯•
 *    - æˆåŠŸåˆ™è¿”å›ç»“æœ
 * 4. æ‰€æœ‰é‡è¯•éƒ½å¤±è´¥ï¼ŒæŠ›å‡ºæœ€åä¸€æ¬¡å¼‚å¸¸
 * 
 * æ³¨æ„äº‹é¡¹ï¼š
 * - ä¸šåŠ¡å¼‚å¸¸ä¸é‡è¯•
 * - é‡è¯•æ—¶é‡æ–°è·å–Provideråˆ—è¡¨
 * - é¿å…é‡è¯•åŒä¸€ä¸ªProvider
 */
```

#### Q3: Directoryçš„ä½œç”¨æ˜¯ä»€ä¹ˆï¼Ÿ

```
Directoryçš„ä½œç”¨ï¼š

1. ç»´æŠ¤æœåŠ¡æä¾›è€…åˆ—è¡¨
   - ä»æ³¨å†Œä¸­å¿ƒè·å–Providerä¿¡æ¯
   - å°†URLè½¬æ¢ä¸ºInvoker

2. ç›‘å¬æ³¨å†Œä¸­å¿ƒå˜åŒ–
   - å®ç°NotifyListeneræ¥å£
   - åŠ¨æ€æ›´æ–°Invokeråˆ—è¡¨

3. åº”ç”¨è·¯ç”±è§„åˆ™
   - é€šè¿‡RouterChainè¿‡æ»¤Invoker
   - æ”¯æŒæ¡ä»¶è·¯ç”±ã€è„šæœ¬è·¯ç”±ç­‰

4. æä¾›InvokeræŸ¥è¯¢
   - list()æ–¹æ³•è¿”å›å¯ç”¨Invokeråˆ—è¡¨
   - æ”¯æŒæ–¹æ³•çº§åˆ«çš„Invokerè¿‡æ»¤
```

#### Q4: Routerè·¯ç”±è§„åˆ™å¦‚ä½•å·¥ä½œï¼Ÿ

```
Routerè·¯ç”±è§„åˆ™å·¥ä½œåŸç†ï¼š

1. è·¯ç”±è§„åˆ™æ ¼å¼
   - whenæ¡ä»¶ => thenæ¡ä»¶
   - when: æ¶ˆè´¹è€…åŒ¹é…æ¡ä»¶
   - then: æä¾›è€…è¿‡æ»¤æ¡ä»¶

2. æ‰§è¡Œæµç¨‹
   - æ£€æŸ¥whenæ¡ä»¶æ˜¯å¦åŒ¹é…æ¶ˆè´¹è€…
   - å¦‚æœåŒ¹é…ï¼Œåº”ç”¨thenæ¡ä»¶è¿‡æ»¤æä¾›è€…
   - è¿”å›è¿‡æ»¤åçš„Invokeråˆ—è¡¨

3. å¸¸ç”¨è§„åˆ™
   - é»‘ç™½åå•ï¼šhost = 192.168.1.1
   - è¯»å†™åˆ†ç¦»ï¼šmethod = get* => host = read-server
   - åº”ç”¨éš”ç¦»ï¼šapplication = app1 => host = app1-server

4. ä¼˜å…ˆçº§
   - å¤šä¸ªRouteræŒ‰priorityæ’åº
   - æ•°å€¼è¶Šå°ä¼˜å…ˆçº§è¶Šé«˜
```

### 7.2 æºç é˜…è¯»è¦ç‚¹

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  é›†ç¾¤å®¹é”™æºç é˜…è¯»è·¯çº¿                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                             â”‚
â”‚  å…¥å£ï¼šAbstractClusterInvoker.invoke()                      â”‚
â”‚    â”‚                                                        â”‚
â”‚    â”œâ”€â”€ Directory.list() è·å–Invokeråˆ—è¡¨                     â”‚
â”‚    â”‚     â””â”€â”€ RouterChain.route() è·¯ç”±è¿‡æ»¤                   â”‚
â”‚    â”‚                                                        â”‚
â”‚    â”œâ”€â”€ LoadBalance.select() è´Ÿè½½å‡è¡¡é€‰æ‹©                    â”‚
â”‚    â”‚                                                        â”‚
â”‚    â””â”€â”€ doInvoke() å…·ä½“å®¹é”™ç­–ç•¥                              â”‚
â”‚          â”œâ”€â”€ FailoverClusterInvoker é‡è¯•                    â”‚
â”‚          â”œâ”€â”€ FailfastClusterInvoker å¿«é€Ÿå¤±è´¥                â”‚
â”‚          â”œâ”€â”€ FailsafeClusterInvoker å¤±è´¥å®‰å…¨                â”‚
â”‚          â”œâ”€â”€ FailbackClusterInvoker åå°é‡è¯•                â”‚
â”‚          â”œâ”€â”€ ForkingClusterInvoker å¹¶è¡Œè°ƒç”¨                 â”‚
â”‚          â””â”€â”€ BroadcastClusterInvoker å¹¿æ’­è°ƒç”¨               â”‚
â”‚                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 7.3 é…ç½®ç¤ºä¾‹

```java
/**
 * é›†ç¾¤å®¹é”™é…ç½®
 */
// æœåŠ¡çº§åˆ«é…ç½®
@DubboReference(cluster = "failfast")
private UserService userService;

// æ–¹æ³•çº§åˆ«é…ç½®
@DubboReference(methods = {
    @Method(name = "save", cluster = "failfast"),
    @Method(name = "query", cluster = "failover", retries = 3)
})
private UserService userService;

// è·¯ç”±è§„åˆ™é…ç½®
// host != 192.168.1.100 => host != 192.168.1.100
// method = get*,list* => host = 192.168.1.1,192.168.1.2
```

---

## ğŸ“š æ€»ç»“

### æ ¸å¿ƒè¦ç‚¹

```
1. Clusteræ¥å£å®šä¹‰é›†ç¾¤å®¹é”™
   - join()æ–¹æ³•å°†å¤šä¸ªInvokeråˆå¹¶
   - ä¸åŒç­–ç•¥å¤„ç†å¤±è´¥åœºæ™¯

2. AbstractClusterInvokeræä¾›åŸºç¡€å®ç°
   - è·å–Invokeråˆ—è¡¨
   - è´Ÿè½½å‡è¡¡é€‰æ‹©
   - ç²˜æ»è¿æ¥æ”¯æŒ

3. å…­ç§ä¸»è¦å®¹é”™ç­–ç•¥
   - Failover: å¤±è´¥é‡è¯•ï¼ˆé»˜è®¤ï¼‰
   - Failfast: å¿«é€Ÿå¤±è´¥
   - Failsafe: å¤±è´¥å®‰å…¨
   - Failback: åå°é‡è¯•
   - Forking: å¹¶è¡Œè°ƒç”¨
   - Broadcast: å¹¿æ’­è°ƒç”¨

4. Directoryç»´æŠ¤æœåŠ¡æä¾›è€…
   - ç›‘å¬æ³¨å†Œä¸­å¿ƒå˜åŒ–
   - åº”ç”¨è·¯ç”±è§„åˆ™è¿‡æ»¤

5. Routerå®ç°è·¯ç”±è§„åˆ™
   - æ¡ä»¶è·¯ç”±æ”¯æŒå¤æ‚è§„åˆ™
   - æ”¯æŒé»‘ç™½åå•ã€è¯»å†™åˆ†ç¦»ç­‰
```

---

**ç›¸å…³æ–‡æ¡£**ï¼š
- [SPIæœºåˆ¶æºç è§£æ](./SPIæœºåˆ¶æºç è§£æ.md)
- [æœåŠ¡æš´éœ²æºç è§£æ](./æœåŠ¡æš´éœ²æºç è§£æ.md)
- [æœåŠ¡å¼•ç”¨æºç è§£æ](./æœåŠ¡å¼•ç”¨æºç è§£æ.md)
- [è´Ÿè½½å‡è¡¡æºç è§£æ](./è´Ÿè½½å‡è¡¡æºç è§£æ.md)
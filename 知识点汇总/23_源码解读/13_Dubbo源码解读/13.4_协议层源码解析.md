# Dubboåè®®å±‚æºç è§£æ

> ğŸ’¡ æ·±å…¥ç†è§£Dubboåè®®å®ç°å’Œç½‘ç»œé€šä¿¡æœºåˆ¶

---

## ğŸ“š ç›®å½•

1. [åè®®å±‚æ¦‚è¿°](#1-åè®®å±‚æ¦‚è¿°)
2. [Protocolæ¥å£è®¾è®¡](#2-protocolæ¥å£è®¾è®¡)
3. [DubboProtocolå®ç°](#3-dubboprotocolå®ç°)
4. [ç¼–è§£ç æœºåˆ¶](#4-ç¼–è§£ç æœºåˆ¶)
5. [åºåˆ—åŒ–æœºåˆ¶](#5-åºåˆ—åŒ–æœºåˆ¶)
6. [å¿ƒè·³æœºåˆ¶](#6-å¿ƒè·³æœºåˆ¶)
7. [é¢è¯•è¦ç‚¹](#7-é¢è¯•è¦ç‚¹)

---

## 1. åè®®å±‚æ¦‚è¿°

### 1.1 åè®®æ ˆæ¶æ„

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  Dubboåè®®æ ˆ                                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                             â”‚
â”‚  åº”ç”¨å±‚    â”‚ RPCè°ƒç”¨                                         â”‚
â”‚           â”‚                                                â”‚
â”‚  åè®®å±‚    â”‚ Dubbo Protocol                                 â”‚
â”‚           â”‚ â”œâ”€â”€ è¯·æ±‚/å“åº”æ¨¡å‹                                â”‚
â”‚           â”‚ â”œâ”€â”€ åºåˆ—åŒ–/ååºåˆ—åŒ–                               â”‚
â”‚           â”‚ â””â”€â”€ ç¼–è§£ç                                        â”‚
â”‚           â”‚                                                â”‚
â”‚  ä¼ è¾“å±‚    â”‚ Netty/Mina                                      â”‚
â”‚           â”‚ â”œâ”€â”€ NIOäº‹ä»¶é©±åŠ¨                                  â”‚
â”‚           â”‚ â”œâ”€â”€ è¿æ¥ç®¡ç†                                     â”‚
â”‚           â”‚ â””â”€â”€ å¿ƒè·³æ£€æµ‹                                     â”‚
â”‚           â”‚                                                 â”‚
â”‚  ç½‘ç»œå±‚    â”‚ TCP/UDP                                         â”‚
â”‚                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 1.2 Dubboåè®®ç‰¹ç‚¹

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  Dubboåè®®ç‰¹ç‚¹                               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                             â”‚
â”‚  1. äºŒè¿›åˆ¶åè®®                                               â”‚
â”‚     â”œâ”€â”€ é«˜æ•ˆçš„åºåˆ—åŒ–                                        â”‚
â”‚     â”œâ”€â”€ ç´§å‡‘çš„æ•°æ®æ ¼å¼                                      â”‚
â”‚     â””â”€â”€ å‡å°‘ç½‘ç»œä¼ è¾“                                        â”‚
â”‚                                                             â”‚
â”‚  2. é•¿è¿æ¥                                                   â”‚
â”‚     â”œâ”€â”€ å¤ç”¨TCPè¿æ¥                                         â”‚
â”‚     â”œâ”€â”€ å‡å°‘è¿æ¥å¼€é”€                                        â”‚
â”‚     â””â”€â”€ æ”¯æŒå¿ƒè·³æ£€æµ‹                                        â”‚
â”‚                                                             â”‚
â”‚  3. å¼‚æ­¥é€šä¿¡                                                 â”‚
â”‚     â”œâ”€â”€ è¯·æ±‚/å“åº”åˆ†ç¦»                                       â”‚
â”‚     â”œâ”€â”€ æ”¯æŒå¼‚æ­¥è°ƒç”¨                                        â”‚
â”‚     â””â”€â”€ æé«˜å¹¶å‘æ€§èƒ½                                        â”‚
â”‚                                                             â”‚
â”‚  4. å¤šç§åºåˆ—åŒ–                                               â”‚
â”‚     â”œâ”€â”€ Hessian2ï¼ˆé»˜è®¤ï¼‰                                    â”‚
â”‚     â”œâ”€â”€ FastJson                                            â”‚
â”‚     â”œâ”€â”€ Kryo                                                â”‚
â”‚     â””â”€â”€ Protobuf                                            â”‚
â”‚                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 2. Protocolæ¥å£è®¾è®¡

### 2.1 Protocolæ¥å£

```java
/**
 * Protocol - åè®®æ¥å£
 */
@SPI("dubbo")
public interface Protocol {
    
    /**
     * è·å–é»˜è®¤ç«¯å£
     */
    int getDefaultPort();
    
    /**
     * ğŸ”¥ æš´éœ²æœåŠ¡
     * @param invoker æœåŠ¡è°ƒç”¨è€…
     * @return æœåŠ¡æš´éœ²è€…
     */
    @Adaptive
    <T> Exporter<T> export(Invoker<T> invoker) throws RpcException;
    
    /**
     * ğŸ”¥ å¼•ç”¨æœåŠ¡
     * @param type æœåŠ¡æ¥å£
     * @param url æœåŠ¡URL
     * @return æœåŠ¡è°ƒç”¨è€…
     */
    @Adaptive
    <T> Invoker<T> refer(Class<T> type, URL url) throws RpcException;
    
    /**
     * é”€æ¯åè®®
     */
    void destroy();
}
```

### 2.2 AbstractProtocol

```java
/**
 * AbstractProtocol - åè®®æŠ½è±¡åŸºç±»
 */
public abstract class AbstractProtocol implements Protocol {
    
    // ğŸ”¥ æœåŠ¡æš´éœ²è€…ç¼“å­˜
    protected final Map<String, Exporter<?>> exporterMap = 
        new ConcurrentHashMap<>();
    
    // ğŸ”¥ æœåŠ¡å¼•ç”¨è€…ç¼“å­˜
    protected final Set<Invoker<?>> invokers = ConcurrentHashMap.newKeySet();
    
    protected static String serviceKey(URL url) {
        int port = url.getParameter(BIND_PORT_KEY, url.getPort());
        return serviceKey(port, url.getPath(), url.getParameter(VERSION_KEY),
            url.getParameter(GROUP_KEY));
    }
    
    protected static String serviceKey(int port, String serviceName, 
            String serviceVersion, String serviceGroup) {
        return ProtocolUtils.serviceKey(port, serviceName, serviceVersion, serviceGroup);
    }
    
    @Override
    public void destroy() {
        // ğŸ”¥ å–æ¶ˆæš´éœ²æ‰€æœ‰æœåŠ¡
        for (Exporter<?> exporter : exporterMap.values()) {
            if (exporter != null) {
                try {
                    exporter.unexport();
                } catch (Throwable t) {
                    logger.warn(t.getMessage(), t);
                }
            }
        }
        exporterMap.clear();
        
        // ğŸ”¥ é”€æ¯æ‰€æœ‰å¼•ç”¨
        for (Invoker<?> invoker : invokers) {
            if (invoker != null) {
                try {
                    invoker.destroy();
                } catch (Throwable t) {
                    logger.warn(t.getMessage(), t);
                }
            }
        }
        invokers.clear();
    }
}
```

---

## 3. DubboProtocolå®ç°

### 3.1 DubboProtocolç±»ç»“æ„

```java
/**
 * DubboProtocol - Dubboåè®®å®ç°
 */
public class DubboProtocol extends AbstractProtocol {
    
    public static final String NAME = "dubbo";
    public static final int DEFAULT_PORT = 20880;
    
    // ğŸ”¥ æœåŠ¡ç«¯Serverç¼“å­˜
    private final Map<String, ExchangeServer> serverMap = new ConcurrentHashMap<>();
    
    // ğŸ”¥ å®¢æˆ·ç«¯Clientç¼“å­˜
    private final Map<String, ReferenceCountExchangeClient> referenceClientMap = 
        new ConcurrentHashMap<>();
    
    // ğŸ”¥ æ‡’è¿æ¥Clientç¼“å­˜
    private final ConcurrentMap<String, LazyConnectExchangeClient> ghostClientMap = 
        new ConcurrentHashMap<>();
    
    // ğŸ”¥ å®¢æˆ·ç«¯é”
    private final Set<String> clientLock = new ConcurrentHashSet<>();
    
    // åºåˆ—åŒ–ä¼˜åŒ–å™¨
    private ExchangeHandler requestHandler = new ExchangeHandlerAdapter() {
        
        @Override
        public CompletableFuture<Object> reply(ExchangeChannel channel, Object message) 
                throws RemotingException {
            
            if (!(message instanceof Invocation)) {
                throw new RemotingException(channel, "...");
            }
            
            Invocation inv = (Invocation) message;
            
            // ğŸ”¥ è·å–Invoker
            Invoker<?> invoker = getInvoker(channel, inv);
            
            // å¤„ç†å›è°ƒ
            if (Boolean.TRUE.toString().equals(
                    inv.getObjectAttachments().get(IS_CALLBACK_SERVICE_INVOKE))) {
                // ...
            }
            
            RpcContext.getContext().setRemoteAddress(channel.getRemoteAddress());
            
            // ğŸ”¥ æ‰§è¡Œè°ƒç”¨
            Result result = invoker.invoke(inv);
            
            return result.thenApply(Function.identity());
        }
        
        @Override
        public void received(Channel channel, Object message) throws RemotingException {
            if (message instanceof Invocation) {
                reply((ExchangeChannel) channel, message);
            } else {
                super.received(channel, message);
            }
        }
        
        @Override
        public void connected(Channel channel) throws RemotingException {
            invoke(channel, ON_CONNECT_KEY);
        }
        
        @Override
        public void disconnected(Channel channel) throws RemotingException {
            invoke(channel, ON_DISCONNECT_KEY);
        }
    };
    
    @Override
    public int getDefaultPort() {
        return DEFAULT_PORT;
    }
}
```

### 3.2 æœåŠ¡æš´éœ²

```java
/**
 * ğŸ”¥ æš´éœ²æœåŠ¡
 */
@Override
public <T> Exporter<T> export(Invoker<T> invoker) throws RpcException {
    URL url = invoker.getUrl();
    
    // 1. è·å–æœåŠ¡æ ‡è¯†
    String key = serviceKey(url);
    
    // 2. ğŸ”¥ åˆ›å»ºDubboExporter
    DubboExporter<T> exporter = new DubboExporter<T>(invoker, key, exporterMap);
    exporterMap.put(key, exporter);
    
    // 3. æœ¬åœ°å­˜æ ¹ç›¸å…³å¤„ç†
    Boolean isStubSupportEvent = url.getParameter(STUB_EVENT_KEY, DEFAULT_STUB_EVENT);
    Boolean isCallbackservice = url.getParameter(IS_CALLBACK_SERVICE, false);
    if (isStubSupportEvent && !isCallbackservice) {
        String stubServiceMethods = url.getParameter(STUB_EVENT_METHODS_KEY);
        if (stubServiceMethods == null || stubServiceMethods.length() == 0) {
            // ...
        }
    }
    
    // 4. ğŸ”¥ å¯åŠ¨æœåŠ¡ç«¯Server
    openServer(url);
    
    // 5. ä¼˜åŒ–åºåˆ—åŒ–
    optimizeSerialization(url);
    
    return exporter;
}

/**
 * ğŸ”¥ å¯åŠ¨Server
 */
private void openServer(URL url) {
    String key = url.getAddress();
    boolean isServer = url.getParameter(IS_SERVER_KEY, true);
    
    if (isServer) {
        ExchangeServer server = serverMap.get(key);
        if (server == null) {
            synchronized (this) {
                server = serverMap.get(key);
                if (server == null) {
                    // ğŸ”¥ åˆ›å»ºServer
                    serverMap.put(key, createServer(url));
                }
            }
        } else {
            // é‡ç½®Serveré…ç½®
            server.reset(url);
        }
    }
}

/**
 * ğŸ”¥ åˆ›å»ºServer
 */
private ExchangeServer createServer(URL url) {
    // æ·»åŠ é»˜è®¤å‚æ•°
    url = URLBuilder.from(url)
        .addParameterIfAbsent(CHANNEL_READONLYEVENT_SENT_KEY, Boolean.TRUE.toString())
        .addParameterIfAbsent(HEARTBEAT_KEY, String.valueOf(DEFAULT_HEARTBEAT))
        .addParameter(CODEC_KEY, DubboCodec.NAME)
        .build();
    
    // è·å–Serverç±»å‹ï¼Œé»˜è®¤netty
    String str = url.getParameter(SERVER_KEY, DEFAULT_REMOTING_SERVER);
    
    if (str != null && str.length() > 0 && 
            !ExtensionLoader.getExtensionLoader(Transporter.class).hasExtension(str)) {
        throw new RpcException("Unsupported server type: " + str);
    }
    
    ExchangeServer server;
    try {
        // ğŸ”¥ ç»‘å®šç«¯å£ï¼Œå¯åŠ¨Server
        server = Exchangers.bind(url, requestHandler);
    } catch (RemotingException e) {
        throw new RpcException("Fail to start server...");
    }
    
    // æ£€æŸ¥å®¢æˆ·ç«¯ç±»å‹
    str = url.getParameter(CLIENT_KEY);
    if (str != null && str.length() > 0) {
        Set<String> supportedTypes = ExtensionLoader
            .getExtensionLoader(Transporter.class).getSupportedExtensions();
        if (!supportedTypes.contains(str)) {
            throw new RpcException("Unsupported client type: " + str);
        }
    }
    
    return server;
}
```

### 3.3 æœåŠ¡å¼•ç”¨

```java
/**
 * ğŸ”¥ å¼•ç”¨æœåŠ¡
 */
@Override
public <T> Invoker<T> refer(Class<T> serviceType, URL url) throws RpcException {
    optimizeSerialization(url);
    
    // ğŸ”¥ åˆ›å»ºDubboInvoker
    DubboInvoker<T> invoker = new DubboInvoker<T>(serviceType, url, 
        getClients(url), invokers);
    invokers.add(invoker);
    
    return invoker;
}

/**
 * ğŸ”¥ è·å–å®¢æˆ·ç«¯è¿æ¥
 */
private ExchangeClient[] getClients(URL url) {
    // æ˜¯å¦å…±äº«è¿æ¥
    boolean useShareConnect = false;
    
    // è¿æ¥æ•°
    int connections = url.getParameter(CONNECTIONS_KEY, 0);
    List<ReferenceCountExchangeClient> shareClients = null;
    
    if (connections == 0) {
        useShareConnect = true;
        
        // è·å–å…±äº«è¿æ¥æ•°
        String shareConnectionsStr = url.getParameter(SHARE_CONNECTIONS_KEY, (String) null);
        connections = Integer.parseInt(StringUtils.isBlank(shareConnectionsStr) ? 
            ConfigUtils.getProperty(SHARE_CONNECTIONS_KEY, DEFAULT_SHARE_CONNECTIONS) : 
            shareConnectionsStr);
        shareClients = getSharedClient(url, connections);
    }
    
    ExchangeClient[] clients = new ExchangeClient[connections];
    for (int i = 0; i < clients.length; i++) {
        if (useShareConnect) {
            clients[i] = shareClients.get(i);
        } else {
            // ğŸ”¥ åˆ›å»ºç‹¬ç«‹è¿æ¥
            clients[i] = initClient(url);
        }
    }
    
    return clients;
}

/**
 * ğŸ”¥ åˆå§‹åŒ–å®¢æˆ·ç«¯
 */
private ExchangeClient initClient(URL url) {
    // è·å–å®¢æˆ·ç«¯ç±»å‹
    String str = url.getParameter(CLIENT_KEY, url.getParameter(SERVER_KEY, DEFAULT_REMOTING_CLIENT));
    
    url = url.addParameter(CODEC_KEY, DubboCodec.NAME);
    url = url.addParameterIfAbsent(HEARTBEAT_KEY, String.valueOf(DEFAULT_HEARTBEAT));
    
    // æ£€æŸ¥å®¢æˆ·ç«¯ç±»å‹
    if (str != null && str.length() > 0 && 
            !ExtensionLoader.getExtensionLoader(Transporter.class).hasExtension(str)) {
        throw new RpcException("Unsupported client type: " + str);
    }
    
    ExchangeClient client;
    try {
        // ğŸ”¥ æ˜¯å¦æ‡’è¿æ¥
        if (url.getParameter(LAZY_CONNECT_KEY, false)) {
            client = new LazyConnectExchangeClient(url, requestHandler);
        } else {
            client = Exchangers.connect(url, requestHandler);
        }
        
    } catch (RemotingException e) {
        throw new RpcException("Fail to create remoting client for service...");
    }
    
    return client;
}
```

---

## 4. ç¼–è§£ç æœºåˆ¶

### 4.1 Dubboåè®®æ ¼å¼

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  Dubboåè®®æ ¼å¼                               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                             â”‚
â”‚  0         1         2         3         4                  â”‚
â”‚  0123456789012345678901234567890123456789                   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”               â”‚
â”‚  â”‚ magic â”‚flagâ”‚ status â”‚    request id     â”‚               â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤               â”‚
â”‚  â”‚              data length                â”‚               â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤               â”‚
â”‚  â”‚                                         â”‚               â”‚
â”‚  â”‚              data bytes                 â”‚               â”‚
â”‚  â”‚                                         â”‚               â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜               â”‚
â”‚                                                             â”‚
â”‚  å­—æ®µè¯´æ˜ï¼š                                                  â”‚
â”‚  - magic: é­”æ•°ï¼Œ0xdabb                                      â”‚
â”‚  - flag: æ ‡å¿—ä½                                             â”‚
â”‚    â”œâ”€â”€ bit 7: 1=request, 0=response                        â”‚
â”‚    â”œâ”€â”€ bit 6: 1=two way, 0=one way                         â”‚
â”‚    â”œâ”€â”€ bit 5: 1=event, 0=normal                            â”‚
â”‚    â””â”€â”€ bit 0-4: åºåˆ—åŒ–ç±»å‹                                 â”‚
â”‚  - status: å“åº”çŠ¶æ€                                         â”‚
â”‚  - request id: è¯·æ±‚ID                                       â”‚
â”‚  - data length: æ•°æ®é•¿åº¦                                    â”‚
â”‚  - data bytes: æ•°æ®å†…å®¹                                     â”‚
â”‚                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 4.2 DubboCodec

```java
/**
 * DubboCodec - Dubboç¼–è§£ç å™¨
 */
public class DubboCodec extends ExchangeCodec {
    
    public static final String NAME = "dubbo";
    public static final String DUBBO_VERSION_KEY = "dubbo";
    public static final String DEFAULT_DUBBO_VERSION = "2.0.2";
    
    // ğŸ”¥ åè®®å¤´é•¿åº¦
    protected static final int HEADER_LENGTH = 16;
    
    // ğŸ”¥ é­”æ•°
    protected static final short MAGIC = (short) 0xdabb;
    protected static final byte MAGIC_HIGH = Bytes.short2bytes(MAGIC)[0];
    protected static final byte MAGIC_LOW = Bytes.short2bytes(MAGIC)[1];
    
    // ğŸ”¥ æ ‡å¿—ä½
    protected static final byte FLAG_REQUEST = (byte) 0x80;
    protected static final byte FLAG_TWOWAY = (byte) 0x40;
    protected static final byte FLAG_EVENT = (byte) 0x20;
    protected static final int SERIALIZATION_MASK = 0x1f;
    
    @Override
    protected Object decodeBody(Channel channel, InputStream is, byte[] header) 
            throws IOException {
        
        byte flag = header[2], proto = (byte) (flag & SERIALIZATION_MASK);
        
        // ğŸ”¥ è·å–åºåˆ—åŒ–å™¨
        Serialization s = CodecSupport.getSerialization(channel.getUrl(), proto);
        
        // è·å–è¯·æ±‚ID
        long id = Bytes.bytes2long(header, 4);
        
        // ğŸ”¥ è§£ç å“åº”
        if ((flag & FLAG_REQUEST) == 0) {
            Response res = new Response(id);
            if ((flag & FLAG_EVENT) != 0) {
                res.setEvent(true);
            }
            
            // è·å–çŠ¶æ€
            byte status = header[3];
            res.setStatus(status);
            
            try {
                if (status == Response.OK) {
                    Object data;
                    if (res.isEvent()) {
                        // äº‹ä»¶æ•°æ®
                        ObjectInput in = s.deserialize(channel.getUrl(), is);
                        data = decodeEventData(channel, in);
                    } else {
                        // ğŸ”¥ è§£ç å“åº”æ•°æ®
                        DecodeableRpcResult result = new DecodeableRpcResult(channel, res, is,
                            (Invocation) getRequestData(id), proto);
                        
                        if (channel.getUrl().getParameter(DECODE_IN_IO_THREAD_KEY, DEFAULT_DECODE_IN_IO_THREAD)) {
                            result.decode();
                        }
                        data = result;
                    }
                    res.setResult(data);
                } else {
                    // é”™è¯¯å“åº”
                    ObjectInput in = s.deserialize(channel.getUrl(), is);
                    res.setErrorMessage(in.readUTF());
                }
            } catch (Throwable t) {
                res.setStatus(Response.CLIENT_ERROR);
                res.setErrorMessage(StringUtils.toString(t));
            }
            return res;
            
        } else {
            // ğŸ”¥ è§£ç è¯·æ±‚
            Request req = new Request(id);
            req.setVersion(Version.getProtocolVersion());
            req.setTwoWay((flag & FLAG_TWOWAY) != 0);
            
            if ((flag & FLAG_EVENT) != 0) {
                req.setEvent(true);
            }
            
            try {
                Object data;
                if (req.isEvent()) {
                    // äº‹ä»¶æ•°æ®
                    ObjectInput in = s.deserialize(channel.getUrl(), is);
                    data = decodeEventData(channel, in);
                } else {
                    // ğŸ”¥ è§£ç è¯·æ±‚æ•°æ®
                    DecodeableRpcInvocation inv = new DecodeableRpcInvocation(channel, req, is, proto);
                    
                    if (channel.getUrl().getParameter(DECODE_IN_IO_THREAD_KEY, DEFAULT_DECODE_IN_IO_THREAD)) {
                        inv.decode();
                    }
                    data = inv;
                }
                req.setData(data);
            } catch (Throwable t) {
                req.setBroken(true);
                req.setData(t);
            }
            
            return req;
        }
    }
    
    @Override
    protected void encodeRequestData(Channel channel, ObjectOutput out, Object data, String version) 
            throws IOException {
        
        RpcInvocation inv = (RpcInvocation) data;
        
        // ğŸ”¥ å†™å…¥Dubboç‰ˆæœ¬
        out.writeUTF(version);
        
        // ğŸ”¥ å†™å…¥æœåŠ¡è·¯å¾„
        out.writeUTF(inv.getAttachment(PATH_KEY));
        
        // ğŸ”¥ å†™å…¥æœåŠ¡ç‰ˆæœ¬
        out.writeUTF(inv.getAttachment(VERSION_KEY));
        
        // ğŸ”¥ å†™å…¥æ–¹æ³•å
        out.writeUTF(inv.getMethodName());
        
        // ğŸ”¥ å†™å…¥å‚æ•°ç±»å‹
        out.writeUTF(inv.getParameterTypesDesc());
        
        Object[] args = inv.getArguments();
        if (args != null) {
            // ğŸ”¥ å†™å…¥å‚æ•°å€¼
            for (int i = 0; i < args.length; i++) {
                out.writeObject(encodeInvocationArgument(channel, inv, i));
            }
        }
        
        // ğŸ”¥ å†™å…¥é™„åŠ ä¿¡æ¯
        out.writeAttachments(inv.getObjectAttachments());
    }
    
    @Override
    protected void encodeResponseData(Channel channel, ObjectOutput out, Object data, String version) 
            throws IOException {
        
        Result result = (Result) data;
        
        // æ£€æŸ¥æ˜¯å¦æœ‰å¼‚å¸¸
        boolean hasException = result.hasException();
        
        if (hasException) {
            // ğŸ”¥ å†™å…¥å¼‚å¸¸æ ‡è¯†å’Œå¼‚å¸¸å¯¹è±¡
            out.writeByte(RESPONSE_WITH_EXCEPTION);
            out.writeThrowable(result.getException());
        } else {
            Object ret = result.getValue();
            if (ret == null) {
                // ğŸ”¥ å†™å…¥ç©ºå€¼æ ‡è¯†
                out.writeByte(RESPONSE_NULL_VALUE);
            } else {
                // ğŸ”¥ å†™å…¥æ­£å¸¸å€¼æ ‡è¯†å’Œè¿”å›å€¼
                out.writeByte(RESPONSE_VALUE);
                out.writeObject(ret);
            }
        }
        
        // ğŸ”¥ å†™å…¥é™„åŠ ä¿¡æ¯
        out.writeAttachments(result.getObjectAttachments());
    }
}
```
---

## 5. åºåˆ—åŒ–æœºåˆ¶

### 5.1 Serializationæ¥å£

```java
/**
 * Serialization - åºåˆ—åŒ–æ¥å£
 */
@SPI("hessian2")
public interface Serialization {
    
    /**
     * è·å–å†…å®¹ç±»å‹ID
     */
    byte getContentTypeId();
    
    /**
     * è·å–å†…å®¹ç±»å‹
     */
    String getContentType();
    
    /**
     * ğŸ”¥ åˆ›å»ºåºåˆ—åŒ–å™¨
     */
    @Adaptive
    ObjectOutput serialize(URL url, OutputStream output) throws IOException;
    
    /**
     * ğŸ”¥ åˆ›å»ºååºåˆ—åŒ–å™¨
     */
    @Adaptive
    ObjectInput deserialize(URL url, InputStream input) throws IOException;
}
```

### 5.2 Hessian2åºåˆ—åŒ–

```java
/**
 * Hessian2Serialization - Hessian2åºåˆ—åŒ–ï¼ˆé»˜è®¤ï¼‰
 */
public class Hessian2Serialization implements Serialization {
    
    public static final byte ID = 2;
    
    @Override
    public byte getContentTypeId() {
        return ID;
    }
    
    @Override
    public String getContentType() {
        return "x-application/hessian2";
    }
    
    @Override
    public ObjectOutput serialize(URL url, OutputStream out) throws IOException {
        return new Hessian2ObjectOutput(out);
    }
    
    @Override
    public ObjectInput deserialize(URL url, InputStream is) throws IOException {
        return new Hessian2ObjectInput(is);
    }
}

/**
 * Hessian2ObjectOutput - Hessian2åºåˆ—åŒ–è¾“å‡º
 */
public class Hessian2ObjectOutput implements ObjectOutput {
    
    private final Hessian2Output mH2o;
    
    public Hessian2ObjectOutput(OutputStream os) {
        mH2o = new Hessian2Output(os);
        mH2o.setSerializerFactory(Hessian2SerializerFactory.SERIALIZER_FACTORY);
    }
    
    @Override
    public void writeBool(boolean v) throws IOException {
        mH2o.writeBoolean(v);
    }
    
    @Override
    public void writeByte(byte v) throws IOException {
        mH2o.writeInt(v);
    }
    
    @Override
    public void writeShort(short v) throws IOException {
        mH2o.writeInt(v);
    }
    
    @Override
    public void writeInt(int v) throws IOException {
        mH2o.writeInt(v);
    }
    
    @Override
    public void writeLong(long v) throws IOException {
        mH2o.writeLong(v);
    }
    
    @Override
    public void writeFloat(float v) throws IOException {
        mH2o.writeDouble(v);
    }
    
    @Override
    public void writeDouble(double v) throws IOException {
        mH2o.writeDouble(v);
    }
    
    @Override
    public void writeUTF(String v) throws IOException {
        mH2o.writeString(v);
    }
    
    @Override
    public void writeBytes(byte[] v) throws IOException {
        mH2o.writeBytes(v);
    }
    
    @Override
    public void writeBytes(byte[] v, int off, int len) throws IOException {
        mH2o.writeBytes(v, off, len);
    }
    
    @Override
    public void writeObject(Object obj) throws IOException {
        mH2o.writeObject(obj);
    }
    
    @Override
    public void flushBuffer() throws IOException {
        mH2o.flushBuffer();
    }
}
```

### 5.3 åºåˆ—åŒ–æ€§èƒ½å¯¹æ¯”

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  åºåˆ—åŒ–æ€§èƒ½å¯¹æ¯”                              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  åºåˆ—åŒ–æ–¹å¼    â”‚ æ€§èƒ½    â”‚ å¤§å°    â”‚ å…¼å®¹æ€§  â”‚ æ˜“ç”¨æ€§    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Hessian2     â”‚ ä¸­ç­‰    â”‚ ä¸­ç­‰    â”‚ å¥½      â”‚ å¥½        â”‚
â”‚  FastJson     â”‚ å¿«      â”‚ å¤§      â”‚ ä¸€èˆ¬    â”‚ å¥½        â”‚
â”‚  Kryo         â”‚ å¾ˆå¿«    â”‚ å°      â”‚ å·®      â”‚ ä¸€èˆ¬      â”‚
â”‚  Protobuf     â”‚ å¿«      â”‚ å¾ˆå°    â”‚ å¥½      â”‚ å¤æ‚      â”‚
â”‚  FST          â”‚ å¾ˆå¿«    â”‚ å°      â”‚ å·®      â”‚ ä¸€èˆ¬      â”‚
â”‚  JavaåŸç”Ÿ     â”‚ æ…¢      â”‚ å¤§      â”‚ å¥½      â”‚ å¥½        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 6. å¿ƒè·³æœºåˆ¶

### 6.1 å¿ƒè·³æ£€æµ‹åŸç†

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  å¿ƒè·³æ£€æµ‹æœºåˆ¶                                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                             â”‚
â”‚  Client                           Server                    â”‚
â”‚    â”‚                               â”‚                       â”‚
â”‚    â”‚ â”€â”€â”€â”€â”€â”€â”€â”€ Request â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ â”‚                       â”‚
â”‚    â”‚ â—€â”€â”€â”€â”€â”€â”€â”€ Response â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ â”‚                       â”‚
â”‚    â”‚                               â”‚                       â”‚
â”‚    â”‚ â”€â”€â”€â”€â”€â”€â”€â”€ Heartbeat â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ â”‚ (60sé—´éš”)             â”‚
â”‚    â”‚ â—€â”€â”€â”€â”€â”€â”€â”€ Heartbeat â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ â”‚                       â”‚
â”‚    â”‚                               â”‚                       â”‚
â”‚    â”‚         (è¶…æ—¶æ£€æµ‹)             â”‚                       â”‚
â”‚    â”‚                               â”‚                       â”‚
â”‚    â”‚ â”€â”€â”€â”€â”€â”€â”€â”€ Heartbeat â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ â”‚                       â”‚
â”‚    â”‚           (è¶…æ—¶)               â”‚                       â”‚
â”‚    â”‚                               â”‚                       â”‚
â”‚    â”‚ â”€â”€â”€â”€â”€â”€â”€â”€ Reconnect â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ â”‚                       â”‚
â”‚    â”‚ â—€â”€â”€â”€â”€â”€â”€â”€ Connected â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ â”‚                       â”‚
â”‚                                                             â”‚
â”‚  é…ç½®å‚æ•°ï¼š                                                  â”‚
â”‚  - heartbeat: å¿ƒè·³é—´éš”ï¼ˆé»˜è®¤60sï¼‰                           â”‚
â”‚  - heartbeat.timeout: å¿ƒè·³è¶…æ—¶ï¼ˆé»˜è®¤heartbeat*3ï¼‰           â”‚
â”‚                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 6.2 HeartbeatHandler

```java
/**
 * HeartbeatHandler - å¿ƒè·³å¤„ç†å™¨
 */
@Sharable
public class HeartbeatHandler extends ChannelDuplexHandler {
    
    private static final Logger logger = LoggerFactory.getLogger(HeartbeatHandler.class);
    
    public static final String KEY_READ_TIMESTAMP = "READ_TIMESTAMP";
    public static final String KEY_WRITE_TIMESTAMP = "WRITE_TIMESTAMP";
    
    @Override
    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
        // ğŸ”¥ æ›´æ–°è¯»å–æ—¶é—´æˆ³
        setReadTimestamp(ctx.channel());
        
        if (isHeartbeatRequest(msg)) {
            // ğŸ”¥ å¤„ç†å¿ƒè·³è¯·æ±‚
            Request req = (Request) msg;
            if (req.isTwoWay()) {
                Response res = new Response(req.getId(), req.getVersion());
                res.setEvent(Response.HEARTBEAT_EVENT);
                ctx.writeAndFlush(res);
            }
            return;
        }
        
        if (isHeartbeatResponse(msg)) {
            // ğŸ”¥ å¤„ç†å¿ƒè·³å“åº”
            return;
        }
        
        ctx.fireChannelRead(msg);
    }
    
    @Override
    public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) 
            throws Exception {
        // ğŸ”¥ æ›´æ–°å†™å…¥æ—¶é—´æˆ³
        setWriteTimestamp(ctx.channel());
        ctx.write(msg, promise);
    }
    
    private void setReadTimestamp(Channel channel) {
        channel.attr(AttributeKey.valueOf(KEY_READ_TIMESTAMP)).set(System.currentTimeMillis());
    }
    
    private void setWriteTimestamp(Channel channel) {
        channel.attr(AttributeKey.valueOf(KEY_WRITE_TIMESTAMP)).set(System.currentTimeMillis());
    }
    
    private boolean isHeartbeatRequest(Object msg) {
        return msg instanceof Request && ((Request) msg).isHeartbeat();
    }
    
    private boolean isHeartbeatResponse(Object msg) {
        return msg instanceof Response && ((Response) msg).isHeartbeat();
    }
}
```

### 6.3 å¿ƒè·³å®šæ—¶å™¨

```java
/**
 * AbstractClient - æŠ½è±¡å®¢æˆ·ç«¯
 */
public abstract class AbstractClient extends AbstractEndpoint implements Client {
    
    // ğŸ”¥ å¿ƒè·³å®šæ—¶å™¨
    private static final ScheduledThreadPoolExecutor IDLE_CHECK_EXECUTOR = 
        new ScheduledThreadPoolExecutor(2, new NamedThreadFactory("dubbo-client-idleCheck", true));
    
    private ScheduledFuture<?> idleCheckFuture;
    
    public AbstractClient(URL url, ChannelHandler handler) throws RemotingException {
        super(url, handler);
        
        // ğŸ”¥ å¯åŠ¨å¿ƒè·³æ£€æµ‹
        startIdleCheckTask(url);
    }
    
    /**
     * ğŸ”¥ å¯åŠ¨ç©ºé—²æ£€æµ‹ä»»åŠ¡
     */
    private void startIdleCheckTask(URL url) {
        if (!canHandleIdle()) {
            AbstractTimerTask.ChannelProvider cp = () -> getChannels();
            
            int heartbeat = getHeartbeat(url);
            long heartbeatTick = calculateLeastDuration(heartbeat);
            
            this.idleCheckFuture = IDLE_CHECK_EXECUTOR.scheduleWithFixedDelay(
                new IdleCheckTask(cp, heartbeat, heartbeatTick),
                heartbeatTick, heartbeatTick, TimeUnit.MILLISECONDS);
        }
    }
    
    /**
     * ğŸ”¥ ç©ºé—²æ£€æµ‹ä»»åŠ¡
     */
    private static class IdleCheckTask extends AbstractTimerTask {
        
        private final int heartbeat;
        private final long heartbeatTimeoutTick;
        
        IdleCheckTask(ChannelProvider channelProvider, int heartbeat, long heartbeatTimeoutTick) {
            super(channelProvider, heartbeatTimeoutTick);
            this.heartbeat = heartbeat;
            this.heartbeatTimeoutTick = heartbeatTimeoutTick;
        }
        
        @Override
        protected void doTask(Channel channel) {
            try {
                Long lastRead = lastRead(channel);
                Long lastWrite = lastWrite(channel);
                
                if ((lastRead != null && now() - lastRead > heartbeat)
                        || (lastWrite != null && now() - lastWrite > heartbeat)) {
                    
                    Request req = new Request();
                    req.setVersion(Version.getProtocolVersion());
                    req.setTwoWay(true);
                    req.setEvent(Request.HEARTBEAT_EVENT);
                    
                    // ğŸ”¥ å‘é€å¿ƒè·³
                    channel.send(req);
                }
                
                if (lastRead != null && now() - lastRead > heartbeatTimeoutTick) {
                    logger.warn("Close channel " + channel + 
                        " because idleCheck timeout: " + heartbeatTimeoutTick + "ms");
                    
                    // ğŸ”¥ è¶…æ—¶å…³é—­è¿æ¥
                    channel.close();
                }
            } catch (Throwable t) {
                logger.warn("Exception when heartbeat to remote channel " + channel.getRemoteAddress(), t);
            }
        }
    }
}
```

---

## 7. é¢è¯•è¦ç‚¹

### 7.1 é«˜é¢‘é¢è¯•é¢˜

#### Q1: Dubboåè®®çš„ç‰¹ç‚¹ï¼Ÿ

```
Dubboåè®®ç‰¹ç‚¹ï¼š

1. äºŒè¿›åˆ¶åè®®
   - é«˜æ•ˆçš„åºåˆ—åŒ–
   - ç´§å‡‘çš„æ•°æ®æ ¼å¼
   - å‡å°‘ç½‘ç»œä¼ è¾“

2. é•¿è¿æ¥
   - å¤ç”¨TCPè¿æ¥
   - å‡å°‘è¿æ¥å¼€é”€
   - æ”¯æŒå¿ƒè·³æ£€æµ‹

3. å¼‚æ­¥é€šä¿¡
   - è¯·æ±‚/å“åº”åˆ†ç¦»
   - æ”¯æŒå¼‚æ­¥è°ƒç”¨
   - æé«˜å¹¶å‘æ€§èƒ½

4. å¤šç§åºåˆ—åŒ–
   - Hessian2ï¼ˆé»˜è®¤ï¼‰
   - FastJsonã€Kryoç­‰
   - å¯æ’æ‹”è®¾è®¡

5. åè®®å¤´å›ºå®š16å­—èŠ‚
   - é­”æ•°ï¼š0xdabb
   - æ ‡å¿—ä½ï¼šè¯·æ±‚/å“åº”ã€å•åŒå‘ç­‰
   - è¯·æ±‚IDï¼šç”¨äºå¼‚æ­¥åŒ¹é…
   - æ•°æ®é•¿åº¦ï¼šå˜é•¿æ•°æ®
```

#### Q2: Dubboåè®®æ ¼å¼è¯¦è§£ï¼Ÿ

```
Dubboåè®®æ ¼å¼ï¼ˆ16å­—èŠ‚å¤´ + å˜é•¿æ•°æ®ï¼‰ï¼š

0-1å­—èŠ‚ï¼šé­”æ•° 0xdabb
2å­—èŠ‚ï¼šæ ‡å¿—ä½
  - bit 7: 1=request, 0=response
  - bit 6: 1=two way, 0=one way  
  - bit 5: 1=event, 0=normal
  - bit 0-4: åºåˆ—åŒ–ç±»å‹ID

3å­—èŠ‚ï¼šçŠ¶æ€ç ï¼ˆä»…å“åº”ï¼‰
4-11å­—èŠ‚ï¼šè¯·æ±‚IDï¼ˆ8å­—èŠ‚longï¼‰
12-15å­—èŠ‚ï¼šæ•°æ®é•¿åº¦ï¼ˆ4å­—èŠ‚intï¼‰
16+å­—èŠ‚ï¼šåºåˆ—åŒ–æ•°æ®

ä¼˜åŠ¿ï¼š
- å›ºå®šå¤´éƒ¨ä¾¿äºè§£æ
- è¯·æ±‚IDæ”¯æŒå¼‚æ­¥
- åºåˆ—åŒ–ç±»å‹å¯æ‰©å±•
```

#### Q3: Dubboæ”¯æŒå“ªäº›åºåˆ—åŒ–æ–¹å¼ï¼Ÿ

```
Dubboåºåˆ—åŒ–æ–¹å¼ï¼š

1. Hessian2ï¼ˆé»˜è®¤ï¼‰
   - è·¨è¯­è¨€æ”¯æŒ
   - æ€§èƒ½é€‚ä¸­
   - å…¼å®¹æ€§å¥½

2. FastJson
   - JSONæ ¼å¼
   - æ€§èƒ½è¾ƒå¥½
   - å¯è¯»æ€§å¼º

3. Kryo
   - é«˜æ€§èƒ½
   - ä½“ç§¯å°
   - ä¸è·¨è¯­è¨€

4. Protobuf
   - Googleå¼€æº
   - é«˜æ•ˆç´§å‡‘
   - éœ€è¦IDLå®šä¹‰

5. FST
   - é«˜æ€§èƒ½
   - å…¼å®¹Javaåºåˆ—åŒ–
   - ä¸è·¨è¯­è¨€

é€‰æ‹©å»ºè®®ï¼š
- è·¨è¯­è¨€ï¼šHessian2ã€Protobuf
- é«˜æ€§èƒ½ï¼šKryoã€FST
- å¯è¯»æ€§ï¼šFastJson
```

#### Q4: Dubboå¿ƒè·³æœºåˆ¶å¦‚ä½•å·¥ä½œï¼Ÿ

```
Dubboå¿ƒè·³æœºåˆ¶ï¼š

1. å¿ƒè·³é—´éš”
   - é»˜è®¤60ç§’å‘é€ä¸€æ¬¡å¿ƒè·³
   - å¯é€šè¿‡heartbeatå‚æ•°é…ç½®

2. è¶…æ—¶æ£€æµ‹
   - å¿ƒè·³è¶…æ—¶ = heartbeat * 3
   - è¶…æ—¶åå…³é—­è¿æ¥å¹¶é‡è¿

3. å¿ƒè·³æ¶ˆæ¯
   - ç‰¹æ®Šçš„Request/Response
   - Eventæ ‡å¿—ä½ä¸ºtrue
   - æ•°æ®ä¸ºHEARTBEAT_EVENT

4. æ£€æµ‹é€»è¾‘
   - è¯»å†™æ—¶é—´æˆ³è®°å½•
   - å®šæ—¶æ£€æŸ¥ç©ºé—²æ—¶é—´
   - è¶…è¿‡é—´éš”å‘é€å¿ƒè·³
   - è¶…è¿‡è¶…æ—¶å…³é—­è¿æ¥

ä½œç”¨ï¼š
- æ£€æµ‹è¿æ¥å¯ç”¨æ€§
- ä¿æŒé•¿è¿æ¥æ´»è·ƒ
- åŠæ—¶å‘ç°ç½‘ç»œå¼‚å¸¸
```

### 7.2 æºç é˜…è¯»è¦ç‚¹

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  åè®®å±‚æºç é˜…è¯»è·¯çº¿                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                             â”‚
â”‚  Protocolæ¥å£                                               â”‚
â”‚    â”‚                                                        â”‚
â”‚    â”œâ”€â”€ DubboProtocol.export() æœåŠ¡æš´éœ²                      â”‚
â”‚    â”‚     â”œâ”€â”€ createServer() åˆ›å»ºæœåŠ¡å™¨                      â”‚
â”‚    â”‚     â””â”€â”€ Exchangers.bind() ç»‘å®šç«¯å£                     â”‚
â”‚    â”‚                                                        â”‚
â”‚    â””â”€â”€ DubboProtocol.refer() æœåŠ¡å¼•ç”¨                       â”‚
â”‚          â”œâ”€â”€ getClients() è·å–å®¢æˆ·ç«¯                        â”‚
â”‚          â””â”€â”€ Exchangers.connect() å»ºç«‹è¿æ¥                  â”‚
â”‚                                                             â”‚
â”‚  ç¼–è§£ç å±‚                                                    â”‚
â”‚    â”œâ”€â”€ DubboCodec.encode() ç¼–ç                              â”‚
â”‚    â”œâ”€â”€ DubboCodec.decode() è§£ç                              â”‚
â”‚    â””â”€â”€ Serialization åºåˆ—åŒ–                                â”‚
â”‚                                                             â”‚
â”‚  ä¼ è¾“å±‚                                                      â”‚
â”‚    â”œâ”€â”€ NettyTransporter ä¼ è¾“å®ç°                           â”‚
â”‚    â”œâ”€â”€ HeartbeatHandler å¿ƒè·³å¤„ç†                           â”‚
â”‚    â””â”€â”€ IdleCheckTask ç©ºé—²æ£€æµ‹                              â”‚
â”‚                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 7.3 é…ç½®ç¤ºä¾‹

```java
/**
 * åè®®é…ç½®ç¤ºä¾‹
 */
// åè®®é…ç½®
@DubboService(protocol = "dubbo")
public class UserServiceImpl implements UserService {}

// åºåˆ—åŒ–é…ç½®
@DubboService(parameters = {"serialization", "kryo"})
public class UserServiceImpl implements UserService {}

// å¿ƒè·³é…ç½®
@DubboReference(parameters = {
    "heartbeat", "30000",           // 30ç§’å¿ƒè·³
    "heartbeat.timeout", "90000"    // 90ç§’è¶…æ—¶
})
private UserService userService;

// è¿æ¥æ•°é…ç½®
@DubboReference(parameters = {
    "connections", "2",             // 2ä¸ªè¿æ¥
    "share.connections", "1"        // å…±äº«è¿æ¥æ•°
})
private UserService userService;
```

---

## ğŸ“š æ€»ç»“

### æ ¸å¿ƒè¦ç‚¹

```
1. Protocolæ¥å£å®šä¹‰åè®®è§„èŒƒ
   - export()æš´éœ²æœåŠ¡
   - refer()å¼•ç”¨æœåŠ¡
   - æ”¯æŒå¤šç§åè®®å®ç°

2. DubboProtocolæ˜¯é»˜è®¤å®ç°
   - äºŒè¿›åˆ¶åè®®æ ¼å¼
   - é•¿è¿æ¥å¤ç”¨
   - å¼‚æ­¥è¯·æ±‚å“åº”

3. ç¼–è§£ç æœºåˆ¶
   - å›ºå®š16å­—èŠ‚åè®®å¤´
   - å˜é•¿æ•°æ®ä½“
   - æ”¯æŒå¤šç§åºåˆ—åŒ–

4. åºåˆ—åŒ–å¯æ’æ‹”
   - Hessian2é»˜è®¤
   - æ”¯æŒKryoã€Protobufç­‰
   - æ€§èƒ½å’Œå…¼å®¹æ€§æƒè¡¡

5. å¿ƒè·³ä¿æ´»æœºåˆ¶
   - å®šæ—¶å‘é€å¿ƒè·³
   - è¶…æ—¶æ£€æµ‹é‡è¿
   - ä¿è¯è¿æ¥å¯ç”¨æ€§
```

---

**ç›¸å…³æ–‡æ¡£**ï¼š
- [SPIæœºåˆ¶æºç è§£æ](./SPIæœºåˆ¶æºç è§£æ.md)
- [æœåŠ¡æš´éœ²æºç è§£æ](./æœåŠ¡æš´éœ²æºç è§£æ.md)
- [æœåŠ¡å¼•ç”¨æºç è§£æ](./æœåŠ¡å¼•ç”¨æºç è§£æ.md)
- [è´Ÿè½½å‡è¡¡æºç è§£æ](./è´Ÿè½½å‡è¡¡æºç è§£æ.md)
- [é›†ç¾¤å®¹é”™æºç è§£æ](./é›†ç¾¤å®¹é”™æºç è§£æ.md)
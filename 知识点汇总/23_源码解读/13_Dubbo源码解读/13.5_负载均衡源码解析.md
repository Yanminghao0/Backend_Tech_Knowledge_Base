# Dubboè´Ÿè½½å‡è¡¡æºç è§£æ

> ğŸ’¡ æ·±å…¥ç†è§£Dubboå¦‚ä½•åœ¨å¤šä¸ªæœåŠ¡æä¾›è€…ä¹‹é—´åˆ†é…è¯·æ±‚

---

## ğŸ“š ç›®å½•

1. [è´Ÿè½½å‡è¡¡æ¦‚è¿°](#1-è´Ÿè½½å‡è¡¡æ¦‚è¿°)
2. [LoadBalanceæ¥å£](#2-loadbalanceæ¥å£)
3. [éšæœºè´Ÿè½½å‡è¡¡](#3-éšæœºè´Ÿè½½å‡è¡¡)
4. [è½®è¯¢è´Ÿè½½å‡è¡¡](#4-è½®è¯¢è´Ÿè½½å‡è¡¡)
5. [æœ€å°‘æ´»è·ƒæ•°](#5-æœ€å°‘æ´»è·ƒæ•°)
6. [ä¸€è‡´æ€§å“ˆå¸Œ](#6-ä¸€è‡´æ€§å“ˆå¸Œ)
7. [é¢è¯•è¦ç‚¹](#7-é¢è¯•è¦ç‚¹)

---

## 1. è´Ÿè½½å‡è¡¡æ¦‚è¿°

### 1.1 æ•´ä½“æ¶æ„

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  Dubboè´Ÿè½½å‡è¡¡æ¶æ„                           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                             â”‚
â”‚  æ¶ˆè´¹è€…                                                      â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚  ClusterInvoker                                      â”‚   â”‚
â”‚  â”‚      â”‚                                               â”‚   â”‚
â”‚  â”‚      â–¼                                               â”‚   â”‚
â”‚  â”‚  Directory.list() â†’ [Invoker1, Invoker2, Invoker3]  â”‚   â”‚
â”‚  â”‚      â”‚                                               â”‚   â”‚
â”‚  â”‚      â–¼                                               â”‚   â”‚
â”‚  â”‚  LoadBalance.select()                                â”‚   â”‚
â”‚  â”‚      â”‚                                               â”‚   â”‚
â”‚  â”‚      â”œâ”€â”€ Random (éšæœº)                               â”‚   â”‚
â”‚  â”‚      â”œâ”€â”€ RoundRobin (è½®è¯¢)                           â”‚   â”‚
â”‚  â”‚      â”œâ”€â”€ LeastActive (æœ€å°‘æ´»è·ƒ)                      â”‚   â”‚
â”‚  â”‚      â””â”€â”€ ConsistentHash (ä¸€è‡´æ€§å“ˆå¸Œ)                 â”‚   â”‚
â”‚  â”‚      â”‚                                               â”‚   â”‚
â”‚  â”‚      â–¼                                               â”‚   â”‚
â”‚  â”‚  é€‰ä¸­çš„Invoker.invoke()                              â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 1.2 è´Ÿè½½å‡è¡¡ç­–ç•¥

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  è´Ÿè½½å‡è¡¡ç­–ç•¥å¯¹æ¯”                            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  ç­–ç•¥              â”‚ ç‰¹ç‚¹                â”‚ é€‚ç”¨åœºæ™¯         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  random           â”‚ æŒ‰æƒé‡éšæœº          â”‚ é»˜è®¤ï¼Œé€šç”¨       â”‚
â”‚  roundrobin       â”‚ æŒ‰æƒé‡è½®è¯¢          â”‚ è¯·æ±‚å‡åŒ€åˆ†å¸ƒ     â”‚
â”‚  leastactive      â”‚ æœ€å°‘æ´»è·ƒæ•°ä¼˜å…ˆ      â”‚ æ…¢æä¾›è€…å°‘åˆ†é…   â”‚
â”‚  consistenthash   â”‚ ç›¸åŒå‚æ•°åŒä¸€æä¾›è€…  â”‚ æœ‰çŠ¶æ€æœåŠ¡       â”‚
â”‚  shortestresponse â”‚ æœ€çŸ­å“åº”æ—¶é—´ä¼˜å…ˆ    â”‚ æ€§èƒ½æ•æ„Ÿåœºæ™¯     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 2. LoadBalanceæ¥å£

### 2.1 æ¥å£å®šä¹‰

```java
/**
 * LoadBalance - è´Ÿè½½å‡è¡¡æ¥å£
 */
@SPI(RandomLoadBalance.NAME)
public interface LoadBalance {
    
    /**
     * ğŸ”¥ ä»å¤šä¸ªInvokerä¸­é€‰æ‹©ä¸€ä¸ª
     * @param invokers æœåŠ¡æä¾›è€…åˆ—è¡¨
     * @param url æœåŠ¡URL
     * @param invocation è°ƒç”¨ä¿¡æ¯
     * @return é€‰ä¸­çš„Invoker
     */
    @Adaptive("loadbalance")
    <T> Invoker<T> select(List<Invoker<T>> invokers, URL url, Invocation invocation) 
        throws RpcException;
}
```

### 2.2 AbstractLoadBalance

```java
/**
 * AbstractLoadBalance - è´Ÿè½½å‡è¡¡æŠ½è±¡åŸºç±»
 */
public abstract class AbstractLoadBalance implements LoadBalance {
    
    /**
     * è®¡ç®—é¢„çƒ­æƒé‡
     */
    static int calculateWarmupWeight(int uptime, int warmup, int weight) {
        // ğŸ”¥ é¢„çƒ­æœŸé—´æƒé‡é€æ¸å¢åŠ 
        int ww = (int) (uptime / ((float) warmup / weight));
        return ww < 1 ? 1 : (Math.min(ww, weight));
    }
    
    @Override
    public <T> Invoker<T> select(List<Invoker<T>> invokers, URL url, Invocation invocation) {
        if (CollectionUtils.isEmpty(invokers)) {
            return null;
        }
        // åªæœ‰ä¸€ä¸ªInvokerï¼Œç›´æ¥è¿”å›
        if (invokers.size() == 1) {
            return invokers.get(0);
        }
        // ğŸ”¥ è°ƒç”¨å­ç±»å®ç°
        return doSelect(invokers, url, invocation);
    }
    
    /**
     * å­ç±»å®ç°çš„é€‰æ‹©é€»è¾‘
     */
    protected abstract <T> Invoker<T> doSelect(List<Invoker<T>> invokers, 
        URL url, Invocation invocation);
    
    /**
     * ğŸ”¥ è·å–Invokeræƒé‡
     */
    int getWeight(Invoker<?> invoker, Invocation invocation) {
        int weight;
        URL url = invoker.getUrl();
        
        // æ³¨å†Œä¸­å¿ƒä¸å‚ä¸è´Ÿè½½å‡è¡¡
        if (UrlUtils.isRegistryService(url)) {
            weight = url.getParameter(REGISTRY_KEY + "." + WEIGHT_KEY, DEFAULT_WEIGHT);
        } else {
            weight = url.getMethodParameter(invocation.getMethodName(), WEIGHT_KEY, DEFAULT_WEIGHT);
            if (weight > 0) {
                // ğŸ”¥ è·å–æœåŠ¡å¯åŠ¨æ—¶é—´
                long timestamp = invoker.getUrl().getParameter(TIMESTAMP_KEY, 0L);
                if (timestamp > 0L) {
                    long uptime = System.currentTimeMillis() - timestamp;
                    if (uptime < 0) {
                        return 1;
                    }
                    // è·å–é¢„çƒ­æ—¶é—´
                    int warmup = invoker.getUrl().getParameter(WARMUP_KEY, DEFAULT_WARMUP);
                    // ğŸ”¥ é¢„çƒ­æœŸé—´é™ä½æƒé‡
                    if (uptime > 0 && uptime < warmup) {
                        weight = calculateWarmupWeight((int) uptime, warmup, weight);
                    }
                }
            }
        }
        return Math.max(weight, 0);
    }
}
```


---

## 3. éšæœºè´Ÿè½½å‡è¡¡

### 3.1 RandomLoadBalance

```java
/**
 * RandomLoadBalance - éšæœºè´Ÿè½½å‡è¡¡ï¼ˆé»˜è®¤ï¼‰
 * æŒ‰æƒé‡éšæœºé€‰æ‹©
 */
public class RandomLoadBalance extends AbstractLoadBalance {
    
    public static final String NAME = "random";
    
    @Override
    protected <T> Invoker<T> doSelect(List<Invoker<T>> invokers, URL url, 
            Invocation invocation) {
        
        int length = invokers.size();
        
        // æ˜¯å¦æ‰€æœ‰æƒé‡ç›¸åŒ
        boolean sameWeight = true;
        
        // æ¯ä¸ªInvokerçš„æƒé‡
        int[] weights = new int[length];
        
        // ç¬¬ä¸€ä¸ªInvokerçš„æƒé‡
        int firstWeight = getWeight(invokers.get(0), invocation);
        weights[0] = firstWeight;
        
        // æƒé‡æ€»å’Œ
        int totalWeight = firstWeight;
        
        // ğŸ”¥ è®¡ç®—æ‰€æœ‰æƒé‡
        for (int i = 1; i < length; i++) {
            int weight = getWeight(invokers.get(i), invocation);
            weights[i] = weight;
            totalWeight += weight;
            
            if (sameWeight && weight != firstWeight) {
                sameWeight = false;
            }
        }
        
        // ğŸ”¥ æƒé‡ä¸åŒï¼ŒæŒ‰æƒé‡éšæœº
        if (totalWeight > 0 && !sameWeight) {
            // ç”Ÿæˆéšæœºæ•°
            int offset = ThreadLocalRandom.current().nextInt(totalWeight);
            
            // ç¡®å®šéšæœºæ•°è½åœ¨å“ªä¸ªåŒºé—´
            for (int i = 0; i < length; i++) {
                offset -= weights[i];
                if (offset < 0) {
                    return invokers.get(i);
                }
            }
        }
        
        // ğŸ”¥ æƒé‡ç›¸åŒï¼Œå®Œå…¨éšæœº
        return invokers.get(ThreadLocalRandom.current().nextInt(length));
    }
}
```

### 3.2 éšæœºç®—æ³•å›¾è§£

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  éšæœºè´Ÿè½½å‡è¡¡ç®—æ³•                            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                             â”‚
â”‚  å‡è®¾æœ‰3ä¸ªInvokerï¼Œæƒé‡åˆ†åˆ«ä¸ºï¼š                             â”‚
â”‚  Invoker1: weight=5                                         â”‚
â”‚  Invoker2: weight=3                                         â”‚
â”‚  Invoker3: weight=2                                         â”‚
â”‚                                                             â”‚
â”‚  æ€»æƒé‡ = 5 + 3 + 2 = 10                                    â”‚
â”‚                                                             â”‚
â”‚  æƒé‡åŒºé—´ï¼š                                                  â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”¤                       â”‚
â”‚  0             5           8       10                       â”‚
â”‚  â”‚  Invoker1   â”‚ Invoker2  â”‚Inv3   â”‚                       â”‚
â”‚                                                             â”‚
â”‚  éšæœºæ•°è½åœ¨ [0,5) â†’ é€‰æ‹© Invoker1                           â”‚
â”‚  éšæœºæ•°è½åœ¨ [5,8) â†’ é€‰æ‹© Invoker2                           â”‚
â”‚  éšæœºæ•°è½åœ¨ [8,10) â†’ é€‰æ‹© Invoker3                          â”‚
â”‚                                                             â”‚
â”‚  é€‰ä¸­æ¦‚ç‡ï¼š                                                  â”‚
â”‚  Invoker1: 50%                                              â”‚
â”‚  Invoker2: 30%                                              â”‚
â”‚  Invoker3: 20%                                              â”‚
â”‚                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 4. è½®è¯¢è´Ÿè½½å‡è¡¡

### 4.1 RoundRobinLoadBalance

```java
/**
 * RoundRobinLoadBalance - è½®è¯¢è´Ÿè½½å‡è¡¡
 * åŠ æƒè½®è¯¢ç®—æ³•
 */
public class RoundRobinLoadBalance extends AbstractLoadBalance {
    
    public static final String NAME = "roundrobin";
    
    // å›æ”¶å‘¨æœŸ
    private static final int RECYCLE_PERIOD = 60000;
    
    // æ–¹æ³•çº§åˆ«çš„æƒé‡ä¿¡æ¯
    private ConcurrentMap<String, ConcurrentMap<String, WeightedRoundRobin>> 
        methodWeightMap = new ConcurrentHashMap<>();
    
    /**
     * åŠ æƒè½®è¯¢ä¿¡æ¯
     */
    protected static class WeightedRoundRobin {
        private int weight;
        private AtomicLong current = new AtomicLong(0);
        private long lastUpdate;
        
        public int getWeight() {
            return weight;
        }
        
        public void setWeight(int weight) {
            this.weight = weight;
            current.set(0);
        }
        
        public long increaseCurrent() {
            return current.addAndGet(weight);
        }
        
        public void sel(int total) {
            current.addAndGet(-1 * total);
        }
        
        public long getLastUpdate() {
            return lastUpdate;
        }
        
        public void setLastUpdate(long lastUpdate) {
            this.lastUpdate = lastUpdate;
        }
    }
    
    @Override
    protected <T> Invoker<T> doSelect(List<Invoker<T>> invokers, URL url, 
            Invocation invocation) {
        
        String key = invokers.get(0).getUrl().getServiceKey() + "." + 
            invocation.getMethodName();
        
        // è·å–æˆ–åˆ›å»ºæ–¹æ³•çº§åˆ«çš„æƒé‡Map
        ConcurrentMap<String, WeightedRoundRobin> map = 
            methodWeightMap.computeIfAbsent(key, k -> new ConcurrentHashMap<>());
        
        int totalWeight = 0;
        long maxCurrent = Long.MIN_VALUE;
        long now = System.currentTimeMillis();
        Invoker<T> selectedInvoker = null;
        WeightedRoundRobin selectedWRR = null;
        
        // ğŸ”¥ éå†æ‰€æœ‰Invoker
        for (Invoker<T> invoker : invokers) {
            String identifyString = invoker.getUrl().toIdentityString();
            int weight = getWeight(invoker, invocation);
            
            // è·å–æˆ–åˆ›å»ºWeightedRoundRobin
            WeightedRoundRobin weightedRoundRobin = 
                map.computeIfAbsent(identifyString, k -> {
                    WeightedRoundRobin wrr = new WeightedRoundRobin();
                    wrr.setWeight(weight);
                    return wrr;
                });
            
            // æ›´æ–°æƒé‡
            if (weight != weightedRoundRobin.getWeight()) {
                weightedRoundRobin.setWeight(weight);
            }
            
            // ğŸ”¥ å¢åŠ å½“å‰æƒé‡
            long cur = weightedRoundRobin.increaseCurrent();
            weightedRoundRobin.setLastUpdate(now);
            
            // ğŸ”¥ é€‰æ‹©å½“å‰æƒé‡æœ€å¤§çš„
            if (cur > maxCurrent) {
                maxCurrent = cur;
                selectedInvoker = invoker;
                selectedWRR = weightedRoundRobin;
            }
            
            totalWeight += weight;
        }
        
        // æ¸…ç†è¿‡æœŸæ•°æ®
        if (invokers.size() != map.size()) {
            map.entrySet().removeIf(item -> 
                now - item.getValue().getLastUpdate() > RECYCLE_PERIOD);
        }
        
        if (selectedInvoker != null) {
            // ğŸ”¥ å‡å»æ€»æƒé‡
            selectedWRR.sel(totalWeight);
            return selectedInvoker;
        }
        
        return invokers.get(0);
    }
}
```

### 4.2 åŠ æƒè½®è¯¢ç®—æ³•å›¾è§£

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  åŠ æƒè½®è¯¢ç®—æ³•ï¼ˆå¹³æ»‘ï¼‰                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                             â”‚
â”‚  å‡è®¾æœ‰3ä¸ªInvokerï¼Œæƒé‡åˆ†åˆ«ä¸ºï¼š                             â”‚
â”‚  A: weight=5, B: weight=1, C: weight=1                      â”‚
â”‚  æ€»æƒé‡ = 7                                                  â”‚
â”‚                                                             â”‚
â”‚  è½®è¯¢è¿‡ç¨‹ï¼š                                                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚
â”‚  â”‚ è¯·æ±‚   â”‚ é€‰æ‹©å‰current       â”‚ é€‰ä¸­   â”‚ é€‰æ‹©åcurrent   â”‚â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤â”‚
â”‚  â”‚ 1      â”‚ A:5, B:1, C:1       â”‚ A      â”‚ A:-2, B:1, C:1  â”‚â”‚
â”‚  â”‚ 2      â”‚ A:3, B:2, C:2       â”‚ A      â”‚ A:-4, B:2, C:2  â”‚â”‚
â”‚  â”‚ 3      â”‚ A:1, B:3, C:3       â”‚ B      â”‚ A:1, B:-4, C:3  â”‚â”‚
â”‚  â”‚ 4      â”‚ A:6, B:-3, C:4      â”‚ A      â”‚ A:-1, B:-3, C:4 â”‚â”‚
â”‚  â”‚ 5      â”‚ A:4, B:-2, C:5      â”‚ C      â”‚ A:4, B:-2, C:-2 â”‚â”‚
â”‚  â”‚ 6      â”‚ A:9, B:-1, C:-1     â”‚ A      â”‚ A:2, B:-1, C:-1 â”‚â”‚
â”‚  â”‚ 7      â”‚ A:7, B:0, C:0       â”‚ A      â”‚ A:0, B:0, C:0   â”‚â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚
â”‚                                                             â”‚
â”‚  7æ¬¡è¯·æ±‚ç»“æœï¼šA:5æ¬¡, B:1æ¬¡, C:1æ¬¡                           â”‚
â”‚  ç¬¦åˆæƒé‡æ¯”ä¾‹ 5:1:1                                         â”‚
â”‚                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 5. æœ€å°‘æ´»è·ƒæ•°

### 5.1 LeastActiveLoadBalance

```java
/**
 * LeastActiveLoadBalance - æœ€å°‘æ´»è·ƒæ•°è´Ÿè½½å‡è¡¡
 * æ´»è·ƒæ•°è¶Šå°‘ï¼Œè¯´æ˜å¤„ç†èƒ½åŠ›è¶Šå¼º
 */
public class LeastActiveLoadBalance extends AbstractLoadBalance {
    
    public static final String NAME = "leastactive";
    
    @Override
    protected <T> Invoker<T> doSelect(List<Invoker<T>> invokers, URL url, 
            Invocation invocation) {
        
        int length = invokers.size();
        
        // æœ€å°æ´»è·ƒæ•°
        int leastActive = -1;
        
        // å…·æœ‰ç›¸åŒæœ€å°æ´»è·ƒæ•°çš„Invokeræ•°é‡
        int leastCount = 0;
        
        // å…·æœ‰ç›¸åŒæœ€å°æ´»è·ƒæ•°çš„Invokerç´¢å¼•
        int[] leastIndexes = new int[length];
        
        // æ¯ä¸ªInvokerçš„æƒé‡
        int[] weights = new int[length];
        
        // æœ€å°æ´»è·ƒæ•°Invokerçš„æƒé‡æ€»å’Œ
        int totalWeight = 0;
        
        // ç¬¬ä¸€ä¸ªæœ€å°æ´»è·ƒæ•°Invokerçš„æƒé‡
        int firstWeight = 0;
        
        // æ˜¯å¦æ‰€æœ‰æœ€å°æ´»è·ƒæ•°Invokeræƒé‡ç›¸åŒ
        boolean sameWeight = true;
        
        // ğŸ”¥ éå†æ‰€æœ‰Invoker
        for (int i = 0; i < length; i++) {
            Invoker<T> invoker = invokers.get(i);
            
            // è·å–æ´»è·ƒæ•°
            int active = RpcStatus.getStatus(invoker.getUrl(), 
                invocation.getMethodName()).getActive();
            
            // è·å–æƒé‡
            int afterWarmup = getWeight(invoker, invocation);
            weights[i] = afterWarmup;
            
            // ğŸ”¥ å‘ç°æ›´å°çš„æ´»è·ƒæ•°
            if (leastActive == -1 || active < leastActive) {
                leastActive = active;
                leastCount = 1;
                leastIndexes[0] = i;
                totalWeight = afterWarmup;
                firstWeight = afterWarmup;
                sameWeight = true;
                
            // ğŸ”¥ æ´»è·ƒæ•°ç›¸åŒ
            } else if (active == leastActive) {
                leastIndexes[leastCount++] = i;
                totalWeight += afterWarmup;
                
                if (sameWeight && afterWarmup != firstWeight) {
                    sameWeight = false;
                }
            }
        }
        
        // ğŸ”¥ åªæœ‰ä¸€ä¸ªæœ€å°æ´»è·ƒæ•°Invoker
        if (leastCount == 1) {
            return invokers.get(leastIndexes[0]);
        }
        
        // ğŸ”¥ å¤šä¸ªæœ€å°æ´»è·ƒæ•°Invokerï¼ŒæŒ‰æƒé‡éšæœº
        if (!sameWeight && totalWeight > 0) {
            int offsetWeight = ThreadLocalRandom.current().nextInt(totalWeight);
            for (int i = 0; i < leastCount; i++) {
                int leastIndex = leastIndexes[i];
                offsetWeight -= weights[leastIndex];
                if (offsetWeight < 0) {
                    return invokers.get(leastIndex);
                }
            }
        }
        
        // ğŸ”¥ æƒé‡ç›¸åŒï¼Œéšæœºé€‰æ‹©
        return invokers.get(leastIndexes[ThreadLocalRandom.current().nextInt(leastCount)]);
    }
}
```

### 5.2 æ´»è·ƒæ•°ç»Ÿè®¡

```java
/**
 * RpcStatus - RPCçŠ¶æ€ç»Ÿè®¡
 */
public class RpcStatus {
    
    // æœåŠ¡çº§åˆ«ç»Ÿè®¡
    private static final ConcurrentMap<String, RpcStatus> SERVICE_STATISTICS = 
        new ConcurrentHashMap<>();
    
    // æ–¹æ³•çº§åˆ«ç»Ÿè®¡
    private static final ConcurrentMap<String, ConcurrentMap<String, RpcStatus>> 
        METHOD_STATISTICS = new ConcurrentHashMap<>();
    
    // ğŸ”¥ æ´»è·ƒæ•°ï¼ˆæ­£åœ¨å¤„ç†çš„è¯·æ±‚æ•°ï¼‰
    private final AtomicInteger active = new AtomicInteger();
    
    // æ€»è¯·æ±‚æ•°
    private final AtomicLong total = new AtomicLong();
    
    // å¤±è´¥è¯·æ±‚æ•°
    private final AtomicInteger failed = new AtomicInteger();
    
    // æ€»è€—æ—¶
    private final AtomicLong totalElapsed = new AtomicLong();
    
    // å¤±è´¥è€—æ—¶
    private final AtomicLong failedElapsed = new AtomicLong();
    
    // æœ€å¤§è€—æ—¶
    private final AtomicLong maxElapsed = new AtomicLong();
    
    // å¤±è´¥æœ€å¤§è€—æ—¶
    private final AtomicLong failedMaxElapsed = new AtomicLong();
    
    // æˆåŠŸæœ€å¤§è€—æ—¶
    private final AtomicLong succeededMaxElapsed = new AtomicLong();
    
    /**
     * ğŸ”¥ å¼€å§‹è®¡æ•°
     */
    public static boolean beginCount(URL url, String methodName, int max) {
        max = (max <= 0) ? Integer.MAX_VALUE : max;
        RpcStatus appStatus = getStatus(url);
        RpcStatus methodStatus = getStatus(url, methodName);
        
        if (methodStatus.active.incrementAndGet() > max) {
            methodStatus.active.decrementAndGet();
            return false;
        }
        
        appStatus.active.incrementAndGet();
        return true;
    }
    
    /**
     * ğŸ”¥ ç»“æŸè®¡æ•°
     */
    public static void endCount(URL url, String methodName, long elapsed, boolean succeeded) {
        endCount(getStatus(url), elapsed, succeeded);
        endCount(getStatus(url, methodName), elapsed, succeeded);
    }
    
    private static void endCount(RpcStatus status, long elapsed, boolean succeeded) {
        // å‡å°‘æ´»è·ƒæ•°
        status.active.decrementAndGet();
        status.total.incrementAndGet();
        status.totalElapsed.addAndGet(elapsed);
        
        // æ›´æ–°æœ€å¤§è€—æ—¶
        if (status.maxElapsed.get() < elapsed) {
            status.maxElapsed.set(elapsed);
        }
        
        if (succeeded) {
            if (status.succeededMaxElapsed.get() < elapsed) {
                status.succeededMaxElapsed.set(elapsed);
            }
        } else {
            status.failed.incrementAndGet();
            status.failedElapsed.addAndGet(elapsed);
            if (status.failedMaxElapsed.get() < elapsed) {
                status.failedMaxElapsed.set(elapsed);
            }
        }
    }
}
```

---

## 6. ä¸€è‡´æ€§å“ˆå¸Œ

### 6.1 ConsistentHashLoadBalance

```java
/**
 * ConsistentHashLoadBalance - ä¸€è‡´æ€§å“ˆå¸Œè´Ÿè½½å‡è¡¡
 * ç›¸åŒå‚æ•°çš„è¯·æ±‚æ€»æ˜¯å‘åˆ°åŒä¸€æä¾›è€…
 */
public class ConsistentHashLoadBalance extends AbstractLoadBalance {
    
    public static final String NAME = "consistenthash";
    
    // é€‰æ‹©å™¨ç¼“å­˜
    private final ConcurrentMap<String, ConsistentHashSelector<?>> selectors = 
        new ConcurrentHashMap<>();
    
    @Override
    protected <T> Invoker<T> doSelect(List<Invoker<T>> invokers, URL url, 
            Invocation invocation) {
        
        String methodName = RpcUtils.getMethodName(invocation);
        String key = invokers.get(0).getUrl().getServiceKey() + "." + methodName;
        
        // è®¡ç®—Invokeråˆ—è¡¨çš„hashCode
        int invokersHashCode = invokers.hashCode();
        
        // è·å–é€‰æ‹©å™¨
        ConsistentHashSelector<T> selector = (ConsistentHashSelector<T>) selectors.get(key);
        
        // ğŸ”¥ Invokeråˆ—è¡¨å˜åŒ–ï¼Œé‡æ–°åˆ›å»ºé€‰æ‹©å™¨
        if (selector == null || selector.identityHashCode != invokersHashCode) {
            selectors.put(key, new ConsistentHashSelector<>(invokers, methodName, 
                invokersHashCode));
            selector = (ConsistentHashSelector<T>) selectors.get(key);
        }
        
        // ğŸ”¥ é€‰æ‹©Invoker
        return selector.select(invocation);
    }
    
    /**
     * ä¸€è‡´æ€§å“ˆå¸Œé€‰æ‹©å™¨
     */
    private static final class ConsistentHashSelector<T> {
        
        // ğŸ”¥ è™šæ‹ŸèŠ‚ç‚¹åˆ°Invokerçš„æ˜ å°„
        private final TreeMap<Long, Invoker<T>> virtualInvokers;
        
        // è™šæ‹ŸèŠ‚ç‚¹æ•°
        private final int replicaNumber;
        
        // Invokeråˆ—è¡¨çš„hashCode
        private final int identityHashCode;
        
        // å‚ä¸å“ˆå¸Œè®¡ç®—çš„å‚æ•°ç´¢å¼•
        private final int[] argumentIndex;
        
        ConsistentHashSelector(List<Invoker<T>> invokers, String methodName, 
                int identityHashCode) {
            
            this.virtualInvokers = new TreeMap<>();
            this.identityHashCode = identityHashCode;
            
            URL url = invokers.get(0).getUrl();
            
            // è·å–è™šæ‹ŸèŠ‚ç‚¹æ•°ï¼Œé»˜è®¤160
            this.replicaNumber = url.getMethodParameter(methodName, 
                HASH_NODES, 160);
            
            // è·å–å‚ä¸å“ˆå¸Œçš„å‚æ•°ç´¢å¼•
            String[] index = COMMA_SPLIT_PATTERN.split(
                url.getMethodParameter(methodName, HASH_ARGUMENTS, "0"));
            argumentIndex = new int[index.length];
            for (int i = 0; i < index.length; i++) {
                argumentIndex[i] = Integer.parseInt(index[i]);
            }
            
            // ğŸ”¥ ä¸ºæ¯ä¸ªInvokeråˆ›å»ºè™šæ‹ŸèŠ‚ç‚¹
            for (Invoker<T> invoker : invokers) {
                String address = invoker.getUrl().getAddress();
                for (int i = 0; i < replicaNumber / 4; i++) {
                    byte[] digest = Bytes.getMD5(address + i);
                    for (int h = 0; h < 4; h++) {
                        long m = hash(digest, h);
                        virtualInvokers.put(m, invoker);
                    }
                }
            }
        }
        
        /**
         * ğŸ”¥ é€‰æ‹©Invoker
         */
        public Invoker<T> select(Invocation invocation) {
            // è·å–å‚ä¸å“ˆå¸Œçš„å‚æ•°å€¼
            String key = toKey(invocation.getArguments());
            
            // è®¡ç®—å“ˆå¸Œå€¼
            byte[] digest = Bytes.getMD5(key);
            
            // é€‰æ‹©èŠ‚ç‚¹
            return selectForKey(hash(digest, 0));
        }
        
        private String toKey(Object[] args) {
            StringBuilder buf = new StringBuilder();
            for (int i : argumentIndex) {
                if (i >= 0 && i < args.length) {
                    buf.append(args[i]);
                }
            }
            return buf.toString();
        }
        
        /**
         * ğŸ”¥ æ ¹æ®å“ˆå¸Œå€¼é€‰æ‹©èŠ‚ç‚¹
         */
        private Invoker<T> selectForKey(long hash) {
            // æ‰¾åˆ°ç¬¬ä¸€ä¸ªå¤§äºç­‰äºhashçš„èŠ‚ç‚¹
            Map.Entry<Long, Invoker<T>> entry = virtualInvokers.ceilingEntry(hash);
            
            // å¦‚æœæ²¡æœ‰ï¼Œå–ç¬¬ä¸€ä¸ªèŠ‚ç‚¹ï¼ˆç¯å½¢ï¼‰
            if (entry == null) {
                entry = virtualInvokers.firstEntry();
            }
            
            return entry.getValue();
        }
        
        private long hash(byte[] digest, int number) {
            return (((long) (digest[3 + number * 4] & 0xFF) << 24)
                | ((long) (digest[2 + number * 4] & 0xFF) << 16)
                | ((long) (digest[1 + number * 4] & 0xFF) << 8)
                | (digest[number * 4] & 0xFF))
                & 0xFFFFFFFFL;
        }
    }
}
```

### 6.2 ä¸€è‡´æ€§å“ˆå¸Œå›¾è§£

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  ä¸€è‡´æ€§å“ˆå¸Œç¯                                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                             â”‚
â”‚                        0                                    â”‚
â”‚                        â”‚                                    â”‚
â”‚                   â”Œâ”€â”€â”€â”€â”´â”€â”€â”€â”€â”                               â”‚
â”‚                   â”‚         â”‚                               â”‚
â”‚              A-1 â—         â— B-1                            â”‚
â”‚                 /           \                               â”‚
â”‚                /             \                              â”‚
â”‚           A-2 â—               â— B-2                         â”‚
â”‚              â”‚                 â”‚                            â”‚
â”‚              â”‚    å“ˆå¸Œç¯       â”‚                            â”‚
â”‚              â”‚                 â”‚                            â”‚
â”‚           C-1 â—               â— C-2                         â”‚
â”‚                \             /                              â”‚
â”‚                 \           /                               â”‚
â”‚              A-3 â—         â— B-3                            â”‚
â”‚                   â”‚         â”‚                               â”‚
â”‚                   â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜                               â”‚
â”‚                        â”‚                                    â”‚
â”‚                      2^32                                   â”‚
â”‚                                                             â”‚
â”‚  è¯·æ±‚å“ˆå¸Œå€¼è½åœ¨ [A-1, B-1) â†’ é€‰æ‹© B                         â”‚
â”‚  è¯·æ±‚å“ˆå¸Œå€¼è½åœ¨ [B-2, C-1) â†’ é€‰æ‹© C                         â”‚
â”‚                                                             â”‚
â”‚  è™šæ‹ŸèŠ‚ç‚¹ä½œç”¨ï¼š                                              â”‚
â”‚  - è§£å†³èŠ‚ç‚¹åˆ†å¸ƒä¸å‡é—®é¢˜                                      â”‚
â”‚  - èŠ‚ç‚¹å¢å‡æ—¶å½±å“èŒƒå›´å°                                      â”‚
â”‚                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 7. é¢è¯•è¦ç‚¹

### 7.1 é«˜é¢‘é¢è¯•é¢˜

#### Q1: Dubboæœ‰å“ªäº›è´Ÿè½½å‡è¡¡ç­–ç•¥ï¼Ÿ

```
Dubboè´Ÿè½½å‡è¡¡ç­–ç•¥ï¼š

1. Randomï¼ˆéšæœºï¼‰- é»˜è®¤
   - æŒ‰æƒé‡éšæœºé€‰æ‹©
   - è°ƒç”¨é‡è¶Šå¤§åˆ†å¸ƒè¶Šå‡åŒ€

2. RoundRobinï¼ˆè½®è¯¢ï¼‰
   - æŒ‰æƒé‡è½®è¯¢
   - å¹³æ»‘åŠ æƒè½®è¯¢ç®—æ³•

3. LeastActiveï¼ˆæœ€å°‘æ´»è·ƒæ•°ï¼‰
   - æ´»è·ƒæ•°è¶Šå°‘ä¼˜å…ˆçº§è¶Šé«˜
   - æ…¢æä¾›è€…æ”¶åˆ°æ›´å°‘è¯·æ±‚

4. ConsistentHashï¼ˆä¸€è‡´æ€§å“ˆå¸Œï¼‰
   - ç›¸åŒå‚æ•°è¯·æ±‚åˆ°åŒä¸€æä¾›è€…
   - é€‚åˆæœ‰çŠ¶æ€æœåŠ¡

5. ShortestResponseï¼ˆæœ€çŸ­å“åº”æ—¶é—´ï¼‰
   - å“åº”æ—¶é—´è¶ŠçŸ­ä¼˜å…ˆçº§è¶Šé«˜
   - Dubbo 2.7+æ–°å¢
```

#### Q2: éšæœºè´Ÿè½½å‡è¡¡å¦‚ä½•å®ç°æƒé‡ï¼Ÿ

```java
/**
 * éšæœºè´Ÿè½½å‡è¡¡æƒé‡å®ç°ï¼š
 * 
 * 1. è®¡ç®—æ‰€æœ‰Invokerçš„æƒé‡æ€»å’Œ
 * 2. ç”Ÿæˆ[0, totalWeight)çš„éšæœºæ•°
 * 3. éå†Invokerï¼Œå‡å»å„è‡ªæƒé‡
 * 4. å½“éšæœºæ•°å°äº0æ—¶ï¼Œé€‰ä¸­å½“å‰Invoker
 * 
 * ç¤ºä¾‹ï¼š
 * A:5, B:3, C:2ï¼Œæ€»æƒé‡10
 * éšæœºæ•°7
 * 7-5=2 (>0, ç»§ç»­)
 * 2-3=-1 (<0, é€‰ä¸­B)
 */
```

#### Q3: ä¸€è‡´æ€§å“ˆå¸Œçš„ä¼˜åŠ¿ï¼Ÿ

```
ä¸€è‡´æ€§å“ˆå¸Œä¼˜åŠ¿ï¼š

1. ç›¸åŒå‚æ•°è¯·æ±‚åˆ°åŒä¸€æä¾›è€…
   - é€‚åˆæœ‰çŠ¶æ€æœåŠ¡
   - åˆ©äºç¼“å­˜å‘½ä¸­

2. èŠ‚ç‚¹å¢å‡å½±å“å°
   - åªå½±å“ç›¸é‚»èŠ‚ç‚¹
   - ä¸ä¼šå¯¼è‡´å…¨éƒ¨é‡æ–°åˆ†é…

3. è™šæ‹ŸèŠ‚ç‚¹è§£å†³åˆ†å¸ƒä¸å‡
   - æ¯ä¸ªç‰©ç†èŠ‚ç‚¹å¯¹åº”å¤šä¸ªè™šæ‹ŸèŠ‚ç‚¹
   - è¯·æ±‚åˆ†å¸ƒæ›´å‡åŒ€
```

#### Q4: æœ€å°‘æ´»è·ƒæ•°å¦‚ä½•ç»Ÿè®¡ï¼Ÿ

```java
/**
 * æ´»è·ƒæ•°ç»Ÿè®¡ï¼š
 * 
 * 1. è¯·æ±‚å¼€å§‹æ—¶ï¼šactive++
 * 2. è¯·æ±‚ç»“æŸæ—¶ï¼šactive--
 * 
 * é€šè¿‡ActiveLimitFilterå®ç°ï¼š
 * - è°ƒç”¨å‰ï¼šRpcStatus.beginCount()
 * - è°ƒç”¨åï¼šRpcStatus.endCount()
 * 
 * æ´»è·ƒæ•°å«ä¹‰ï¼š
 * - æ­£åœ¨å¤„ç†çš„è¯·æ±‚æ•°
 * - æ´»è·ƒæ•°è¶Šå°‘ï¼Œè¯´æ˜å¤„ç†èƒ½åŠ›è¶Šå¼º
 */
```

### 7.2 æºç é˜…è¯»è¦ç‚¹

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  è´Ÿè½½å‡è¡¡æºç é˜…è¯»è·¯çº¿                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                             â”‚
â”‚  å…¥å£ï¼šAbstractClusterInvoker.select()                      â”‚
â”‚    â”‚                                                        â”‚
â”‚    â–¼                                                        â”‚
â”‚  LoadBalance.select()                                       â”‚
â”‚    â”‚                                                        â”‚
â”‚    â”œâ”€â”€ AbstractLoadBalance.select()                         â”‚
â”‚    â”‚     â”œâ”€â”€ å•ä¸ªInvokerç›´æ¥è¿”å›                            â”‚
â”‚    â”‚     â””â”€â”€ è°ƒç”¨doSelect()                                 â”‚
â”‚    â”‚                                                        â”‚
â”‚    â””â”€â”€ å…·ä½“å®ç°                                             â”‚
â”‚          â”œâ”€â”€ RandomLoadBalance.doSelect()                   â”‚
â”‚          â”œâ”€â”€ RoundRobinLoadBalance.doSelect()               â”‚
â”‚          â”œâ”€â”€ LeastActiveLoadBalance.doSelect()              â”‚
â”‚          â””â”€â”€ ConsistentHashLoadBalance.doSelect()           â”‚
â”‚                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 7.3 é…ç½®ç¤ºä¾‹

```java
/**
 * è´Ÿè½½å‡è¡¡é…ç½®
 */
// æœåŠ¡ç«¯é…ç½®
@DubboService(loadbalance = "roundrobin")
public class UserServiceImpl implements UserService {}

// æ¶ˆè´¹ç«¯é…ç½®
@DubboReference(loadbalance = "leastactive")
private UserService userService;

// æ–¹æ³•çº§é…ç½®
@DubboReference(methods = {
    @Method(name = "getUser", loadbalance = "consistenthash")
})
private UserService userService;
```

---

## ğŸ“š æ€»ç»“

### æ ¸å¿ƒè¦ç‚¹

```
1. LoadBalanceæ¥å£å®šä¹‰è´Ÿè½½å‡è¡¡
   - select()æ–¹æ³•é€‰æ‹©Invoker
   - @SPIé»˜è®¤random

2. AbstractLoadBalanceæä¾›åŸºç¡€å®ç°
   - æƒé‡è®¡ç®—
   - é¢„çƒ­å¤„ç†

3. å››ç§ä¸»è¦ç­–ç•¥
   - Randomï¼šæŒ‰æƒé‡éšæœº
   - RoundRobinï¼šå¹³æ»‘åŠ æƒè½®è¯¢
   - LeastActiveï¼šæœ€å°‘æ´»è·ƒæ•°ä¼˜å…ˆ
   - ConsistentHashï¼šä¸€è‡´æ€§å“ˆå¸Œ

4. æƒé‡å½±å“é€‰æ‹©æ¦‚ç‡
   - é¢„çƒ­æœŸé—´æƒé‡é€æ¸å¢åŠ 
   - é¿å…æ–°å¯åŠ¨æœåŠ¡å‹åŠ›è¿‡å¤§

5. å¯é€šè¿‡é…ç½®çµæ´»é€‰æ‹©
   - æœåŠ¡çº§ã€æ–¹æ³•çº§é…ç½®
   - æ¶ˆè´¹ç«¯ã€æœåŠ¡ç«¯é…ç½®
```

---

**ç›¸å…³æ–‡æ¡£**ï¼š
- [SPIæœºåˆ¶æºç è§£æ](./SPIæœºåˆ¶æºç è§£æ.md)
- [æœåŠ¡æš´éœ²æºç è§£æ](./æœåŠ¡æš´éœ²æºç è§£æ.md)
- [æœåŠ¡å¼•ç”¨æºç è§£æ](./æœåŠ¡å¼•ç”¨æºç è§£æ.md)
- [é›†ç¾¤å®¹é”™æºç è§£æ](./é›†ç¾¤å®¹é”™æºç è§£æ.md)

# Tomcatçº¿ç¨‹æ¨¡å‹æºç è§£æ

> ğŸ’¡ æ·±å…¥ç†è§£Tomcatçš„å¤šçº¿ç¨‹å¤„ç†æœºåˆ¶å’Œæ€§èƒ½ä¼˜åŒ–

---

## ğŸ“š ç›®å½•

1. [çº¿ç¨‹æ¨¡å‹æ¦‚è¿°](#1-çº¿ç¨‹æ¨¡å‹æ¦‚è¿°)
2. [Connectorçº¿ç¨‹æ¨¡å‹](#2-connectorçº¿ç¨‹æ¨¡å‹)
3. [NIOçº¿ç¨‹æ¨¡å‹](#3-nioçº¿ç¨‹æ¨¡å‹)
4. [çº¿ç¨‹æ± ç®¡ç†](#4-çº¿ç¨‹æ± ç®¡ç†)
5. [è¯·æ±‚å¤„ç†æµç¨‹](#5-è¯·æ±‚å¤„ç†æµç¨‹)
6. [æ€§èƒ½ä¼˜åŒ–](#6-æ€§èƒ½ä¼˜åŒ–)
7. [é¢è¯•è¦ç‚¹](#7-é¢è¯•è¦ç‚¹)

---

## 1. çº¿ç¨‹æ¨¡å‹æ¦‚è¿°

### 1.1 Tomcatçº¿ç¨‹æ¶æ„

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  Tomcatçº¿ç¨‹æ¨¡å‹æ¶æ„                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                             â”‚
â”‚  å®¢æˆ·ç«¯è¯·æ±‚                                                 â”‚
â”‚      â”‚                                                     â”‚
â”‚      â–¼                                                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚              Acceptorçº¿ç¨‹                           â”‚   â”‚
â”‚  â”‚  â”œâ”€â”€ ç›‘å¬ç«¯å£                                       â”‚   â”‚
â”‚  â”‚  â”œâ”€â”€ æ¥å—è¿æ¥                                       â”‚   â”‚
â”‚  â”‚  â””â”€â”€ åˆ†å‘ç»™Poller                                   â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚      â”‚                                                     â”‚
â”‚      â–¼                                                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚              Pollerçº¿ç¨‹                             â”‚   â”‚
â”‚  â”‚  â”œâ”€â”€ ç®¡ç†è¿æ¥                                       â”‚   â”‚
â”‚  â”‚  â”œâ”€â”€ ç›‘å¬I/Oäº‹ä»¶                                    â”‚   â”‚
â”‚  â”‚  â””â”€â”€ åˆ†å‘ç»™Worker                                   â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚      â”‚                                                     â”‚
â”‚      â–¼                                                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚              Workerçº¿ç¨‹æ±                            â”‚   â”‚
â”‚  â”‚  â”œâ”€â”€ å¤„ç†HTTPè¯·æ±‚                                   â”‚   â”‚
â”‚  â”‚  â”œâ”€â”€ æ‰§è¡ŒServlet                                    â”‚   â”‚
â”‚  â”‚  â””â”€â”€ ç”Ÿæˆå“åº”                                       â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                             â”‚
â”‚  çº¿ç¨‹æ¨¡å‹ç‰¹ç‚¹ï¼š                                              â”‚
â”‚  âœ… å¼‚æ­¥éé˜»å¡I/O                                           â”‚
â”‚  âœ… äº‹ä»¶é©±åŠ¨                                               â”‚
â”‚  âœ… çº¿ç¨‹æ± å¤ç”¨                                             â”‚
â”‚  âœ… é«˜å¹¶å‘æ”¯æŒ                                             â”‚
â”‚                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 1.2 çº¿ç¨‹ç±»å‹åˆ†æ

```java
/**
 * Tomcatçº¿ç¨‹ç±»å‹å’ŒèŒè´£
 */
public class TomcatThreadTypes {
    
    /**
     * ğŸ”¥ Acceptorçº¿ç¨‹
     * - æ•°é‡ï¼šé€šå¸¸1ä¸ª
     * - èŒè´£ï¼šæ¥å—æ–°è¿æ¥
     * - ç‰¹ç‚¹ï¼šé˜»å¡å¼accept()
     */
    public class AcceptorThread extends Thread {
        // ç›‘å¬ServerSocket
        // æ¥å—å®¢æˆ·ç«¯è¿æ¥
        // å°†è¿æ¥åˆ†å‘ç»™Poller
    }
    
    /**
     * ğŸ”¥ Pollerçº¿ç¨‹
     * - æ•°é‡ï¼šé€šå¸¸1-2ä¸ª
     * - èŒè´£ï¼šç®¡ç†è¿æ¥ï¼Œç›‘å¬I/Oäº‹ä»¶
     * - ç‰¹ç‚¹ï¼šä½¿ç”¨Selectorï¼Œéé˜»å¡I/O
     */
    public class PollerThread extends Thread {
        // ç®¡ç†Selector
        // ç›‘å¬è¯»å†™äº‹ä»¶
        // åˆ†å‘å°±ç»ªçš„è¿æ¥ç»™Worker
    }
    
    /**
     * ğŸ”¥ Workerçº¿ç¨‹
     * - æ•°é‡ï¼šå¯é…ç½®çº¿ç¨‹æ± 
     * - èŒè´£ï¼šå¤„ç†HTTPè¯·æ±‚
     * - ç‰¹ç‚¹ï¼šæ‰§è¡Œä¸šåŠ¡é€»è¾‘
     */
    public class WorkerThread extends Thread {
        // è§£æHTTPè¯·æ±‚
        // æ‰§è¡ŒServlet
        // ç”ŸæˆHTTPå“åº”
    }
    
    /**
     * ğŸ”¥ åå°çº¿ç¨‹
     * - ContainerBackgroundProcessorï¼šå®¹å™¨åå°å¤„ç†
     * - AsyncTimeoutï¼šå¼‚æ­¥è¶…æ—¶å¤„ç†
     * - ClientPollerï¼šå®¢æˆ·ç«¯è½®è¯¢
     */
    public class BackgroundThreads {
        // å®šæœŸæ¸…ç†ä»»åŠ¡
        // ä¼šè¯è¶…æ—¶å¤„ç†
        // èµ„æºå›æ”¶
    }
}
```

---

## 2. Connectorçº¿ç¨‹æ¨¡å‹

### 2.1 AbstractEndpointæ ¸å¿ƒç»“æ„

```java
/**
 * AbstractEndpoint - ç«¯ç‚¹æŠ½è±¡ç±»
 * å®šä¹‰äº†Tomcatçš„çº¿ç¨‹æ¨¡å‹åŸºç¡€
 */
public abstract class AbstractEndpoint<S,U> {
    
    private static final Log log = LogFactory.getLog(AbstractEndpoint.class);
    
    // ğŸ”¥ Acceptorçº¿ç¨‹æ•°é‡
    protected int acceptorThreadCount = 1;
    
    // ğŸ”¥ Pollerçº¿ç¨‹æ•°é‡  
    protected int pollerThreadCount = Math.min(2, Runtime.getRuntime().availableProcessors());
    
    // ğŸ”¥ æœ€å¤§è¿æ¥æ•°
    protected int maxConnections = 8192;
    
    // ğŸ”¥ è¿æ¥è¶…æ—¶æ—¶é—´
    protected int connectionTimeout = 60000;
    
    // ğŸ”¥ Acceptorçº¿ç¨‹æ•°ç»„
    protected Acceptor<U>[] acceptors;
    
    // ğŸ”¥ è¿æ¥é™åˆ¶å™¨
    protected LimitLatch connectionLimitLatch;
    
    // ğŸ”¥ æ‰§è¡Œå™¨ï¼ˆçº¿ç¨‹æ± ï¼‰
    protected Executor executor = null;
    
    /**
     * ğŸ”¥ å¯åŠ¨ç«¯ç‚¹
     */
    public final void start() throws Exception {
        if (bindState == BindState.UNBOUND) {
            bindWithCleanup();
            bindState = BindState.BOUND_ON_START;
        }
        startInternal();
    }
    
    /**
     * ğŸ”¥ å†…éƒ¨å¯åŠ¨é€»è¾‘
     */
    public abstract void startInternal() throws Exception;
    
    /**
     * ğŸ”¥ åˆ›å»ºæ‰§è¡Œå™¨
     */
    public void createExecutor() {
        internalExecutor = true;
        TaskQueue taskqueue = new TaskQueue();
        TaskThreadFactory tf = new TaskThreadFactory(getName() + "-exec-", daemon, getThreadPriority());
        executor = new ThreadPoolExecutor(getMinSpareThreads(), getMaxThreads(), 60, TimeUnit.SECONDS,
                taskqueue, tf);
        taskqueue.setParent( (ThreadPoolExecutor) executor);
    }
    
    /**
     * ğŸ”¥ Acceptoræ¥å£
     */
    public interface Acceptor<U> extends Runnable {
        public enum AcceptorState {
            NEW, RUNNING, PAUSED, ENDED
        }
    }
    
    /**
     * ğŸ”¥ å¤„ç†å™¨æ¥å£
     */
    public interface Handler<S> {
        
        /**
         * å¤„ç†è¿æ¥
         */
        public SocketState process(SocketWrapperBase<S> wrapper, SocketEvent status);
        
        /**
         * è·å–å…¨å±€è¯·æ±‚å¤„ç†å™¨
         */
        public Set<S> getOpenSockets();
        
        /**
         * é‡Šæ”¾ç¼“å­˜çš„å¤„ç†å™¨å¯¹è±¡
         */
        public void release(SocketWrapperBase<S> wrapper);
        
        /**
         * æš‚åœå¤„ç†
         */
        public void pause();
        
        /**
         * å›æ”¶å¤„ç†å™¨
         */
        public void recycle();
    }
}
```

### 2.2 è¿æ¥é™åˆ¶æœºåˆ¶

```java
/**
 * LimitLatch - è¿æ¥æ•°é™åˆ¶å™¨
 * æ§åˆ¶å¹¶å‘è¿æ¥æ•°ï¼Œé˜²æ­¢ç³»ç»Ÿè¿‡è½½
 */
public class LimitLatch {
    
    private static final Log log = LogFactory.getLog(LimitLatch.class);
    
    // ğŸ”¥ å½“å‰è¿æ¥æ•°
    private volatile long count;
    
    // ğŸ”¥ æœ€å¤§è¿æ¥æ•°é™åˆ¶
    private volatile long limit;
    
    // ğŸ”¥ ç­‰å¾…é˜Ÿåˆ—
    private volatile boolean released = false;
    
    /**
     * ğŸ”¥ æ„é€ å‡½æ•°
     */
    public LimitLatch(long limit) {
        this.limit = limit;
        this.count = 0;
    }
    
    /**
     * ğŸ”¥ è·å–è¿æ¥è®¸å¯
     */
    public void countUpOrAwait() throws InterruptedException {
        if (log.isDebugEnabled()) {
            log.debug("Counting up[" + Thread.currentThread().getName() + "] latch=" + getCount());
        }
        
        synchronized (lock) {
            while (count >= limit) {
                if (released) {
                    throw new InterruptedException();
                }
                lock.wait();
            }
            count++;
        }
    }
    
    /**
     * ğŸ”¥ é‡Šæ”¾è¿æ¥è®¸å¯
     */
    public long countDown() {
        synchronized (lock) {
            count--;
            if (log.isDebugEnabled()) {
                log.debug("Counting down[" + Thread.currentThread().getName() + "] latch=" + count);
            }
            lock.notifyAll();
            return count;
        }
    }
    
    /**
     * ğŸ”¥ è·å–å½“å‰è¿æ¥æ•°
     */
    public long getCount() {
        return count;
    }
    
    /**
     * ğŸ”¥ è·å–è¿æ¥æ•°é™åˆ¶
     */
    public long getLimit() {
        return limit;
    }
    
    /**
     * ğŸ”¥ è®¾ç½®è¿æ¥æ•°é™åˆ¶
     */
    public void setLimit(long limit) {
        synchronized (lock) {
            this.limit = limit;
            lock.notifyAll();
        }
    }
    
    /**
     * ğŸ”¥ é‡Šæ”¾æ‰€æœ‰ç­‰å¾…çš„çº¿ç¨‹
     */
    public void releaseAll() {
        synchronized (lock) {
            released = true;
            lock.notifyAll();
        }
    }
    
    /**
     * ğŸ”¥ é‡ç½®çŠ¶æ€
     */
    public void reset() {
        synchronized (lock) {
            this.count = 0;
            released = false;
        }
    }
    
    /**
     * ğŸ”¥ æ£€æŸ¥æ˜¯å¦æœ‰å¯ç”¨è®¸å¯
     */
    public boolean hasQueuedThreads() {
        synchronized (lock) {
            return count >= limit;
        }
    }
}
```

---

## 3. NIOçº¿ç¨‹æ¨¡å‹

### 3.1 NioEndpointå®ç°

```java
/**
 * NioEndpoint - NIOç«¯ç‚¹å®ç°
 * åŸºäºJava NIOçš„é«˜æ€§èƒ½ç½‘ç»œå¤„ç†
 */
public class NioEndpoint extends AbstractJsseEndpoint<NioChannel,SocketChannel> {
    
    private static final Log log = LogFactory.getLog(NioEndpoint.class);
    
    // ğŸ”¥ NIOæœåŠ¡å™¨å¥—æ¥å­—é€šé“
    private volatile ServerSocketChannel serverSock = null;
    
    // ğŸ”¥ Pollerçº¿ç¨‹æ•°ç»„
    private Poller[] pollers = null;
    
    // ğŸ”¥ ä¸‹ä¸€ä¸ªPollerç´¢å¼•
    private int pollerRotater = 0;
    
    // ğŸ”¥ NIOé€‰æ‹©å™¨æ± 
    private NioSelectorPool selectorPool = new NioSelectorPool();
    
    /**
     * ğŸ”¥ å¯åŠ¨å†…éƒ¨é€»è¾‘
     */
    @Override
    public void startInternal() throws Exception {
        
        if (!running) {
            running = true;
            paused = false;
            
            // ğŸ”¥ åˆ›å»ºçº¿ç¨‹æ± 
            if (getExecutor() == null) {
                createExecutor();
            }
            
            // ğŸ”¥ åˆå§‹åŒ–è¿æ¥é™åˆ¶å™¨
            initializeConnectionLatch();
            
            // ğŸ”¥ å¯åŠ¨Pollerçº¿ç¨‹
            pollers = new Poller[getPollerThreadCount()];
            for (int i = 0; i < pollers.length; i++) {
                pollers[i] = new Poller();
                Thread pollerThread = new Thread(pollers[i], getName() + "-ClientPoller-" + i);
                pollerThread.setPriority(threadPriority);
                pollerThread.setDaemon(true);
                pollerThread.start();
            }
            
            // ğŸ”¥ å¯åŠ¨Acceptorçº¿ç¨‹
            startAcceptorThreads();
        }
    }
    
    /**
     * ğŸ”¥ è·å–ä¸‹ä¸€ä¸ªPoller
     */
    public Poller getPoller0() {
        int idx = Math.abs(pollerRotater++) % pollers.length;
        return pollers[idx];
    }
    
    /**
     * ğŸ”¥ NIO Acceptorå®ç°
     */
    protected class Acceptor extends AbstractEndpoint.Acceptor<ServerSocketChannel> {
        
        @Override
        public void run() {
            
            int errorDelay = 0;
            
            // ğŸ”¥ å¾ªç¯æ¥å—è¿æ¥
            while (running && !paused) {
                
                // ğŸ”¥ æ£€æŸ¥è¿æ¥é™åˆ¶
                while (paused && running) {
                    state = AcceptorState.PAUSED;
                    try {
                        Thread.sleep(50);
                    } catch (InterruptedException e) {
                        // Ignore
                    }
                }
                
                if (!running) {
                    break;
                }
                state = AcceptorState.RUNNING;
                
                try {
                    // ğŸ”¥ è·å–è¿æ¥è®¸å¯
                    countUpOrAwaitConnection();
                    
                    SocketChannel socket = null;
                    try {
                        // ğŸ”¥ æ¥å—è¿æ¥
                        socket = serverSock.accept();
                    } catch (IOException ioe) {
                        // ğŸ”¥ å¤„ç†å¼‚å¸¸
                        countDownConnection();
                        if (running) {
                            errorDelay = handleExceptionWithDelay(errorDelay);
                            throw ioe;
                        } else {
                            break;
                        }
                    }
                    
                    // ğŸ”¥ æˆåŠŸæ¥å—è¿æ¥ï¼Œé‡ç½®é”™è¯¯å»¶è¿Ÿ
                    errorDelay = 0;
                    
                    // ğŸ”¥ é…ç½®å¥—æ¥å­—
                    if (running && !paused) {
                        if (!setSocketOptions(socket)) {
                            closeSocket(socket);
                        }
                    } else {
                        closeSocket(socket);
                    }
                } catch (Throwable t) {
                    ExceptionUtils.handleThrowable(t);
                    log.error("Accept error", t);
                }
            }
            state = AcceptorState.ENDED;
        }
    }
    
    /**
     * ğŸ”¥ è®¾ç½®å¥—æ¥å­—é€‰é¡¹
     */
    protected boolean setSocketOptions(SocketChannel socket) {
        
        try {
            // ğŸ”¥ è®¾ç½®éé˜»å¡æ¨¡å¼
            socket.configureBlocking(false);
            Socket sock = socket.socket();
            socketProperties.setProperties(sock);
            
            // ğŸ”¥ åˆ›å»ºNIOé€šé“åŒ…è£…å™¨
            NioChannel channel = nioChannels.pop();
            if (channel == null) {
                SocketBufferHandler bufhandler = new SocketBufferHandler(
                        socketProperties.getAppReadBufSize(),
                        socketProperties.getAppWriteBufSize(),
                        socketProperties.getDirectBuffer());
                if (isSSLEnabled()) {
                    channel = new SecureNioChannel(socket, bufhandler, selectorPool, this);
                } else {
                    channel = new NioChannel(socket, bufhandler);
                }
            } else {
                channel.setIOChannel(socket);
                channel.reset();
            }
            
            // ğŸ”¥ æ³¨å†Œåˆ°Poller
            getPoller0().register(channel);
            
        } catch (Throwable t) {
            ExceptionUtils.handleThrowable(t);
            try {
                log.error("Failed to set socket options", t);
            } catch (Throwable tt) {
                ExceptionUtils.handleThrowable(tt);
            }
            return false;
        }
        return true;
    }
}
```

### 3.2 Pollerçº¿ç¨‹å®ç°

```java
/**
 * Poller - è½®è¯¢å™¨çº¿ç¨‹
 * ä½¿ç”¨Selectorç›‘å¬I/Oäº‹ä»¶
 */
public class Poller implements Runnable {
    
    // ğŸ”¥ NIOé€‰æ‹©å™¨
    private Selector selector;
    
    // ğŸ”¥ äº‹ä»¶é˜Ÿåˆ—
    private final SynchronizedQueue<PollerEvent> events = new SynchronizedQueue<>();
    
    // ğŸ”¥ å…³é—­æ ‡å¿—
    private volatile boolean close = false;
    
    // ğŸ”¥ å”¤é†’æ ‡å¿—
    private long nextExpiration = 0;
    
    /**
     * ğŸ”¥ æ„é€ å‡½æ•°
     */
    public Poller() throws IOException {
        this.selector = Selector.open();
    }
    
    /**
     * ğŸ”¥ æ³¨å†Œé€šé“
     */
    public void register(final NioChannel socket) {
        socket.setPoller(this);
        NioSocketWrapper ka = new NioSocketWrapper(socket, NioEndpoint.this);
        socket.setSocketWrapper(ka);
        ka.setPoller(this);
        ka.setReadTimeout(getConnectionTimeout());
        ka.setWriteTimeout(getConnectionTimeout());
        ka.setKeepAliveLeft(NioEndpoint.this.getMaxKeepAliveRequests());
        ka.setSecure(isSSLEnabled());
        PollerEvent r = eventCache.pop();
        ka.interestOps(SelectionKey.OP_READ);//this is what OP_REGISTER turns into.
        if ( r==null) r = new PollerEvent(socket,ka,OP_REGISTER);
        else r.reset(socket,ka,OP_REGISTER);
        addEvent(r);
    }
    
    /**
     * ğŸ”¥ æ·»åŠ äº‹ä»¶
     */
    public void addEvent(PollerEvent event) {
        events.offer(event);
        if ( wakeupCounter.incrementAndGet() == 0 ) selector.wakeup();
    }
    
    /**
     * ğŸ”¥ ä¸»è¿è¡Œå¾ªç¯
     */
    @Override
    public void run() {
        
        // ğŸ”¥ å¾ªç¯å¤„ç†äº‹ä»¶
        while (true) {
            
            boolean hasEvents = false;
            
            try {
                if (!close) {
                    hasEvents = events();
                    if (wakeupCounter.getAndSet(-1) > 0) {
                        // ğŸ”¥ å¦‚æœæˆ‘ä»¬è¢«å”¤é†’ï¼Œä¸è¦ç­‰å¾…
                        keyCount = selector.selectNow();
                    } else {
                        keyCount = selector.select(selectorTimeout);
                    }
                    wakeupCounter.set(0);
                }
                if (close) {
                    events();
                    timeout(0, false);
                    try {
                        selector.close();
                    } catch (IOException ioe) {
                        log.error("Error closing selector", ioe);
                    }
                    break;
                }
            } catch (Throwable x) {
                ExceptionUtils.handleThrowable(x);
                log.error("Poller error", x);
                continue;
            }
            
            // ğŸ”¥ å¤„ç†é€‰æ‹©å™¨äº‹ä»¶
            Iterator<SelectionKey> iterator = 
                keyCount > 0 ? selector.selectedKeys().iterator() : null;
                
            while (iterator != null && iterator.hasNext()) {
                SelectionKey sk = iterator.next();
                NioSocketWrapper attachment = (NioSocketWrapper)sk.attachment();
                
                if (attachment == null) {
                    iterator.remove();
                } else {
                    iterator.remove();
                    processKey(sk, attachment);
                }
            }
            
            // ğŸ”¥ å¤„ç†è¶…æ—¶
            timeout(keyCount,hasEvents);
        }
        
        getStopLatch().countDown();
    }
    
    /**
     * ğŸ”¥ å¤„ç†é€‰æ‹©é”®
     */
    protected void processKey(SelectionKey sk, NioSocketWrapper attachment) {
        
        try {
            if ( close ) {
                cancelledKey(sk);
            } else if ( sk.isValid() && attachment != null ) {
                if (sk.isReadable() || sk.isWritable() ) {
                    if ( attachment.getSendfileData() != null ) {
                        processSendfile(sk,attachment, false);
                    } else {
                        unreg(sk, attachment, sk.readyOps());
                        boolean closeSocket = false;
                        
                        // ğŸ”¥ è¯»äº‹ä»¶
                        if (sk.isReadable()) {
                            if (!processSocket(attachment, SocketEvent.OPEN_READ, true)) {
                                closeSocket = true;
                            }
                        }
                        
                        // ğŸ”¥ å†™äº‹ä»¶
                        if (!closeSocket && sk.isWritable()) {
                            if (!processSocket(attachment, SocketEvent.OPEN_WRITE, true)) {
                                closeSocket = true;
                            }
                        }
                        
                        if (closeSocket) {
                            cancelledKey(sk);
                        }
                    }
                }
            } else {
                // ğŸ”¥ æ— æ•ˆçš„é”®
                cancelledKey(sk);
            }
        } catch (CancelledKeyException ckx) {
            cancelledKey(sk);
        } catch (Throwable t) {
            ExceptionUtils.handleThrowable(t);
            log.error("Error processing key", t);
        }
    }
    
    /**
     * ğŸ”¥ å¤„ç†å¥—æ¥å­—äº‹ä»¶
     */
    public boolean processSocket(NioSocketWrapper attachment, SocketEvent status, boolean dispatch) {
        try {
            if (attachment == null) {
                return false;
            }
            SocketProcessor sc = processorCache.pop();
            if (sc == null) {
                sc = new SocketProcessor(attachment, status);
            } else {
                sc.reset(attachment, status);
            }
            Executor executor = getExecutor();
            if (dispatch && executor != null) {
                executor.execute(sc);
            } else {
                sc.run();
            }
        } catch (RejectedExecutionException ree) {
            log.warn("Socket processing request was rejected for:" + attachment, ree);
            return false;
        } catch (Throwable t) {
            ExceptionUtils.handleThrowable(t);
            log.error("Error processing socket", t);
            return false;
        }
        return true;
    }
}
```

---

## 4. çº¿ç¨‹æ± ç®¡ç†

### 4.1 ThreadPoolExecutoré…ç½®

```java
/**
 * Tomcatçº¿ç¨‹æ± é…ç½®å’Œç®¡ç†
 */
public class TomcatThreadPoolManagement {
    
    /**
     * ğŸ”¥ åˆ›å»ºæ ‡å‡†çº¿ç¨‹æ± 
     */
    public void createStandardExecutor() {
        
        // ğŸ”¥ ä»»åŠ¡é˜Ÿåˆ—
        TaskQueue taskqueue = new TaskQueue();
        
        // ğŸ”¥ çº¿ç¨‹å·¥å‚
        TaskThreadFactory tf = new TaskThreadFactory(
            getName() + "-exec-", 
            daemon, 
            getThreadPriority()
        );
        
        // ğŸ”¥ çº¿ç¨‹æ± æ‰§è¡Œå™¨
        executor = new ThreadPoolExecutor(
            getMinSpareThreads(),    // æ ¸å¿ƒçº¿ç¨‹æ•°
            getMaxThreads(),         // æœ€å¤§çº¿ç¨‹æ•°
            60,                      // ç©ºé—²æ—¶é—´
            TimeUnit.SECONDS,        // æ—¶é—´å•ä½
            taskqueue,               // ä»»åŠ¡é˜Ÿåˆ—
            tf                       // çº¿ç¨‹å·¥å‚
        );
        
        // ğŸ”¥ è®¾ç½®é˜Ÿåˆ—çš„çˆ¶æ‰§è¡Œå™¨
        taskqueue.setParent((ThreadPoolExecutor) executor);
    }
    
    /**
     * ğŸ”¥ çº¿ç¨‹æ± å‚æ•°é…ç½®
     */
    public class ThreadPoolConfig {
        
        // ğŸ”¥ æ ¸å¿ƒçº¿ç¨‹æ•°ï¼ˆæœ€å°ç©ºé—²çº¿ç¨‹ï¼‰
        private int minSpareThreads = 10;
        
        // ğŸ”¥ æœ€å¤§çº¿ç¨‹æ•°
        private int maxThreads = 200;
        
        // ğŸ”¥ æœ€å¤§é˜Ÿåˆ—å¤§å°
        private int maxQueueSize = Integer.MAX_VALUE;
        
        // ğŸ”¥ çº¿ç¨‹ç©ºé—²æ—¶é—´
        private int threadRenewalDelay = 1000;
        
        // ğŸ”¥ çº¿ç¨‹ä¼˜å…ˆçº§
        private int threadPriority = Thread.NORM_PRIORITY;
        
        // ğŸ”¥ æ˜¯å¦å®ˆæŠ¤çº¿ç¨‹
        private boolean daemon = true;
        
        // ğŸ”¥ çº¿ç¨‹åå‰ç¼€
        private String namePrefix = "tomcat-exec-";
    }
}
```

### 4.2 TaskQueueå®ç°

```java
/**
 * TaskQueue - Tomcatä»»åŠ¡é˜Ÿåˆ—
 * ä¼˜åŒ–çš„LinkedBlockingQueueï¼Œæ”¯æŒåŠ¨æ€çº¿ç¨‹åˆ›å»º
 */
public class TaskQueue extends LinkedBlockingQueue<Runnable> {
    
    private static final long serialVersionUID = 1L;
    
    // ğŸ”¥ çˆ¶çº¿ç¨‹æ± æ‰§è¡Œå™¨
    protected ThreadPoolExecutor parent = null;
    
    // ğŸ”¥ å¼ºåˆ¶å…¥é˜Ÿæ ‡å¿—
    private volatile boolean forcedRemainingCapacity = false;
    
    /**
     * ğŸ”¥ æ„é€ å‡½æ•°
     */
    public TaskQueue() {
        super();
    }
    
    public TaskQueue(int capacity) {
        super(capacity);
    }
    
    /**
     * ğŸ”¥ è®¾ç½®çˆ¶æ‰§è¡Œå™¨
     */
    public void setParent(ThreadPoolExecutor tp) {
        parent = tp;
    }
    
    /**
     * ğŸ”¥ å¼ºåˆ¶è®¾ç½®å‰©ä½™å®¹é‡
     */
    public void setForcedRemainingCapacity(boolean forcedRemainingCapacity) {
        this.forcedRemainingCapacity = forcedRemainingCapacity;
    }
    
    /**
     * ğŸ”¥ è·å–å‰©ä½™å®¹é‡
     */
    @Override
    public int remainingCapacity() {
        if (forcedRemainingCapacity) {
            // ğŸ”¥ å¼ºåˆ¶è¿”å›0ï¼Œè§¦å‘çº¿ç¨‹åˆ›å»º
            return 0;
        }
        return super.remainingCapacity();
    }
    
    /**
     * ğŸ”¥ å°è¯•æ·»åŠ ä»»åŠ¡
     * æ ¸å¿ƒé€»è¾‘ï¼šä¼˜å…ˆåˆ›å»ºçº¿ç¨‹è€Œä¸æ˜¯å…¥é˜Ÿ
     */
    @Override
    public boolean offer(Runnable o) {
        
        // ğŸ”¥ å¦‚æœæ²¡æœ‰çˆ¶æ‰§è¡Œå™¨ï¼Œä½¿ç”¨é»˜è®¤è¡Œä¸º
        if (parent == null) {
            return super.offer(o);
        }
        
        // ğŸ”¥ å¦‚æœçº¿ç¨‹æ•°å·²è¾¾åˆ°æœ€å¤§å€¼ï¼Œå…¥é˜Ÿ
        if (parent.getPoolSize() == parent.getMaximumPoolSize()) {
            return super.offer(o);
        }
        
        // ğŸ”¥ å¦‚æœæäº¤çš„ä»»åŠ¡æ•°å°äºç­‰äºå½“å‰çº¿ç¨‹æ•°ï¼Œå…¥é˜Ÿ
        if (parent.getSubmittedCount() <= parent.getPoolSize()) {
            return super.offer(o);
        }
        
        // ğŸ”¥ å¦‚æœçº¿ç¨‹æ•°å°äºæœ€å¤§å€¼ï¼Œæ‹’ç»å…¥é˜Ÿï¼Œå¼ºåˆ¶åˆ›å»ºæ–°çº¿ç¨‹
        if (parent.getPoolSize() < parent.getMaximumPoolSize()) {
            return false;
        }
        
        // ğŸ”¥ å¦åˆ™å…¥é˜Ÿ
        return super.offer(o);
    }
    
    /**
     * ğŸ”¥ é˜»å¡æ·»åŠ ä»»åŠ¡
     */
    @Override
    public boolean offer(Runnable o, long timeout, TimeUnit unit) throws InterruptedException {
        
        // ğŸ”¥ å¦‚æœæ²¡æœ‰çˆ¶æ‰§è¡Œå™¨ï¼Œä½¿ç”¨é»˜è®¤è¡Œä¸º
        if (parent == null) {
            return super.offer(o, timeout, unit);
        }
        
        // ğŸ”¥ å¦‚æœçº¿ç¨‹æ•°å·²è¾¾åˆ°æœ€å¤§å€¼ï¼Œé˜»å¡å…¥é˜Ÿ
        if (parent.getPoolSize() == parent.getMaximumPoolSize()) {
            return super.offer(o, timeout, unit);
        }
        
        // ğŸ”¥ å¦‚æœæäº¤çš„ä»»åŠ¡æ•°å°äºç­‰äºå½“å‰çº¿ç¨‹æ•°ï¼Œé˜»å¡å…¥é˜Ÿ
        if (parent.getSubmittedCount() <= parent.getPoolSize()) {
            return super.offer(o, timeout, unit);
        }
        
        // ğŸ”¥ å¦‚æœçº¿ç¨‹æ•°å°äºæœ€å¤§å€¼ï¼Œæ‹’ç»å…¥é˜Ÿï¼Œå¼ºåˆ¶åˆ›å»ºæ–°çº¿ç¨‹
        if (parent.getPoolSize() < parent.getMaximumPoolSize()) {
            return false;
        }
        
        // ğŸ”¥ å¦åˆ™é˜»å¡å…¥é˜Ÿ
        return super.offer(o, timeout, unit);
    }
    
    /**
     * ğŸ”¥ è·å–å¹¶ç§»é™¤ä»»åŠ¡
     */
    @Override
    public Runnable poll(long timeout, TimeUnit unit) throws InterruptedException {
        Runnable runnable = super.poll(timeout, unit);
        if (runnable == null && parent != null) {
            // ğŸ”¥ å¦‚æœæ²¡æœ‰ä»»åŠ¡ä¸”çº¿ç¨‹æ•°å¤§äºæ ¸å¿ƒçº¿ç¨‹æ•°ï¼Œå‡å°‘çº¿ç¨‹
            parent.setCorePoolSize(parent.getCorePoolSize());
        }
        return runnable;
    }
    
    /**
     * ğŸ”¥ è·å–å¹¶ç§»é™¤ä»»åŠ¡
     */
    @Override
    public Runnable take() throws InterruptedException {
        if (parent != null && parent.getCurrentThreadCount() > parent.getCorePoolSize()) {
            // ğŸ”¥ å¦‚æœå½“å‰çº¿ç¨‹æ•°å¤§äºæ ¸å¿ƒçº¿ç¨‹æ•°ï¼Œä½¿ç”¨è¶…æ—¶poll
            return poll(parent.getKeepAliveTime(TimeUnit.MILLISECONDS), TimeUnit.MILLISECONDS);
        }
        return super.take();
    }
}
```

### 4.3 ThreadPoolExecutoræ‰©å±•

```java
/**
 * ThreadPoolExecutoræ‰©å±•
 * æ”¯æŒæäº¤ä»»åŠ¡è®¡æ•°å’ŒåŠ¨æ€è°ƒæ•´
 */
public class ThreadPoolExecutor extends java.util.concurrent.ThreadPoolExecutor {
    
    // ğŸ”¥ æäº¤çš„ä»»åŠ¡è®¡æ•°
    private final AtomicInteger submittedCount = new AtomicInteger(0);
    
    // ğŸ”¥ æœ€åä¸€æ¬¡ä¸Šä¸‹æ–‡åœæ­¢æ—¶é—´
    private final AtomicLong lastContextStoppedTime = new AtomicLong(0L);
    
    // ğŸ”¥ æœ€åä¸€æ¬¡çº¿ç¨‹æ£€æŸ¥æ—¶é—´
    private final AtomicLong lastTimeThreadKilledItself = new AtomicLong(0L);
    
    // ğŸ”¥ çº¿ç¨‹ç»­çº¦å»¶è¿Ÿ
    private long threadRenewalDelay = 1000L;
    
    /**
     * ğŸ”¥ æ„é€ å‡½æ•°
     */
    public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime,
                              TimeUnit unit, BlockingQueue<Runnable> workQueue, ThreadFactory threadFactory,
                              RejectedExecutionHandler handler) {
        super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, threadFactory, handler);
        prestartAllCoreThreads();
    }
    
    /**
     * ğŸ”¥ æ‰§è¡Œä»»åŠ¡å‰
     */
    @Override
    protected void beforeExecute(Thread t, Runnable r) {
        if (r instanceof StopPooledThread) {
            // ğŸ”¥ åœæ­¢æ± åŒ–çº¿ç¨‹
            ((StopPooledThread) r).stop();
            return;
        }
        submittedCount.incrementAndGet();
    }
    
    /**
     * ğŸ”¥ æ‰§è¡Œä»»åŠ¡å
     */
    @Override
    protected void afterExecute(Runnable r, Throwable t) {
        submittedCount.decrementAndGet();
        if (t != null) {
            log.warn("Error in afterExecute", t);
        }
    }
    
    /**
     * ğŸ”¥ è·å–æäº¤çš„ä»»åŠ¡æ•°
     */
    public int getSubmittedCount() {
        return submittedCount.get();
    }
    
    /**
     * ğŸ”¥ è·å–å½“å‰çº¿ç¨‹æ•°
     */
    public int getCurrentThreadCount() {
        return getPoolSize();
    }
    
    /**
     * ğŸ”¥ è·å–å½“å‰çº¿ç¨‹å¿™ç¢Œæ•°
     */
    public int getCurrentThreadsBusy() {
        return getActiveCount();
    }
    
    /**
     * ğŸ”¥ æ£€æŸ¥æ˜¯å¦éœ€è¦åœæ­¢çº¿ç¨‹
     */
    protected boolean shouldStopThread() {
        int poolSize = getPoolSize();
        int corePoolSize = getCorePoolSize();
        
        if (poolSize > corePoolSize) {
            long now = System.currentTimeMillis();
            if (now - lastContextStoppedTime.get() > threadRenewalDelay) {
                // ğŸ”¥ å¦‚æœè·ç¦»ä¸Šæ¬¡ä¸Šä¸‹æ–‡åœæ­¢æ—¶é—´è¶…è¿‡ç»­çº¦å»¶è¿Ÿï¼Œåœæ­¢çº¿ç¨‹
                return true;
            }
        }
        return false;
    }
    
    /**
     * ğŸ”¥ ä¸Šä¸‹æ–‡åœæ­¢
     */
    public void contextStopping() {
        lastContextStoppedTime.set(System.currentTimeMillis());
        
        // ğŸ”¥ ä¿å­˜å½“å‰çº¿ç¨‹æ•°
        int savedCorePoolSize = getCorePoolSize();
        TaskQueue taskQueue = getQueue() instanceof TaskQueue ? (TaskQueue) getQueue() : null;
        
        // ğŸ”¥ ä¸´æ—¶è®¾ç½®æ ¸å¿ƒçº¿ç¨‹æ•°ä¸ºå½“å‰çº¿ç¨‹æ•°
        setCorePoolSize(getPoolSize());
        
        // ğŸ”¥ å¼ºåˆ¶è®¾ç½®é˜Ÿåˆ—å‰©ä½™å®¹é‡
        if (taskQueue != null) {
            taskQueue.setForcedRemainingCapacity(true);
        }
        
        // ğŸ”¥ æ¢å¤æ ¸å¿ƒçº¿ç¨‹æ•°
        setCorePoolSize(savedCorePoolSize);
        
        // ğŸ”¥ æ¢å¤é˜Ÿåˆ—å‰©ä½™å®¹é‡
        if (taskQueue != null) {
            taskQueue.setForcedRemainingCapacity(false);
        }
    }
}
```

---

## 5. è¯·æ±‚å¤„ç†æµç¨‹

### 5.1 SocketProcessorå¤„ç†å™¨

```java
/**
 * SocketProcessor - å¥—æ¥å­—å¤„ç†å™¨
 * åœ¨Workerçº¿ç¨‹ä¸­æ‰§è¡ŒHTTPè¯·æ±‚å¤„ç†
 */
protected class SocketProcessor extends SocketProcessorBase<NioChannel> {
    
    /**
     * ğŸ”¥ æ„é€ å‡½æ•°
     */
    public SocketProcessor(SocketWrapperBase<NioChannel> socketWrapper, SocketEvent event) {
        super(socketWrapper, event);
    }
    
    /**
     * ğŸ”¥ æ‰§è¡Œå¤„ç†é€»è¾‘
     */
    @Override
    protected void doRun() {
        NioChannel socket = socketWrapper.getSocket();
        SelectionKey key = socket.getIOChannel().keyFor(socket.getPoller().getSelector());
        
        try {
            int handshake = -1;
            
            try {
                if (key != null) {
                    if (socket.isHandshakeComplete()) {
                        // ğŸ”¥ æ¡æ‰‹å·²å®Œæˆï¼Œæ­£å¸¸å¤„ç†
                        handshake = 0;
                    } else if (event == SocketEvent.STOP || event == SocketEvent.DISCONNECT ||
                               event == SocketEvent.ERROR) {
                        // ğŸ”¥ è¿æ¥äº‹ä»¶ï¼Œç›´æ¥å¤„ç†
                        handshake = 0;
                    } else {
                        // ğŸ”¥ æ‰§è¡Œæ¡æ‰‹
                        handshake = socket.handshake(key.isReadable(), key.isWritable());
                        event = SocketEvent.OPEN_READ;
                    }
                }
            } catch (IOException x) {
                handshake = -1;
                if (log.isDebugEnabled()) log.debug("Error during SSL handshake",x);
            } catch (CancelledKeyException ckx) {
                handshake = -1;
            }
            
            if (handshake == 0) {
                SocketState state = SocketState.OPEN;
                
                // ğŸ”¥ å¤„ç†å¥—æ¥å­—äº‹ä»¶
                if (event == null) {
                    state = getHandler().process(socketWrapper, SocketEvent.OPEN_READ);
                } else {
                    state = getHandler().process(socketWrapper, event);
                }
                
                // ğŸ”¥ æ ¹æ®çŠ¶æ€å†³å®šåç»­æ“ä½œ
                if (state == SocketState.CLOSED) {
                    close(socket, key);
                } else if (state == SocketState.OPEN || state == SocketState.UPGRADING) {
                    socket.setKeptAlive(true);
                    socket.access();
                    if (key != null) {
                        socketWrapper.interestOps(SelectionKey.OP_READ);
                        key.attach(socketWrapper);
                    }
                } else if (state == SocketState.LONG) {
                    socket.access();
                    if (key != null) {
                        key.attach(socketWrapper);
                    }
                } else if (state == SocketState.ASYNC_END || state == SocketState.ASYNC_ERROR) {
                    if (key != null) {
                        socketWrapper.interestOps(0);
                        key.attach(socketWrapper);
                    }
                }
            } else if (handshake == -1 ) {
                close(socket, key);
            } else if (handshake == SelectionKey.OP_READ){
                socketWrapper.interestOps(SelectionKey.OP_READ);
                key.attach(socketWrapper);
            } else if (handshake == SelectionKey.OP_WRITE){
                socketWrapper.interestOps(SelectionKey.OP_WRITE);
                key.attach(socketWrapper);
            }
        } catch (CancelledKeyException cx) {
            socket.getPoller().cancelledKey(key);
        } catch (VirtualMachineError vme) {
            ExceptionUtils.handleThrowable(vme);
        } catch (Throwable t) {
            log.error("Error processing socket", t);
            socket.getPoller().cancelledKey(key);
        } finally {
            socketWrapper = null;
            event = null;
            //return to cache
            if (running && !paused) {
                processorCache.push(this);
            }
        }
    }
}
```

### 5.2 Http11Processorè¯·æ±‚å¤„ç†

```java
/**
 * Http11Processor - HTTP/1.1åè®®å¤„ç†å™¨
 * è§£æHTTPè¯·æ±‚å¹¶ç”Ÿæˆå“åº”
 */
public class Http11Processor extends AbstractProcessor {
    
    /**
     * ğŸ”¥ å¤„ç†HTTPè¯·æ±‚
     */
    @Override
    public SocketState process(SocketWrapperBase<?> socketWrapper, SocketEvent status)
            throws IOException {
        
        SocketState state = SocketState.CLOSED;
        Iterator<DispatchType> dispatches = null;
        
        do {
            if (dispatches != null) {
                DispatchType nextDispatch = dispatches.next();
                if (getLog().isDebugEnabled()) {
                    getLog().debug("Processing dispatch type: " + nextDispatch);
                }
                state = dispatch(nextDispatch.getSocketStatus());
                if (!dispatches.hasNext()) {
                    state = checkForPipelinedData(state, socketWrapper);
                }
            } else if (status == SocketEvent.DISCONNECT) {
                // ğŸ”¥ å¤„ç†æ–­å¼€è¿æ¥
                state = SocketState.CLOSED;
            } else if (isAsync() || isUpgrade()) {
                state = dispatch(status);
                if (state == SocketState.OPEN) {
                    state = service(socketWrapper);
                }
            } else if (status == SocketEvent.OPEN_WRITE) {
                // ğŸ”¥ å¤„ç†å†™äº‹ä»¶
                state = SocketState.LONG;
            } else if (status == SocketEvent.OPEN_READ) {
                // ğŸ”¥ å¤„ç†è¯»äº‹ä»¶
                state = service(socketWrapper);
            } else if (status == SocketEvent.CONNECT_FAIL) {
                logAccess(socketWrapper);
            } else {
                // ğŸ”¥ é»˜è®¤å¤„ç†
                state = SocketState.CLOSED;
            }
            
            if (getLog().isDebugEnabled()) {
                getLog().debug("Socket: [" + socketWrapper + "], Status in: [" + status +
                              "], State out: [" + state + "]");
            }
            
            if (isAsync()) {
                state = asyncPostProcess();
                if (getLog().isDebugEnabled()) {
                    getLog().debug("Socket: [" + socketWrapper + "], State after async post processing: [" + state + "]");
                }
            }
            
            if (dispatches == null || !dispatches.hasNext()) {
                dispatches = getIteratorAndClearDispatches();
            }
        } while (state == SocketState.ASYNC_END ||
                 dispatches != null && state != SocketState.CLOSED);
        
        return state;
    }
    
    /**
     * ğŸ”¥ æœåŠ¡å¤„ç†
     */
    @Override
    public SocketState service(SocketWrapperBase<?> socketWrapper) throws IOException {
        
        RequestInfo rp = request.getRequestProcessor();
        rp.setStage(org.apache.coyote.Constants.STAGE_PARSE);
        
        // ğŸ”¥ è®¾ç½®è¯·æ±‚å¼€å§‹æ—¶é—´
        request.setStartTime(System.currentTimeMillis());
        
        boolean keptAlive = false;
        boolean openSocket = false;
        boolean readComplete = true;
        boolean http11 = true;
        Error error = null;
        
        try {
            if (!inputBuffer.parseRequestLine(keptAlive, protocol.getConnectionTimeout(),
                                              protocol.getKeepAliveTimeout())) {
                
                if (inputBuffer.getParsingRequestLinePhase() == -1) {
                    return SocketState.UPGRADING;
                } else if (handleIncompleteRequestLineRead()) {
                    break;
                }
            }
            
            // ğŸ”¥ è§£æè¯·æ±‚å¤´
            if (!inputBuffer.parseHeaders()) {
                openSocket = true;
                readComplete = false;
                break;
            }
            
            if (!disableUploadTimeout) {
                socketWrapper.setReadTimeout(connectionUploadTimeout);
            }
            
        } catch (IOException e) {
            if (log.isDebugEnabled()) {
                log.debug("Error parsing HTTP request header", e);
            }
            error = new Error();
            break;
        } catch (Throwable t) {
            ExceptionUtils.handleThrowable(t);
            UserDataHelper.Mode logMode = userDataHelper.getNextMode();
            if (logMode != null) {
                String message = "Error parsing HTTP request header";
                switch (logMode) {
                    case INFO_THEN_DEBUG:
                        message += " Note: further occurrences of HTTP request parsing errors will be logged at DEBUG level.";
                        log.info(message, t);
                        break;
                    case INFO:
                        log.info(message, t);
                        break;
                    case DEBUG:
                        log.debug(message, t);
                        break;
                }
            }
            response.setStatus(400);
            error = new Error();
        }
        
        // ğŸ”¥ è®¾ç½®å¤„ç†é˜¶æ®µ
        rp.setStage(org.apache.coyote.Constants.STAGE_SERVICE);
        
        try {
            // ğŸ”¥ è°ƒç”¨é€‚é…å™¨å¤„ç†è¯·æ±‚
            getAdapter().service(request, response);
            
            if(keepAlive && !error && !isAsync() && statusDropsConnection(response.getStatus())) {
                error = new Error();
            }
        } catch (InterruptedIOException e) {
            error = new Error();
        } catch (HeadersTooLargeException e) {
            error = new Error();
            if (response.isCommitted()) {
                throw new IOException("Response header is too large");
            }
        } catch (Throwable t) {
            ExceptionUtils.handleThrowable(t);
            log.error("Error processing request", t);
            error = new Error();
        }
        
        // ğŸ”¥ å®Œæˆè¯·æ±‚å¤„ç†
        rp.setStage(org.apache.coyote.Constants.STAGE_ENDINPUT);
        
        if (!isAsync()) {
            endRequest();
        }
        
        rp.setStage(org.apache.coyote.Constants.STAGE_ENDOUTPUT);
        
        // ğŸ”¥ å¦‚æœæœ‰é”™è¯¯ï¼Œå…³é—­è¿æ¥
        if (error != null) {
            response.setStatus(500);
            response.setError();
        }
        
        if (!isAsync()) {
            if (getErrorState().isError()) {
                return SocketState.CLOSED;
            } else if (isUpgrade()) {
                return SocketState.UPGRADING;
            } else {
                if (sendfileData != null) {
                    return SocketState.SENDFILE;
                } else {
                    if (openSocket) {
                        if (readComplete) {
                            return SocketState.OPEN;
                        } else {
                            return SocketState.LONG;
                        }
                    } else {
                        return SocketState.CLOSED;
                    }
                }
            }
        }
        
        return SocketState.LONG;
    }
}
```

---

## 6. æ€§èƒ½ä¼˜åŒ–

### 6.1 çº¿ç¨‹æ± è°ƒä¼˜å‚æ•°

```xml
<!-- ğŸ”¥ Connectorçº¿ç¨‹æ± é…ç½® -->
<Connector port="8080" 
           protocol="org.apache.coyote.http11.Http11NioProtocol"
           connectionTimeout="20000"
           redirectPort="8443"
           
           <!-- çº¿ç¨‹æ± é…ç½® -->
           minSpareThreads="10"
           maxThreads="200"
           acceptCount="100"
           
           <!-- è¿æ¥é…ç½® -->
           maxConnections="8192"
           acceptorThreadCount="1"
           pollerThreadCount="1"
           
           <!-- æ€§èƒ½ä¼˜åŒ– -->
           enableLookups="false"
           disableUploadTimeout="true"
           compression="on"
           compressionMinSize="2048"
           noCompressionUserAgents="gozilla, traviata"
           compressableMimeType="text/html,text/xml,text/plain,text/css,text/javascript,application/javascript,application/json"
           
           <!-- NIOä¼˜åŒ– -->
           socket.directBuffer="true"
           socket.appReadBufSize="8192"
           socket.appWriteBufSize="8192"
           socket.bufferPool="500"
           socket.processorCache="500"
           socket.keyCache="500"
           socket.eventCache="500" />
```

### 6.2 æ€§èƒ½ç›‘æ§æŒ‡æ ‡

```java
/**
 * Tomcatçº¿ç¨‹æ± æ€§èƒ½ç›‘æ§
 */
public class ThreadPoolMonitoring {
    
    /**
     * ğŸ”¥ è·å–çº¿ç¨‹æ± ç»Ÿè®¡ä¿¡æ¯
     */
    public ThreadPoolStats getThreadPoolStats(ThreadPoolExecutor executor) {
        
        ThreadPoolStats stats = new ThreadPoolStats();
        
        // ğŸ”¥ åŸºæœ¬ä¿¡æ¯
        stats.setCorePoolSize(executor.getCorePoolSize());
        stats.setMaximumPoolSize(executor.getMaximumPoolSize());
        stats.setPoolSize(executor.getPoolSize());
        stats.setActiveCount(executor.getActiveCount());
        
        // ğŸ”¥ ä»»åŠ¡ç»Ÿè®¡
        stats.setTaskCount(executor.getTaskCount());
        stats.setCompletedTaskCount(executor.getCompletedTaskCount());
        stats.setQueueSize(executor.getQueue().size());
        
        // ğŸ”¥ æ‰©å±•ç»Ÿè®¡ï¼ˆå¦‚æœæ˜¯Tomcatçš„ThreadPoolExecutorï¼‰
        if (executor instanceof org.apache.tomcat.util.threads.ThreadPoolExecutor) {
            org.apache.tomcat.util.threads.ThreadPoolExecutor tomcatExecutor = 
                (org.apache.tomcat.util.threads.ThreadPoolExecutor) executor;
            stats.setSubmittedCount(tomcatExecutor.getSubmittedCount());
            stats.setCurrentThreadsBusy(tomcatExecutor.getCurrentThreadsBusy());
        }
        
        return stats;
    }
    
    /**
     * ğŸ”¥ çº¿ç¨‹æ± ç»Ÿè®¡ä¿¡æ¯
     */
    public static class ThreadPoolStats {
        private int corePoolSize;
        private int maximumPoolSize;
        private int poolSize;
        private int activeCount;
        private long taskCount;
        private long completedTaskCount;
        private int queueSize;
        private int submittedCount;
        private int currentThreadsBusy;
        
        // ğŸ”¥ è®¡ç®—çº¿ç¨‹æ± åˆ©ç”¨ç‡
        public double getThreadUtilization() {
            return maximumPoolSize > 0 ? (double) activeCount / maximumPoolSize : 0.0;
        }
        
        // ğŸ”¥ è®¡ç®—é˜Ÿåˆ—åˆ©ç”¨ç‡
        public double getQueueUtilization() {
            return queueSize > 0 ? (double) queueSize / (queueSize + 100) : 0.0;
        }
        
        // ğŸ”¥ è®¡ç®—ä»»åŠ¡å®Œæˆç‡
        public double getTaskCompletionRate() {
            return taskCount > 0 ? (double) completedTaskCount / taskCount : 0.0;
        }
        
        // getterå’Œsetteræ–¹æ³•...
    }
    
    /**
     * ğŸ”¥ æ€§èƒ½è°ƒä¼˜å»ºè®®
     */
    public List<String> getPerformanceTuningAdvice(ThreadPoolStats stats) {
        
        List<String> advice = new ArrayList<>();
        
        // ğŸ”¥ çº¿ç¨‹æ•°è°ƒä¼˜
        if (stats.getThreadUtilization() > 0.8) {
            advice.add("çº¿ç¨‹åˆ©ç”¨ç‡è¿‡é«˜(" + String.format("%.2f", stats.getThreadUtilization() * 100) + 
                      "%)ï¼Œå»ºè®®å¢åŠ maxThreads");
        }
        
        if (stats.getThreadUtilization() < 0.2 && stats.getPoolSize() > stats.getCorePoolSize()) {
            advice.add("çº¿ç¨‹åˆ©ç”¨ç‡è¾ƒä½(" + String.format("%.2f", stats.getThreadUtilization() * 100) + 
                      "%)ï¼Œå¯ä»¥è€ƒè™‘å‡å°‘maxThreads");
        }
        
        // ğŸ”¥ é˜Ÿåˆ—è°ƒä¼˜
        if (stats.getQueueUtilization() > 0.7) {
            advice.add("ä»»åŠ¡é˜Ÿåˆ—åˆ©ç”¨ç‡è¿‡é«˜(" + String.format("%.2f", stats.getQueueUtilization() * 100) + 
                      "%)ï¼Œå¯èƒ½å­˜åœ¨æ€§èƒ½ç“¶é¢ˆ");
        }
        
        // ğŸ”¥ æ ¸å¿ƒçº¿ç¨‹æ•°è°ƒä¼˜
        if (stats.getActiveCount() > stats.getCorePoolSize() * 1.5) {
            advice.add("æ´»è·ƒçº¿ç¨‹æ•°è¶…è¿‡æ ¸å¿ƒçº¿ç¨‹æ•°è¾ƒå¤šï¼Œå»ºè®®å¢åŠ minSpareThreads");
        }
        
        return advice;
    }
}
```

### 6.3 JVMè°ƒä¼˜å‚æ•°

```bash
# ğŸ”¥ Tomcat JVMè°ƒä¼˜å‚æ•°
export CATALINA_OPTS="$CATALINA_OPTS -server"

# ğŸ”¥ å†…å­˜è®¾ç½®
export CATALINA_OPTS="$CATALINA_OPTS -Xms2g -Xmx4g"
export CATALINA_OPTS="$CATALINA_OPTS -XX:MetaspaceSize=256m -XX:MaxMetaspaceSize=512m"

# ğŸ”¥ åƒåœ¾å›æ”¶å™¨
export CATALINA_OPTS="$CATALINA_OPTS -XX:+UseG1GC"
export CATALINA_OPTS="$CATALINA_OPTS -XX:MaxGCPauseMillis=200"
export CATALINA_OPTS="$CATALINA_OPTS -XX:G1HeapRegionSize=16m"

# ğŸ”¥ GCæ—¥å¿—
export CATALINA_OPTS="$CATALINA_OPTS -XX:+PrintGC -XX:+PrintGCDetails"
export CATALINA_OPTS="$CATALINA_OPTS -XX:+PrintGCTimeStamps -XX:+PrintGCApplicationStoppedTime"
export CATALINA_OPTS="$CATALINA_OPTS -Xloggc:$CATALINA_HOME/logs/gc.log"

# ğŸ”¥ çº¿ç¨‹ä¼˜åŒ–
export CATALINA_OPTS="$CATALINA_OPTS -XX:+UseBiasedLocking"
export CATALINA_OPTS="$CATALINA_OPTS -XX:+UseFastAccessorMethods"

# ğŸ”¥ ç½‘ç»œä¼˜åŒ–
export CATALINA_OPTS="$CATALINA_OPTS -Djava.net.preferIPv4Stack=true"
export CATALINA_OPTS="$CATALINA_OPTS -Dsun.net.inetaddr.ttl=60"

# ğŸ”¥ å®‰å…¨éšæœºæ•°ä¼˜åŒ–
export CATALINA_OPTS="$CATALINA_OPTS -Djava.security.egd=file:/dev/./urandom"

# ğŸ”¥ æ–‡ä»¶ç¼–ç 
export CATALINA_OPTS="$CATALINA_OPTS -Dfile.encoding=UTF-8"

# ğŸ”¥ æ—¶åŒºè®¾ç½®
export CATALINA_OPTS="$CATALINA_OPTS -Duser.timezone=Asia/Shanghai"
```

---

## 7. é¢è¯•è¦ç‚¹

### 7.1 æ ¸å¿ƒæ¦‚å¿µ

```
ğŸ¯ Tomcatçº¿ç¨‹æ¨¡å‹é¢è¯•è¦ç‚¹

1. çº¿ç¨‹æ¨¡å‹æ¶æ„
   Q: Tomcatçš„çº¿ç¨‹æ¨¡å‹æ˜¯æ€æ ·çš„ï¼Ÿ
   A: 
   - Acceptorçº¿ç¨‹ï¼šæ¥å—è¿æ¥
   - Pollerçº¿ç¨‹ï¼šç›‘å¬I/Oäº‹ä»¶ï¼ˆNIOï¼‰
   - Workerçº¿ç¨‹æ± ï¼šå¤„ç†HTTPè¯·æ±‚
   - åå°çº¿ç¨‹ï¼šå®šæœŸæ¸…ç†ä»»åŠ¡

2. NIO vs BIO
   Q: Tomcatçš„NIOå’ŒBIOæœ‰ä»€ä¹ˆåŒºåˆ«ï¼Ÿ
   A:
   - BIOï¼šæ¯ä¸ªè¿æ¥ä¸€ä¸ªçº¿ç¨‹ï¼Œé˜»å¡I/O
   - NIOï¼šå°‘é‡çº¿ç¨‹å¤„ç†å¤§é‡è¿æ¥ï¼Œéé˜»å¡I/O
   - NIOæ”¯æŒæ›´é«˜çš„å¹¶å‘è¿æ¥æ•°

3. çº¿ç¨‹æ± é…ç½®
   Q: å¦‚ä½•é…ç½®Tomcatçº¿ç¨‹æ± ï¼Ÿ
   A:
   - minSpareThreadsï¼šæœ€å°ç©ºé—²çº¿ç¨‹æ•°
   - maxThreadsï¼šæœ€å¤§çº¿ç¨‹æ•°
   - acceptCountï¼šç­‰å¾…é˜Ÿåˆ—å¤§å°
   - maxConnectionsï¼šæœ€å¤§è¿æ¥æ•°

4. æ€§èƒ½è°ƒä¼˜
   Q: å¦‚ä½•ä¼˜åŒ–Tomcatçº¿ç¨‹æ€§èƒ½ï¼Ÿ
   A:
   - åˆç†è®¾ç½®çº¿ç¨‹æ± å‚æ•°
   - ä½¿ç”¨NIOè¿æ¥å™¨
   - å¯ç”¨è¿æ¥æ± 
   - è°ƒä¼˜JVMå‚æ•°
```

### 7.2 å®é™…åº”ç”¨

```
ğŸ”§ å®é™…åº”ç”¨åœºæ™¯

1. é«˜å¹¶å‘ä¼˜åŒ–
   åœºæ™¯: ç³»ç»Ÿéœ€è¦æ”¯æŒ10000+å¹¶å‘è¿æ¥
   æ–¹æ¡ˆ:
   - ä½¿ç”¨NIOè¿æ¥å™¨
   - å¢åŠ maxConnections
   - ä¼˜åŒ–çº¿ç¨‹æ± é…ç½®
   - å¯ç”¨è¿æ¥å¤ç”¨

2. å†…å­˜ä¼˜åŒ–
   åœºæ™¯: å‡å°‘å†…å­˜å ç”¨
   æ–¹æ¡ˆ:
   - å‡å°‘maxThreads
   - ä¼˜åŒ–å¯¹è±¡æ± é…ç½®
   - ä½¿ç”¨ç›´æ¥å†…å­˜ç¼“å†²åŒº
   - è°ƒæ•´JVMå †å¤§å°

3. å“åº”æ—¶é—´ä¼˜åŒ–
   åœºæ™¯: é™ä½è¯·æ±‚å“åº”æ—¶é—´
   æ–¹æ¡ˆ:
   - å¢åŠ Workerçº¿ç¨‹æ•°
   - ä¼˜åŒ–ä¸šåŠ¡é€»è¾‘
   - ä½¿ç”¨å¼‚æ­¥å¤„ç†
   - å¯ç”¨HTTPå‹ç¼©

4. ç¨³å®šæ€§ä¼˜åŒ–
   åœºæ™¯: æé«˜ç³»ç»Ÿç¨³å®šæ€§
   æ–¹æ¡ˆ:
   - è®¾ç½®åˆç†çš„è¶…æ—¶æ—¶é—´
   - é…ç½®è¿æ¥æ•°é™åˆ¶
   - ç›‘æ§çº¿ç¨‹æ± çŠ¶æ€
   - å®ç°ä¼˜é›…å…³é—­
```

### 7.3 å¸¸è§é—®é¢˜

```
â“ å¸¸è§é¢è¯•é—®é¢˜

Q1: Tomcatå¦‚ä½•å¤„ç†å¤§é‡å¹¶å‘è¿æ¥ï¼Ÿ
A1: 
- ä½¿ç”¨NIOè¿æ¥å™¨å®ç°éé˜»å¡I/O
- Acceptoræ¥å—è¿æ¥ï¼ŒPollerç›‘å¬äº‹ä»¶
- Workerçº¿ç¨‹æ± å¤„ç†è¯·æ±‚
- è¿æ¥å¤ç”¨å‡å°‘çº¿ç¨‹åˆ›å»ºå¼€é”€

Q2: å¦‚ä½•ç¡®å®šåˆé€‚çš„çº¿ç¨‹æ± å¤§å°ï¼Ÿ
A2:
- CPUå¯†é›†å‹ï¼šçº¿ç¨‹æ•° = CPUæ ¸å¿ƒæ•° + 1
- I/Oå¯†é›†å‹ï¼šçº¿ç¨‹æ•° = CPUæ ¸å¿ƒæ•° * (1 + I/Oç­‰å¾…æ—¶é—´/CPUå¤„ç†æ—¶é—´)
- é€šè¿‡å‹æµ‹å’Œç›‘æ§ç¡®å®šæœ€ä¼˜å€¼

Q3: Tomcatçº¿ç¨‹æ± å’ŒJDKçº¿ç¨‹æ± æœ‰ä»€ä¹ˆåŒºåˆ«ï¼Ÿ
A3:
- Tomcatçš„TaskQueueä¼˜å…ˆåˆ›å»ºçº¿ç¨‹è€Œä¸æ˜¯å…¥é˜Ÿ
- æ”¯æŒåŠ¨æ€è°ƒæ•´å’Œç›‘æ§
- é’ˆå¯¹Webè¯·æ±‚å¤„ç†ä¼˜åŒ–
- æä¾›æ›´è¯¦ç»†çš„ç»Ÿè®¡ä¿¡æ¯

Q4: å¦‚ä½•ç›‘æ§Tomcatçº¿ç¨‹æ± æ€§èƒ½ï¼Ÿ
A4:
- JMXç›‘æ§çº¿ç¨‹æ± æŒ‡æ ‡
- æŸ¥çœ‹Manageråº”ç”¨çŠ¶æ€
- åˆ†æGCæ—¥å¿—
- ä½¿ç”¨APMå·¥å…·ç›‘æ§

Q5: çº¿ç¨‹æ± æ»¡äº†æ€ä¹ˆåŠï¼Ÿ
A5:
- è¯·æ±‚ä¼šè¿›å…¥acceptCounté˜Ÿåˆ—ç­‰å¾…
- é˜Ÿåˆ—æ»¡åæ‹’ç»æ–°è¿æ¥
- å¯ä»¥é€šè¿‡å¢åŠ çº¿ç¨‹æ•°æˆ–ä¼˜åŒ–å¤„ç†é€»è¾‘è§£å†³
- å®ç°é™çº§å’Œé™æµæœºåˆ¶
```

### 7.4 æœ€ä½³å®è·µ

```
âœ… å¼€å‘æœ€ä½³å®è·µ

1. çº¿ç¨‹æ± é…ç½®
   - æ ¹æ®ä¸šåŠ¡ç‰¹ç‚¹è®¾ç½®åˆé€‚çš„çº¿ç¨‹æ•°
   - é¢„ç•™ä¸€å®šçš„ç¼“å†²ç©ºé—´
   - å®šæœŸç›‘æ§å’Œè°ƒæ•´å‚æ•°
   - é¿å…çº¿ç¨‹æ•°è®¾ç½®è¿‡å¤§å¯¼è‡´ä¸Šä¸‹æ–‡åˆ‡æ¢å¼€é”€

2. è¿æ¥ç®¡ç†
   - è®¾ç½®åˆç†çš„è¿æ¥è¶…æ—¶æ—¶é—´
   - å¯ç”¨è¿æ¥å¤ç”¨
   - ç›‘æ§è¿æ¥æ•°ä½¿ç”¨æƒ…å†µ
   - å®ç°è¿æ¥æ± é¢„çƒ­

3. æ€§èƒ½ç›‘æ§
   - ç›‘æ§çº¿ç¨‹æ± åˆ©ç”¨ç‡
   - å…³æ³¨é˜Ÿåˆ—é•¿åº¦å˜åŒ–
   - åˆ†æå“åº”æ—¶é—´åˆ†å¸ƒ
   - è®¾ç½®æ€§èƒ½å‘Šè­¦é˜ˆå€¼

4. æ•…éšœå¤„ç†
   - å®ç°ä¼˜é›…å…³é—­æœºåˆ¶
   - é…ç½®åˆç†çš„æ‹’ç»ç­–ç•¥
   - è®°å½•è¯¦ç»†çš„æ€§èƒ½æ—¥å¿—
   - å»ºç«‹æ€§èƒ½åŸºçº¿å’Œå®¹é‡è§„åˆ’
```

---

## ğŸ“‹ æ€»ç»“

Tomcatçš„çº¿ç¨‹æ¨¡å‹æ˜¯ä¸€ä¸ªé«˜æ•ˆçš„å¼‚æ­¥éé˜»å¡I/Oå¤„ç†æ¶æ„ï¼Œé€šè¿‡Acceptorã€Pollerå’ŒWorkerçº¿ç¨‹çš„åä½œï¼Œå®ç°äº†é«˜å¹¶å‘è¯·æ±‚çš„å¤„ç†èƒ½åŠ›ã€‚ç†è§£è¿™ä¸ªæ¨¡å‹å¯¹äºTomcatæ€§èƒ½è°ƒä¼˜å’Œæ•…éšœæ’æŸ¥éƒ½éå¸¸é‡è¦ã€‚

**æ ¸å¿ƒè¦ç‚¹**ï¼š
- **åˆ†å±‚æ¶æ„**ï¼šAcceptoræ¥å—è¿æ¥ï¼ŒPollerç›‘å¬äº‹ä»¶ï¼ŒWorkerå¤„ç†è¯·æ±‚
- **å¼‚æ­¥éé˜»å¡**ï¼šåŸºäºNIOå®ç°é«˜å¹¶å‘è¿æ¥å¤„ç†
- **çº¿ç¨‹æ± ç®¡ç†**ï¼šä¼˜åŒ–çš„ä»»åŠ¡é˜Ÿåˆ—å’ŒåŠ¨æ€çº¿ç¨‹è°ƒæ•´
- **æ€§èƒ½ç›‘æ§**ï¼šä¸°å¯Œçš„ç›‘æ§æŒ‡æ ‡å’Œè°ƒä¼˜å‚æ•°

æŒæ¡è¿™äº›çŸ¥è¯†ç‚¹ï¼Œèƒ½å¤Ÿå¸®åŠ©æˆ‘ä»¬æ›´å¥½åœ°ç†è§£Tomcatçš„å·¥ä½œåŸç†ï¼Œè¿›è¡Œæœ‰æ•ˆçš„æ€§èƒ½è°ƒä¼˜ï¼Œå¹¶è§£å†³å®é™…ç”Ÿäº§ç¯å¢ƒä¸­çš„å¹¶å‘é—®é¢˜ã€‚
# Tomcat Connectoræºç è§£æ

> ğŸ’¡ æ·±å…¥ç†è§£Tomcatè¿æ¥å™¨çš„å®ç°åŸç†ï¼ŒæŒæ¡ç½‘ç»œè¯·æ±‚å¤„ç†æœºåˆ¶

---

## ğŸ“š ç›®å½•

1. [Connectoræ¦‚è¿°](#1-connectoræ¦‚è¿°)
2. [æ ¸å¿ƒç»„ä»¶](#2-æ ¸å¿ƒç»„ä»¶)
3. [Endpointå®ç°](#3-endpointå®ç°)
4. [åè®®å¤„ç†](#4-åè®®å¤„ç†)
5. [è¯·æ±‚å¤„ç†æµç¨‹](#5-è¯·æ±‚å¤„ç†æµç¨‹)
6. [NIOæ¨¡å‹è¯¦è§£](#6-nioæ¨¡å‹è¯¦è§£)
7. [é¢è¯•è¦ç‚¹](#7-é¢è¯•è¦ç‚¹)

---

## 1. Connectoræ¦‚è¿°

### 1.1 Connectoræ¶æ„

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Connectoræ¶æ„                             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚                    Connector                         â”‚   â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚   â”‚
â”‚  â”‚  â”‚              ProtocolHandler                 â”‚    â”‚   â”‚
â”‚  â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚    â”‚   â”‚
â”‚  â”‚  â”‚  â”‚    Endpoint     â”‚  â”‚    Processor    â”‚   â”‚    â”‚   â”‚
â”‚  â”‚  â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚  â”‚                 â”‚   â”‚    â”‚   â”‚
â”‚  â”‚  â”‚  â”‚  â”‚ Acceptor  â”‚  â”‚  â”‚  HTTP/1.1è§£æ   â”‚   â”‚    â”‚   â”‚
â”‚  â”‚  â”‚  â”‚  â”‚           â”‚  â”‚  â”‚  HTTP/2è§£æ     â”‚   â”‚    â”‚   â”‚
â”‚  â”‚  â”‚  â”‚  â”‚ Poller    â”‚  â”‚  â”‚  AJPè§£æ       â”‚   â”‚    â”‚   â”‚
â”‚  â”‚  â”‚  â”‚  â”‚           â”‚  â”‚  â”‚                 â”‚   â”‚    â”‚   â”‚
â”‚  â”‚  â”‚  â”‚  â”‚ Executor  â”‚  â”‚  â”‚                 â”‚   â”‚    â”‚   â”‚
â”‚  â”‚  â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚    â”‚   â”‚
â”‚  â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                        â”‚    â”‚   â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                             â”‚
â”‚  ç½‘ç»œè¯·æ±‚ â”€â”€â–¶ Endpoint â”€â”€â–¶ Processor â”€â”€â–¶ Adapter â”€â”€â–¶ Container
â”‚                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 1.2 æ ¸å¿ƒèŒè´£

```java
// Connectorçš„æ ¸å¿ƒèŒè´£ï¼š
// 1. ç›‘å¬ç½‘ç»œç«¯å£ï¼Œæ¥æ”¶è¿æ¥
// 2. è§£æHTTP/AJPåè®®
// 3. å°†è¯·æ±‚è½¬å‘ç»™Containerå¤„ç†
// 4. å°†å“åº”è¿”å›ç»™å®¢æˆ·ç«¯

// æ”¯æŒçš„åè®®ï¼š
// - HTTP/1.1 (é»˜è®¤)
// - HTTP/2
// - AJP (Apache JServ Protocol)

// æ”¯æŒçš„I/Oæ¨¡å‹ï¼š
// - NIO (é»˜è®¤)
// - NIO2 (å¼‚æ­¥I/O)
// - APR (Apache Portable Runtime)
```


---

## 2. æ ¸å¿ƒç»„ä»¶

### 2.1 Connectorç±»

```java
/**
 * Connector - è¿æ¥å™¨
 * è´Ÿè´£æ¥æ”¶ç½‘ç»œè¯·æ±‚å¹¶è½¬å‘ç»™Container
 */
public class Connector extends LifecycleMBeanBase {
    
    // åè®®å¤„ç†å™¨
    protected final ProtocolHandler protocolHandler;
    
    // æœåŠ¡
    protected Service service = null;
    
    // é€‚é…å™¨
    protected Adapter adapter = null;
    
    // ç«¯å£
    protected int port = -1;
    
    // åè®®
    protected String protocol = "HTTP/1.1";
    
    // URIç¼–ç 
    private Charset uriCharset = StandardCharsets.UTF_8;
    
    /**
     * æ„é€ å‡½æ•°
     */
    public Connector(String protocol) {
        // æ ¹æ®åè®®åˆ›å»ºProtocolHandler
        boolean aprConnector = AprLifecycleListener.isAprAvailable() &&
            AprLifecycleListener.getUseAprConnector();
        
        if ("HTTP/1.1".equals(protocol) || protocol == null) {
            if (aprConnector) {
                protocolHandler = new Http11AprProtocol();
            } else {
                // ğŸ”¥ é»˜è®¤ä½¿ç”¨NIO
                protocolHandler = new Http11NioProtocol();
            }
        } else if ("AJP/1.3".equals(protocol)) {
            if (aprConnector) {
                protocolHandler = new AjpAprProtocol();
            } else {
                protocolHandler = new AjpNioProtocol();
            }
        } else {
            // è‡ªå®šä¹‰åè®®å¤„ç†å™¨
            protocolHandler = (ProtocolHandler) Class.forName(protocol)
                .getConstructor().newInstance();
        }
    }
    
    /**
     * ğŸ”¥ åˆå§‹åŒ–Connector
     */
    @Override
    protected void initInternal() throws LifecycleException {
        super.initInternal();
        
        // åˆ›å»ºCoyoteAdapter
        adapter = new CoyoteAdapter(this);
        protocolHandler.setAdapter(adapter);
        
        // è®¾ç½®è§£æè¯·æ±‚ä½“çš„æ–¹æ³•
        if (service != null) {
            protocolHandler.setUtilityExecutor(service.getServer().getUtilityExecutor());
        }
        
        // ğŸ”¥ åˆå§‹åŒ–ProtocolHandler
        try {
            protocolHandler.init();
        } catch (Exception e) {
            throw new LifecycleException(
                sm.getString("coyoteConnector.protocolHandlerInitializationFailed"), e);
        }
    }
    
    /**
     * ğŸ”¥ å¯åŠ¨Connector
     */
    @Override
    protected void startInternal() throws LifecycleException {
        if (getPort() < 0) {
            throw new LifecycleException(sm.getString(
                "coyoteConnector.invalidPort", Integer.valueOf(getPort())));
        }
        
        setState(LifecycleState.STARTING);
        
        // ğŸ”¥ å¯åŠ¨ProtocolHandler
        try {
            protocolHandler.start();
        } catch (Exception e) {
            throw new LifecycleException(
                sm.getString("coyoteConnector.protocolHandlerStartFailed"), e);
        }
    }
}
```

### 2.2 ProtocolHandleræ¥å£

```java
/**
 * åè®®å¤„ç†å™¨æ¥å£
 */
public interface ProtocolHandler {
    
    // è·å–/è®¾ç½®é€‚é…å™¨
    public Adapter getAdapter();
    public void setAdapter(Adapter adapter);
    
    // è·å–æ‰§è¡Œå™¨
    public Executor getExecutor();
    
    // ç”Ÿå‘½å‘¨æœŸæ–¹æ³•
    public void init() throws Exception;
    public void start() throws Exception;
    public void pause() throws Exception;
    public void resume() throws Exception;
    public void stop() throws Exception;
    public void destroy() throws Exception;
    
    // å…³é—­ç«¯ç‚¹
    public void closeServerSocketGraceful();
    public long awaitConnectionsClose(long waitMillis);
}

/**
 * æŠ½è±¡åè®®å¤„ç†å™¨
 */
public abstract class AbstractProtocol<S> implements ProtocolHandler {
    
    // ç«¯ç‚¹
    private final AbstractEndpoint<S, ?> endpoint;
    
    // å¤„ç†å™¨ç¼“å­˜
    private final Set<Processor> waitingProcessors = 
        Collections.newSetFromMap(new ConcurrentHashMap<>());
    
    // è¿æ¥å¤„ç†å™¨
    protected abstract static class ConnectionHandler<S> implements AbstractEndpoint.Handler<S> {
        
        private final AbstractProtocol<S> proto;
        private final Map<S, Processor> connections = new ConcurrentHashMap<>();
        
        @Override
        public SocketState process(SocketWrapperBase<S> wrapper, SocketEvent status) {
            // è·å–æˆ–åˆ›å»ºProcessor
            Processor processor = connections.get(wrapper.getSocket());
            
            if (processor == null) {
                processor = recycledProcessors.pop();
                if (processor == null) {
                    processor = getProtocol().createProcessor();
                }
            }
            
            // ğŸ”¥ å¤„ç†è¯·æ±‚
            SocketState state = processor.process(wrapper, status);
            
            // å¤„ç†ç»“æœ
            if (state == SocketState.LONG) {
                connections.put(wrapper.getSocket(), processor);
            } else if (state == SocketState.OPEN) {
                connections.remove(wrapper.getSocket());
                release(processor);
            }
            
            return state;
        }
    }
}
```

### 2.3 CoyoteAdapteré€‚é…å™¨

```java
/**
 * Coyoteé€‚é…å™¨
 * è¿æ¥Connectorå’ŒContainer
 */
public class CoyoteAdapter implements Adapter {
    
    private final Connector connector;
    
    /**
     * ğŸ”¥ å¤„ç†è¯·æ±‚
     */
    @Override
    public void service(org.apache.coyote.Request req, 
                       org.apache.coyote.Response res) throws Exception {
        
        // 1. åˆ›å»ºServletè¯·æ±‚å’Œå“åº”å¯¹è±¡
        Request request = (Request) req.getNote(ADAPTER_NOTES);
        Response response = (Response) res.getNote(ADAPTER_NOTES);
        
        if (request == null) {
            request = connector.createRequest();
            request.setCoyoteRequest(req);
            response = connector.createResponse();
            response.setCoyoteResponse(res);
            
            request.setResponse(response);
            response.setRequest(request);
            
            req.setNote(ADAPTER_NOTES, request);
            res.setNote(ADAPTER_NOTES, response);
        }
        
        // 2. è®¾ç½®è¯·æ±‚å±æ€§
        if (connector.getXpoweredBy()) {
            response.addHeader("X-Powered-By", POWERED_BY);
        }
        
        boolean async = false;
        boolean postParseSuccess = false;
        
        try {
            // 3. è§£æè¯·æ±‚ï¼ˆURIã€Cookieç­‰ï¼‰
            postParseSuccess = postParseRequest(req, request, res, response);
            
            if (postParseSuccess) {
                request.setAsyncSupported(
                    connector.getService().getContainer().getPipeline().isAsyncSupported());
                
                // 4. ğŸ”¥ è°ƒç”¨Containerå¤„ç†è¯·æ±‚
                connector.getService().getContainer().getPipeline()
                    .getFirst().invoke(request, response);
            }
            
            // 5. å¤„ç†å¼‚æ­¥è¯·æ±‚
            if (request.isAsync()) {
                async = true;
                // ...
            }
            
        } catch (IOException e) {
            // å¤„ç†å¼‚å¸¸
        } finally {
            // 6. æ¸…ç†èµ„æº
            if (!async) {
                request.recycle();
                response.recycle();
            }
        }
    }
}
```

---

## 3. Endpointå®ç°

### 3.1 AbstractEndpoint

```java
/**
 * æŠ½è±¡ç«¯ç‚¹
 * è´Ÿè´£ç½‘ç»œI/O
 */
public abstract class AbstractEndpoint<S, U> {
    
    // è¿è¡ŒçŠ¶æ€
    protected volatile boolean running = false;
    protected volatile boolean paused = false;
    
    // ç«¯å£
    private int port = -1;
    
    // åœ°å€
    private InetAddress address;
    
    // è¿æ¥è¶…æ—¶
    private int connectionTimeout = 60000;
    
    // æœ€å¤§è¿æ¥æ•°
    private int maxConnections = 8 * 1024;
    
    // æ¥å—é˜Ÿåˆ—å¤§å°
    private int acceptCount = 100;
    
    // çº¿ç¨‹æ± 
    private Executor executor = null;
    
    // æœ€å¤§çº¿ç¨‹æ•°
    private int maxThreads = 200;
    
    // æœ€å°ç©ºé—²çº¿ç¨‹
    private int minSpareThreads = 10;
    
    /**
     * ğŸ”¥ åˆå§‹åŒ–ç«¯ç‚¹
     */
    public void init() throws Exception {
        if (bindOnInit) {
            bindWithCleanup();
            bindState = BindState.BOUND_ON_INIT;
        }
    }
    
    /**
     * ğŸ”¥ å¯åŠ¨ç«¯ç‚¹
     */
    public final void start() throws Exception {
        if (bindState == BindState.UNBOUND) {
            bindWithCleanup();
            bindState = BindState.BOUND_ON_START;
        }
        startInternal();
    }
    
    /**
     * ç»‘å®šç«¯å£
     */
    protected abstract void bind() throws Exception;
    
    /**
     * å¯åŠ¨å†…éƒ¨
     */
    protected abstract void startInternal() throws Exception;
    
    /**
     * åˆ›å»ºçº¿ç¨‹æ± 
     */
    public void createExecutor() {
        internalExecutor = true;
        TaskQueue taskqueue = new TaskQueue();
        TaskThreadFactory tf = new TaskThreadFactory(
            getName() + "-exec-", daemon, getThreadPriority());
        
        executor = new ThreadPoolExecutor(
            getMinSpareThreads(), 
            getMaxThreads(), 
            60, TimeUnit.SECONDS,
            taskqueue, 
            tf);
        
        taskqueue.setParent((ThreadPoolExecutor) executor);
    }
}
```

### 3.2 NioEndpoint

```java
/**
 * NIOç«¯ç‚¹å®ç°
 */
public class NioEndpoint extends AbstractJsseEndpoint<NioChannel, SocketChannel> {
    
    // ServerSocketChannel
    private volatile ServerSocketChannel serverSock = null;
    
    // Selectoræ± 
    private NioSelectorPool selectorPool = new NioSelectorPool();
    
    // Polleræ•°ç»„
    private Poller[] pollers = null;
    private AtomicInteger pollerRotater = new AtomicInteger(0);
    
    /**
     * ğŸ”¥ ç»‘å®šç«¯å£
     */
    @Override
    public void bind() throws Exception {
        initServerSocket();
        
        // åˆå§‹åŒ–SSL
        if (isSSLEnabled()) {
            sslContext = createSSLContext(sslHostConfig);
        }
        
        // åˆå§‹åŒ–Selectoræ± 
        selectorPool.open(getName());
    }
    
    /**
     * åˆå§‹åŒ–ServerSocketChannel
     */
    protected void initServerSocket() throws Exception {
        // åˆ›å»ºServerSocketChannel
        serverSock = ServerSocketChannel.open();
        
        // è®¾ç½®Socketé€‰é¡¹
        socketProperties.setProperties(serverSock.socket());
        
        // ç»‘å®šåœ°å€å’Œç«¯å£
        InetSocketAddress addr = new InetSocketAddress(getAddress(), getPortWithOffset());
        serverSock.socket().bind(addr, getAcceptCount());
        
        // è®¾ç½®ä¸ºé˜»å¡æ¨¡å¼ï¼ˆAcceptorä½¿ç”¨é˜»å¡acceptï¼‰
        serverSock.configureBlocking(true);
    }
    
    /**
     * ğŸ”¥ å¯åŠ¨ç«¯ç‚¹
     */
    @Override
    public void startInternal() throws Exception {
        if (!running) {
            running = true;
            paused = false;
            
            // åˆ›å»ºå¤„ç†å™¨ç¼“å­˜
            if (socketProperties.getProcessorCache() != 0) {
                processorCache = new SynchronizedStack<>(
                    SynchronizedStack.DEFAULT_SIZE,
                    socketProperties.getProcessorCache());
            }
            
            // åˆ›å»ºäº‹ä»¶ç¼“å­˜
            if (socketProperties.getEventCache() != 0) {
                eventCache = new SynchronizedStack<>(
                    SynchronizedStack.DEFAULT_SIZE,
                    socketProperties.getEventCache());
            }
            
            // åˆ›å»ºNioChannelç¼“å­˜
            if (socketProperties.getBufferPool() != 0) {
                nioChannels = new SynchronizedStack<>(
                    SynchronizedStack.DEFAULT_SIZE,
                    socketProperties.getBufferPool());
            }
            
            // ğŸ”¥ åˆ›å»ºçº¿ç¨‹æ± 
            if (getExecutor() == null) {
                createExecutor();
            }
            
            // åˆå§‹åŒ–è¿æ¥é™åˆ¶å™¨
            initializeConnectionLatch();
            
            // ğŸ”¥ åˆ›å»ºPollerçº¿ç¨‹
            pollers = new Poller[getPollerThreadCount()];
            for (int i = 0; i < pollers.length; i++) {
                pollers[i] = new Poller();
                Thread pollerThread = new Thread(pollers[i], getName() + "-ClientPoller-" + i);
                pollerThread.setPriority(threadPriority);
                pollerThread.setDaemon(true);
                pollerThread.start();
            }
            
            // ğŸ”¥ åˆ›å»ºAcceptorçº¿ç¨‹
            startAcceptorThread();
        }
    }
}
```

### 3.3 Acceptorçº¿ç¨‹

```java
/**
 * Acceptor - æ¥æ”¶è¿æ¥çš„çº¿ç¨‹
 */
public class Acceptor<U> implements Runnable {
    
    private final AbstractEndpoint<?, U> endpoint;
    
    @Override
    public void run() {
        int errorDelay = 0;
        
        while (endpoint.isRunning()) {
            // æš‚åœçŠ¶æ€
            while (endpoint.isPaused() && endpoint.isRunning()) {
                state = AcceptorState.PAUSED;
                try {
                    Thread.sleep(50);
                } catch (InterruptedException e) {
                    // Ignore
                }
            }
            
            if (!endpoint.isRunning()) {
                break;
            }
            
            state = AcceptorState.RUNNING;
            
            try {
                // è¿æ¥æ•°é™åˆ¶
                endpoint.countUpOrAwaitConnection();
                
                if (endpoint.isPaused()) {
                    continue;
                }
                
                U socket = null;
                try {
                    // ğŸ”¥ æ¥æ”¶è¿æ¥ï¼ˆé˜»å¡ï¼‰
                    socket = endpoint.serverSocketAccept();
                } catch (Exception ioe) {
                    endpoint.countDownConnection();
                    if (endpoint.isRunning()) {
                        errorDelay = handleExceptionWithDelay(errorDelay);
                        throw ioe;
                    } else {
                        break;
                    }
                }
                
                errorDelay = 0;
                
                if (endpoint.isRunning() && !endpoint.isPaused()) {
                    // ğŸ”¥ å¤„ç†è¿æ¥
                    if (!endpoint.setSocketOptions(socket)) {
                        endpoint.closeSocket(socket);
                    }
                } else {
                    endpoint.destroySocket(socket);
                }
            } catch (Throwable t) {
                ExceptionUtils.handleThrowable(t);
                log.error(sm.getString("endpoint.accept.fail"), t);
            }
        }
        
        state = AcceptorState.ENDED;
    }
}
```

### 3.4 Pollerçº¿ç¨‹

```java
/**
 * Poller - è½®è¯¢I/Oäº‹ä»¶çš„çº¿ç¨‹
 */
public class Poller implements Runnable {
    
    private Selector selector;
    private final SynchronizedQueue<PollerEvent> events = new SynchronizedQueue<>();
    private volatile boolean close = false;
    
    public Poller() throws IOException {
        this.selector = Selector.open();
    }
    
    /**
     * æ³¨å†Œé€šé“
     */
    public void register(final NioChannel socket, final int interestOps) {
        PollerEvent event = null;
        if (eventCache != null) {
            event = eventCache.pop();
        }
        if (event == null) {
            event = new PollerEvent(socket, interestOps);
        } else {
            event.reset(socket, interestOps);
        }
        addEvent(event);
    }
    
    @Override
    public void run() {
        while (true) {
            boolean hasEvents = false;
            
            try {
                if (!close) {
                    // å¤„ç†äº‹ä»¶é˜Ÿåˆ—
                    hasEvents = events();
                    
                    if (wakeupCounter.getAndSet(-1) > 0) {
                        keyCount = selector.selectNow();
                    } else {
                        // ğŸ”¥ é˜»å¡ç­‰å¾…I/Oäº‹ä»¶
                        keyCount = selector.select(selectorTimeout);
                    }
                    wakeupCounter.set(0);
                }
                
                if (close) {
                    events();
                    timeout(0, false);
                    try {
                        selector.close();
                    } catch (IOException ioe) {
                        log.error(sm.getString("endpoint.nio.selectorCloseFail"), ioe);
                    }
                    break;
                }
            } catch (Throwable x) {
                ExceptionUtils.handleThrowable(x);
                log.error(sm.getString("endpoint.nio.selectorLoopError"), x);
                continue;
            }
            
            // ğŸ”¥ å¤„ç†å°±ç»ªçš„SelectionKey
            if (keyCount == 0) {
                hasEvents = (hasEvents | events());
            }
            
            Iterator<SelectionKey> iterator = 
                keyCount > 0 ? selector.selectedKeys().iterator() : null;
            
            while (iterator != null && iterator.hasNext()) {
                SelectionKey sk = iterator.next();
                iterator.remove();
                
                NioSocketWrapper socketWrapper = (NioSocketWrapper) sk.attachment();
                
                if (socketWrapper != null) {
                    // ğŸ”¥ å¤„ç†I/Oäº‹ä»¶
                    processKey(sk, socketWrapper);
                }
            }
            
            // å¤„ç†è¶…æ—¶
            timeout(keyCount, hasEvents);
        }
        
        getStopLatch().countDown();
    }
    
    /**
     * å¤„ç†SelectionKey
     */
    protected void processKey(SelectionKey sk, NioSocketWrapper socketWrapper) {
        try {
            if (close) {
                cancelledKey(sk, socketWrapper);
            } else if (sk.isValid() && socketWrapper != null) {
                if (sk.isReadable() || sk.isWritable()) {
                    // å–æ¶ˆæ³¨å†Œ
                    if (socketWrapper.getSendfileData() != null) {
                        processSendfile(sk, socketWrapper, false);
                    } else {
                        unreg(sk, socketWrapper, sk.readyOps());
                        boolean closeSocket = false;
                        
                        // ğŸ”¥ æäº¤åˆ°çº¿ç¨‹æ± å¤„ç†
                        if (sk.isReadable()) {
                            if (socketWrapper.readOperation != null) {
                                if (!socketWrapper.readOperation.process()) {
                                    closeSocket = true;
                                }
                            } else if (!processSocket(socketWrapper, SocketEvent.OPEN_READ, true)) {
                                closeSocket = true;
                            }
                        }
                        if (!closeSocket && sk.isWritable()) {
                            if (socketWrapper.writeOperation != null) {
                                if (!socketWrapper.writeOperation.process()) {
                                    closeSocket = true;
                                }
                            } else if (!processSocket(socketWrapper, SocketEvent.OPEN_WRITE, true)) {
                                closeSocket = true;
                            }
                        }
                        if (closeSocket) {
                            cancelledKey(sk, socketWrapper);
                        }
                    }
                }
            } else {
                cancelledKey(sk, socketWrapper);
            }
        } catch (Exception x) {
            log.error(sm.getString("endpoint.nio.keyProcessingError"), x);
        }
    }
}
```


---

## 4. åè®®å¤„ç†

### 4.1 Http11Processor

```java
/**
 * HTTP/1.1åè®®å¤„ç†å™¨
 */
public class Http11Processor extends AbstractProcessor {
    
    private final Http11InputBuffer inputBuffer;
    private final Http11OutputBuffer outputBuffer;
    
    /**
     * ğŸ”¥ å¤„ç†è¯·æ±‚
     */
    @Override
    public SocketState service(SocketWrapperBase<?> socketWrapper) throws IOException {
        RequestInfo rp = request.getRequestProcessor();
        rp.setStage(org.apache.coyote.Constants.STAGE_PARSE);
        
        // è®¾ç½®SocketåŒ…è£…å™¨
        setSocketWrapper(socketWrapper);
        
        // è·å–è¾“å…¥è¾“å‡ºæµ
        inputBuffer.init(socketWrapper);
        outputBuffer.init(socketWrapper);
        
        // Keep-Aliveå¾ªç¯
        while (!getErrorState().isError() && keepAlive && !isAsync() && 
               upgradeToken == null && sendfileState == SendfileState.DONE && 
               !endpoint.isPaused()) {
            
            // 1. ğŸ”¥ è§£æè¯·æ±‚è¡Œ
            try {
                if (!inputBuffer.parseRequestLine(keptAlive, connectionTimeout, 
                        keepAliveTimeout)) {
                    if (inputBuffer.getParsingRequestLinePhase() == -1) {
                        return SocketState.UPGRADING;
                    } else if (handleIncompleteRequestLineRead()) {
                        break;
                    }
                }
            } catch (IOException e) {
                // å¤„ç†å¼‚å¸¸
            }
            
            // 2. ğŸ”¥ è§£æè¯·æ±‚å¤´
            if (getErrorState().isIoAllowed()) {
                rp.setStage(org.apache.coyote.Constants.STAGE_PARSE);
                try {
                    if (!inputBuffer.parseHeaders()) {
                        openSocket = true;
                        readComplete = false;
                        break;
                    }
                } catch (IOException e) {
                    // å¤„ç†å¼‚å¸¸
                }
            }
            
            // 3. å‡†å¤‡è¯·æ±‚
            if (getErrorState().isIoAllowed()) {
                rp.setStage(org.apache.coyote.Constants.STAGE_PREPARE);
                try {
                    prepareRequest();
                } catch (Throwable t) {
                    // å¤„ç†å¼‚å¸¸
                }
            }
            
            // 4. ğŸ”¥ è°ƒç”¨é€‚é…å™¨å¤„ç†è¯·æ±‚
            if (getErrorState().isIoAllowed()) {
                try {
                    rp.setStage(org.apache.coyote.Constants.STAGE_SERVICE);
                    getAdapter().service(request, response);
                    
                    if (keepAlive && !getErrorState().isError() && !isAsync() &&
                            statusDropsConnection(response.getStatus())) {
                        setErrorState(ErrorState.CLOSE_CLEAN, null);
                    }
                } catch (Exception e) {
                    // å¤„ç†å¼‚å¸¸
                }
            }
            
            // 5. å®Œæˆå“åº”
            rp.setStage(org.apache.coyote.Constants.STAGE_ENDINPUT);
            if (!isAsync()) {
                endRequest();
            }
            
            rp.setStage(org.apache.coyote.Constants.STAGE_ENDOUTPUT);
            if (!isAsync()) {
                outputBuffer.end();
            }
            
            // 6. æ£€æŸ¥Keep-Alive
            if (getErrorState().isError()) {
                response.setStatus(500);
            }
            
            if (!isAsync() || getErrorState().isError()) {
                request.updateCounters();
                if (getErrorState().isIoAllowed()) {
                    inputBuffer.nextRequest();
                    outputBuffer.nextRequest();
                }
            }
            
            rp.setStage(org.apache.coyote.Constants.STAGE_KEEPALIVE);
        }
        
        // è¿”å›SocketçŠ¶æ€
        if (getErrorState().isError() || endpoint.isPaused()) {
            return SocketState.CLOSED;
        } else if (isAsync()) {
            return SocketState.LONG;
        } else if (isUpgrade()) {
            return SocketState.UPGRADING;
        } else {
            if (sendfileState == SendfileState.PENDING) {
                return SocketState.SENDFILE;
            } else {
                if (openSocket) {
                    if (readComplete) {
                        return SocketState.OPEN;
                    } else {
                        return SocketState.LONG;
                    }
                } else {
                    return SocketState.CLOSED;
                }
            }
        }
    }
}
```

---

## 5. è¯·æ±‚å¤„ç†æµç¨‹

### 5.1 å®Œæ•´æµç¨‹å›¾

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  è¯·æ±‚å¤„ç†å®Œæ•´æµç¨‹                            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                             â”‚
â”‚  å®¢æˆ·ç«¯è¯·æ±‚                                                  â”‚
â”‚       â”‚                                                     â”‚
â”‚       â–¼                                                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”               â”‚
â”‚  â”‚ 1. Acceptor.accept()                    â”‚               â”‚
â”‚  â”‚    æ¥æ”¶TCPè¿æ¥                          â”‚               â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜               â”‚
â”‚       â”‚                                                     â”‚
â”‚       â–¼                                                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”               â”‚
â”‚  â”‚ 2. setSocketOptions()                   â”‚               â”‚
â”‚  â”‚    é…ç½®Socketï¼Œæ³¨å†Œåˆ°Poller             â”‚               â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜               â”‚
â”‚       â”‚                                                     â”‚
â”‚       â–¼                                                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”               â”‚
â”‚  â”‚ 3. Poller.select()                      â”‚               â”‚
â”‚  â”‚    ç­‰å¾…I/Oäº‹ä»¶                          â”‚               â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜               â”‚
â”‚       â”‚                                                     â”‚
â”‚       â–¼                                                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”               â”‚
â”‚  â”‚ 4. processSocket()                      â”‚               â”‚
â”‚  â”‚    æäº¤åˆ°çº¿ç¨‹æ±                          â”‚               â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜               â”‚
â”‚       â”‚                                                     â”‚
â”‚       â–¼                                                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”               â”‚
â”‚  â”‚ 5. SocketProcessor.run()                â”‚               â”‚
â”‚  â”‚    åœ¨å·¥ä½œçº¿ç¨‹ä¸­æ‰§è¡Œ                     â”‚               â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜               â”‚
â”‚       â”‚                                                     â”‚
â”‚       â–¼                                                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”               â”‚
â”‚  â”‚ 6. ConnectionHandler.process()          â”‚               â”‚
â”‚  â”‚    è·å–/åˆ›å»ºProcessor                   â”‚               â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜               â”‚
â”‚       â”‚                                                     â”‚
â”‚       â–¼                                                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”               â”‚
â”‚  â”‚ 7. Http11Processor.service()            â”‚               â”‚
â”‚  â”‚    è§£æHTTPè¯·æ±‚                         â”‚               â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜               â”‚
â”‚       â”‚                                                     â”‚
â”‚       â–¼                                                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”               â”‚
â”‚  â”‚ 8. CoyoteAdapter.service()              â”‚               â”‚
â”‚  â”‚    è½¬æ¢ä¸ºServletè¯·æ±‚                    â”‚               â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜               â”‚
â”‚       â”‚                                                     â”‚
â”‚       â–¼                                                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”               â”‚
â”‚  â”‚ 9. Container.invoke()                   â”‚               â”‚
â”‚  â”‚    Engine â†’ Host â†’ Context â†’ Wrapper    â”‚               â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜               â”‚
â”‚       â”‚                                                     â”‚
â”‚       â–¼                                                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”               â”‚
â”‚  â”‚ 10. Servlet.service()                   â”‚               â”‚
â”‚  â”‚     æ‰§è¡Œä¸šåŠ¡é€»è¾‘                        â”‚               â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜               â”‚
â”‚       â”‚                                                     â”‚
â”‚       â–¼                                                     â”‚
â”‚  å“åº”è¿”å›å®¢æˆ·ç«¯                                             â”‚
â”‚                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 6. NIOæ¨¡å‹è¯¦è§£

### 6.1 çº¿ç¨‹æ¨¡å‹

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  Tomcat NIOçº¿ç¨‹æ¨¡å‹                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚                    Acceptorçº¿ç¨‹                      â”‚   â”‚
â”‚  â”‚  - æ•°é‡ï¼š1ä¸ª                                        â”‚   â”‚
â”‚  â”‚  - èŒè´£ï¼šæ¥æ”¶æ–°è¿æ¥                                 â”‚   â”‚
â”‚  â”‚  - æ¨¡å¼ï¼šé˜»å¡accept()                               â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                          â”‚                                  â”‚
â”‚                          â–¼                                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚                    Pollerçº¿ç¨‹                        â”‚   â”‚
â”‚  â”‚  - æ•°é‡ï¼š1-2ä¸ªï¼ˆé»˜è®¤Math.min(2, CPUæ ¸å¿ƒæ•°)ï¼‰        â”‚   â”‚
â”‚  â”‚  - èŒè´£ï¼šè½®è¯¢I/Oäº‹ä»¶                                â”‚   â”‚
â”‚  â”‚  - æ¨¡å¼ï¼šNIO Selector                               â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                          â”‚                                  â”‚
â”‚                          â–¼                                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚                   Workerçº¿ç¨‹æ±                        â”‚   â”‚
â”‚  â”‚  - æ•°é‡ï¼š10-200ï¼ˆå¯é…ç½®ï¼‰                           â”‚   â”‚
â”‚  â”‚  - èŒè´£ï¼šå¤„ç†è¯·æ±‚                                   â”‚   â”‚
â”‚  â”‚  - æ¨¡å¼ï¼šçº¿ç¨‹æ±                                      â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 6.2 å…³é”®é…ç½®å‚æ•°

```xml
<!-- server.xml Connectoré…ç½® -->
<Connector port="8080" protocol="HTTP/1.1"
           connectionTimeout="20000"
           redirectPort="8443"
           
           <!-- çº¿ç¨‹æ± é…ç½® -->
           maxThreads="200"
           minSpareThreads="10"
           
           <!-- è¿æ¥é…ç½® -->
           maxConnections="8192"
           acceptCount="100"
           
           <!-- Keep-Aliveé…ç½® -->
           maxKeepAliveRequests="100"
           keepAliveTimeout="20000"
           
           <!-- å…¶ä»–é…ç½® -->
           URIEncoding="UTF-8"
           compression="on"
           compressionMinSize="2048"
           />
```

---

## 7. é¢è¯•è¦ç‚¹

### 7.1 é«˜é¢‘é¢è¯•é¢˜

#### Q1: Tomcat Connectorçš„ä½œç”¨ï¼Ÿ

```
ç­”æ¡ˆè¦ç‚¹ï¼š
1. ç›‘å¬ç½‘ç»œç«¯å£ï¼Œæ¥æ”¶TCPè¿æ¥
2. è§£æHTTP/AJPåè®®
3. å°†è¯·æ±‚è½¬å‘ç»™Containerå¤„ç†
4. å°†å“åº”è¿”å›ç»™å®¢æˆ·ç«¯

æ ¸å¿ƒç»„ä»¶ï¼š
- Endpoint: å¤„ç†ç½‘ç»œI/O
- Processor: è§£æåè®®
- Adapter: è¿æ¥Container
```

#### Q2: Tomcat NIOæ¨¡å‹çš„å·¥ä½œåŸç†ï¼Ÿ

```
ç­”æ¡ˆè¦ç‚¹ï¼š
1. Acceptorçº¿ç¨‹ï¼šé˜»å¡æ¥æ”¶æ–°è¿æ¥
2. Pollerçº¿ç¨‹ï¼šNIO Selectorè½®è¯¢I/Oäº‹ä»¶
3. Workerçº¿ç¨‹æ± ï¼šå¤„ç†è¯·æ±‚

æµç¨‹ï¼š
Acceptor.accept() â†’ æ³¨å†Œåˆ°Poller 
â†’ Poller.select() â†’ æäº¤åˆ°çº¿ç¨‹æ±  
â†’ Workerå¤„ç†è¯·æ±‚
```

#### Q3: maxConnectionså’ŒacceptCountçš„åŒºåˆ«ï¼Ÿ

```
maxConnectionsï¼š
- Tomcatèƒ½åŒæ—¶å¤„ç†çš„æœ€å¤§è¿æ¥æ•°
- è¶…è¿‡åæ–°è¿æ¥è¿›å…¥acceptCounté˜Ÿåˆ—
- é»˜è®¤8192

acceptCountï¼š
- ç­‰å¾…é˜Ÿåˆ—çš„å¤§å°
- è¶…è¿‡åæ‹’ç»è¿æ¥
- é»˜è®¤100

å…³ç³»ï¼š
æ€»è¿æ¥æ•° = æ­£åœ¨å¤„ç†çš„è¿æ¥ + ç­‰å¾…é˜Ÿåˆ—ä¸­çš„è¿æ¥
æœ€å¤§æ€»è¿æ¥æ•° = maxConnections + acceptCount
```

### 7.2 çŸ¥è¯†ç‚¹æ€»ç»“

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              Tomcat Connectoræ€»ç»“                            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                             â”‚
â”‚  æ ¸å¿ƒç»„ä»¶ï¼š                                                  â”‚
â”‚  â”œâ”€â”€ Connector: è¿æ¥å™¨å…¥å£                                 â”‚
â”‚  â”œâ”€â”€ ProtocolHandler: åè®®å¤„ç†å™¨                           â”‚
â”‚  â”œâ”€â”€ Endpoint: ç½‘ç»œI/O                                     â”‚
â”‚  â”œâ”€â”€ Processor: åè®®è§£æ                                   â”‚
â”‚  â””â”€â”€ Adapter: é€‚é…Container                                â”‚
â”‚                                                             â”‚
â”‚  NIOçº¿ç¨‹æ¨¡å‹ï¼š                                               â”‚
â”‚  â”œâ”€â”€ Acceptor: æ¥æ”¶è¿æ¥ï¼ˆ1ä¸ªï¼‰                             â”‚
â”‚  â”œâ”€â”€ Poller: è½®è¯¢äº‹ä»¶ï¼ˆ1-2ä¸ªï¼‰                             â”‚
â”‚  â””â”€â”€ Worker: å¤„ç†è¯·æ±‚ï¼ˆçº¿ç¨‹æ± ï¼‰                            â”‚
â”‚                                                             â”‚
â”‚  å…³é”®å‚æ•°ï¼š                                                  â”‚
â”‚  â”œâ”€â”€ maxThreads: æœ€å¤§å·¥ä½œçº¿ç¨‹                              â”‚
â”‚  â”œâ”€â”€ maxConnections: æœ€å¤§è¿æ¥æ•°                            â”‚
â”‚  â”œâ”€â”€ acceptCount: ç­‰å¾…é˜Ÿåˆ—å¤§å°                             â”‚
â”‚  â””â”€â”€ connectionTimeout: è¿æ¥è¶…æ—¶                           â”‚
â”‚                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ“š å‚è€ƒèµ„æ–™

- [Tomcatå®˜æ–¹æ–‡æ¡£ - Connector](https://tomcat.apache.org/tomcat-9.0-doc/config/http.html)
- [Tomcatæºç ](https://github.com/apache/tomcat)

---

**æŒæ¡ConnectoråŸç†ï¼Œæ·±å…¥ç†è§£Tomcatç½‘ç»œå¤„ç†ï¼** ğŸš€

*æœ€åæ›´æ–°ï¼š2025-12-28*

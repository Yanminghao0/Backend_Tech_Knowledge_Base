# Tomcat Containeræºç è§£æ

> ğŸ’¡ æ·±å…¥ç†è§£Tomcatå®¹å™¨æ¶æ„å’Œè¯·æ±‚å¤„ç†æœºåˆ¶

---

## ğŸ“š ç›®å½•

1. [Containeræ¶æ„æ¦‚è¿°](#1-containeræ¶æ„æ¦‚è¿°)
2. [Containeræ¥å£è®¾è®¡](#2-containeræ¥å£è®¾è®¡)
3. [Engineå®¹å™¨](#3-engineå®¹å™¨)
4. [Hostå®¹å™¨](#4-hostå®¹å™¨)
5. [Contextå®¹å™¨](#5-contextå®¹å™¨)
6. [Wrapperå®¹å™¨](#6-wrapperå®¹å™¨)
7. [é¢è¯•è¦ç‚¹](#7-é¢è¯•è¦ç‚¹)

---

## 1. Containeræ¶æ„æ¦‚è¿°

### 1.1 å®¹å™¨å±‚æ¬¡ç»“æ„

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  Tomcatå®¹å™¨æ¶æ„                              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                             â”‚
â”‚  Server (Catalina)                                          â”‚
â”‚  â””â”€â”€ Service (StandardService)                              â”‚
â”‚      â”œâ”€â”€ Connector (HTTP/AJP)                               â”‚
â”‚      â””â”€â”€ Engine (StandardEngine)                            â”‚
â”‚          â””â”€â”€ Host (StandardHost)                             â”‚
â”‚              â””â”€â”€ Context (StandardContext)                   â”‚
â”‚                  â””â”€â”€ Wrapper (StandardWrapper)              â”‚
â”‚                      â””â”€â”€ Servlet                             â”‚
â”‚                                                             â”‚
â”‚  å®¹å™¨èŒè´£ï¼š                                                  â”‚
â”‚  â”œâ”€â”€ Engine: æ•´ä¸ªServletå¼•æ“                               â”‚
â”‚  â”œâ”€â”€ Host: è™šæ‹Ÿä¸»æœº                                         â”‚
â”‚  â”œâ”€â”€ Context: Webåº”ç”¨                                       â”‚
â”‚  â””â”€â”€ Wrapper: ServletåŒ…è£…å™¨                                â”‚
â”‚                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 1.2 è¯·æ±‚å¤„ç†æµç¨‹

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  è¯·æ±‚å¤„ç†æµç¨‹                                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                             â”‚
â”‚  HTTPè¯·æ±‚                                                   â”‚
â”‚     â”‚                                                       â”‚
â”‚     â–¼                                                       â”‚
â”‚  Connector (è§£æHTTP)                                       â”‚
â”‚     â”‚                                                       â”‚
â”‚     â–¼                                                       â”‚
â”‚  Engine.invoke()                                            â”‚
â”‚     â”‚                                                       â”‚
â”‚     â”œâ”€â”€ é€‰æ‹©Host                                            â”‚
â”‚     â–¼                                                       â”‚
â”‚  Host.invoke()                                              â”‚
â”‚     â”‚                                                       â”‚
â”‚     â”œâ”€â”€ é€‰æ‹©Context                                         â”‚
â”‚     â–¼                                                       â”‚
â”‚  Context.invoke()                                           â”‚
â”‚     â”‚                                                       â”‚
â”‚     â”œâ”€â”€ é€‰æ‹©Wrapper                                         â”‚
â”‚     â–¼                                                       â”‚
â”‚  Wrapper.invoke()                                           â”‚
â”‚     â”‚                                                       â”‚
â”‚     â”œâ”€â”€ è°ƒç”¨Servlet                                         â”‚
â”‚     â–¼                                                       â”‚
â”‚  Servlet.service()                                          â”‚
â”‚                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 2. Containeræ¥å£è®¾è®¡

### 2.1 Containeræ¥å£

```java
/**
 * Container - å®¹å™¨æ¥å£
 * å®šä¹‰äº†æ‰€æœ‰å®¹å™¨çš„é€šç”¨è¡Œä¸º
 */
public interface Container extends Lifecycle {
    
    /**
     * è·å–å®¹å™¨åç§°
     */
    String getName();
    void setName(String name);
    
    /**
     * è·å–çˆ¶å®¹å™¨
     */
    Container getParent();
    void setParent(Container container);
    
    /**
     * ğŸ”¥ æ·»åŠ å­å®¹å™¨
     */
    void addChild(Container child);
    void removeChild(Container child);
    Container findChild(String name);
    Container[] findChildren();
    
    /**
     * ğŸ”¥ å¤„ç†è¯·æ±‚
     */
    void invoke(Request request, Response response) throws IOException, ServletException;
    
    /**
     * è·å–Pipeline
     */
    Pipeline getPipeline();
    
    /**
     * è·å–ç±»åŠ è½½å™¨
     */
    ClassLoader getParentClassLoader();
    void setParentClassLoader(ClassLoader parent);
    
    /**
     * è·å–Realm
     */
    Realm getRealm();
    void setRealm(Realm realm);
    
    /**
     * æ·»åŠ å®¹å™¨ç›‘å¬å™¨
     */
    void addContainerListener(ContainerListener listener);
    void removeContainerListener(ContainerListener listener);
    
    /**
     * æ·»åŠ å±æ€§å˜æ›´ç›‘å¬å™¨
     */
    void addPropertyChangeListener(PropertyChangeListener listener);
    void removePropertyChangeListener(PropertyChangeListener listener);
    
    /**
     * æ—¥å¿—è®¿é—®
     */
    Log getLogger();
    String getLogName();
    
    /**
     * JMXç®¡ç†
     */
    ObjectName getObjectName();
}
```

### 2.2 ContainerBaseæŠ½è±¡åŸºç±»

```java
/**
 * ContainerBase - å®¹å™¨æŠ½è±¡åŸºç±»
 * å®ç°äº†Containeræ¥å£çš„é€šç”¨åŠŸèƒ½
 */
public abstract class ContainerBase extends LifecycleMBeanBase implements Container {
    
    private static final Log log = LogFactory.getLog(ContainerBase.class);
    
    // ğŸ”¥ å­å®¹å™¨æ˜ å°„
    protected final HashMap<String, Container> children = new HashMap<>();
    
    // ğŸ”¥ Pipelineå¤„ç†é“¾
    protected final Pipeline pipeline = new StandardPipeline(this);
    
    // çˆ¶å®¹å™¨
    protected Container parent = null;
    
    // å®¹å™¨åç§°
    protected String name = null;
    
    // ç±»åŠ è½½å™¨
    protected ClassLoader parentClassLoader = null;
    
    // å®‰å…¨åŸŸ
    protected Realm realm = null;
    
    // ğŸ”¥ åå°å¤„ç†çº¿ç¨‹
    protected Thread thread = null;
    protected volatile boolean threadDone = false;
    
    // ç›‘å¬å™¨åˆ—è¡¨
    protected final List<ContainerListener> listeners = new ArrayList<>();
    protected final PropertyChangeSupport support = new PropertyChangeSupport(this);
    
    /**
     * ğŸ”¥ å¤„ç†è¯·æ±‚ - å§”æ‰˜ç»™Pipeline
     */
    @Override
    public void invoke(Request request, Response response) 
            throws IOException, ServletException {
        pipeline.getFirst().invoke(request, response);
    }
    
    /**
     * ğŸ”¥ æ·»åŠ å­å®¹å™¨
     */
    @Override
    public void addChild(Container child) {
        if (Globals.IS_SECURITY_ENABLED) {
            PrivilegedAction<Void> dp = new PrivilegedAddChild(child);
            AccessController.doPrivileged(dp);
        } else {
            addChildInternal(child);
        }
    }
    
    private void addChildInternal(Container child) {
        if (log.isDebugEnabled()) {
            log.debug("Add child " + child + " " + this);
        }
        
        synchronized (children) {
            if (children.get(child.getName()) != null) {
                throw new IllegalArgumentException("addChild:  Child name '" + 
                    child.getName() + "' is not unique");
            }
            
            // è®¾ç½®çˆ¶å®¹å™¨
            child.setParent(this);
            
            // æ·»åŠ åˆ°å­å®¹å™¨æ˜ å°„
            children.put(child.getName(), child);
            
            // å¦‚æœå®¹å™¨å·²å¯åŠ¨ï¼Œå¯åŠ¨å­å®¹å™¨
            if (getState().isAvailable()) {
                if (child instanceof Lifecycle) {
                    try {
                        ((Lifecycle) child).start();
                    } catch (LifecycleException e) {
                        log.error("ContainerBase.addChild: start: ", e);
                        throw new IllegalStateException("ContainerBase.addChild: start: " + e);
                    }
                }
            }
        }
        
        // ğŸ”¥ è§¦å‘ADD_CHILD_EVENTäº‹ä»¶
        fireContainerEvent(ADD_CHILD_EVENT, child);
    }
    
    /**
     * ğŸ”¥ ç§»é™¤å­å®¹å™¨
     */
    @Override
    public void removeChild(Container child) {
        if (child == null) {
            return;
        }
        
        try {
            if (child.getState().isAvailable()) {
                ((Lifecycle) child).stop();
            }
        } catch (LifecycleException e) {
            log.error("ContainerBase.removeChild: stop: ", e);
        }
        
        try {
            if (!child.getState().equals(LifecycleState.DESTROYED)) {
                ((Lifecycle) child).destroy();
            }
        } catch (LifecycleException e) {
            log.error("ContainerBase.removeChild: destroy: ", e);
        }
        
        synchronized (children) {
            if (children.get(child.getName()) == child) {
                children.remove(child.getName());
            }
        }
        
        // ğŸ”¥ è§¦å‘REMOVE_CHILD_EVENTäº‹ä»¶
        fireContainerEvent(REMOVE_CHILD_EVENT, child);
    }
    
    /**
     * ğŸ”¥ åå°å¤„ç†çº¿ç¨‹
     */
    @Override
    protected void threadStart() {
        if (thread != null) {
            return;
        }
        if (backgroundProcessorDelay <= 0) {
            return;
        }
        
        threadDone = false;
        String threadName = "ContainerBackgroundProcessor[" + toString() + "]";
        thread = new Thread(new ContainerBackgroundProcessor(), threadName);
        thread.setDaemon(true);
        thread.start();
    }
    
    /**
     * åå°å¤„ç†å™¨
     */
    protected class ContainerBackgroundProcessor implements Runnable {
        
        @Override
        public void run() {
            Throwable t = null;
            String unexpectedDeathMessage = sm.getString(
                "containerBase.backgroundProcess.unexpectedThreadDeath", 
                Thread.currentThread().getName());
            
            try {
                while (!threadDone) {
                    try {
                        Thread.sleep(backgroundProcessorDelay * 1000L);
                    } catch (InterruptedException e) {
                        // Ignore
                    }
                    
                    if (!threadDone) {
                        // ğŸ”¥ æ‰§è¡Œåå°å¤„ç†
                        processChildren(ContainerBase.this);
                    }
                }
            } catch (RuntimeException|Error e) {
                t = e;
                throw e;
            } finally {
                if (!threadDone) {
                    log.error(unexpectedDeathMessage, t);
                }
            }
        }
        
        protected void processChildren(Container container) {
            ClassLoader originalClassLoader = null;
            
            try {
                if (container instanceof Context) {
                    Loader loader = ((Context) container).getLoader();
                    if (loader == null) {
                        return;
                    }
                    
                    // åˆ‡æ¢ç±»åŠ è½½å™¨
                    originalClassLoader = ((Context) container).bind(false, null);
                }
                
                // ğŸ”¥ æ‰§è¡Œå®¹å™¨çš„åå°å¤„ç†
                container.backgroundProcess();
                
                // ğŸ”¥ é€’å½’å¤„ç†å­å®¹å™¨
                Container[] children = container.findChildren();
                for (Container child : children) {
                    if (child.getBackgroundProcessorDelay() <= 0) {
                        processChildren(child);
                    }
                }
            } catch (Throwable t) {
                ExceptionUtils.handleThrowable(t);
                log.error("Exception invoking periodic operation: ", t);
            } finally {
                if (container instanceof Context) {
                    ((Context) container).unbind(false, originalClassLoader);
                }
            }
        }
    }
}
```
---

## 3. Engineå®¹å™¨

### 3.1 StandardEngine

```java
/**
 * StandardEngine - æ ‡å‡†Engineå®ç°
 * æ•´ä¸ªServletå¼•æ“çš„é¡¶çº§å®¹å™¨
 */
public class StandardEngine extends ContainerBase implements Engine {
    
    private static final Log log = LogFactory.getLog(StandardEngine.class);
    
    // ğŸ”¥ é»˜è®¤Hoståç§°
    private String defaultHost = null;
    
    // ğŸ”¥ Serviceå¼•ç”¨
    private Service service = null;
    
    // JVMè·¯ç”±ID
    private String jvmRouteId = null;
    
    public StandardEngine() {
        super();
        // ğŸ”¥ è®¾ç½®Engineçš„åŸºç¡€Valve
        pipeline.setBasic(new StandardEngineValve());
    }
    
    @Override
    public void addChild(Container child) {
        if (!(child instanceof Host)) {
            throw new IllegalArgumentException(
                sm.getString("standardEngine.notHost"));
        }
        super.addChild(child);
    }
    
    /**
     * ğŸ”¥ è·å–é»˜è®¤Host
     */
    public String getDefaultHost() {
        return defaultHost;
    }
    
    public void setDefaultHost(String host) {
        String oldDefaultHost = this.defaultHost;
        if (host == null) {
            this.defaultHost = null;
        } else {
            this.defaultHost = host.toLowerCase(Locale.ENGLISH);
        }
        
        if (getState().isAvailable()) {
            service.getMapper().setDefaultHostName(this.defaultHost);
        }
        
        support.firePropertyChange("defaultHost", oldDefaultHost, this.defaultHost);
    }
    
    @Override
    public void setParent(Container container) {
        throw new IllegalArgumentException(
            sm.getString("standardEngine.notParent"));
    }
    
    @Override
    protected void startInternal() throws LifecycleException {
        // Log our server identification information
        if (log.isInfoEnabled()) {
            log.info(sm.getString("standardEngine.start", ServerInfo.getServerInfo()));
        }
        
        // Standard container startup
        super.startInternal();
    }
    
    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder("StandardEngine[");
        sb.append(getName());
        sb.append("]");
        return sb.toString();
    }
}
```

### 3.2 StandardEngineValve

```java
/**
 * StandardEngineValve - Engineçš„åŸºç¡€Valve
 * è´Ÿè´£é€‰æ‹©åˆé€‚çš„Hostå¤„ç†è¯·æ±‚
 */
final class StandardEngineValve extends ValveBase {
    
    private static final Log log = LogFactory.getLog(StandardEngineValve.class);
    
    public StandardEngineValve() {
        super(true);
    }
    
    /**
     * ğŸ”¥ å¤„ç†è¯·æ±‚ - é€‰æ‹©Host
     */
    @Override
    public void invoke(Request request, Response response) 
            throws IOException, ServletException {
        
        // ğŸ”¥ è·å–Host
        Host host = request.getHost();
        if (host == null) {
            // æ²¡æœ‰æ‰¾åˆ°Hostï¼Œè¿”å›400é”™è¯¯
            response.sendError(HttpServletResponse.SC_BAD_REQUEST,
                sm.getString("standardEngine.noHost", 
                request.getServerName()));
            return;
        }
        
        if (request.isAsyncSupported()) {
            request.setAsyncSupported(host.getPipeline().isAsyncSupported());
        }
        
        // ğŸ”¥ è°ƒç”¨Hostå¤„ç†è¯·æ±‚
        host.getPipeline().getFirst().invoke(request, response);
    }
}
```

---

## 4. Hostå®¹å™¨

### 4.1 StandardHost

```java
/**
 * StandardHost - æ ‡å‡†Hostå®ç°
 * ä»£è¡¨è™šæ‹Ÿä¸»æœº
 */
public class StandardHost extends ContainerBase implements Host {
    
    private static final Log log = LogFactory.getLog(StandardHost.class);
    
    // ğŸ”¥ åº”ç”¨æ ¹ç›®å½•
    private String appBase = "webapps";
    
    // ğŸ”¥ è‡ªåŠ¨éƒ¨ç½²
    private boolean autoDeploy = true;
    
    // ğŸ”¥ éƒ¨ç½²æ—¶è§£å‹WAR
    private boolean unpackWARs = true;
    
    // ğŸ”¥ Hostéƒ¨ç½²å™¨
    private String hostConfigClass = "org.apache.catalina.startup.HostConfig";
    
    // åˆ«ååˆ—è¡¨
    private final List<String> aliases = new ArrayList<>();
    
    // ğŸ”¥ é”™è¯¯æŠ¥å‘ŠValveç±»
    private String errorReportValveClass = 
        "org.apache.catalina.valves.ErrorReportValve";
    
    public StandardHost() {
        super();
        // ğŸ”¥ è®¾ç½®Hostçš„åŸºç¡€Valve
        pipeline.setBasic(new StandardHostValve());
    }
    
    @Override
    public void addChild(Container child) {
        if (!(child instanceof Context)) {
            throw new IllegalArgumentException(
                sm.getString("standardHost.notContext"));
        }
        
        // ğŸ”¥ è®¾ç½®Contextçš„å·¥ä½œç›®å½•
        child.addLifecycleListener(new MemoryLeakTrackingListener());
        
        super.addChild(child);
    }
    
    /**
     * ğŸ”¥ è·å–åº”ç”¨æ ¹ç›®å½•
     */
    public String getAppBase() {
        return this.appBase;
    }
    
    public void setAppBase(String appBase) {
        if (appBase.trim().equals("")) {
            log.warn(sm.getString("standardHost.problematicAppBase", getName()));
        }
        
        String oldAppBase = this.appBase;
        this.appBase = appBase;
        support.firePropertyChange("appBase", oldAppBase, this.appBase);
    }
    
    /**
     * ğŸ”¥ æ·»åŠ åˆ«å
     */
    @Override
    public void addAlias(String alias) {
        alias = alias.toLowerCase(Locale.ENGLISH);
        
        synchronized (aliases) {
            aliases.add(alias);
        }
        
        // é€šçŸ¥Mapper
        fireContainerEvent(ADD_ALIAS_EVENT, alias);
    }
    
    /**
     * ğŸ”¥ æŸ¥æ‰¾åˆ«å
     */
    @Override
    public String[] findAliases() {
        synchronized (aliases) {
            return aliases.toArray(new String[0]);
        }
    }
    
    @Override
    protected void startInternal() throws LifecycleException {
        // Set error report valve
        String errorValve = getErrorReportValveClass();
        if ((errorValve != null) && (!errorValve.equals(""))) {
            try {
                boolean found = false;
                Valve[] valves = getPipeline().getValves();
                for (Valve valve : valves) {
                    if (errorValve.equals(valve.getClass().getName())) {
                        found = true;
                        break;
                    }
                }
                
                if (!found) {
                    Valve valve = (Valve) Class.forName(errorValve).getConstructor().newInstance();
                    getPipeline().addValve(valve);
                }
            } catch (Throwable t) {
                ExceptionUtils.handleThrowable(t);
                log.error(sm.getString("standardHost.invalidErrorReportValveClass", errorValve), t);
            }
        }
        
        super.startInternal();
    }
}
```

### 4.2 StandardHostValve

```java
/**
 * StandardHostValve - Hostçš„åŸºç¡€Valve
 * è´Ÿè´£é€‰æ‹©åˆé€‚çš„Contextå¤„ç†è¯·æ±‚
 */
final class StandardHostValve extends ValveBase {
    
    private static final Log log = LogFactory.getLog(StandardHostValve.class);
    
    public StandardHostValve() {
        super(true);
    }
    
    /**
     * ğŸ”¥ å¤„ç†è¯·æ±‚ - é€‰æ‹©Context
     */
    @Override
    public void invoke(Request request, Response response) 
            throws IOException, ServletException {
        
        // ğŸ”¥ è·å–Context
        Context context = request.getContext();
        if (context == null) {
            // æ²¡æœ‰æ‰¾åˆ°Contextï¼Œè¿”å›404é”™è¯¯
            response.sendError(HttpServletResponse.SC_NOT_FOUND,
                request.getRequestURI());
            return;
        }
        
        if (request.isAsyncSupported()) {
            request.setAsyncSupported(context.getPipeline().isAsyncSupported());
        }
        
        boolean asyncAtStart = request.isAsync();
        boolean asyncDispatching = request.isAsyncDispatching();
        
        try {
            // ğŸ”¥ ç»‘å®šContextç±»åŠ è½½å™¨
            context.bind(Globals.IS_SECURITY_ENABLED, MY_CLASSLOADER);
            
            if (!asyncAtStart && !context.fireRequestInitEvent(request.getRequest())) {
                return;
            }
            
            try {
                if (!asyncAtStart || asyncDispatching) {
                    // ğŸ”¥ è°ƒç”¨Contextå¤„ç†è¯·æ±‚
                    context.getPipeline().getFirst().invoke(request, response);
                } else {
                    if (!response.isErrorReportRequired()) {
                        throw new IllegalStateException(
                            sm.getString("standardHost.asyncStateError"));
                    }
                }
            } catch (Throwable t) {
                ExceptionUtils.handleThrowable(t);
                container.getLogger().error("Exception Processing " + request.getRequestURI(), t);
                
                if (!response.isCommitted()) {
                    request.setAttribute(RequestDispatcher.ERROR_EXCEPTION, t);
                    response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
                }
            }
            
            if (!asyncAtStart && !asyncDispatching) {
                context.fireRequestDestroyEvent(request.getRequest());
            }
        } finally {
            // ğŸ”¥ è§£ç»‘Contextç±»åŠ è½½å™¨
            context.unbind(Globals.IS_SECURITY_ENABLED, MY_CLASSLOADER);
        }
    }
}
```

---

## 5. Contextå®¹å™¨

### 5.1 StandardContext

```java
/**
 * StandardContext - æ ‡å‡†Contextå®ç°
 * ä»£è¡¨Webåº”ç”¨
 */
public class StandardContext extends ContainerBase implements Context, NotificationEmitter {
    
    private static final Log log = LogFactory.getLog(StandardContext.class);
    
    // ğŸ”¥ Webåº”ç”¨æ ¹ç›®å½•
    private String docBase = null;
    
    // ğŸ”¥ åº”ç”¨ç±»åŠ è½½å™¨
    private Loader loader = null;
    
    // ğŸ”¥ ä¼šè¯ç®¡ç†å™¨
    private Manager manager = null;
    
    // ğŸ”¥ Servletæ˜ å°„
    private final HashMap<String, String> servletMappings = new HashMap<>();
    
    // ğŸ”¥ Filteræ˜ å°„
    private final ContextFilterMaps filterMaps = new ContextFilterMaps();
    
    // ğŸ”¥ åº”ç”¨å‚æ•°
    private final HashMap<String, String> parameters = new HashMap<>();
    
    // ğŸ”¥ å®‰å…¨çº¦æŸ
    private SecurityConstraint[] constraints = new SecurityConstraint[0];
    
    // ğŸ”¥ ç™»å½•é…ç½®
    private LoginConfig loginConfig = null;
    
    // ğŸ”¥ æ¬¢è¿æ–‡ä»¶åˆ—è¡¨
    private String[] welcomeFiles = new String[0];
    
    // ğŸ”¥ é”™è¯¯é¡µé¢æ˜ å°„
    private final HashMap<String, ErrorPage> exceptionPages = new HashMap<>();
    private final HashMap<Integer, ErrorPage> statusPages = new HashMap<>();
    
    // ğŸ”¥ MIMEç±»å‹æ˜ å°„
    private final HashMap<String, String> mimeMappings = new HashMap<>();
    
    // ğŸ”¥ åº”ç”¨ç”Ÿå‘½å‘¨æœŸç›‘å¬å™¨
    private final Object[] applicationLifecycleListeners = new Object[0];
    
    // ğŸ”¥ åº”ç”¨äº‹ä»¶ç›‘å¬å™¨
    private final Object[] applicationEventListeners = new Object[0];
    
    // ğŸ”¥ Servletä¸Šä¸‹æ–‡
    private ApplicationContext context = null;
    
    // ğŸ”¥ Webåº”ç”¨ç±»åŠ è½½å™¨
    private WebappLoader webappLoader = null;
    
    public StandardContext() {
        super();
        // ğŸ”¥ è®¾ç½®Contextçš„åŸºç¡€Valve
        pipeline.setBasic(new StandardContextValve());
        
        // ğŸ”¥ è®¾ç½®é»˜è®¤çš„Broadcaster
        broadcaster = new NotificationBroadcasterSupport();
    }
    
    @Override
    public void addChild(Container child) {
        // Validate that this Container accepts only Wrapper children
        if (!(child instanceof Wrapper)) {
            throw new IllegalArgumentException(
                sm.getString("standardContext.notWrapper"));
        }
        
        super.addChild(child);
    }
    
    /**
     * ğŸ”¥ æ·»åŠ Servletæ˜ å°„
     */
    @Override
    public void addServletMappingDecoded(String pattern, String name, boolean jspWildCard) {
        if (findChild(name) == null) {
            throw new IllegalArgumentException(
                sm.getString("standardContext.servletMap.name", name));
        }
        
        String adjustedPattern = RequestUtil.URLDecode(pattern, getCharset());
        pattern = adjustedPattern;
        
        synchronized (servletMappings) {
            servletMappings.put(pattern, name);
        }
        
        // ğŸ”¥ é€šçŸ¥Mapper
        fireContainerEvent("addServletMapping", pattern);
    }
    
    /**
     * ğŸ”¥ æŸ¥æ‰¾Servletæ˜ å°„
     */
    @Override
    public String findServletMapping(String pattern) {
        synchronized (servletMappings) {
            return servletMappings.get(pattern);
        }
    }
    
    /**
     * ğŸ”¥ æ·»åŠ Filteræ˜ å°„
     */
    @Override
    public void addFilterMap(FilterMap filterMap) {
        validateFilterMap(filterMap);
        
        // Add this filter mapping to our registered set
        filterMaps.add(filterMap);
        
        fireContainerEvent("addFilterMap", filterMap);
    }
    
    /**
     * ğŸ”¥ æŸ¥æ‰¾Filteræ˜ å°„
     */
    @Override
    public FilterMap[] findFilterMaps() {
        return filterMaps.asArray();
    }
    
    @Override
    protected synchronized void startInternal() throws LifecycleException {
        if (log.isDebugEnabled()) {
            log.debug("Starting " + getBaseName());
        }
        
        // Send j2ee.state.starting notification
        if (this.getObjectName() != null) {
            Notification notification = new Notification("j2ee.state.starting",
                this.getObjectName(), sequenceNumber.getAndIncrement());
            broadcaster.sendNotification(notification);
        }
        
        setConfigured(false);
        boolean ok = true;
        
        // Currently this is effectively a no-op but may be used at some point
        // in the future to check that the required resources are available
        // before allowing the context to start
        if (ok && isUseNaming()) {
            if (getNamingContextListener() == null) {
                NamingContextListener ncl = new NamingContextListener();
                ncl.setName(getNamingContextName());
                ncl.setExceptionOnFailedWrite(getJndiExceptionOnFailedWrite());
                addLifecycleListener(ncl);
                setNamingContextListener(ncl);
            }
        }
        
        // ğŸ”¥ å¯åŠ¨Webåº”ç”¨ç±»åŠ è½½å™¨
        if (getLoader() == null) {
            WebappLoader webappLoader = new WebappLoader();
            webappLoader.setDelegate(getDelegate());
            setLoader(webappLoader);
        }
        
        // ğŸ”¥ åˆå§‹åŒ–å­—ç¬¦é›†æ˜ å°„å™¨
        getCharsetMapper();
        
        // ğŸ”¥ å¯åŠ¨å­å®¹å™¨ï¼ˆWrapperï¼‰
        super.startInternal();
        
        // ğŸ”¥ ç»‘å®šçº¿ç¨‹
        if (ok) {
            if (!listenerStart()) {
                log.error(sm.getString("standardContext.listenerFail"));
                ok = false;
            }
        }
        
        // ğŸ”¥ å¯åŠ¨Filter
        if (ok) {
            if (!filterStart()) {
                log.error(sm.getString("standardContext.filterFail"));
                ok = false;
            }
        }
        
        // ğŸ”¥ åŠ è½½å¹¶å¯åŠ¨Servlet
        if (ok) {
            if (!loadOnStartup(findChildren())) {
                log.error(sm.getString("standardContext.servletFail"));
                ok = false;
            }
        }
        
        // Start ContainerBackgroundProcessor thread
        super.threadStart();
        
        setState(LifecycleState.STARTING);
        
        // Send j2ee.state.running notification
        if (this.getObjectName() != null) {
            Notification notification = new Notification("j2ee.state.running",
                this.getObjectName(), sequenceNumber.getAndIncrement());
            broadcaster.sendNotification(notification);
        }
    }
}
```

---

## 6. Wrapperå®¹å™¨

### 6.1 StandardWrapper

```java
/**
 * StandardWrapper - æ ‡å‡†Wrapperå®ç°
 * ä»£è¡¨å•ä¸ªServlet
 */
public class StandardWrapper extends ContainerBase implements ServletConfig, Wrapper {
    
    private static final Log log = LogFactory.getLog(StandardWrapper.class);
    
    // ğŸ”¥ Servletå®ä¾‹
    protected volatile Servlet instance = null;
    
    // ğŸ”¥ Servletç±»å
    protected String servletClass = null;
    
    // ğŸ”¥ JSPæ–‡ä»¶è·¯å¾„
    protected String jspFile = null;
    
    // ğŸ”¥ åˆå§‹åŒ–å‚æ•°
    protected final HashMap<String, String> parameters = new HashMap<>();
    
    // ğŸ”¥ å®‰å…¨è§’è‰²å¼•ç”¨
    protected final HashMap<String, String> references = new HashMap<>();
    
    // ğŸ”¥ è¿è¡Œæ—¶ä¿¡æ¯
    protected String runAs = null;
    
    // ğŸ”¥ åŠ è½½æ—¶æœº
    protected int loadOnStartup = -1;
    
    // ğŸ”¥ æ˜¯å¦å¯ç”¨
    protected volatile boolean available = false;
    
    // ğŸ”¥ å•çº¿ç¨‹æ¨¡å‹
    protected boolean singleThreadModel = false;
    
    // ğŸ”¥ å•çº¿ç¨‹å®ä¾‹æ± 
    protected Stack<Servlet> instancePool = null;
    
    // ğŸ”¥ æœ€å¤§å®ä¾‹æ•°
    protected int nInstances = 0;
    
    // ğŸ”¥ æœªåŠ è½½å®ä¾‹æ•°
    protected int countAllocated = 0;
    
    // ğŸ”¥ Servletç»Ÿè®¡ä¿¡æ¯
    protected StandardWrapperFacade facade = new StandardWrapperFacade(this);
    
    public StandardWrapper() {
        super();
        swValve = new StandardWrapperValve();
        pipeline.setBasic(swValve);
        broadcaster = new NotificationBroadcasterSupport();
    }
    
    /**
     * ğŸ”¥ åˆ†é…Servletå®ä¾‹
     */
    @Override
    public Servlet allocate() throws ServletException {
        // If we are currently unloading this servlet, throw an exception
        if (unloading) {
            throw new ServletException(sm.getString("standardWrapper.unloading", getName()));
        }
        
        boolean newInstance = false;
        
        // If not SingleThreadedModel, return the same instance every time
        if (!singleThreadModel) {
            // Load and initialize our instance if necessary
            if (instance == null || !instanceInitialized) {
                synchronized (this) {
                    if (instance == null) {
                        try {
                            if (log.isDebugEnabled()) {
                                log.debug("Allocating non-STM instance");
                            }
                            
                            // ğŸ”¥ åŠ è½½Servletå®ä¾‹
                            instance = loadServlet();
                            newInstance = true;
                            
                            if (!singleThreadModel) {
                                // For non-STM, increment here to prevent a race
                                // condition with unload. Bug 43683, test case
                                // #3
                                countAllocated.incrementAndGet();
                            }
                        } catch (ServletException e) {
                            throw e;
                        } catch (Throwable e) {
                            ExceptionUtils.handleThrowable(e);
                            throw new ServletException(sm.getString("standardWrapper.allocate"), e);
                        }
                    }
                    
                    if (!instanceInitialized) {
                        // ğŸ”¥ åˆå§‹åŒ–Servlet
                        initServlet(instance);
                    }
                }
            }
            
            if (singleThreadModel) {
                if (newInstance) {
                    // Have to do this outside of the sync above to prevent a
                    // possible deadlock
                    synchronized (instancePool) {
                        instancePool.push(instance);
                        nInstances++;
                    }
                }
            } else {
                if (log.isTraceEnabled()) {
                    log.trace("  Returning non-STM instance");
                }
                
                // For new instances, count will have been incremented at the
                // time of creation
                if (!newInstance) {
                    countAllocated.incrementAndGet();
                }
                
                return instance;
            }
        }
        
        // ğŸ”¥ å¤„ç†å•çº¿ç¨‹æ¨¡å‹
        synchronized (instancePool) {
            while (countAllocated.get() >= nInstances) {
                // Allocate a new instance if possible, or else wait
                if (nInstances < maxInstances) {
                    try {
                        instancePool.push(loadServlet());
                        nInstances++;
                    } catch (ServletException e) {
                        throw e;
                    } catch (Throwable e) {
                        ExceptionUtils.handleThrowable(e);
                        throw new ServletException(sm.getString("standardWrapper.allocate"), e);
                    }
                } else {
                    try {
                        instancePool.wait();
                    } catch (InterruptedException e) {
                        // Ignore
                    }
                }
            }
            
            if (log.isTraceEnabled()) {
                log.trace("  Returning allocated STM instance");
            }
            
            countAllocated.incrementAndGet();
            return instancePool.pop();
        }
    }
    
    /**
     * ğŸ”¥ é‡Šæ”¾Servletå®ä¾‹
     */
    @Override
    public void deallocate(Servlet servlet) throws ServletException {
        // If not SingleThreadModel, no action is required
        if (!singleThreadModel) {
            countAllocated.decrementAndGet();
            return;
        }
        
        // Unlock and free this instance
        synchronized (instancePool) {
            countAllocated.decrementAndGet();
            instancePool.push(servlet);
            instancePool.notify();
        }
    }
    
    /**
     * ğŸ”¥ åŠ è½½Servlet
     */
    public synchronized Servlet loadServlet() throws ServletException {
        // Nothing to do if we already have an instance or an instance pool
        if (!singleThreadModel && (instance != null)) {
            return instance;
        }
        
        PrintStream out = System.out;
        if (swallowOutput) {
            SystemLogHandler.startCapture();
        }
        
        Servlet servlet;
        try {
            long t1 = System.currentTimeMillis();
            
            // Complain if no servlet class has been specified
            if (servletClass == null) {
                unavailable(null);
                throw new ServletException(
                    sm.getString("standardWrapper.notClass", getName()));
            }
            
            // ğŸ”¥ è·å–ç±»åŠ è½½å™¨
            InstanceManager instanceManager = ((StandardContext) getParent()).getInstanceManager();
            
            try {
                // ğŸ”¥ åˆ›å»ºServletå®ä¾‹
                servlet = (Servlet) instanceManager.newInstance(servletClass);
            } catch (ClassCastException e) {
                unavailable(null);
                throw new ServletException(sm.getString("standardWrapper.notServlet", servletClass), e);
            } catch (Throwable e) {
                e = ExceptionUtils.unwrapInvocationTargetException(e);
                ExceptionUtils.handleThrowable(e);
                unavailable(null);
                throw new ServletException(sm.getString("standardWrapper.instantiate", servletClass), e);
            }
            
            // ğŸ”¥ æ£€æŸ¥æ˜¯å¦ä¸ºå•çº¿ç¨‹æ¨¡å‹
            if ((servlet instanceof SingleThreadModel) &&
                    (instancePool == null)) {
                instancePool = new Stack<>();
            }
            
            // ğŸ”¥ åˆå§‹åŒ–Servlet
            initServlet(servlet);
            
            long t2 = System.currentTimeMillis();
            if ((t2 - t1) > 10000) {
                log.warn(sm.getString("standardWrapper.loadTime", getName(), Long.valueOf(t2 - t1)));
            }
        } finally {
            if (swallowOutput) {
                String log = SystemLogHandler.stopCapture();
                if (log != null && log.length() > 0) {
                    if (getServletContext() != null) {
                        getServletContext().log(log);
                    } else {
                        out.println(log);
                    }
                }
            }
        }
        
        return servlet;
    }
    
    /**
     * ğŸ”¥ åˆå§‹åŒ–Servlet
     */
    private synchronized void initServlet(Servlet servlet) throws ServletException {
        if (instanceInitialized && !singleThreadModel) {
            return;
        }
        
        // Call the initialization method of this servlet
        try {
            if (Globals.IS_SECURITY_ENABLED) {
                boolean success = false;
                try {
                    Object[] args = new Object[] { facade };
                    SecurityUtil.doAsPrivilege("init", servlet, classType, args);
                    success = true;
                } finally {
                    if (!success) {
                        // destroy() will not be called, thus clear the reference now
                        SecurityUtil.remove(servlet);
                    }
                }
            } else {
                // ğŸ”¥ è°ƒç”¨Servletçš„initæ–¹æ³•
                servlet.init(facade);
            }
            
            instanceInitialized = true;
        } catch (UnavailableException f) {
            unavailable(f);
            throw f;
        } catch (ServletException f) {
            // If the servlet wanted to be unavailable it would have
            // said so, so do not call unavailable(null).
            throw f;
        } catch (Throwable f) {
            ExceptionUtils.handleThrowable(f);
            getServletContext().log(sm.getString("standardWrapper.initException", getName()), f);
            // If the servlet wanted to be unavailable it would have
            // said so, so do not call unavailable(null).
            throw new ServletException(
                sm.getString("standardWrapper.initException", getName()), f);
        }
    }
}
```

---

## 7. é¢è¯•è¦ç‚¹

### 7.1 é«˜é¢‘é¢è¯•é¢˜

#### Q1: Tomcatå®¹å™¨çš„å±‚æ¬¡ç»“æ„ï¼Ÿ

```
Tomcatå®¹å™¨å±‚æ¬¡ç»“æ„ï¼š

Server (Catalina)
â””â”€â”€ Service (StandardService)
    â”œâ”€â”€ Connector (HTTP/AJPè¿æ¥å™¨)
    â””â”€â”€ Engine (StandardEngine)
        â””â”€â”€ Host (StandardHost)
            â””â”€â”€ Context (StandardContext)
                â””â”€â”€ Wrapper (StandardWrapper)
                    â””â”€â”€ Servlet

å„å±‚èŒè´£ï¼š
- Server: æ•´ä¸ªTomcatæœåŠ¡å™¨
- Service: æœåŠ¡ç»„åˆï¼ŒåŒ…å«è¿æ¥å™¨å’Œå®¹å™¨
- Engine: Servletå¼•æ“ï¼Œç®¡ç†å¤šä¸ªè™šæ‹Ÿä¸»æœº
- Host: è™šæ‹Ÿä¸»æœºï¼Œç®¡ç†å¤šä¸ªWebåº”ç”¨
- Context: Webåº”ç”¨ï¼Œç®¡ç†å¤šä¸ªServlet
- Wrapper: ServletåŒ…è£…å™¨ï¼Œç®¡ç†å•ä¸ªServlet
```

#### Q2: è¯·æ±‚åœ¨å®¹å™¨ä¸­çš„å¤„ç†æµç¨‹ï¼Ÿ

```
è¯·æ±‚å¤„ç†æµç¨‹ï¼š

1. Connectoræ¥æ”¶HTTPè¯·æ±‚
   - è§£æHTTPåè®®
   - åˆ›å»ºRequest/Responseå¯¹è±¡

2. Engine.invoke()
   - æ ¹æ®Hoståé€‰æ‹©Hostå®¹å™¨
   - è°ƒç”¨StandardEngineValve

3. Host.invoke()
   - æ ¹æ®Contextè·¯å¾„é€‰æ‹©Context
   - è°ƒç”¨StandardHostValve

4. Context.invoke()
   - æ ¹æ®URLæ¨¡å¼é€‰æ‹©Wrapper
   - åº”ç”¨Filteré“¾
   - è°ƒç”¨StandardContextValve

5. Wrapper.invoke()
   - åˆ†é…Servletå®ä¾‹
   - è°ƒç”¨Servlet.service()
   - è°ƒç”¨StandardWrapperValve

æ¯å±‚éƒ½é€šè¿‡Pipeline-Valveæ¨¡å¼å¤„ç†
```

#### Q3: Containeræ¥å£çš„æ ¸å¿ƒæ–¹æ³•ï¼Ÿ

```java
/**
 * Containeræ ¸å¿ƒæ–¹æ³•ï¼š
 */
public interface Container {
    // ğŸ”¥ è¯·æ±‚å¤„ç†
    void invoke(Request request, Response response);
    
    // ğŸ”¥ å­å®¹å™¨ç®¡ç†
    void addChild(Container child);
    void removeChild(Container child);
    Container findChild(String name);
    Container[] findChildren();
    
    // ğŸ”¥ Pipelineè·å–
    Pipeline getPipeline();
    
    // ğŸ”¥ ç”Ÿå‘½å‘¨æœŸç®¡ç†ï¼ˆç»§æ‰¿è‡ªLifecycleï¼‰
    void start() throws LifecycleException;
    void stop() throws LifecycleException;
    
    // ğŸ”¥ ç±»åŠ è½½å™¨ç®¡ç†
    ClassLoader getParentClassLoader();
    void setParentClassLoader(ClassLoader parent);
}
```

#### Q4: Wrapperå¦‚ä½•ç®¡ç†Servletå®ä¾‹ï¼Ÿ

```
Wrapperç®¡ç†Servletå®ä¾‹ï¼š

1. å•ä¾‹æ¨¡å¼ï¼ˆé»˜è®¤ï¼‰
   - ä¸€ä¸ªServletç±»åªåˆ›å»ºä¸€ä¸ªå®ä¾‹
   - å¤šçº¿ç¨‹å…±äº«åŒä¸€å®ä¾‹
   - æ€§èƒ½æœ€å¥½

2. å•çº¿ç¨‹æ¨¡å‹ï¼ˆå·²åºŸå¼ƒï¼‰
   - å®ç°SingleThreadModelæ¥å£
   - åˆ›å»ºå®ä¾‹æ± 
   - æ¯æ¬¡è¯·æ±‚åˆ†é…ä¸€ä¸ªå®ä¾‹

3. å®ä¾‹ç®¡ç†æ–¹æ³•
   - allocate(): åˆ†é…å®ä¾‹
   - deallocate(): é‡Šæ”¾å®ä¾‹
   - loadServlet(): åŠ è½½Servlet
   - initServlet(): åˆå§‹åŒ–Servlet

4. ç”Ÿå‘½å‘¨æœŸ
   - åŠ è½½ï¼šClass.forName()
   - å®ä¾‹åŒ–ï¼šnewInstance()
   - åˆå§‹åŒ–ï¼šinit()
   - æœåŠ¡ï¼šservice()
   - é”€æ¯ï¼šdestroy()
```

### 7.2 æºç é˜…è¯»è¦ç‚¹

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  Containeræºç é˜…è¯»è·¯çº¿                       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                             â”‚
â”‚  Containeræ¥å£                                              â”‚
â”‚    â”‚                                                        â”‚
â”‚    â”œâ”€â”€ ContainerBase æŠ½è±¡åŸºç±»                               â”‚
â”‚    â”‚     â”œâ”€â”€ å­å®¹å™¨ç®¡ç†                                     â”‚
â”‚    â”‚     â”œâ”€â”€ Pipelineå§”æ‰˜                                   â”‚
â”‚    â”‚     â””â”€â”€ åå°å¤„ç†çº¿ç¨‹                                   â”‚
â”‚    â”‚                                                        â”‚
â”‚    â”œâ”€â”€ StandardEngine                                       â”‚
â”‚    â”‚     â””â”€â”€ StandardEngineValve                            â”‚
â”‚    â”‚                                                        â”‚
â”‚    â”œâ”€â”€ StandardHost                                         â”‚
â”‚    â”‚     â””â”€â”€ StandardHostValve                              â”‚
â”‚    â”‚                                                        â”‚
â”‚    â”œâ”€â”€ StandardContext                                      â”‚
â”‚    â”‚     â”œâ”€â”€ Servlet/Filteræ˜ å°„                            â”‚
â”‚    â”‚     â””â”€â”€ StandardContextValve                           â”‚
â”‚    â”‚                                                        â”‚
â”‚    â””â”€â”€ StandardWrapper                                      â”‚
â”‚          â”œâ”€â”€ Servletå®ä¾‹ç®¡ç†                               â”‚
â”‚          â””â”€â”€ StandardWrapperValve                           â”‚
â”‚                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 7.3 å…³é”®è®¾è®¡æ¨¡å¼

```
Containerä¸­ä½¿ç”¨çš„è®¾è®¡æ¨¡å¼ï¼š

1. ç»„åˆæ¨¡å¼
   - Containerå½¢æˆæ ‘å½¢ç»“æ„
   - ç»Ÿä¸€å¤„ç†å•ä¸ªå®¹å™¨å’Œå®¹å™¨ç»„åˆ

2. è´£ä»»é“¾æ¨¡å¼
   - Pipeline-Valveé“¾å¼å¤„ç†
   - æ¯å±‚å®¹å™¨éƒ½æœ‰è‡ªå·±çš„å¤„ç†é“¾

3. æ¨¡æ¿æ–¹æ³•æ¨¡å¼
   - ContainerBaseå®šä¹‰é€šç”¨æµç¨‹
   - å­ç±»å®ç°å…·ä½“é€»è¾‘

4. å·¥å‚æ¨¡å¼
   - InstanceManageråˆ›å»ºå®ä¾‹
   - æ”¯æŒä¾èµ–æ³¨å…¥

5. è§‚å¯Ÿè€…æ¨¡å¼
   - ContainerListenerç›‘å¬å®¹å™¨äº‹ä»¶
   - PropertyChangeListenerç›‘å¬å±æ€§å˜åŒ–
```

---

## ğŸ“š æ€»ç»“

### æ ¸å¿ƒè¦ç‚¹

```
1. Containeré‡‡ç”¨ç»„åˆæ¨¡å¼
   - å››å±‚å®¹å™¨ï¼šEngineâ†’Hostâ†’Contextâ†’Wrapper
   - æ¯å±‚è´Ÿè´£ä¸åŒç²’åº¦çš„ç®¡ç†

2. è¯·æ±‚å¤„ç†é‡‡ç”¨è´£ä»»é“¾
   - Pipeline-Valveæ¨¡å¼
   - æ¯å±‚å®¹å™¨é€‰æ‹©ä¸‹å±‚å®¹å™¨

3. å®¹å™¨ç”Ÿå‘½å‘¨æœŸç®¡ç†
   - ç»§æ‰¿Lifecycleæ¥å£
   - ç»Ÿä¸€çš„å¯åŠ¨åœæ­¢æµç¨‹

4. Wrapperç®¡ç†Servletå®ä¾‹
   - æ”¯æŒå•ä¾‹å’Œå®ä¾‹æ± 
   - å®Œæ•´çš„Servletç”Ÿå‘½å‘¨æœŸ

5. åå°å¤„ç†æœºåˆ¶
   - ContainerBackgroundProcessor
   - å®šæœŸæ‰§è¡Œç»´æŠ¤ä»»åŠ¡
```

---

**ç›¸å…³æ–‡æ¡£**ï¼š
- [Tomcatå¯åŠ¨æµç¨‹æºç è§£æ](./Tomcatå¯åŠ¨æµç¨‹æºç è§£æ.md)
- [Connectoræºç è§£æ](./Connectoræºç è§£æ.md)
- [Servletå¤„ç†æµç¨‹æºç è§£æ](./Servletå¤„ç†æµç¨‹æºç è§£æ.md)
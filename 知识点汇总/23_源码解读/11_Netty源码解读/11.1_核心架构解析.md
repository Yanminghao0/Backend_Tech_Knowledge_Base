# Nettyæ ¸å¿ƒæ¶æ„è§£æ

> ğŸ’¡ æ·±å…¥ç†è§£Nettyçš„æ•´ä½“æ¶æ„å’Œæ ¸å¿ƒè®¾è®¡æ€æƒ³

---

## ğŸ“‹ ç›®å½•

- [1. Nettyæ¦‚è¿°](#1-nettyæ¦‚è¿°)
- [2. æ ¸å¿ƒç»„ä»¶](#2-æ ¸å¿ƒç»„ä»¶)
- [3. Reactorçº¿ç¨‹æ¨¡å‹](#3-reactorçº¿ç¨‹æ¨¡å‹)
- [4. å¯åŠ¨æµç¨‹åˆ†æ](#4-å¯åŠ¨æµç¨‹åˆ†æ)
- [5. è¿æ¥å»ºç«‹æµç¨‹](#5-è¿æ¥å»ºç«‹æµç¨‹)
- [6. é¢è¯•è¦ç‚¹](#6-é¢è¯•è¦ç‚¹)

---

## 1. Nettyæ¦‚è¿°

### 1.1 ä»€ä¹ˆæ˜¯Netty

```
Nettyæ˜¯ä¸€ä¸ªå¼‚æ­¥äº‹ä»¶é©±åŠ¨çš„ç½‘ç»œåº”ç”¨æ¡†æ¶ï¼Œç”¨äºå¿«é€Ÿå¼€å‘é«˜æ€§èƒ½ã€é«˜å¯é æ€§çš„ç½‘ç»œæœåŠ¡å™¨å’Œå®¢æˆ·ç«¯ç¨‹åºã€‚

æ ¸å¿ƒç‰¹ç‚¹ï¼š
- é«˜æ€§èƒ½ï¼šåŸºäºNIOï¼Œæ”¯æŒé›¶æ‹·è´
- é«˜å¯é ï¼šå®Œå–„çš„å¼‚å¸¸å¤„ç†æœºåˆ¶
- æ˜“ç”¨æ€§ï¼šç®€æ´çš„APIè®¾è®¡
- å¯æ‰©å±•ï¼šçµæ´»çš„çº¿ç¨‹æ¨¡å‹å’Œç»„ä»¶è®¾è®¡
```

### 1.2 Nettyæ¶æ„å›¾

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      Application Layer                       â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚              Business Logic Handlers                 â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                      Protocol Layer                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚  HTTP   â”‚ â”‚WebSocketâ”‚ â”‚  SSL    â”‚ â”‚ Custom Protocol â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                      Transport Layer                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚    Channel    Pipeline    EventLoop    ByteBuf      â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                      Core Layer                              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚   NIO   â”‚ â”‚  Epoll  â”‚ â”‚  KQueue â”‚ â”‚     OIO         â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 2. æ ¸å¿ƒç»„ä»¶

### 2.1 Channel

```java
// Channelæ˜¯Nettyç½‘ç»œæ“ä½œçš„æŠ½è±¡
public interface Channel extends AttributeMap, ChannelOutboundInvoker, Comparable<Channel> {
    
    // è·å–EventLoop
    EventLoop eventLoop();
    
    // è·å–çˆ¶Channel
    Channel parent();
    
    // è·å–é…ç½®
    ChannelConfig config();
    
    // æ˜¯å¦æ‰“å¼€
    boolean isOpen();
    
    // æ˜¯å¦æ³¨å†Œ
    boolean isRegistered();
    
    // æ˜¯å¦æ¿€æ´»
    boolean isActive();
    
    // è·å–Pipeline
    ChannelPipeline pipeline();
    
    // è·å–ByteBufåˆ†é…å™¨
    ByteBufAllocator alloc();
    
    // è¯»å–æ•°æ®
    Channel read();
    
    // åˆ·æ–°æ•°æ®
    Channel flush();
}

// å¸¸ç”¨Channelå®ç°
NioServerSocketChannel  // NIOæœåŠ¡ç«¯
NioSocketChannel        // NIOå®¢æˆ·ç«¯
EpollServerSocketChannel // Linux EpollæœåŠ¡ç«¯
EpollSocketChannel      // Linux Epollå®¢æˆ·ç«¯
```

### 2.2 EventLoop

```java
// EventLoopæ˜¯äº‹ä»¶å¾ªç¯çš„æ ¸å¿ƒ
public interface EventLoop extends OrderedEventExecutor, EventLoopGroup {
    
    // è·å–æ‰€å±çš„EventLoopGroup
    @Override
    EventLoopGroup parent();
    
    // æ³¨å†ŒChannel
    ChannelFuture register(Channel channel);
    
    // æ³¨å†ŒChannelå¹¶è¿”å›Promise
    ChannelFuture register(ChannelPromise promise);
}

// EventLoopç»§æ‰¿ä½“ç³»
EventExecutorGroup
â””â”€â”€ EventLoopGroup
    â””â”€â”€ MultithreadEventLoopGroup
        â””â”€â”€ NioEventLoopGroup
        
EventExecutor
â””â”€â”€ OrderedEventExecutor
    â””â”€â”€ EventLoop
        â””â”€â”€ SingleThreadEventLoop
            â””â”€â”€ NioEventLoop
```

### 2.3 ChannelPipeline

```java
// Pipelineæ˜¯Handlerçš„å®¹å™¨
public interface ChannelPipeline extends ChannelInboundInvoker, 
        ChannelOutboundInvoker, Iterable<Entry<String, ChannelHandler>> {
    
    // æ·»åŠ Handleråˆ°å¤´éƒ¨
    ChannelPipeline addFirst(String name, ChannelHandler handler);
    
    // æ·»åŠ Handleråˆ°å°¾éƒ¨
    ChannelPipeline addLast(String name, ChannelHandler handler);
    
    // æ·»åŠ Handleråˆ°æŒ‡å®šä½ç½®ä¹‹å‰
    ChannelPipeline addBefore(String baseName, String name, ChannelHandler handler);
    
    // æ·»åŠ Handleråˆ°æŒ‡å®šä½ç½®ä¹‹å
    ChannelPipeline addAfter(String baseName, String name, ChannelHandler handler);
    
    // ç§»é™¤Handler
    ChannelPipeline remove(ChannelHandler handler);
    
    // è·å–Channel
    Channel channel();
    
    // è§¦å‘å…¥ç«™äº‹ä»¶
    ChannelPipeline fireChannelRead(Object msg);
    
    // è§¦å‘å‡ºç«™äº‹ä»¶
    ChannelFuture write(Object msg);
}
```

### 2.4 ChannelHandler

```java
// å…¥ç«™Handler
public interface ChannelInboundHandler extends ChannelHandler {
    void channelRegistered(ChannelHandlerContext ctx);
    void channelUnregistered(ChannelHandlerContext ctx);
    void channelActive(ChannelHandlerContext ctx);
    void channelInactive(ChannelHandlerContext ctx);
    void channelRead(ChannelHandlerContext ctx, Object msg);
    void channelReadComplete(ChannelHandlerContext ctx);
    void userEventTriggered(ChannelHandlerContext ctx, Object evt);
    void channelWritabilityChanged(ChannelHandlerContext ctx);
    void exceptionCaught(ChannelHandlerContext ctx, Throwable cause);
}

// å‡ºç«™Handler
public interface ChannelOutboundHandler extends ChannelHandler {
    void bind(ChannelHandlerContext ctx, SocketAddress localAddress, ChannelPromise promise);
    void connect(ChannelHandlerContext ctx, SocketAddress remoteAddress, 
                 SocketAddress localAddress, ChannelPromise promise);
    void disconnect(ChannelHandlerContext ctx, ChannelPromise promise);
    void close(ChannelHandlerContext ctx, ChannelPromise promise);
    void deregister(ChannelHandlerContext ctx, ChannelPromise promise);
    void read(ChannelHandlerContext ctx);
    void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise);
    void flush(ChannelHandlerContext ctx);
}
```

---

## 3. Reactorçº¿ç¨‹æ¨¡å‹

### 3.1 ä¸‰ç§Reactoræ¨¡å‹

```
1. å•çº¿ç¨‹æ¨¡å‹
   - ä¸€ä¸ªçº¿ç¨‹å¤„ç†æ‰€æœ‰IOæ“ä½œ
   - é€‚ç”¨äºè¿æ¥æ•°å°‘ã€ä¸šåŠ¡ç®€å•çš„åœºæ™¯
   
   EventLoopGroup group = new NioEventLoopGroup(1);
   bootstrap.group(group);

2. å¤šçº¿ç¨‹æ¨¡å‹
   - ä¸€ä¸ªçº¿ç¨‹æ¥æ”¶è¿æ¥
   - å¤šä¸ªçº¿ç¨‹å¤„ç†IO
   - é€‚ç”¨äºè¿æ¥æ•°å¤šã€ä¸šåŠ¡å¤æ‚çš„åœºæ™¯
   
   EventLoopGroup group = new NioEventLoopGroup();
   bootstrap.group(group);

3. ä¸»ä»å¤šçº¿ç¨‹æ¨¡å‹ï¼ˆæ¨èï¼‰
   - Bossçº¿ç¨‹ç»„æ¥æ”¶è¿æ¥
   - Workerçº¿ç¨‹ç»„å¤„ç†IO
   - èŒè´£åˆ†ç¦»ï¼Œæ€§èƒ½æœ€ä¼˜
   
   EventLoopGroup bossGroup = new NioEventLoopGroup(1);
   EventLoopGroup workerGroup = new NioEventLoopGroup();
   bootstrap.group(bossGroup, workerGroup);
```

### 3.2 ä¸»ä»å¤šçº¿ç¨‹æ¨¡å‹è¯¦è§£

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Client Connections                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚
                              â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   Boss EventLoopGroup                        â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚                  NioEventLoop                        â”‚   â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚   â”‚
â”‚  â”‚  â”‚  Selector.select() â†’ Accept â†’ Register      â”‚   â”‚   â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚
                    Channelæ³¨å†Œåˆ°Worker
                              â”‚
                              â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  Worker EventLoopGroup                       â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”           â”‚
â”‚  â”‚ NioEventLoopâ”‚ â”‚ NioEventLoopâ”‚ â”‚ NioEventLoopâ”‚  ...      â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”  â”‚ â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”  â”‚ â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”  â”‚           â”‚
â”‚  â”‚  â”‚Channelâ”‚  â”‚ â”‚  â”‚Channelâ”‚  â”‚ â”‚  â”‚Channelâ”‚  â”‚           â”‚
â”‚  â”‚  â”‚Channelâ”‚  â”‚ â”‚  â”‚Channelâ”‚  â”‚ â”‚  â”‚Channelâ”‚  â”‚           â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚ â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚ â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚           â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```


---

## 4. å¯åŠ¨æµç¨‹åˆ†æ

### 4.1 ServerBootstrapé…ç½®

```java
// æœåŠ¡ç«¯å¯åŠ¨é…ç½®
ServerBootstrap bootstrap = new ServerBootstrap();
bootstrap
    // è®¾ç½®çº¿ç¨‹ç»„
    .group(bossGroup, workerGroup)
    // è®¾ç½®Channelç±»å‹
    .channel(NioServerSocketChannel.class)
    // è®¾ç½®æœåŠ¡ç«¯é€‰é¡¹
    .option(ChannelOption.SO_BACKLOG, 128)
    // è®¾ç½®å®¢æˆ·ç«¯é€‰é¡¹
    .childOption(ChannelOption.SO_KEEPALIVE, true)
    // è®¾ç½®Handler
    .handler(new LoggingHandler(LogLevel.INFO))
    // è®¾ç½®å­Handler
    .childHandler(new ChannelInitializer<SocketChannel>() {
        @Override
        protected void initChannel(SocketChannel ch) {
            ch.pipeline().addLast(new MyHandler());
        }
    });
```

### 4.2 bindæµç¨‹åˆ†æ

```java
// AbstractBootstrap.bind()
public ChannelFuture bind(int inetPort) {
    return bind(new InetSocketAddress(inetPort));
}

public ChannelFuture bind(SocketAddress localAddress) {
    validate();
    return doBind(localAddress);
}

private ChannelFuture doBind(final SocketAddress localAddress) {
    // 1. åˆå§‹åŒ–å¹¶æ³¨å†ŒChannel
    final ChannelFuture regFuture = initAndRegister();
    final Channel channel = regFuture.channel();
    
    if (regFuture.cause() != null) {
        return regFuture;
    }
    
    if (regFuture.isDone()) {
        // 2. æ³¨å†Œå®Œæˆï¼Œæ‰§è¡Œç»‘å®š
        ChannelPromise promise = channel.newPromise();
        doBind0(regFuture, channel, localAddress, promise);
        return promise;
    } else {
        // 3. æ³¨å†Œæœªå®Œæˆï¼Œæ·»åŠ ç›‘å¬å™¨
        final PendingRegistrationPromise promise = new PendingRegistrationPromise(channel);
        regFuture.addListener(new ChannelFutureListener() {
            @Override
            public void operationComplete(ChannelFuture future) {
                if (future.cause() != null) {
                    promise.setFailure(future.cause());
                } else {
                    promise.registered();
                    doBind0(regFuture, channel, localAddress, promise);
                }
            }
        });
        return promise;
    }
}
```

### 4.3 initAndRegisteræµç¨‹

```java
final ChannelFuture initAndRegister() {
    Channel channel = null;
    try {
        // 1. åˆ›å»ºChannelï¼ˆåå°„åˆ›å»ºNioServerSocketChannelï¼‰
        channel = channelFactory.newChannel();
        
        // 2. åˆå§‹åŒ–Channel
        init(channel);
    } catch (Throwable t) {
        // å¼‚å¸¸å¤„ç†...
    }
    
    // 3. æ³¨å†ŒChannelåˆ°EventLoop
    ChannelFuture regFuture = config().group().register(channel);
    
    if (regFuture.cause() != null) {
        if (channel.isRegistered()) {
            channel.close();
        } else {
            channel.unsafe().closeForcibly();
        }
    }
    
    return regFuture;
}

// ServerBootstrap.init()
@Override
void init(Channel channel) {
    // è®¾ç½®é€‰é¡¹
    setChannelOptions(channel, newOptionsArray(), logger);
    // è®¾ç½®å±æ€§
    setAttributes(channel, newAttributesArray());
    
    ChannelPipeline p = channel.pipeline();
    
    // è·å–å­é…ç½®
    final EventLoopGroup currentChildGroup = childGroup;
    final ChannelHandler currentChildHandler = childHandler;
    final Entry<ChannelOption<?>, Object>[] currentChildOptions = newOptionsArray(childOptions);
    final Entry<AttributeKey<?>, Object>[] currentChildAttrs = newAttributesArray(childAttrs);
    
    // æ·»åŠ ServerBootstrapAcceptor
    p.addLast(new ChannelInitializer<Channel>() {
        @Override
        public void initChannel(final Channel ch) {
            final ChannelPipeline pipeline = ch.pipeline();
            ChannelHandler handler = config.handler();
            if (handler != null) {
                pipeline.addLast(handler);
            }
            
            ch.eventLoop().execute(new Runnable() {
                @Override
                public void run() {
                    // æ·»åŠ Acceptorå¤„ç†æ–°è¿æ¥
                    pipeline.addLast(new ServerBootstrapAcceptor(
                        ch, currentChildGroup, currentChildHandler, 
                        currentChildOptions, currentChildAttrs));
                }
            });
        }
    });
}
```

### 4.4 Channelæ³¨å†Œæµç¨‹

```java
// AbstractChannel.register()
@Override
public final void register(EventLoop eventLoop, final ChannelPromise promise) {
    // ä¿å­˜EventLoop
    AbstractChannel.this.eventLoop = eventLoop;
    
    if (eventLoop.inEventLoop()) {
        // å½“å‰çº¿ç¨‹æ˜¯EventLoopçº¿ç¨‹ï¼Œç›´æ¥æ³¨å†Œ
        register0(promise);
    } else {
        // æäº¤ä»»åŠ¡åˆ°EventLoop
        eventLoop.execute(new Runnable() {
            @Override
            public void run() {
                register0(promise);
            }
        });
    }
}

private void register0(ChannelPromise promise) {
    try {
        // 1. æ‰§è¡Œæ³¨å†Œ
        doRegister();
        
        // 2. è°ƒç”¨Pipelineçš„handlerAdded
        pipeline.invokeHandlerAddedIfNeeded();
        
        // 3. è®¾ç½®æ³¨å†ŒæˆåŠŸ
        safeSetSuccess(promise);
        
        // 4. è§¦å‘channelRegisteredäº‹ä»¶
        pipeline.fireChannelRegistered();
        
        // 5. å¦‚æœChannelå·²æ¿€æ´»ï¼Œè§¦å‘channelActiveäº‹ä»¶
        if (isActive()) {
            if (firstRegistration) {
                pipeline.fireChannelActive();
            } else if (config().isAutoRead()) {
                beginRead();
            }
        }
    } catch (Throwable t) {
        closeForcibly();
        closeFuture.setClosed();
        safeSetFailure(promise, t);
    }
}

// AbstractNioChannel.doRegister()
@Override
protected void doRegister() throws Exception {
    boolean selected = false;
    for (;;) {
        try {
            // æ³¨å†Œåˆ°Selectorï¼Œä¸å…³æ³¨ä»»ä½•äº‹ä»¶
            selectionKey = javaChannel().register(eventLoop().unwrappedSelector(), 0, this);
            return;
        } catch (CancelledKeyException e) {
            // å¤„ç†å¼‚å¸¸...
        }
    }
}
```

---

## 5. è¿æ¥å»ºç«‹æµç¨‹

### 5.1 Acceptæµç¨‹

```java
// NioEventLoop.processSelectedKey()
private void processSelectedKey(SelectionKey k, AbstractNioChannel ch) {
    final AbstractNioChannel.NioUnsafe unsafe = ch.unsafe();
    
    try {
        int readyOps = k.readyOps();
        
        // å¤„ç†è¿æ¥äº‹ä»¶
        if ((readyOps & SelectionKey.OP_CONNECT) != 0) {
            int ops = k.interestOps();
            ops &= ~SelectionKey.OP_CONNECT;
            k.interestOps(ops);
            unsafe.finishConnect();
        }
        
        // å¤„ç†å†™äº‹ä»¶
        if ((readyOps & SelectionKey.OP_WRITE) != 0) {
            ch.unsafe().forceFlush();
        }
        
        // å¤„ç†è¯»äº‹ä»¶ï¼ˆåŒ…æ‹¬Acceptï¼‰
        if ((readyOps & (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) != 0 || readyOps == 0) {
            unsafe.read();
        }
    } catch (CancelledKeyException ignored) {
        unsafe.close(unsafe.voidPromise());
    }
}

// NioMessageUnsafe.read() - å¤„ç†Accept
@Override
public void read() {
    final ChannelConfig config = config();
    final ChannelPipeline pipeline = pipeline();
    final RecvByteBufAllocator.Handle allocHandle = unsafe().recvBufAllocHandle();
    allocHandle.reset(config);
    
    boolean closed = false;
    Throwable exception = null;
    try {
        do {
            // æ¥æ”¶æ–°è¿æ¥
            int localRead = doReadMessages(readBuf);
            if (localRead == 0) {
                break;
            }
            if (localRead < 0) {
                closed = true;
                break;
            }
            allocHandle.incMessagesRead(localRead);
        } while (allocHandle.continueReading());
    } catch (Throwable t) {
        exception = t;
    }
    
    int size = readBuf.size();
    for (int i = 0; i < size; i++) {
        readPending = false;
        // è§¦å‘channelReadäº‹ä»¶ï¼Œä¼ é€’æ–°è¿æ¥
        pipeline.fireChannelRead(readBuf.get(i));
    }
    readBuf.clear();
    allocHandle.readComplete();
    pipeline.fireChannelReadComplete();
}
```

### 5.2 ServerBootstrapAcceptor

```java
// ServerBootstrapAcceptorå¤„ç†æ–°è¿æ¥
private static class ServerBootstrapAcceptor extends ChannelInboundHandlerAdapter {
    
    private final EventLoopGroup childGroup;
    private final ChannelHandler childHandler;
    private final Entry<ChannelOption<?>, Object>[] childOptions;
    private final Entry<AttributeKey<?>, Object>[] childAttrs;
    
    @Override
    public void channelRead(ChannelHandlerContext ctx, Object msg) {
        // msgæ˜¯æ–°å»ºç«‹çš„å®¢æˆ·ç«¯Channel
        final Channel child = (Channel) msg;
        
        // 1. æ·»åŠ childHandler
        child.pipeline().addLast(childHandler);
        
        // 2. è®¾ç½®é€‰é¡¹
        setChannelOptions(child, childOptions, logger);
        
        // 3. è®¾ç½®å±æ€§
        setAttributes(child, childAttrs);
        
        try {
            // 4. æ³¨å†Œåˆ°Worker EventLoopGroup
            childGroup.register(child).addListener(new ChannelFutureListener() {
                @Override
                public void operationComplete(ChannelFuture future) {
                    if (!future.isSuccess()) {
                        forceClose(child, future.cause());
                    }
                }
            });
        } catch (Throwable t) {
            forceClose(child, t);
        }
    }
}
```

---

## 6. é¢è¯•è¦ç‚¹

### 6.1 é«˜é¢‘é—®é¢˜

**Q1: Nettyçš„çº¿ç¨‹æ¨¡å‹æ˜¯æ€æ ·çš„ï¼Ÿ**
```
Nettyé‡‡ç”¨ä¸»ä»Reactorå¤šçº¿ç¨‹æ¨¡å‹ï¼š

1. Boss EventLoopGroup
   - è´Ÿè´£æ¥æ”¶å®¢æˆ·ç«¯è¿æ¥
   - é€šå¸¸é…ç½®1ä¸ªçº¿ç¨‹
   - å°†æ–°è¿æ¥æ³¨å†Œåˆ°Worker

2. Worker EventLoopGroup
   - è´Ÿè´£å¤„ç†IOè¯»å†™
   - é»˜è®¤CPUæ ¸å¿ƒæ•°*2ä¸ªçº¿ç¨‹
   - æ¯ä¸ªEventLoopç»‘å®šå¤šä¸ªChannel

3. ä¸€ä¸ªChannelåªä¼šç»‘å®šä¸€ä¸ªEventLoop
   - ä¿è¯çº¿ç¨‹å®‰å…¨
   - é¿å…å¹¶å‘é—®é¢˜
```

**Q2: Nettyå¦‚ä½•å®ç°é«˜æ€§èƒ½ï¼Ÿ**
```
1. ä¸»ä»Reactorçº¿ç¨‹æ¨¡å‹
   - èŒè´£åˆ†ç¦»ï¼Œå……åˆ†åˆ©ç”¨å¤šæ ¸

2. é›¶æ‹·è´
   - CompositeByteBufç»„åˆç¼“å†²åŒº
   - FileRegionæ–‡ä»¶ä¼ è¾“
   - å †å¤–å†…å­˜å‡å°‘æ‹·è´

3. å†…å­˜æ± 
   - PooledByteBufAllocator
   - å‡å°‘GCå‹åŠ›

4. é«˜æ•ˆçš„åºåˆ—åŒ–
   - æ”¯æŒProtobufç­‰é«˜æ•ˆåºåˆ—åŒ–

5. æ— é”åŒ–è®¾è®¡
   - å•çº¿ç¨‹å¤„ç†Channel
   - é¿å…é”ç«äº‰
```

**Q3: NioEventLoopçš„å·¥ä½œæµç¨‹ï¼Ÿ**
```
1. select()ï¼šè½®è¯¢IOäº‹ä»¶
2. processSelectedKeys()ï¼šå¤„ç†IOäº‹ä»¶
3. runAllTasks()ï¼šæ‰§è¡Œä»»åŠ¡é˜Ÿåˆ—

å¾ªç¯æ‰§è¡Œä»¥ä¸Šä¸‰ä¸ªæ­¥éª¤
```

**Q4: Nettyå¦‚ä½•è§£å†³JDK NIOçš„ç©ºè½®è¯¢Bugï¼Ÿ**
```
1. è®°å½•selectç©ºè½®è¯¢æ¬¡æ•°
2. è¶…è¿‡é˜ˆå€¼ï¼ˆé»˜è®¤512æ¬¡ï¼‰
3. é‡å»ºSelector
4. å°†åŸChannelé‡æ–°æ³¨å†Œ

// NioEventLoop.select()
if (SELECTOR_AUTO_REBUILD_THRESHOLD > 0 &&
    selectCnt >= SELECTOR_AUTO_REBUILD_THRESHOLD) {
    rebuildSelector();
    selectCnt = 0;
}
```

### 6.2 æ ¸å¿ƒç±»æ€»ç»“

```
å¯åŠ¨ç›¸å…³ï¼š
- ServerBootstrapï¼šæœåŠ¡ç«¯å¯åŠ¨å¼•å¯¼
- Bootstrapï¼šå®¢æˆ·ç«¯å¯åŠ¨å¼•å¯¼
- ChannelInitializerï¼šChannelåˆå§‹åŒ–å™¨

Channelç›¸å…³ï¼š
- NioServerSocketChannelï¼šNIOæœåŠ¡ç«¯Channel
- NioSocketChannelï¼šNIOå®¢æˆ·ç«¯Channel
- ChannelPipelineï¼šHandlerç®¡é“
- ChannelHandlerContextï¼šHandlerä¸Šä¸‹æ–‡

EventLoopç›¸å…³ï¼š
- NioEventLoopGroupï¼šNIOäº‹ä»¶å¾ªç¯ç»„
- NioEventLoopï¼šNIOäº‹ä»¶å¾ªç¯
- DefaultEventExecutorGroupï¼šé»˜è®¤æ‰§è¡Œå™¨ç»„

å†…å­˜ç›¸å…³ï¼š
- ByteBufï¼šå­—èŠ‚ç¼“å†²åŒº
- PooledByteBufAllocatorï¼šæ± åŒ–åˆ†é…å™¨
- UnpooledByteBufAllocatorï¼šéæ± åŒ–åˆ†é…å™¨
```

---

**æ·±å…¥ç†è§£Nettyæ¶æ„ï¼ŒæŒæ¡é«˜æ€§èƒ½ç½‘ç»œç¼–ç¨‹ï¼** ğŸš€

*æœ€åæ›´æ–°ï¼š2025-12-28*

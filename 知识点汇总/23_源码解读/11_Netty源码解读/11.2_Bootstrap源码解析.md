# Bootstrapæºç è§£æ

> ğŸ’¡ æ·±å…¥ç†è§£Nettyå¯åŠ¨å™¨çš„è®¾è®¡åŸç†å’Œå®ç°æœºåˆ¶

---

## ğŸ“š ç›®å½•

1. [Bootstrapæ¦‚è¿°](#1-bootstrapæ¦‚è¿°)
2. [ServerBootstrapæºç è§£æ](#2-serverbootstrapæºç è§£æ)
3. [Bootstrapæºç è§£æ](#3-bootstrapæºç è§£æ)
4. [å¯åŠ¨æµç¨‹åˆ†æ](#4-å¯åŠ¨æµç¨‹åˆ†æ)
5. [é…ç½®å‚æ•°è¯¦è§£](#5-é…ç½®å‚æ•°è¯¦è§£)
6. [æœ€ä½³å®è·µ](#6-æœ€ä½³å®è·µ)
7. [é¢è¯•è¦ç‚¹](#7-é¢è¯•è¦ç‚¹)

---

## 1. Bootstrapæ¦‚è¿°

### 1.1 Bootstrapä½“ç³»ç»“æ„

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  Netty Bootstrapä½“ç³»                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                             â”‚
â”‚  AbstractBootstrap (æŠ½è±¡å¯åŠ¨å™¨)                             â”‚
â”‚  â”œâ”€â”€ é€šç”¨é…ç½®å’Œå¯åŠ¨é€»è¾‘                                     â”‚
â”‚  â”œâ”€â”€ EventLoopGroupç®¡ç†                                     â”‚
â”‚  â””â”€â”€ ChannelFactoryé…ç½®                                     â”‚
â”‚      â”‚                                                     â”‚
â”‚      â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                 â”‚
â”‚      â–¼                 â–¼                 â–¼                 â”‚
â”‚  ServerBootstrap   Bootstrap        å…¶ä»–æ‰©å±•               â”‚
â”‚  (æœåŠ¡ç«¯å¯åŠ¨å™¨)    (å®¢æˆ·ç«¯å¯åŠ¨å™¨)                           â”‚
â”‚  â”œâ”€â”€ çˆ¶å­EventLoop  â”œâ”€â”€ å•ä¸€EventLoop                      â”‚
â”‚  â”œâ”€â”€ ServerChannel  â”œâ”€â”€ å®¢æˆ·ç«¯Channel                      â”‚
â”‚  â””â”€â”€ ç»‘å®šç«¯å£       â””â”€â”€ è¿æ¥æœåŠ¡å™¨                         â”‚
â”‚                                                             â”‚
â”‚  ä½¿ç”¨åœºæ™¯ï¼š                                                  â”‚
â”‚  ServerBootstrap: TCPæœåŠ¡å™¨ã€HTTPæœåŠ¡å™¨ã€WebSocketæœåŠ¡å™¨    â”‚
â”‚  Bootstrap: TCPå®¢æˆ·ç«¯ã€HTTPå®¢æˆ·ç«¯ã€ä»£ç†å®¢æˆ·ç«¯               â”‚
â”‚                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 1.2 æ ¸å¿ƒè®¾è®¡ç†å¿µ

```java
/**
 * Bootstrapè®¾è®¡ç†å¿µ
 */
public class BootstrapDesignPrinciples {
    
    /**
     * ğŸ”¥ å»ºé€ è€…æ¨¡å¼
     * - é“¾å¼è°ƒç”¨é…ç½®
     * - å‚æ•°æ ¡éªŒ
     * - å»¶è¿Ÿåˆå§‹åŒ–
     */
    public void builderPattern() {
        ServerBootstrap bootstrap = new ServerBootstrap()
            .group(bossGroup, workerGroup)
            .channel(NioServerSocketChannel.class)
            .option(ChannelOption.SO_BACKLOG, 128)
            .childOption(ChannelOption.SO_KEEPALIVE, true)
            .childHandler(new ChannelInitializer<SocketChannel>() {
                @Override
                protected void initChannel(SocketChannel ch) {
                    // é…ç½®pipeline
                }
            });
    }
    
    /**
     * ğŸ”¥ æ¨¡æ¿æ–¹æ³•æ¨¡å¼
     * - AbstractBootstrapå®šä¹‰éª¨æ¶
     * - å­ç±»å®ç°å…·ä½“é€»è¾‘
     * - æ‰©å±•ç‚¹æ¸…æ™°
     */
    public abstract class AbstractBootstrap<B extends AbstractBootstrap<B, C>, C extends Channel> {
        // æ¨¡æ¿æ–¹æ³•
        public ChannelFuture bind(int inetPort) {
            return bind(new InetSocketAddress(inetPort));
        }
        
        // æŠ½è±¡æ–¹æ³•ï¼Œå­ç±»å®ç°
        abstract void init(Channel channel) throws Exception;
    }
    
    /**
     * ğŸ”¥ å·¥å‚æ¨¡å¼
     * - ChannelFactoryåˆ›å»ºChannel
     * - EventLoopGroupå·¥å‚
     * - è§£è€¦åˆ›å»ºé€»è¾‘
     */
    public interface ChannelFactory<T extends Channel> {
        T newChannel();
    }
}
```

---

## 2. ServerBootstrapæºç è§£æ

### 2.1 ServerBootstrapç±»ç»“æ„

```java
/**
 * ServerBootstrap - æœåŠ¡ç«¯å¯åŠ¨å™¨
 * ç”¨äºå¯åŠ¨NettyæœåŠ¡å™¨
 */
public class ServerBootstrap extends AbstractBootstrap<ServerBootstrap, ServerChannel> {
    
    private static final InternalLogger logger = InternalLoggerFactory.getInstance(ServerBootstrap.class);
    
    // ğŸ”¥ å­EventLoopGroupé…ç½®
    private volatile EventLoopGroup childGroup;
    private volatile ChannelHandler childHandler;
    private final Map<ChannelOption<?>, Object> childOptions = new LinkedHashMap<ChannelOption<?>, Object>();
    private final Map<AttributeKey<?>, Object> childAttrs = new LinkedHashMap<AttributeKey<?>, Object>();
    private final ServerBootstrapConfig config = new ServerBootstrapConfig(this);
    
    /**
     * ğŸ”¥ æ„é€ å‡½æ•°
     */
    public ServerBootstrap() { }
    
    private ServerBootstrap(ServerBootstrap bootstrap) {
        super(bootstrap);
        childGroup = bootstrap.childGroup;
        childHandler = bootstrap.childHandler;
        synchronized (bootstrap.childOptions) {
            childOptions.putAll(bootstrap.childOptions);
        }
        synchronized (bootstrap.childAttrs) {
            childAttrs.putAll(bootstrap.childAttrs);
        }
    }
    
    /**
     * ğŸ”¥ è®¾ç½®EventLoopGroup
     * @param parentGroup çˆ¶EventLoopGroupï¼ˆå¤„ç†è¿æ¥ï¼‰
     * @param childGroup å­EventLoopGroupï¼ˆå¤„ç†I/Oï¼‰
     */
    public ServerBootstrap group(EventLoopGroup parentGroup, EventLoopGroup childGroup) {
        super.group(parentGroup);
        if (childGroup == null) {
            throw new NullPointerException("childGroup");
        }
        if (this.childGroup != null) {
            throw new IllegalStateException("childGroup set already");
        }
        this.childGroup = childGroup;
        return this;
    }
    
    /**
     * ğŸ”¥ è®¾ç½®å­Channelé€‰é¡¹
     */
    public <T> ServerBootstrap childOption(ChannelOption<T> childOption, T value) {
        if (childOption == null) {
            throw new NullPointerException("childOption");
        }
        if (value == null) {
            synchronized (childOptions) {
                childOptions.remove(childOption);
            }
        } else {
            synchronized (childOptions) {
                childOptions.put(childOption, value);
            }
        }
        return this;
    }
    
    /**
     * ğŸ”¥ è®¾ç½®å­Channelå±æ€§
     */
    public <T> ServerBootstrap childAttr(AttributeKey<T> childKey, T value) {
        if (childKey == null) {
            throw new NullPointerException("childKey");
        }
        if (value == null) {
            childAttrs.remove(childKey);
        } else {
            childAttrs.put(childKey, value);
        }
        return this;
    }
    
    /**
     * ğŸ”¥ è®¾ç½®å­Channelå¤„ç†å™¨
     */
    public ServerBootstrap childHandler(ChannelHandler childHandler) {
        if (childHandler == null) {
            throw new NullPointerException("childHandler");
        }
        this.childHandler = childHandler;
        return this;
    }
    
    /**
     * ğŸ”¥ åˆå§‹åŒ–Channel - æ ¸å¿ƒæ–¹æ³•
     */
    @Override
    void init(Channel channel) throws Exception {
        // ğŸ”¥ è®¾ç½®Channelé€‰é¡¹
        final Map<ChannelOption<?>, Object> options = options0();
        synchronized (options) {
            setChannelOptions(channel, options, logger);
        }
        
        // ğŸ”¥ è®¾ç½®Channelå±æ€§
        final Map<AttributeKey<?>, Object> attrs = attrs0();
        synchronized (attrs) {
            for (Entry<AttributeKey<?>, Object> e: attrs.entrySet()) {
                @SuppressWarnings("unchecked")
                AttributeKey<Object> key = (AttributeKey<Object>) e.getKey();
                channel.attr(key).set(e.getValue());
            }
        }
        
        // ğŸ”¥ è·å–Pipeline
        ChannelPipeline p = channel.pipeline();
        
        // ğŸ”¥ è·å–å­é…ç½®
        final EventLoopGroup currentChildGroup = childGroup;
        final ChannelHandler currentChildHandler = childHandler;
        final Entry<ChannelOption<?>, Object>[] currentChildOptions;
        final Entry<AttributeKey<?>, Object>[] currentChildAttrs;
        
        synchronized (childOptions) {
            currentChildOptions = childOptions.entrySet().toArray(newOptionArray(0));
        }
        synchronized (childAttrs) {
            currentChildAttrs = childAttrs.entrySet().toArray(newAttrArray(0));
        }
        
        // ğŸ”¥ æ·»åŠ ServerBootstrapAcceptor
        p.addLast(new ChannelInitializer<Channel>() {
            @Override
            public void initChannel(final Channel ch) throws Exception {
                final ChannelPipeline pipeline = ch.pipeline();
                ChannelHandler handler = config.handler();
                if (handler != null) {
                    pipeline.addLast(handler);
                }
                
                // ğŸ”¥ æ·»åŠ è¿æ¥æ¥å—å™¨
                ch.eventLoop().execute(new Runnable() {
                    @Override
                    public void run() {
                        pipeline.addLast(new ServerBootstrapAcceptor(
                                ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));
                    }
                });
            }
        });
    }
    
    /**
     * ğŸ”¥ éªŒè¯é…ç½®
     */
    @Override
    public ServerBootstrap validate() {
        super.validate();
        if (childHandler == null) {
            throw new IllegalStateException("childHandler not set");
        }
        if (childGroup == null) {
            logger.warn("childGroup is not set. Using parentGroup instead.");
            childGroup = config.group();
        }
        return this;
    }
    
    /**
     * ğŸ”¥ å…‹éš†Bootstrap
     */
    @Override
    @SuppressWarnings("CloneDoesntCallSuperClone")
    public ServerBootstrap clone() {
        return new ServerBootstrap(this);
    }
    
    /**
     * ğŸ”¥ è·å–é…ç½®
     */
    public final ServerBootstrapConfig config() {
        return config;
    }
}
```

### 2.2 ServerBootstrapAcceptorå®ç°

```java
/**
 * ServerBootstrapAcceptor - è¿æ¥æ¥å—å™¨
 * å¤„ç†æ–°è¿æ¥çš„æ¥å…¥å’Œé…ç½®
 */
private static class ServerBootstrapAcceptor extends ChannelInboundHandlerAdapter {
    
    private final EventLoopGroup childGroup;
    private final ChannelHandler childHandler;
    private final Entry<ChannelOption<?>, Object>[] childOptions;
    private final Entry<AttributeKey<?>, Object>[] childAttrs;
    private final Runnable enableAutoReadTask;
    
    /**
     * ğŸ”¥ æ„é€ å‡½æ•°
     */
    ServerBootstrapAcceptor(
            final Channel channel, EventLoopGroup childGroup, ChannelHandler childHandler,
            Entry<ChannelOption<?>, Object>[] childOptions, Entry<AttributeKey<?>, Object>[] childAttrs) {
        this.childGroup = childGroup;
        this.childHandler = childHandler;
        this.childOptions = childOptions;
        this.childAttrs = childAttrs;
        
        // ğŸ”¥ å¯ç”¨è‡ªåŠ¨è¯»å–ä»»åŠ¡
        enableAutoReadTask = new Runnable() {
            @Override
            public void run() {
                channel.config().setAutoRead(true);
            }
        };
    }
    
    /**
     * ğŸ”¥ å¤„ç†æ–°è¿æ¥ - æ ¸å¿ƒæ–¹æ³•
     */
    @Override
    @SuppressWarnings("unchecked")
    public void channelRead(ChannelHandlerContext ctx, Object msg) {
        final Channel child = (Channel) msg;
        
        // ğŸ”¥ è®¾ç½®å­Channelå¤„ç†å™¨
        child.pipeline().addLast(childHandler);
        
        // ğŸ”¥ è®¾ç½®å­Channelé€‰é¡¹
        setChannelOptions(child, childOptions, logger);
        
        // ğŸ”¥ è®¾ç½®å­Channelå±æ€§
        for (Entry<AttributeKey<?>, Object> e: childAttrs) {
            child.attr((AttributeKey<Object>) e.getKey()).set(e.getValue());
        }
        
        try {
            // ğŸ”¥ å°†å­Channelæ³¨å†Œåˆ°å­EventLoopGroup
            childGroup.register(child).addListener(new ChannelFutureListener() {
                @Override
                public void operationComplete(ChannelFuture future) throws Exception {
                    if (!future.isSuccess()) {
                        forceClose(child, future.cause());
                    }
                }
            });
        } catch (Throwable t) {
            forceClose(child, t);
        }
    }
    
    /**
     * ğŸ”¥ å¼ºåˆ¶å…³é—­Channel
     */
    private static void forceClose(Channel child, Throwable t) {
        child.unsafe().closeForcibly();
        logger.warn("Failed to register an accepted channel: {}", child, t);
    }
    
    /**
     * ğŸ”¥ å¼‚å¸¸å¤„ç†
     */
    @Override
    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
        final ChannelConfig config = ctx.channel().config();
        if (config.isAutoRead()) {
            // ğŸ”¥ åœæ­¢æ¥å—æ–°è¿æ¥
            config.setAutoRead(false);
            ctx.channel().eventLoop().schedule(enableAutoReadTask, 1, TimeUnit.SECONDS);
        }
        // ğŸ”¥ ç»§ç»­ä¼ æ’­å¼‚å¸¸
        ctx.fireExceptionCaught(cause);
    }
}
```

---

## 3. Bootstrapæºç è§£æ

### 3.1 Bootstrapç±»ç»“æ„

```java
/**
 * Bootstrap - å®¢æˆ·ç«¯å¯åŠ¨å™¨
 * ç”¨äºå¯åŠ¨Nettyå®¢æˆ·ç«¯
 */
public class Bootstrap extends AbstractBootstrap<Bootstrap, Channel> {
    
    private static final InternalLogger logger = InternalLoggerFactory.getInstance(Bootstrap.class);
    
    // ğŸ”¥ è¿œç¨‹åœ°å€è§£æå™¨
    private volatile AddressResolverGroup<?> resolver = DefaultAddressResolverGroup.INSTANCE;
    private volatile SocketAddress remoteAddress;
    private final BootstrapConfig config = new BootstrapConfig(this);
    
    /**
     * ğŸ”¥ æ„é€ å‡½æ•°
     */
    public Bootstrap() { }
    
    private Bootstrap(Bootstrap bootstrap) {
        super(bootstrap);
        resolver = bootstrap.resolver;
        remoteAddress = bootstrap.remoteAddress;
    }
    
    /**
     * ğŸ”¥ è®¾ç½®åœ°å€è§£æå™¨
     */
    @SuppressWarnings("unchecked")
    public Bootstrap resolver(AddressResolverGroup<?> resolver) {
        if (resolver == null) {
            throw new NullPointerException("resolver");
        }
        this.resolver = resolver;
        return this;
    }
    
    /**
     * ğŸ”¥ è®¾ç½®è¿œç¨‹åœ°å€
     */
    public Bootstrap remoteAddress(SocketAddress remoteAddress) {
        this.remoteAddress = remoteAddress;
        return this;
    }
    
    public Bootstrap remoteAddress(String inetHost, int inetPort) {
        remoteAddress = InetSocketAddress.createUnresolved(inetHost, inetPort);
        return this;
    }
    
    public Bootstrap remoteAddress(InetAddress inetHost, int inetPort) {
        remoteAddress = new InetSocketAddress(inetHost, inetPort);
        return this;
    }
    
    /**
     * ğŸ”¥ è¿æ¥åˆ°è¿œç¨‹åœ°å€
     */
    public ChannelFuture connect() {
        validate();
        SocketAddress remoteAddress = this.remoteAddress;
        if (remoteAddress == null) {
            throw new IllegalStateException("remoteAddress not set");
        }
        
        return doResolveAndConnect(remoteAddress, config.localAddress());
    }
    
    public ChannelFuture connect(String inetHost, int inetPort) {
        return connect(InetSocketAddress.createUnresolved(inetHost, inetPort));
    }
    
    public ChannelFuture connect(InetAddress inetHost, int inetPort) {
        return connect(new InetSocketAddress(inetHost, inetPort));
    }
    
    public ChannelFuture connect(SocketAddress remoteAddress) {
        if (remoteAddress == null) {
            throw new NullPointerException("remoteAddress");
        }
        
        validate();
        return doResolveAndConnect(remoteAddress, config.localAddress());
    }
    
    public ChannelFuture connect(SocketAddress remoteAddress, SocketAddress localAddress) {
        if (remoteAddress == null) {
            throw new NullPointerException("remoteAddress");
        }
        validate();
        return doResolveAndConnect(remoteAddress, localAddress);
    }
    
    /**
     * ğŸ”¥ è§£æåœ°å€å¹¶è¿æ¥ - æ ¸å¿ƒæ–¹æ³•
     */
    private ChannelFuture doResolveAndConnect(final SocketAddress remoteAddress,
                                               final SocketAddress localAddress) {
        // ğŸ”¥ åˆå§‹åŒ–å¹¶æ³¨å†ŒChannel
        final ChannelFuture regFuture = initAndRegister();
        final Channel channel = regFuture.channel();
        
        if (regFuture.isDone()) {
            if (!regFuture.isSuccess()) {
                return regFuture;
            }
            return doResolveAndConnect0(channel, remoteAddress, localAddress, channel.newPromise());
        } else {
            // ğŸ”¥ æ³¨å†Œæœªå®Œæˆï¼Œæ·»åŠ ç›‘å¬å™¨
            final PendingRegistrationPromise promise = new PendingRegistrationPromise(channel);
            regFuture.addListener(new ChannelFutureListener() {
                @Override
                public void operationComplete(ChannelFuture future) throws Exception {
                    Throwable cause = future.cause();
                    if (cause != null) {
                        promise.setFailure(cause);
                    } else {
                        promise.registered();
                        doResolveAndConnect0(channel, remoteAddress, localAddress, promise);
                    }
                }
            });
            return promise;
        }
    }
    
    /**
     * ğŸ”¥ è§£æåœ°å€å¹¶è¿æ¥çš„å…·ä½“å®ç°
     */
    private ChannelFuture doResolveAndConnect0(final Channel channel, SocketAddress remoteAddress,
                                               final SocketAddress localAddress, final ChannelPromise promise) {
        
        try {
            final EventLoop eventLoop = channel.eventLoop();
            final AddressResolver<SocketAddress> resolver = this.resolver.getResolver(eventLoop);
            
            if (!resolver.isSupported(remoteAddress) || resolver.isResolved(remoteAddress)) {
                // ğŸ”¥ åœ°å€å·²è§£ææˆ–ä¸éœ€è¦è§£æï¼Œç›´æ¥è¿æ¥
                doConnect(remoteAddress, localAddress, promise);
                return promise;
            }
            
            // ğŸ”¥ è§£æåœ°å€
            final Future<SocketAddress> resolveFuture = resolver.resolve(remoteAddress);
            
            if (resolveFuture.isDone()) {
                final Throwable resolveFailureCause = resolveFuture.cause();
                
                if (resolveFailureCause != null) {
                    // ğŸ”¥ è§£æå¤±è´¥
                    channel.close();
                    promise.setFailure(resolveFailureCause);
                } else {
                    // ğŸ”¥ è§£ææˆåŠŸï¼Œæ‰§è¡Œè¿æ¥
                    doConnect(resolveFuture.getNow(), localAddress, promise);
                }
                return promise;
            }
            
            // ğŸ”¥ ç­‰å¾…è§£æå®Œæˆ
            resolveFuture.addListener(new FutureListener<SocketAddress>() {
                @Override
                public void operationComplete(Future<SocketAddress> future) throws Exception {
                    if (future.cause() != null) {
                        channel.close();
                        promise.setFailure(future.cause());
                    } else {
                        doConnect(future.getNow(), localAddress, promise);
                    }
                }
            });
        } catch (Throwable cause) {
            promise.tryFailure(cause);
        }
        
        return promise;
    }
    
    /**
     * ğŸ”¥ æ‰§è¡Œè¿æ¥
     */
    private static void doConnect(
            final SocketAddress remoteAddress, final SocketAddress localAddress, final ChannelPromise connectPromise) {
        
        final Channel channel = connectPromise.channel();
        channel.eventLoop().execute(new Runnable() {
            @Override
            public void run() {
                if (localAddress == null) {
                    channel.connect(remoteAddress, connectPromise);
                } else {
                    channel.connect(remoteAddress, localAddress, connectPromise);
                }
                connectPromise.addListener(ChannelFutureListener.CLOSE_ON_FAILURE);
            }
        });
    }
    
    /**
     * ğŸ”¥ åˆå§‹åŒ–Channel
     */
    @Override
    @SuppressWarnings("unchecked")
    void init(Channel channel) throws Exception {
        ChannelPipeline p = channel.pipeline();
        p.addLast(config.handler());
        
        final Map<ChannelOption<?>, Object> options = options0();
        synchronized (options) {
            setChannelOptions(channel, options, logger);
        }
        
        final Map<AttributeKey<?>, Object> attrs = attrs0();
        synchronized (attrs) {
            for (Entry<AttributeKey<?>, Object> e: attrs.entrySet()) {
                channel.attr((AttributeKey<Object>) e.getKey()).set(e.getValue());
            }
        }
    }
    
    /**
     * ğŸ”¥ éªŒè¯é…ç½®
     */
    @Override
    public Bootstrap validate() {
        super.validate();
        if (config.handler() == null) {
            throw new IllegalStateException("handler not set");
        }
        return this;
    }
    
    /**
     * ğŸ”¥ å…‹éš†Bootstrap
     */
    @Override
    @SuppressWarnings("CloneDoesntCallSuperClone")
    public Bootstrap clone() {
        return new Bootstrap(this);
    }
    
    /**
     * ğŸ”¥ å…‹éš†å¹¶è®¾ç½®EventLoopGroup
     */
    public Bootstrap clone(EventLoopGroup group) {
        Bootstrap bs = new Bootstrap(this);
        bs.group = group;
        return bs;
    }
    
    /**
     * ğŸ”¥ è·å–é…ç½®
     */
    public final BootstrapConfig config() {
        return config;
    }
}
```

---

## 4. å¯åŠ¨æµç¨‹åˆ†æ

### 4.1 æœåŠ¡ç«¯å¯åŠ¨æµç¨‹

```java
/**
 * æœåŠ¡ç«¯å¯åŠ¨æµç¨‹è¯¦è§£
 */
public class ServerStartupFlow {
    
    /**
     * ğŸ”¥ å®Œæ•´çš„æœåŠ¡ç«¯å¯åŠ¨æµç¨‹
     */
    public void serverStartupProcess() {
        
        // 1. åˆ›å»ºEventLoopGroup
        EventLoopGroup bossGroup = new NioEventLoopGroup(1);
        EventLoopGroup workerGroup = new NioEventLoopGroup();
        
        try {
            // 2. åˆ›å»ºServerBootstrap
            ServerBootstrap bootstrap = new ServerBootstrap();
            
            // 3. é…ç½®Bootstrap
            bootstrap.group(bossGroup, workerGroup)
                    .channel(NioServerSocketChannel.class)
                    .option(ChannelOption.SO_BACKLOG, 128)
                    .childOption(ChannelOption.SO_KEEPALIVE, true)
                    .childHandler(new ChannelInitializer<SocketChannel>() {
                        @Override
                        protected void initChannel(SocketChannel ch) {
                            ch.pipeline().addLast(new EchoServerHandler());
                        }
                    });
            
            // 4. ç»‘å®šç«¯å£å¹¶å¯åŠ¨æœåŠ¡å™¨
            ChannelFuture future = bootstrap.bind(8080).sync();
            
            // 5. ç­‰å¾…æœåŠ¡å™¨å…³é—­
            future.channel().closeFuture().sync();
            
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        } finally {
            // 6. ä¼˜é›…å…³é—­
            bossGroup.shutdownGracefully();
            workerGroup.shutdownGracefully();
        }
    }
    
    /**
     * ğŸ”¥ bind()æ–¹æ³•è°ƒç”¨é“¾
     */
    public void bindMethodChain() {
        /*
        ServerBootstrap.bind(port)
        â”œâ”€â”€ AbstractBootstrap.bind(SocketAddress)
        â”œâ”€â”€ AbstractBootstrap.doBind(SocketAddress)
        â”œâ”€â”€ AbstractBootstrap.initAndRegister()
        â”‚   â”œâ”€â”€ channelFactory.newChannel()          // åˆ›å»ºChannel
        â”‚   â”œâ”€â”€ init(channel)                        // åˆå§‹åŒ–Channel
        â”‚   â””â”€â”€ group().register(channel)            // æ³¨å†ŒChannel
        â”œâ”€â”€ doBind0(regFuture, channel, localAddress, promise)
        â””â”€â”€ channel.bind(localAddress, promise)      // ç»‘å®šåœ°å€
        */
    }
}
```

### 4.2 å®¢æˆ·ç«¯å¯åŠ¨æµç¨‹

```java
/**
 * å®¢æˆ·ç«¯å¯åŠ¨æµç¨‹è¯¦è§£
 */
public class ClientStartupFlow {
    
    /**
     * ğŸ”¥ å®Œæ•´çš„å®¢æˆ·ç«¯å¯åŠ¨æµç¨‹
     */
    public void clientStartupProcess() {
        
        EventLoopGroup group = new NioEventLoopGroup();
        
        try {
            // 1. åˆ›å»ºBootstrap
            Bootstrap bootstrap = new Bootstrap();
            
            // 2. é…ç½®Bootstrap
            bootstrap.group(group)
                    .channel(NioSocketChannel.class)
                    .option(ChannelOption.SO_KEEPALIVE, true)
                    .handler(new ChannelInitializer<SocketChannel>() {
                        @Override
                        protected void initChannel(SocketChannel ch) {
                            ch.pipeline().addLast(new EchoClientHandler());
                        }
                    });
            
            // 3. è¿æ¥æœåŠ¡å™¨
            ChannelFuture future = bootstrap.connect("localhost", 8080).sync();
            
            // 4. ç­‰å¾…è¿æ¥å…³é—­
            future.channel().closeFuture().sync();
            
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        } finally {
            // 5. ä¼˜é›…å…³é—­
            group.shutdownGracefully();
        }
    }
    
    /**
     * ğŸ”¥ connect()æ–¹æ³•è°ƒç”¨é“¾
     */
    public void connectMethodChain() {
        /*
        Bootstrap.connect(host, port)
        â”œâ”€â”€ Bootstrap.connect(SocketAddress)
        â”œâ”€â”€ Bootstrap.doResolveAndConnect(remoteAddress, localAddress)
        â”œâ”€â”€ AbstractBootstrap.initAndRegister()
        â”‚   â”œâ”€â”€ channelFactory.newChannel()          // åˆ›å»ºChannel
        â”‚   â”œâ”€â”€ init(channel)                        // åˆå§‹åŒ–Channel
        â”‚   â””â”€â”€ group().register(channel)            // æ³¨å†ŒChannel
        â”œâ”€â”€ doResolveAndConnect0(channel, remoteAddress, localAddress, promise)
        â”œâ”€â”€ resolver.resolve(remoteAddress)          // è§£æåœ°å€
        â””â”€â”€ doConnect(resolvedAddress, localAddress, promise)  // æ‰§è¡Œè¿æ¥
        */
    }
}
```

### 4.3 åˆå§‹åŒ–å’Œæ³¨å†Œæµç¨‹

```java
/**
 * AbstractBootstrapåˆå§‹åŒ–å’Œæ³¨å†Œæµç¨‹
 */
public abstract class AbstractBootstrap<B extends AbstractBootstrap<B, C>, C extends Channel> {
    
    /**
     * ğŸ”¥ åˆå§‹åŒ–å¹¶æ³¨å†ŒChannel
     */
    final ChannelFuture initAndRegister() {
        Channel channel = null;
        try {
            // ğŸ”¥ 1. åˆ›å»ºChannel
            channel = channelFactory.newChannel();
            
            // ğŸ”¥ 2. åˆå§‹åŒ–Channel
            init(channel);
        } catch (Throwable t) {
            if (channel != null) {
                channel.unsafe().closeForcibly();
                return new DefaultChannelPromise(channel, GlobalEventExecutor.INSTANCE).setFailure(t);
            }
            return new DefaultChannelPromise(new FailedChannel(), GlobalEventExecutor.INSTANCE).setFailure(t);
        }
        
        // ğŸ”¥ 3. æ³¨å†ŒChannelåˆ°EventLoop
        ChannelFuture regFuture = config().group().register(channel);
        if (regFuture.cause() != null) {
            if (channel.isRegistered()) {
                channel.close();
            } else {
                channel.unsafe().closeForcibly();
            }
        }
        
        return regFuture;
    }
    
    /**
     * ğŸ”¥ ç»‘å®šåœ°å€
     */
    private ChannelFuture doBind(final SocketAddress localAddress) {
        final ChannelFuture regFuture = initAndRegister();
        final Channel channel = regFuture.channel();
        if (regFuture.cause() != null) {
            return regFuture;
        }
        
        if (regFuture.isDone()) {
            // ğŸ”¥ æ³¨å†Œå·²å®Œæˆ
            ChannelPromise promise = channel.newPromise();
            doBind0(regFuture, channel, localAddress, promise);
            return promise;
        } else {
            // ğŸ”¥ æ³¨å†Œæœªå®Œæˆï¼Œæ·»åŠ ç›‘å¬å™¨
            final PendingRegistrationPromise promise = new PendingRegistrationPromise(channel);
            regFuture.addListener(new ChannelFutureListener() {
                @Override
                public void operationComplete(ChannelFuture future) throws Exception {
                    Throwable cause = future.cause();
                    if (cause != null) {
                        promise.setFailure(cause);
                    } else {
                        promise.registered();
                        doBind0(regFuture, channel, localAddress, promise);
                    }
                }
            });
            return promise;
        }
    }
    
    /**
     * ğŸ”¥ æ‰§è¡Œç»‘å®š
     */
    private static void doBind0(
            final ChannelFuture regFuture, final Channel channel,
            final SocketAddress localAddress, final ChannelPromise promise) {
        
        channel.eventLoop().execute(new Runnable() {
            @Override
            public void run() {
                if (regFuture.isSuccess()) {
                    channel.bind(localAddress, promise).addListener(ChannelFutureListener.CLOSE_ON_FAILURE);
                } else {
                    promise.setFailure(regFuture.cause());
                }
            }
        });
    }
}
```

---

## 5. é…ç½®å‚æ•°è¯¦è§£

### 5.1 Channelé€‰é¡¹é…ç½®

```java
/**
 * Channelé€‰é¡¹é…ç½®è¯¦è§£
 */
public class ChannelOptionsConfiguration {
    
    /**
     * ğŸ”¥ æœåŠ¡ç«¯å¸¸ç”¨é€‰é¡¹
     */
    public void serverChannelOptions() {
        ServerBootstrap bootstrap = new ServerBootstrap();
        
        // ğŸ”¥ æœåŠ¡ç«¯Channelé€‰é¡¹
        bootstrap
            // TCPè¿æ¥é˜Ÿåˆ—å¤§å°
            .option(ChannelOption.SO_BACKLOG, 128)
            // åœ°å€é‡ç”¨
            .option(ChannelOption.SO_REUSEADDR, true)
            // æ¥æ”¶ç¼“å†²åŒºå¤§å°
            .option(ChannelOption.SO_RCVBUF, 32 * 1024)
            // å‘é€ç¼“å†²åŒºå¤§å°
            .option(ChannelOption.SO_SNDBUF, 32 * 1024)
            // æ˜¯å¦å¯ç”¨Nagleç®—æ³•
            .option(ChannelOption.TCP_NODELAY, true)
            // è¿æ¥è¶…æ—¶æ—¶é—´
            .option(ChannelOption.CONNECT_TIMEOUT_MILLIS, 30000);
        
        // ğŸ”¥ å­Channelé€‰é¡¹
        bootstrap
            // ä¿æŒè¿æ¥æ´»è·ƒ
            .childOption(ChannelOption.SO_KEEPALIVE, true)
            // ç¦ç”¨Nagleç®—æ³•
            .childOption(ChannelOption.TCP_NODELAY, true)
            // æ¥æ”¶ç¼“å†²åŒºå¤§å°
            .childOption(ChannelOption.SO_RCVBUF, 32 * 1024)
            // å‘é€ç¼“å†²åŒºå¤§å°
            .childOption(ChannelOption.SO_SNDBUF, 32 * 1024)
            // å†™ç¼“å†²åŒºé«˜æ°´ä½
            .childOption(ChannelOption.WRITE_BUFFER_HIGH_WATER_MARK, 64 * 1024)
            // å†™ç¼“å†²åŒºä½æ°´ä½
            .childOption(ChannelOption.WRITE_BUFFER_LOW_WATER_MARK, 32 * 1024);
    }
    
    /**
     * ğŸ”¥ å®¢æˆ·ç«¯å¸¸ç”¨é€‰é¡¹
     */
    public void clientChannelOptions() {
        Bootstrap bootstrap = new Bootstrap();
        
        bootstrap
            // ä¿æŒè¿æ¥æ´»è·ƒ
            .option(ChannelOption.SO_KEEPALIVE, true)
            // ç¦ç”¨Nagleç®—æ³•
            .option(ChannelOption.TCP_NODELAY, true)
            // è¿æ¥è¶…æ—¶æ—¶é—´
            .option(ChannelOption.CONNECT_TIMEOUT_MILLIS, 5000)
            // æ¥æ”¶ç¼“å†²åŒºå¤§å°
            .option(ChannelOption.SO_RCVBUF, 32 * 1024)
            // å‘é€ç¼“å†²åŒºå¤§å°
            .option(ChannelOption.SO_SNDBUF, 32 * 1024)
            // å†™ç¼“å†²åŒºé«˜æ°´ä½
            .option(ChannelOption.WRITE_BUFFER_HIGH_WATER_MARK, 64 * 1024)
            // å†™ç¼“å†²åŒºä½æ°´ä½
            .option(ChannelOption.WRITE_BUFFER_LOW_WATER_MARK, 32 * 1024);
    }
    
    /**
     * ğŸ”¥ é€‰é¡¹è¯´æ˜
     */
    public class ChannelOptionExplanation {
        
        // SO_BACKLOG: TCPè¿æ¥é˜Ÿåˆ—å¤§å°ï¼Œå½±å“å¹¶å‘è¿æ¥æ•°
        // SO_REUSEADDR: å…è®¸åœ°å€é‡ç”¨ï¼Œé¿å…TIME_WAITçŠ¶æ€å½±å“
        // SO_KEEPALIVE: å¯ç”¨TCPä¿æ´»æœºåˆ¶ï¼Œæ£€æµ‹æ­»è¿æ¥
        // TCP_NODELAY: ç¦ç”¨Nagleç®—æ³•ï¼Œå‡å°‘å»¶è¿Ÿ
        // SO_RCVBUF/SO_SNDBUF: å¥—æ¥å­—ç¼“å†²åŒºå¤§å°
        // CONNECT_TIMEOUT_MILLIS: è¿æ¥è¶…æ—¶æ—¶é—´
        // WRITE_BUFFER_HIGH/LOW_WATER_MARK: å†™ç¼“å†²åŒºæ°´ä½æ§åˆ¶
    }
}
```

### 5.2 EventLoopGroupé…ç½®

```java
/**
 * EventLoopGroupé…ç½®è¯¦è§£
 */
public class EventLoopGroupConfiguration {
    
    /**
     * ğŸ”¥ æœåŠ¡ç«¯EventLoopGroupé…ç½®
     */
    public void serverEventLoopGroupConfig() {
        
        // ğŸ”¥ æ–¹å¼1ï¼šé»˜è®¤çº¿ç¨‹æ•°
        EventLoopGroup bossGroup = new NioEventLoopGroup(); // é»˜è®¤çº¿ç¨‹æ•° = CPUæ ¸å¿ƒæ•° * 2
        EventLoopGroup workerGroup = new NioEventLoopGroup();
        
        // ğŸ”¥ æ–¹å¼2ï¼šæŒ‡å®šçº¿ç¨‹æ•°
        EventLoopGroup bossGroup2 = new NioEventLoopGroup(1); // Bossé€šå¸¸1ä¸ªçº¿ç¨‹è¶³å¤Ÿ
        EventLoopGroup workerGroup2 = new NioEventLoopGroup(8); // Workeræ ¹æ®ä¸šåŠ¡è°ƒæ•´
        
        // ğŸ”¥ æ–¹å¼3ï¼šè‡ªå®šä¹‰çº¿ç¨‹å·¥å‚
        ThreadFactory threadFactory = new DefaultThreadFactory("netty-server");
        EventLoopGroup bossGroup3 = new NioEventLoopGroup(1, threadFactory);
        EventLoopGroup workerGroup3 = new NioEventLoopGroup(8, threadFactory);
        
        // ğŸ”¥ æ–¹å¼4ï¼šæŒ‡å®šæ‰§è¡Œå™¨
        Executor executor = Executors.newCachedThreadPool();
        EventLoopGroup bossGroup4 = new NioEventLoopGroup(1, executor);
        EventLoopGroup workerGroup4 = new NioEventLoopGroup(8, executor);
    }
    
    /**
     * ğŸ”¥ å®¢æˆ·ç«¯EventLoopGroupé…ç½®
     */
    public void clientEventLoopGroupConfig() {
        
        // ğŸ”¥ å®¢æˆ·ç«¯é€šå¸¸åªéœ€è¦ä¸€ä¸ªEventLoopGroup
        EventLoopGroup group = new NioEventLoopGroup();
        
        // ğŸ”¥ æŒ‡å®šçº¿ç¨‹æ•°ï¼ˆæ ¹æ®è¿æ¥æ•°è°ƒæ•´ï¼‰
        EventLoopGroup group2 = new NioEventLoopGroup(4);
        
        // ğŸ”¥ è‡ªå®šä¹‰çº¿ç¨‹å·¥å‚
        ThreadFactory threadFactory = new DefaultThreadFactory("netty-client");
        EventLoopGroup group3 = new NioEventLoopGroup(4, threadFactory);
    }
    
    /**
     * ğŸ”¥ EventLoopGroupé€‰æ‹©ç­–ç•¥
     */
    public class EventLoopGroupStrategy {
        
        /**
         * Boss Groupçº¿ç¨‹æ•°é€‰æ‹©
         * - é€šå¸¸1ä¸ªçº¿ç¨‹è¶³å¤Ÿ
         * - å¤šä¸ªç«¯å£æ—¶å¯ä»¥å¢åŠ çº¿ç¨‹æ•°
         * - ä¸å»ºè®®è¶…è¿‡CPUæ ¸å¿ƒæ•°
         */
        public int chooseBossThreads(int portCount) {
            return Math.min(portCount, Runtime.getRuntime().availableProcessors());
        }
        
        /**
         * Worker Groupçº¿ç¨‹æ•°é€‰æ‹©
         * - CPUå¯†é›†å‹ï¼šCPUæ ¸å¿ƒæ•°
         * - I/Oå¯†é›†å‹ï¼šCPUæ ¸å¿ƒæ•° * 2
         * - æ··åˆå‹ï¼šæ ¹æ®å®é™…æµ‹è¯•è°ƒæ•´
         */
        public int chooseWorkerThreads(String workloadType) {
            int cpuCores = Runtime.getRuntime().availableProcessors();
            switch (workloadType) {
                case "CPU_INTENSIVE":
                    return cpuCores;
                case "IO_INTENSIVE":
                    return cpuCores * 2;
                case "MIXED":
                default:
                    return cpuCores * 2;
            }
        }
    }
}
```

---

## 6. æœ€ä½³å®è·µ

### 6.1 æœåŠ¡ç«¯æœ€ä½³å®è·µ

```java
/**
 * æœåŠ¡ç«¯Bootstrapæœ€ä½³å®è·µ
 */
public class ServerBootstrapBestPractices {
    
    /**
     * ğŸ”¥ ç”Ÿäº§çº§æœåŠ¡ç«¯é…ç½®
     */
    public ServerBootstrap createProductionServer() {
        
        // ğŸ”¥ 1. åˆ›å»ºEventLoopGroup
        EventLoopGroup bossGroup = new NioEventLoopGroup(1, 
            new DefaultThreadFactory("boss", true));
        EventLoopGroup workerGroup = new NioEventLoopGroup(
            Runtime.getRuntime().availableProcessors() * 2,
            new DefaultThreadFactory("worker", true));
        
        // ğŸ”¥ 2. é…ç½®Bootstrap
        ServerBootstrap bootstrap = new ServerBootstrap()
            .group(bossGroup, workerGroup)
            .channel(NioServerSocketChannel.class)
            
            // ğŸ”¥ æœåŠ¡ç«¯é€‰é¡¹
            .option(ChannelOption.SO_BACKLOG, 1024)
            .option(ChannelOption.SO_REUSEADDR, true)
            .option(ChannelOption.SO_RCVBUF, 64 * 1024)
            .option(ChannelOption.SO_SNDBUF, 64 * 1024)
            
            // ğŸ”¥ å­Channelé€‰é¡¹
            .childOption(ChannelOption.SO_KEEPALIVE, true)
            .childOption(ChannelOption.TCP_NODELAY, true)
            .childOption(ChannelOption.SO_RCVBUF, 64 * 1024)
            .childOption(ChannelOption.SO_SNDBUF, 64 * 1024)
            .childOption(ChannelOption.WRITE_BUFFER_WATER_MARK, 
                new WriteBufferWaterMark(32 * 1024, 64 * 1024))
            
            // ğŸ”¥ å¤„ç†å™¨é…ç½®
            .handler(new LoggingHandler(LogLevel.INFO))
            .childHandler(new ChannelInitializer<SocketChannel>() {
                @Override
                protected void initChannel(SocketChannel ch) {
                    ChannelPipeline pipeline = ch.pipeline();
                    
                    // ç©ºé—²æ£€æµ‹
                    pipeline.addLast(new IdleStateHandler(60, 30, 0));
                    
                    // ç¼–è§£ç å™¨
                    pipeline.addLast(new LengthFieldBasedFrameDecoder(1024 * 1024, 0, 4, 0, 4));
                    pipeline.addLast(new LengthFieldPrepender(4));
                    
                    // ä¸šåŠ¡å¤„ç†å™¨
                    pipeline.addLast(new ServerHandler());
                }
            });
        
        return bootstrap;
    }
    
    /**
     * ğŸ”¥ ä¼˜é›…å¯åŠ¨å’Œå…³é—­
     */
    public class GracefulServerLifecycle {
        
        private ServerBootstrap bootstrap;
        private EventLoopGroup bossGroup;
        private EventLoopGroup workerGroup;
        private Channel serverChannel;
        
        public void start(int port) throws InterruptedException {
            bootstrap = createProductionServer();
            
            try {
                // ğŸ”¥ ç»‘å®šç«¯å£å¹¶å¯åŠ¨
                ChannelFuture future = bootstrap.bind(port).sync();
                serverChannel = future.channel();
                
                logger.info("Server started on port {}", port);
                
                // ğŸ”¥ æ³¨å†Œå…³é—­é’©å­
                Runtime.getRuntime().addShutdownHook(new Thread(this::shutdown));
                
                // ğŸ”¥ ç­‰å¾…æœåŠ¡å™¨å…³é—­
                serverChannel.closeFuture().sync();
                
            } finally {
                shutdown();
            }
        }
        
        public void shutdown() {
            logger.info("Shutting down server...");
            
            try {
                // ğŸ”¥ å…³é—­æœåŠ¡å™¨Channel
                if (serverChannel != null) {
                    serverChannel.close().sync();
                }
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            } finally {
                // ğŸ”¥ ä¼˜é›…å…³é—­EventLoopGroup
                if (bossGroup != null) {
                    bossGroup.shutdownGracefully();
                }
                if (workerGroup != null) {
                    workerGroup.shutdownGracefully();
                }
            }
            
            logger.info("Server shutdown complete");
        }
    }
}
```

### 6.2 å®¢æˆ·ç«¯æœ€ä½³å®è·µ

```java
/**
 * å®¢æˆ·ç«¯Bootstrapæœ€ä½³å®è·µ
 */
public class ClientBootstrapBestPractices {
    
    /**
     * ğŸ”¥ ç”Ÿäº§çº§å®¢æˆ·ç«¯é…ç½®
     */
    public Bootstrap createProductionClient() {
        
        EventLoopGroup group = new NioEventLoopGroup(4,
            new DefaultThreadFactory("client", true));
        
        Bootstrap bootstrap = new Bootstrap()
            .group(group)
            .channel(NioSocketChannel.class)
            
            // ğŸ”¥ å®¢æˆ·ç«¯é€‰é¡¹
            .option(ChannelOption.SO_KEEPALIVE, true)
            .option(ChannelOption.TCP_NODELAY, true)
            .option(ChannelOption.CONNECT_TIMEOUT_MILLIS, 5000)
            .option(ChannelOption.SO_RCVBUF, 64 * 1024)
            .option(ChannelOption.SO_SNDBUF, 64 * 1024)
            .option(ChannelOption.WRITE_BUFFER_WATER_MARK,
                new WriteBufferWaterMark(32 * 1024, 64 * 1024))
            
            // ğŸ”¥ å¤„ç†å™¨é…ç½®
            .handler(new ChannelInitializer<SocketChannel>() {
                @Override
                protected void initChannel(SocketChannel ch) {
                    ChannelPipeline pipeline = ch.pipeline();
                    
                    // ç©ºé—²æ£€æµ‹
                    pipeline.addLast(new IdleStateHandler(0, 20, 0));
                    
                    // ç¼–è§£ç å™¨
                    pipeline.addLast(new LengthFieldBasedFrameDecoder(1024 * 1024, 0, 4, 0, 4));
                    pipeline.addLast(new LengthFieldPrepender(4));
                    
                    // ä¸šåŠ¡å¤„ç†å™¨
                    pipeline.addLast(new ClientHandler());
                }
            });
        
        return bootstrap;
    }
    
    /**
     * ğŸ”¥ è¿æ¥æ± å®ç°
     */
    public class ConnectionPool {
        
        private final Bootstrap bootstrap;
        private final Queue<Channel> availableChannels = new ConcurrentLinkedQueue<>();
        private final AtomicInteger totalConnections = new AtomicInteger(0);
        private final int maxConnections;
        private final String host;
        private final int port;
        
        public ConnectionPool(Bootstrap bootstrap, String host, int port, int maxConnections) {
            this.bootstrap = bootstrap;
            this.host = host;
            this.port = port;
            this.maxConnections = maxConnections;
        }
        
        /**
         * ğŸ”¥ è·å–è¿æ¥
         */
        public Channel acquire() throws InterruptedException {
            Channel channel = availableChannels.poll();
            
            if (channel != null && channel.isActive()) {
                return channel;
            }
            
            // ğŸ”¥ åˆ›å»ºæ–°è¿æ¥
            if (totalConnections.get() < maxConnections) {
                ChannelFuture future = bootstrap.connect(host, port).sync();
                if (future.isSuccess()) {
                    totalConnections.incrementAndGet();
                    return future.channel();
                }
            }
            
            throw new IllegalStateException("No available connections");
        }
        
        /**
         * ğŸ”¥ é‡Šæ”¾è¿æ¥
         */
        public void release(Channel channel) {
            if (channel != null && channel.isActive()) {
                availableChannels.offer(channel);
            } else {
                totalConnections.decrementAndGet();
            }
        }
        
        /**
         * ğŸ”¥ å…³é—­è¿æ¥æ± 
         */
        public void close() {
            Channel channel;
            while ((channel = availableChannels.poll()) != null) {
                channel.close();
            }
        }
    }
    
    /**
     * ğŸ”¥ é‡è¿æœºåˆ¶
     */
    public class ReconnectClient {
        
        private final Bootstrap bootstrap;
        private final String host;
        private final int port;
        private final int maxRetries;
        private final long retryDelay;
        
        private volatile Channel channel;
        private volatile boolean reconnecting = false;
        
        public ReconnectClient(Bootstrap bootstrap, String host, int port, 
                              int maxRetries, long retryDelay) {
            this.bootstrap = bootstrap;
            this.host = host;
            this.port = port;
            this.maxRetries = maxRetries;
            this.retryDelay = retryDelay;
        }
        
        /**
         * ğŸ”¥ è¿æ¥æœåŠ¡å™¨
         */
        public void connect() {
            doConnect(0);
        }
        
        private void doConnect(int retryCount) {
            if (retryCount > maxRetries) {
                logger.error("Max retry attempts reached, giving up");
                return;
            }
            
            bootstrap.connect(host, port).addListener(new ChannelFutureListener() {
                @Override
                public void operationComplete(ChannelFuture future) throws Exception {
                    if (future.isSuccess()) {
                        logger.info("Connected to {}:{}", host, port);
                        channel = future.channel();
                        reconnecting = false;
                        
                        // ğŸ”¥ ç›‘å¬è¿æ¥å…³é—­
                        channel.closeFuture().addListener(new ChannelFutureListener() {
                            @Override
                            public void operationComplete(ChannelFuture future) throws Exception {
                                logger.warn("Connection lost, attempting to reconnect...");
                                scheduleReconnect(0);
                            }
                        });
                    } else {
                        logger.warn("Connection attempt {} failed", retryCount + 1, future.cause());
                        scheduleReconnect(retryCount + 1);
                    }
                }
            });
        }
        
        private void scheduleReconnect(int retryCount) {
            if (!reconnecting) {
                reconnecting = true;
                bootstrap.config().group().schedule(() -> doConnect(retryCount), 
                    retryDelay, TimeUnit.MILLISECONDS);
            }
        }
    }
}
```

---

## 7. é¢è¯•è¦ç‚¹

### 7.1 æ ¸å¿ƒæ¦‚å¿µ

```
ğŸ¯ Bootstrapé¢è¯•è¦ç‚¹

1. Bootstrap vs ServerBootstrap
   Q: ä¸¤è€…æœ‰ä»€ä¹ˆåŒºåˆ«ï¼Ÿ
   A: 
   - ServerBootstrapï¼šæœåŠ¡ç«¯å¯åŠ¨å™¨ï¼Œæ”¯æŒçˆ¶å­EventLoopGroup
   - Bootstrapï¼šå®¢æˆ·ç«¯å¯åŠ¨å™¨ï¼Œåªæœ‰ä¸€ä¸ªEventLoopGroup
   - ServerBootstrapæœ‰childOption/childHandleré…ç½®

2. å¯åŠ¨æµç¨‹
   Q: NettyæœåŠ¡å™¨å¯åŠ¨æµç¨‹æ˜¯ä»€ä¹ˆï¼Ÿ
   A:
   - åˆ›å»ºServerBootstrap
   - é…ç½®EventLoopGroupã€Channelç±»å‹ã€é€‰é¡¹
   - è°ƒç”¨bind()ç»‘å®šç«¯å£
   - initAndRegister()åˆ›å»ºå¹¶æ³¨å†ŒChannel
   - æ·»åŠ ServerBootstrapAcceptorå¤„ç†æ–°è¿æ¥

3. EventLoopGroupé…ç½®
   Q: å¦‚ä½•é€‰æ‹©EventLoopGroupçº¿ç¨‹æ•°ï¼Ÿ
   A:
   - Boss Groupï¼šé€šå¸¸1ä¸ªçº¿ç¨‹ï¼Œå¤šç«¯å£æ—¶å¯å¢åŠ 
   - Worker Groupï¼šCPUå¯†é›†å‹=CPUæ ¸å¿ƒæ•°ï¼ŒI/Oå¯†é›†å‹=CPUæ ¸å¿ƒæ•°*2
   - æ ¹æ®å®é™…ä¸šåŠ¡æµ‹è¯•è°ƒä¼˜

4. Channelé€‰é¡¹
   Q: å¸¸ç”¨çš„ChannelOptionæœ‰å“ªäº›ï¼Ÿ
   A:
   - SO_BACKLOGï¼šè¿æ¥é˜Ÿåˆ—å¤§å°
   - SO_KEEPALIVEï¼šä¿æŒè¿æ¥æ´»è·ƒ
   - TCP_NODELAYï¼šç¦ç”¨Nagleç®—æ³•
   - CONNECT_TIMEOUT_MILLISï¼šè¿æ¥è¶…æ—¶
```

### 7.2 å®é™…åº”ç”¨

```
ğŸ”§ å®é™…åº”ç”¨åœºæ™¯

1. é«˜å¹¶å‘æœåŠ¡å™¨
   åœºæ™¯: éœ€è¦å¤„ç†å¤§é‡å¹¶å‘è¿æ¥
   æ–¹æ¡ˆ:
   - åˆç†é…ç½®EventLoopGroupçº¿ç¨‹æ•°
   - è°ƒä¼˜SO_BACKLOGå’Œç¼“å†²åŒºå¤§å°
   - ä½¿ç”¨è¿æ¥æ± ç®¡ç†å®¢æˆ·ç«¯è¿æ¥
   - å®ç°ä¼˜é›…å¯åŠ¨å’Œå…³é—­

2. å®¢æˆ·ç«¯è¿æ¥ç®¡ç†
   åœºæ™¯: å®¢æˆ·ç«¯éœ€è¦ç®¡ç†å¤šä¸ªè¿æ¥
   æ–¹æ¡ˆ:
   - å®ç°è¿æ¥æ± å¤ç”¨è¿æ¥
   - æ·»åŠ é‡è¿æœºåˆ¶å¤„ç†æ–­çº¿
   - é…ç½®åˆé€‚çš„è¶…æ—¶æ—¶é—´
   - ç›‘æ§è¿æ¥çŠ¶æ€

3. å¾®æœåŠ¡é€šä¿¡
   åœºæ™¯: æœåŠ¡é—´RPCé€šä¿¡
   æ–¹æ¡ˆ:
   - å®¢æˆ·ç«¯ä½¿ç”¨è¿æ¥æ± 
   - æœåŠ¡ç«¯é…ç½®åˆé€‚çš„çº¿ç¨‹æ•°
   - å®ç°è´Ÿè½½å‡è¡¡å’Œæ•…éšœè½¬ç§»
   - æ·»åŠ ç›‘æ§å’Œæ—¥å¿—

4. ç½‘å…³ä»£ç†
   åœºæ™¯: å®ç°HTTP/TCPä»£ç†
   æ–¹æ¡ˆ:
   - æœåŠ¡ç«¯æ¥æ”¶è¯·æ±‚
   - å®¢æˆ·ç«¯è½¬å‘åˆ°åç«¯
   - å®ç°è¿æ¥å¤ç”¨å’Œè´Ÿè½½å‡è¡¡
   - å¤„ç†å¼‚å¸¸å’Œè¶…æ—¶
```

### 7.3 å¸¸è§é—®é¢˜

```
â“ å¸¸è§é¢è¯•é—®é¢˜

Q1: ServerBootstrapçš„childHandlerå’Œhandleræœ‰ä»€ä¹ˆåŒºåˆ«ï¼Ÿ
A1: 
- handlerï¼šé…ç½®æœåŠ¡ç«¯Channelçš„å¤„ç†å™¨ï¼Œå¤„ç†è¿æ¥äº‹ä»¶
- childHandlerï¼šé…ç½®å®¢æˆ·ç«¯è¿æ¥Channelçš„å¤„ç†å™¨ï¼Œå¤„ç†ä¸šåŠ¡é€»è¾‘
- ServerBootstrapAcceptorä¼šå°†childHandleræ·»åŠ åˆ°æ–°è¿æ¥çš„Pipeline

Q2: ä¸ºä»€ä¹ˆéœ€è¦ä¸¤ä¸ªEventLoopGroupï¼Ÿ
A2:
- Boss Groupï¼šä¸“é—¨å¤„ç†è¿æ¥æ¥å…¥ï¼Œé¿å…é˜»å¡
- Worker Groupï¼šä¸“é—¨å¤„ç†I/Oè¯»å†™ï¼Œæé«˜å¹¶å‘æ€§èƒ½
- èŒè´£åˆ†ç¦»ï¼Œæé«˜ç³»ç»Ÿæ•´ä½“æ€§èƒ½

Q3: å¦‚ä½•å®ç°å®¢æˆ·ç«¯é‡è¿ï¼Ÿ
A3:
- ç›‘å¬è¿æ¥å…³é—­äº‹ä»¶
- ä½¿ç”¨å®šæ—¶ä»»åŠ¡å»¶è¿Ÿé‡è¿
- è®¾ç½®æœ€å¤§é‡è¯•æ¬¡æ•°
- æŒ‡æ•°é€€é¿ç­–ç•¥é¿å…é¢‘ç¹é‡è¿

Q4: Bootstrapé…ç½®é”™è¯¯ä¼šå¯¼è‡´ä»€ä¹ˆé—®é¢˜ï¼Ÿ
A4:
- çº¿ç¨‹æ•°è¿‡å°‘ï¼šæ€§èƒ½ç“¶é¢ˆï¼Œå“åº”æ…¢
- çº¿ç¨‹æ•°è¿‡å¤šï¼šä¸Šä¸‹æ–‡åˆ‡æ¢å¼€é”€å¤§
- ç¼“å†²åŒºè¿‡å°ï¼šé¢‘ç¹è¯»å†™ï¼Œæ€§èƒ½å·®
- è¶…æ—¶æ—¶é—´ä¸å½“ï¼šè¿æ¥å¼‚å¸¸æˆ–èµ„æºæµªè´¹

Q5: å¦‚ä½•ä¼˜åŒ–Bootstrapæ€§èƒ½ï¼Ÿ
A5:
- æ ¹æ®ä¸šåŠ¡ç‰¹ç‚¹è°ƒæ•´çº¿ç¨‹æ•°
- åˆç†è®¾ç½®ç¼“å†²åŒºå¤§å°
- å¯ç”¨TCP_NODELAYå‡å°‘å»¶è¿Ÿ
- ä½¿ç”¨å¯¹è±¡æ± å‡å°‘GCå‹åŠ›
```

### 7.4 æœ€ä½³å®è·µ

```
âœ… å¼€å‘æœ€ä½³å®è·µ

1. é…ç½®ç®¡ç†
   - å°†é…ç½®å‚æ•°å¤–éƒ¨åŒ–
   - æ ¹æ®ç¯å¢ƒè°ƒæ•´å‚æ•°
   - æä¾›é»˜è®¤é…ç½®å’Œè°ƒä¼˜å»ºè®®
   - æ”¯æŒåŠ¨æ€é…ç½®æ›´æ–°

2. èµ„æºç®¡ç†
   - æ­£ç¡®å…³é—­EventLoopGroup
   - å®ç°ä¼˜é›…å¯åŠ¨å’Œå…³é—­
   - ç›‘æ§èµ„æºä½¿ç”¨æƒ…å†µ
   - é¿å…èµ„æºæ³„æ¼

3. å¼‚å¸¸å¤„ç†
   - å¤„ç†å¯åŠ¨å¤±è´¥æƒ…å†µ
   - å®ç°é‡è¿æœºåˆ¶
   - è®°å½•è¯¦ç»†çš„é”™è¯¯æ—¥å¿—
   - æä¾›é™çº§æ–¹æ¡ˆ

4. ç›‘æ§å‘Šè­¦
   - ç›‘æ§è¿æ¥æ•°å’Œçº¿ç¨‹ä½¿ç”¨ç‡
   - è®¾ç½®æ€§èƒ½æŒ‡æ ‡å‘Šè­¦
   - è®°å½•å…³é”®æ“ä½œæ—¥å¿—
   - æä¾›å¥åº·æ£€æŸ¥æ¥å£
```

---

## ğŸ“‹ æ€»ç»“

Bootstrapæ˜¯Nettyçš„å¯åŠ¨å™¨ï¼Œæä¾›äº†ä¼˜é›…çš„APIæ¥é…ç½®å’Œå¯åŠ¨Nettyåº”ç”¨ã€‚é€šè¿‡å»ºé€ è€…æ¨¡å¼å’Œæ¨¡æ¿æ–¹æ³•æ¨¡å¼ï¼ŒBootstrapå°†å¤æ‚çš„ç½‘ç»œç¼–ç¨‹ç®€åŒ–ä¸ºé“¾å¼é…ç½®è°ƒç”¨ã€‚

**æ ¸å¿ƒè¦ç‚¹**ï¼š
- **è®¾è®¡æ¨¡å¼**ï¼šå»ºé€ è€…æ¨¡å¼æä¾›é“¾å¼é…ç½®ï¼Œæ¨¡æ¿æ–¹æ³•å®šä¹‰å¯åŠ¨æµç¨‹
- **èŒè´£åˆ†ç¦»**ï¼šServerBootstrapæ”¯æŒçˆ¶å­EventLoopGroupï¼Œå®ç°è¿æ¥å’ŒI/Oåˆ†ç¦»
- **é…ç½®çµæ´»**ï¼šä¸°å¯Œçš„ChannelOptionå’Œå±æ€§é…ç½®æ»¡è¶³ä¸åŒåœºæ™¯éœ€æ±‚
- **æœ€ä½³å®è·µ**ï¼šåˆç†çš„çº¿ç¨‹é…ç½®ã€èµ„æºç®¡ç†å’Œå¼‚å¸¸å¤„ç†æ˜¯å…³é”®

æŒæ¡Bootstrapçš„ä½¿ç”¨å’ŒåŸç†ï¼Œæ˜¯æ·±å…¥ç†è§£Nettyæ¶æ„å’Œè¿›è¡Œæ€§èƒ½è°ƒä¼˜çš„åŸºç¡€ã€‚
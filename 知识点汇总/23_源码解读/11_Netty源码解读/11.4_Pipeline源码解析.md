# Pipelineæºç è§£æ

> ğŸ’¡ æ·±å…¥ç†è§£Nettyè´£ä»»é“¾æ¨¡å¼çš„æ ¸å¿ƒå®ç°

---

## ğŸ“‹ ç›®å½•

- [1. Pipelineæ¦‚è¿°](#1-pipelineæ¦‚è¿°)
- [2. æ ¸å¿ƒç»“æ„](#2-æ ¸å¿ƒç»“æ„)
- [3. Handleræ·»åŠ æµç¨‹](#3-handleræ·»åŠ æµç¨‹)
- [4. äº‹ä»¶ä¼ æ’­æœºåˆ¶](#4-äº‹ä»¶ä¼ æ’­æœºåˆ¶)
- [5. é¢è¯•è¦ç‚¹](#5-é¢è¯•è¦ç‚¹)

---

## 1. Pipelineæ¦‚è¿°

### 1.1 ä»€ä¹ˆæ˜¯Pipeline

```
Pipelineæ˜¯Nettyçš„æ ¸å¿ƒç»„ä»¶ï¼Œé‡‡ç”¨è´£ä»»é“¾æ¨¡å¼ï¼š
- æ¯ä¸ªChanneléƒ½æœ‰ä¸€ä¸ªPipeline
- PipelineåŒ…å«ä¸€ç³»åˆ—Handler
- äº‹ä»¶åœ¨Handleré“¾ä¸­ä¼ æ’­

æ ¸å¿ƒä½œç”¨ï¼š
- å¤„ç†å…¥ç«™äº‹ä»¶ï¼ˆè¯»å–æ•°æ®ï¼‰
- å¤„ç†å‡ºç«™äº‹ä»¶ï¼ˆå†™å…¥æ•°æ®ï¼‰
- ç¼–è§£ç ã€ä¸šåŠ¡å¤„ç†ã€å¼‚å¸¸å¤„ç†
```

### 1.2 Pipelineç»“æ„

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      ChannelPipeline                         â”‚
â”‚                                                              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”      â”‚
â”‚  â”‚ Head â”‚ <->â”‚ Handler1 â”‚ <->â”‚ Handler2 â”‚ <->â”‚ Tail â”‚      â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”˜      â”‚
â”‚                                                              â”‚
â”‚  å…¥ç«™äº‹ä»¶ï¼šHead â†’ Handler1 â†’ Handler2 â†’ Tail                â”‚
â”‚  å‡ºç«™äº‹ä»¶ï¼šTail â†’ Handler2 â†’ Handler1 â†’ Head                â”‚
â”‚                                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 2. æ ¸å¿ƒç»“æ„

### 2.1 DefaultChannelPipeline

```java
public class DefaultChannelPipeline implements ChannelPipeline {
    
    // å¤´èŠ‚ç‚¹
    final AbstractChannelHandlerContext head;
    
    // å°¾èŠ‚ç‚¹
    final AbstractChannelHandlerContext tail;
    
    // æ‰€å±Channel
    private final Channel channel;
    
    // æ˜¯å¦å·²æ³¨å†Œ
    private boolean registered;
    
    // å¾…æ·»åŠ çš„Handlerå›è°ƒ
    private PendingHandlerCallback pendingHandlerCallbackHead;
    
    protected DefaultChannelPipeline(Channel channel) {
        this.channel = ObjectUtil.checkNotNull(channel, "channel");
        
        // åˆ›å»ºå°¾èŠ‚ç‚¹
        tail = new TailContext(this);
        // åˆ›å»ºå¤´èŠ‚ç‚¹
        head = new HeadContext(this);
        
        // åŒå‘é“¾è¡¨è¿æ¥
        head.next = tail;
        tail.prev = head;
    }
}
```

### 2.2 ChannelHandlerContext

```java
// Handlerä¸Šä¸‹æ–‡ï¼ŒåŒ…è£…Handlerå¹¶ç»´æŠ¤é“¾è¡¨å…³ç³»
abstract class AbstractChannelHandlerContext implements ChannelHandlerContext {
    
    // å‰é©±èŠ‚ç‚¹
    volatile AbstractChannelHandlerContext next;
    
    // åç»§èŠ‚ç‚¹
    volatile AbstractChannelHandlerContext prev;
    
    // æ‰€å±Pipeline
    private final DefaultChannelPipeline pipeline;
    
    // Handleråç§°
    private final String name;
    
    // æ˜¯å¦æ˜¯å…¥ç«™Handler
    private final boolean inbound;
    
    // æ˜¯å¦æ˜¯å‡ºç«™Handler
    private final boolean outbound;
    
    // æ‰§è¡Œå™¨
    final EventExecutor executor;
    
    // HandlerçŠ¶æ€
    private volatile int handlerState = INIT;
    
    // è·å–Channel
    @Override
    public Channel channel() {
        return pipeline.channel();
    }
    
    // è·å–Pipeline
    @Override
    public ChannelPipeline pipeline() {
        return pipeline;
    }
    
    // è·å–Handler
    @Override
    public ChannelHandler handler() {
        return handler;
    }
}
```

### 2.3 HeadContextå’ŒTailContext

```java
// å¤´èŠ‚ç‚¹ï¼šå¤„ç†å‡ºç«™äº‹ä»¶çš„æœ€åä¸€ç«™
final class HeadContext extends AbstractChannelHandlerContext
        implements ChannelOutboundHandler, ChannelInboundHandler {
    
    private final Unsafe unsafe;
    
    HeadContext(DefaultChannelPipeline pipeline) {
        super(pipeline, null, HEAD_NAME, HeadContext.class);
        unsafe = pipeline.channel().unsafe();
    }
    
    @Override
    public void bind(ChannelHandlerContext ctx, SocketAddress localAddress, 
            ChannelPromise promise) {
        unsafe.bind(localAddress, promise);
    }
    
    @Override
    public void connect(ChannelHandlerContext ctx, SocketAddress remoteAddress,
            SocketAddress localAddress, ChannelPromise promise) {
        unsafe.connect(remoteAddress, localAddress, promise);
    }
    
    @Override
    public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) {
        unsafe.write(msg, promise);
    }
    
    @Override
    public void flush(ChannelHandlerContext ctx) {
        unsafe.flush();
    }
    
    @Override
    public void channelRead(ChannelHandlerContext ctx, Object msg) {
        ctx.fireChannelRead(msg);
    }
}

// å°¾èŠ‚ç‚¹ï¼šå¤„ç†å…¥ç«™äº‹ä»¶çš„æœ€åä¸€ç«™
final class TailContext extends AbstractChannelHandlerContext 
        implements ChannelInboundHandler {
    
    TailContext(DefaultChannelPipeline pipeline) {
        super(pipeline, null, TAIL_NAME, TailContext.class);
    }
    
    @Override
    public void channelRead(ChannelHandlerContext ctx, Object msg) {
        // é‡Šæ”¾æœªå¤„ç†çš„æ¶ˆæ¯
        onUnhandledInboundMessage(ctx, msg);
    }
    
    @Override
    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {
        // è®°å½•æœªå¤„ç†çš„å¼‚å¸¸
        onUnhandledInboundException(cause);
    }
    
    protected void onUnhandledInboundMessage(ChannelHandlerContext ctx, Object msg) {
        try {
            logger.debug("Discarded inbound message {} that reached at the tail.", msg);
        } finally {
            ReferenceCountUtil.release(msg);
        }
    }
}
```

---

## 3. Handleræ·»åŠ æµç¨‹

### 3.1 addLastæ–¹æ³•

```java
@Override
public final ChannelPipeline addLast(String name, ChannelHandler handler) {
    return addLast(null, name, handler);
}

@Override
public final ChannelPipeline addLast(EventExecutorGroup group, String name, 
        ChannelHandler handler) {
    final AbstractChannelHandlerContext newCtx;
    synchronized (this) {
        // 1. æ£€æŸ¥Handleræ˜¯å¦å¯å…±äº«
        checkMultiplicity(handler);
        
        // 2. åˆ›å»ºContext
        newCtx = newContext(group, filterName(name, handler), handler);
        
        // 3. æ·»åŠ åˆ°é“¾è¡¨
        addLast0(newCtx);
        
        // 4. å¦‚æœChannelæœªæ³¨å†Œï¼Œå»¶è¿Ÿå›è°ƒ
        if (!registered) {
            newCtx.setAddPending();
            callHandlerCallbackLater(newCtx, true);
            return this;
        }
        
        // 5. åœ¨EventLoopä¸­æ‰§è¡Œå›è°ƒ
        EventExecutor executor = newCtx.executor();
        if (!executor.inEventLoop()) {
            callHandlerAddedInEventLoop(newCtx, executor);
            return this;
        }
    }
    
    // 6. è°ƒç”¨handlerAddedå›è°ƒ
    callHandlerAdded0(newCtx);
    return this;
}

private void addLast0(AbstractChannelHandlerContext newCtx) {
    AbstractChannelHandlerContext prev = tail.prev;
    newCtx.prev = prev;
    newCtx.next = tail;
    prev.next = newCtx;
    tail.prev = newCtx;
}
```

### 3.2 Handlerå…±äº«æ£€æŸ¥

```java
private static void checkMultiplicity(ChannelHandler handler) {
    if (handler instanceof ChannelHandlerAdapter) {
        ChannelHandlerAdapter h = (ChannelHandlerAdapter) handler;
        // éå…±äº«Handleråªèƒ½æ·»åŠ ä¸€æ¬¡
        if (!h.isSharable() && h.added) {
            throw new ChannelPipelineException(
                h.getClass().getName() + " is not a @Sharable handler");
        }
        h.added = true;
    }
}

// @Sharableæ³¨è§£æ ‡è®°å¯å…±äº«çš„Handler
@Sharable
public class MySharedHandler extends ChannelInboundHandlerAdapter {
    // å¯ä»¥è¢«å¤šä¸ªPipelineå…±äº«
}
```

### 3.3 handlerAddedå›è°ƒ

```java
private void callHandlerAdded0(final AbstractChannelHandlerContext ctx) {
    try {
        ctx.callHandlerAdded();
    } catch (Throwable t) {
        boolean removed = false;
        try {
            atomicRemoveFromHandlerList(ctx);
            ctx.callHandlerRemoved();
            removed = true;
        } catch (Throwable t2) {
            // å¿½ç•¥
        }
        
        if (removed) {
            fireExceptionCaught(new ChannelPipelineException(...));
        } else {
            fireExceptionCaught(new ChannelPipelineException(...));
        }
    }
}

// AbstractChannelHandlerContext.callHandlerAdded()
final void callHandlerAdded() throws Exception {
    if (setAddComplete()) {
        handler().handlerAdded(this);
    }
}
```

---

## 4. äº‹ä»¶ä¼ æ’­æœºåˆ¶

### 4.1 å…¥ç«™äº‹ä»¶ä¼ æ’­

```java
// è§¦å‘channelReadäº‹ä»¶
@Override
public final ChannelPipeline fireChannelRead(Object msg) {
    AbstractChannelHandlerContext.invokeChannelRead(head, msg);
    return this;
}

// AbstractChannelHandlerContext
static void invokeChannelRead(final AbstractChannelHandlerContext next, Object msg) {
    final Object m = next.pipeline.touch(ObjectUtil.checkNotNull(msg, "msg"), next);
    EventExecutor executor = next.executor();
    if (executor.inEventLoop()) {
        next.invokeChannelRead(m);
    } else {
        executor.execute(new Runnable() {
            @Override
            public void run() {
                next.invokeChannelRead(m);
            }
        });
    }
}

private void invokeChannelRead(Object msg) {
    if (invokeHandler()) {
        try {
            // è°ƒç”¨Handlerçš„channelReadæ–¹æ³•
            ((ChannelInboundHandler) handler()).channelRead(this, msg);
        } catch (Throwable t) {
            invokeExceptionCaught(t);
        }
    } else {
        fireChannelRead(msg);
    }
}

// ä¼ æ’­åˆ°ä¸‹ä¸€ä¸ªå…¥ç«™Handler
@Override
public ChannelHandlerContext fireChannelRead(final Object msg) {
    invokeChannelRead(findContextInbound(MASK_CHANNEL_READ), msg);
    return this;
}

// æŸ¥æ‰¾ä¸‹ä¸€ä¸ªå…¥ç«™Handler
private AbstractChannelHandlerContext findContextInbound(int mask) {
    AbstractChannelHandlerContext ctx = this;
    EventExecutor currentExecutor = executor();
    do {
        ctx = ctx.next;
    } while (skipContext(ctx, currentExecutor, mask, MASK_ONLY_INBOUND));
    return ctx;
}
```

### 4.2 å‡ºç«™äº‹ä»¶ä¼ æ’­

```java
// è§¦å‘writeäº‹ä»¶
@Override
public final ChannelFuture write(Object msg) {
    return tail.write(msg);
}

// AbstractChannelHandlerContext
@Override
public ChannelFuture write(Object msg) {
    return write(msg, newPromise());
}

@Override
public ChannelFuture write(final Object msg, final ChannelPromise promise) {
    write(msg, false, promise);
    return promise;
}

private void write(Object msg, boolean flush, ChannelPromise promise) {
    ObjectUtil.checkNotNull(msg, "msg");
    
    // æŸ¥æ‰¾ä¸‹ä¸€ä¸ªå‡ºç«™Handler
    final AbstractChannelHandlerContext next = findContextOutbound(
        flush ? (MASK_WRITE | MASK_FLUSH) : MASK_WRITE);
    final Object m = pipeline.touch(msg, next);
    EventExecutor executor = next.executor();
    
    if (executor.inEventLoop()) {
        if (flush) {
            next.invokeWriteAndFlush(m, promise);
        } else {
            next.invokeWrite(m, promise);
        }
    } else {
        // æäº¤åˆ°EventLoopæ‰§è¡Œ
        final WriteTask task = WriteTask.newInstance(next, m, promise, flush);
        if (!safeExecute(executor, task, promise, m, !flush)) {
            task.cancel();
        }
    }
}

private void invokeWrite(Object msg, ChannelPromise promise) {
    if (invokeHandler()) {
        invokeWrite0(msg, promise);
    } else {
        write(msg, promise);
    }
}

private void invokeWrite0(Object msg, ChannelPromise promise) {
    try {
        // è°ƒç”¨Handlerçš„writeæ–¹æ³•
        ((ChannelOutboundHandler) handler()).write(this, msg, promise);
    } catch (Throwable t) {
        notifyOutboundHandlerException(t, promise);
    }
}

// æŸ¥æ‰¾ä¸‹ä¸€ä¸ªå‡ºç«™Handlerï¼ˆä»åå¾€å‰ï¼‰
private AbstractChannelHandlerContext findContextOutbound(int mask) {
    AbstractChannelHandlerContext ctx = this;
    EventExecutor currentExecutor = executor();
    do {
        ctx = ctx.prev;
    } while (skipContext(ctx, currentExecutor, mask, MASK_ONLY_OUTBOUND));
    return ctx;
}
```

### 4.3 å¼‚å¸¸ä¼ æ’­

```java
// è§¦å‘å¼‚å¸¸äº‹ä»¶
@Override
public ChannelHandlerContext fireExceptionCaught(final Throwable cause) {
    invokeExceptionCaught(findContextInbound(MASK_EXCEPTION_CAUGHT), cause);
    return this;
}

static void invokeExceptionCaught(final AbstractChannelHandlerContext next, 
        final Throwable cause) {
    ObjectUtil.checkNotNull(cause, "cause");
    EventExecutor executor = next.executor();
    if (executor.inEventLoop()) {
        next.invokeExceptionCaught(cause);
    } else {
        try {
            executor.execute(new Runnable() {
                @Override
                public void run() {
                    next.invokeExceptionCaught(cause);
                }
            });
        } catch (Throwable t) {
            // å¿½ç•¥
        }
    }
}

private void invokeExceptionCaught(final Throwable cause) {
    if (invokeHandler()) {
        try {
            handler().exceptionCaught(this, cause);
        } catch (Throwable error) {
            // å¼‚å¸¸å¤„ç†ä¸­åˆæŠ›å¼‚å¸¸
            logger.debug("...", error, cause);
        }
    } else {
        fireExceptionCaught(cause);
    }
}
```


---

## 5. é¢è¯•è¦ç‚¹

### 5.1 é«˜é¢‘é—®é¢˜

**Q1: Pipelineçš„ç»“æ„æ˜¯æ€æ ·çš„ï¼Ÿ**
```
Pipelineæ˜¯ä¸€ä¸ªåŒå‘é“¾è¡¨ç»“æ„ï¼š

1. å¤´èŠ‚ç‚¹ï¼ˆHeadContextï¼‰
   - å¤„ç†å‡ºç«™äº‹ä»¶çš„æœ€åä¸€ç«™
   - è°ƒç”¨Unsafeæ‰§è¡Œå®é™…IOæ“ä½œ

2. å°¾èŠ‚ç‚¹ï¼ˆTailContextï¼‰
   - å¤„ç†å…¥ç«™äº‹ä»¶çš„æœ€åä¸€ç«™
   - é‡Šæ”¾æœªå¤„ç†çš„æ¶ˆæ¯
   - è®°å½•æœªå¤„ç†çš„å¼‚å¸¸

3. ç”¨æˆ·Handler
   - ä½äºHeadå’ŒTailä¹‹é—´
   - æŒ‰æ·»åŠ é¡ºåºæ’åˆ—

ç»“æ„ï¼šHead <-> Handler1 <-> Handler2 <-> ... <-> Tail
```

**Q2: å…¥ç«™å’Œå‡ºç«™äº‹ä»¶çš„ä¼ æ’­æ–¹å‘ï¼Ÿ**
```
å…¥ç«™äº‹ä»¶ï¼ˆInboundï¼‰ï¼š
- ä»Headåˆ°Tail
- ä¾‹å¦‚ï¼šchannelReadã€channelActive
- å¤„ç†è¯»å–çš„æ•°æ®

å‡ºç«™äº‹ä»¶ï¼ˆOutboundï¼‰ï¼š
- ä»Tailåˆ°Head
- ä¾‹å¦‚ï¼šwriteã€flushã€connect
- å¤„ç†å†™å…¥çš„æ•°æ®

å…¥ç«™ï¼šHead â†’ Handler1 â†’ Handler2 â†’ Tail
å‡ºç«™ï¼šTail â†’ Handler2 â†’ Handler1 â†’ Head
```

**Q3: ChannelHandlerContextçš„ä½œç”¨ï¼Ÿ**
```
ChannelHandlerContextæ˜¯Handlerçš„åŒ…è£…å™¨ï¼š

1. ç»´æŠ¤é“¾è¡¨å…³ç³»
   - prevï¼šå‰é©±èŠ‚ç‚¹
   - nextï¼šåç»§èŠ‚ç‚¹

2. æä¾›äº‹ä»¶ä¼ æ’­æ–¹æ³•
   - fireChannelRead()ï¼šä¼ æ’­å…¥ç«™äº‹ä»¶
   - write()ï¼šä¼ æ’­å‡ºç«™äº‹ä»¶

3. è·å–å…³è”å¯¹è±¡
   - channel()ï¼šè·å–Channel
   - pipeline()ï¼šè·å–Pipeline
   - handler()ï¼šè·å–Handler

4. æ‰§è¡Œå™¨ç®¡ç†
   - executor()ï¼šè·å–EventExecutor
   - æ”¯æŒHandleråœ¨ç‹¬ç«‹çº¿ç¨‹æ‰§è¡Œ
```

**Q4: @Sharableæ³¨è§£çš„ä½œç”¨ï¼Ÿ**
```
@Sharableæ ‡è®°Handlerå¯ä»¥è¢«å¤šä¸ªPipelineå…±äº«ï¼š

1. éå…±äº«Handler
   - æ¯ä¸ªPipelineéœ€è¦æ–°å®ä¾‹
   - å¯ä»¥æœ‰çŠ¶æ€

2. å…±äº«Handler
   - å¯ä»¥è¢«å¤šä¸ªPipelineå¤ç”¨
   - å¿…é¡»æ˜¯æ— çŠ¶æ€çš„
   - æˆ–è€…çŠ¶æ€æ˜¯çº¿ç¨‹å®‰å…¨çš„

ä½¿ç”¨åœºæ™¯ï¼š
- ç¼–è§£ç å™¨é€šå¸¸ä¸å…±äº«ï¼ˆæœ‰çŠ¶æ€ï¼‰
- ä¸šåŠ¡Handlerå¯ä»¥å…±äº«ï¼ˆæ— çŠ¶æ€ï¼‰
```

**Q5: å¦‚ä½•æ­£ç¡®å¤„ç†å¼‚å¸¸ï¼Ÿ**
```
1. åœ¨æœ€åæ·»åŠ å¼‚å¸¸å¤„ç†Handler
   pipeline.addLast(new ExceptionHandler());

2. å®ç°exceptionCaughtæ–¹æ³•
   @Override
   public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {
       logger.error("Error", cause);
       ctx.close();
   }

3. å¼‚å¸¸ä¼ æ’­è§„åˆ™
   - å¼‚å¸¸ä¼šæ²¿ç€å…¥ç«™æ–¹å‘ä¼ æ’­
   - å¦‚æœæ²¡æœ‰Handlerå¤„ç†ï¼Œä¼šåˆ°è¾¾TailContext
   - TailContextä¼šè®°å½•è­¦å‘Šæ—¥å¿—

4. æ³¨æ„äº‹é¡¹
   - ä¸è¦åæ‰å¼‚å¸¸
   - è¦ä¹ˆå¤„ç†ï¼Œè¦ä¹ˆç»§ç»­ä¼ æ’­
   - ctx.fireExceptionCaught(cause)
```

### 5.2 æ ¸å¿ƒç±»æ€»ç»“

```
Pipelineç›¸å…³ï¼š
- DefaultChannelPipelineï¼šé»˜è®¤Pipelineå®ç°
- AbstractChannelHandlerContextï¼šHandlerä¸Šä¸‹æ–‡
- HeadContextï¼šå¤´èŠ‚ç‚¹
- TailContextï¼šå°¾èŠ‚ç‚¹

Handlerç›¸å…³ï¼š
- ChannelInboundHandlerï¼šå…¥ç«™Handler
- ChannelOutboundHandlerï¼šå‡ºç«™Handler
- ChannelDuplexHandlerï¼šåŒå‘Handler
- ChannelInboundHandlerAdapterï¼šå…¥ç«™é€‚é…å™¨
- ChannelOutboundHandlerAdapterï¼šå‡ºç«™é€‚é…å™¨

å¸¸ç”¨Handlerï¼š
- StringDecoder/StringEncoderï¼šå­—ç¬¦ä¸²ç¼–è§£ç 
- LengthFieldBasedFrameDecoderï¼šé•¿åº¦å­—æ®µè§£ç 
- IdleStateHandlerï¼šç©ºé—²æ£€æµ‹
- LoggingHandlerï¼šæ—¥å¿—è®°å½•
```

---

## ğŸ“Š äº‹ä»¶ä¼ æ’­æµç¨‹å›¾

```
å…¥ç«™äº‹ä»¶ä¼ æ’­ï¼ˆchannelReadï¼‰ï¼š
â”Œâ”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”
â”‚ Head â”‚ -> â”‚ Decoder  â”‚ -> â”‚ Handler  â”‚ -> â”‚ Tail â”‚
â””â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”˜
    â”‚            â”‚               â”‚              â”‚
    â”‚   fireChannelRead    fireChannelRead     â”‚
    â”‚            â”‚               â”‚              â”‚
    â–¼            â–¼               â–¼              â–¼
  æ¥æ”¶æ•°æ®    è§£ç æ•°æ®       ä¸šåŠ¡å¤„ç†      é‡Šæ”¾æ¶ˆæ¯


å‡ºç«™äº‹ä»¶ä¼ æ’­ï¼ˆwriteï¼‰ï¼š
â”Œâ”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”
â”‚ Head â”‚ <- â”‚ Encoder  â”‚ <- â”‚ Handler  â”‚ <- â”‚ Tail â”‚
â””â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”˜
    â”‚            â”‚               â”‚              â”‚
    â”‚         write           write            â”‚
    â”‚            â”‚               â”‚              â”‚
    â–¼            â–¼               â–¼              â–¼
  å‘é€æ•°æ®    ç¼–ç æ•°æ®       ä¸šåŠ¡å¤„ç†      å‘èµ·å†™å…¥
```

---

## ğŸ’¡ æœ€ä½³å®è·µ

### Handleré¡ºåº

```java
// æ¨èçš„Handleré¡ºåº
ch.pipeline()
    // 1. æ—¥å¿—ï¼ˆå¯é€‰ï¼‰
    .addLast(new LoggingHandler(LogLevel.DEBUG))
    
    // 2. ç©ºé—²æ£€æµ‹
    .addLast(new IdleStateHandler(60, 30, 0))
    
    // 3. è§£ç å™¨ï¼ˆå…¥ç«™ï¼‰
    .addLast(new LengthFieldBasedFrameDecoder(1024, 0, 4, 0, 4))
    .addLast(new StringDecoder())
    
    // 4. ç¼–ç å™¨ï¼ˆå‡ºç«™ï¼‰
    .addLast(new LengthFieldPrepender(4))
    .addLast(new StringEncoder())
    
    // 5. ä¸šåŠ¡Handler
    .addLast(new BusinessHandler())
    
    // 6. å¼‚å¸¸å¤„ç†ï¼ˆæœ€åï¼‰
    .addLast(new ExceptionHandler());
```

### æ³¨æ„äº‹é¡¹

```
1. Handleré¡ºåºå¾ˆé‡è¦
   - è§£ç å™¨åœ¨å‰ï¼Œç¼–ç å™¨åœ¨å
   - å¼‚å¸¸å¤„ç†æ”¾æœ€å

2. åŠæ—¶é‡Šæ”¾ByteBuf
   - å…¥ç«™ï¼šå¤„ç†å®Œè¦release
   - å‡ºç«™ï¼šwriteåè‡ªåŠ¨release

3. é¿å…é˜»å¡EventLoop
   - è€—æ—¶æ“ä½œä½¿ç”¨ç‹¬ç«‹çº¿ç¨‹æ± 
   - pipeline.addLast(group, handler)

4. æ­£ç¡®å¤„ç†å¼‚å¸¸
   - ä¸è¦åæ‰å¼‚å¸¸
   - æ·»åŠ å¼‚å¸¸å¤„ç†Handler
```

---

**æ·±å…¥ç†è§£Pipelineï¼ŒæŒæ¡Nettyæ ¸å¿ƒï¼** ğŸš€

*æœ€åæ›´æ–°ï¼š2025-12-28*

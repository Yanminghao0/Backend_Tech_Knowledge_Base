# é›¶æ‹·è´æºç è§£æ

> ğŸ’¡ æ·±å…¥ç†è§£Nettyé›¶æ‹·è´æŠ€æœ¯çš„å®ç°åŸç†å’Œæ€§èƒ½ä¼˜åŒ–

---

## ğŸ“š ç›®å½•

1. [é›¶æ‹·è´æ¦‚è¿°](#1-é›¶æ‹·è´æ¦‚è¿°)
2. [ByteBufé›¶æ‹·è´å®ç°](#2-bytebufé›¶æ‹·è´å®ç°)
3. [CompositeByteBufæºç è§£æ](#3-compositebytebufæºç è§£æ)
4. [FileRegioné›¶æ‹·è´](#4-fileregioné›¶æ‹·è´)
5. [DirectByteBufferä¼˜åŒ–](#5-directbytebufferä¼˜åŒ–)
6. [æ€§èƒ½æµ‹è¯•ä¸å¯¹æ¯”](#6-æ€§èƒ½æµ‹è¯•ä¸å¯¹æ¯”)
7. [é¢è¯•è¦ç‚¹](#7-é¢è¯•è¦ç‚¹)

---

## 1. é›¶æ‹·è´æ¦‚è¿°

### 1.1 é›¶æ‹·è´åŸç†

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  ä¼ ç»Ÿæ‹·è´ vs é›¶æ‹·è´                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                             â”‚
â”‚  ä¼ ç»Ÿæ‹·è´ï¼ˆ4æ¬¡æ‹·è´ï¼Œ4æ¬¡ä¸Šä¸‹æ–‡åˆ‡æ¢ï¼‰ï¼š                        â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚
â”‚  â”‚    ç£ç›˜      â”‚â”€â”€â”€â–¶â”‚  å†…æ ¸ç¼“å†²åŒº  â”‚â”€â”€â”€â–¶â”‚  ç”¨æˆ·ç¼“å†²åŒº  â”‚     â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚
â”‚         â”‚                                       â”‚          â”‚
â”‚         â”‚            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”            â–¼          â”‚
â”‚         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚  Socketç¼“å†²åŒºâ”‚â—€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚
â”‚                      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                       â”‚
â”‚                             â”‚                              â”‚
â”‚                             â–¼                              â”‚
â”‚                      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                       â”‚
â”‚                      â”‚    ç½‘å¡      â”‚                       â”‚
â”‚                      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                       â”‚
â”‚                                                             â”‚
â”‚  é›¶æ‹·è´ï¼ˆ2æ¬¡æ‹·è´ï¼Œ2æ¬¡ä¸Šä¸‹æ–‡åˆ‡æ¢ï¼‰ï¼š                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚
â”‚  â”‚    ç£ç›˜      â”‚â”€â”€â”€â–¶â”‚  å†…æ ¸ç¼“å†²åŒº  â”‚â”€â”€â”€â–¶â”‚  Socketç¼“å†²åŒºâ”‚     â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚
â”‚                                               â”‚            â”‚
â”‚                                               â–¼            â”‚
â”‚                                        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚
â”‚                                        â”‚    ç½‘å¡      â”‚     â”‚
â”‚                                        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚
â”‚                                                             â”‚
â”‚  Nettyé›¶æ‹·è´æŠ€æœ¯ï¼š                                           â”‚
â”‚  âœ… CompositeByteBufï¼šé€»è¾‘ç»„åˆï¼Œé¿å…å†…å­˜æ‹·è´                â”‚
â”‚  âœ… slice()æ“ä½œï¼šå…±äº«åº•å±‚æ•°ç»„ï¼Œé¿å…æ•°æ®æ‹·è´                 â”‚
â”‚  âœ… FileRegionï¼šç›´æ¥æ–‡ä»¶ä¼ è¾“ï¼Œå‡å°‘å†…å­˜æ‹·è´                  â”‚
â”‚  âœ… DirectByteBufferï¼šç›´æ¥å†…å­˜ï¼Œå‡å°‘JVMå †æ‹·è´               â”‚
â”‚                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 1.2 Nettyé›¶æ‹·è´æŠ€æœ¯åˆ†ç±»

```java
/**
 * Nettyé›¶æ‹·è´æŠ€æœ¯åˆ†ç±»
 */
public class NettyZeroCopyTechniques {
    
    /**
     * ğŸ”¥ 1. å †å¤–å†…å­˜ï¼ˆDirect Memoryï¼‰
     * - é¿å…JVMå †å†…å­˜æ‹·è´
     * - ç›´æ¥ä¸æ“ä½œç³»ç»Ÿäº¤äº’
     * - å‡å°‘GCå‹åŠ›
     */
    public void directMemoryExample() {
        // åˆ†é…ç›´æ¥å†…å­˜
        ByteBuf directBuffer = Unpooled.directBuffer(1024);
        
        // æ£€æŸ¥æ˜¯å¦ä¸ºç›´æ¥å†…å­˜
        boolean isDirect = directBuffer.isDirect(); // true
        
        // ç›´æ¥å†…å­˜åœ°å€
        long memoryAddress = directBuffer.memoryAddress();
    }
    
    /**
     * ğŸ”¥ 2. ç»„åˆç¼“å†²åŒºï¼ˆCompositeByteBufï¼‰
     * - é€»è¾‘ä¸Šç»„åˆå¤šä¸ªByteBuf
     * - é¿å…å®é™…çš„å†…å­˜æ‹·è´
     * - æ”¯æŒåŠ¨æ€æ·»åŠ /åˆ é™¤ç»„ä»¶
     */
    public void compositeByteBufExample() {
        CompositeByteBuf composite = Unpooled.compositeBuffer();
        
        ByteBuf header = Unpooled.copiedBuffer("Header", CharsetUtil.UTF_8);
        ByteBuf body = Unpooled.copiedBuffer("Body", CharsetUtil.UTF_8);
        
        // é€»è¾‘ç»„åˆï¼Œæ— å†…å­˜æ‹·è´
        composite.addComponents(true, header, body);
    }
    
    /**
     * ğŸ”¥ 3. åˆ‡ç‰‡æ“ä½œï¼ˆsliceï¼‰
     * - å…±äº«åº•å±‚å­˜å‚¨
     * - åˆ›å»ºè§†å›¾è€Œéæ‹·è´
     * - å¼•ç”¨è®¡æ•°å…±äº«
     */
    public void sliceExample() {
        ByteBuf buffer = Unpooled.copiedBuffer("Hello World", CharsetUtil.UTF_8);
        
        // åˆ›å»ºåˆ‡ç‰‡ï¼Œå…±äº«åº•å±‚æ•°ç»„
        ByteBuf slice1 = buffer.slice(0, 5);    // "Hello"
        ByteBuf slice2 = buffer.slice(6, 5);    // "World"
        
        // å…±äº«å¼•ç”¨è®¡æ•°
        assert slice1.refCnt() == buffer.refCnt();
    }
    
    /**
     * ğŸ”¥ 4. æ–‡ä»¶ä¼ è¾“ï¼ˆFileRegionï¼‰
     * - ä½¿ç”¨sendfileç³»ç»Ÿè°ƒç”¨
     * - å†…æ ¸ç›´æ¥ä¼ è¾“æ–‡ä»¶
     * - é¿å…ç”¨æˆ·ç©ºé—´æ‹·è´
     */
    public void fileRegionExample() throws IOException {
        FileChannel fileChannel = new RandomAccessFile("test.txt", "r").getChannel();
        
        // åˆ›å»ºæ–‡ä»¶åŒºåŸŸ
        FileRegion fileRegion = new DefaultFileRegion(fileChannel, 0, fileChannel.size());
        
        // ç›´æ¥ä¼ è¾“æ–‡ä»¶
        channel.writeAndFlush(fileRegion);
    }
}
```

---

## 2. ByteBufé›¶æ‹·è´å®ç°

### 2.1 AbstractByteBufåŸºç¡€å®ç°

```java
/**
 * AbstractByteBuf - ByteBufæŠ½è±¡åŸºç±»
 * æä¾›é›¶æ‹·è´æ“ä½œçš„åŸºç¡€å®ç°
 */
public abstract class AbstractByteBuf extends ByteBuf {
    
    static final ResourceLeakDetector<ByteBuf> leakDetector = ResourceLeakDetectorFactory.instance().newResourceLeakDetector(ByteBuf.class);
    
    // ğŸ”¥ è¯»å†™ç´¢å¼•
    int readerIndex;
    int writerIndex;
    private int markedReaderIndex;
    private int markedWriterIndex;
    
    // ğŸ”¥ æœ€å¤§å®¹é‡
    private int maxCapacity;
    
    /**
     * ğŸ”¥ åˆ‡ç‰‡æ“ä½œ - é›¶æ‹·è´æ ¸å¿ƒæ–¹æ³•
     */
    @Override
    public ByteBuf slice() {
        return slice(readerIndex, readableBytes());
    }
    
    @Override
    public ByteBuf slice(int index, int length) {
        ensureAccessible();
        return new UnpooledSlicedByteBuf(this, index, length);
    }
    
    /**
     * ğŸ”¥ é‡å¤æ“ä½œ - åˆ›å»ºè§†å›¾
     */
    @Override
    public ByteBuf duplicate() {
        ensureAccessible();
        return new UnpooledDuplicatedByteBuf(this);
    }
    
    /**
     * ğŸ”¥ åªè¯»ç¼“å†²åŒº
     */
    @Override
    public ByteBuf asReadOnly() {
        if (isReadOnly()) {
            return this;
        }
        return Unpooled.unmodifiableBuffer(this);
    }
    
    /**
     * ğŸ”¥ ä¿ç•™å¼•ç”¨
     */
    @Override
    public ByteBuf retainedSlice() {
        return slice().retain();
    }
    
    @Override
    public ByteBuf retainedSlice(int index, int length) {
        return slice(index, length).retain();
    }
    
    @Override
    public ByteBuf retainedDuplicate() {
        return duplicate().retain();
    }
}
```

### 2.2 UnpooledSlicedByteBufå®ç°

```java
/**
 * UnpooledSlicedByteBuf - åˆ‡ç‰‡ByteBufå®ç°
 * å…±äº«åº•å±‚å­˜å‚¨ï¼Œå®ç°é›¶æ‹·è´
 */
class UnpooledSlicedByteBuf extends AbstractUnpooledSlicedByteBuf {
    
    /**
     * ğŸ”¥ æ„é€ å‡½æ•°
     */
    UnpooledSlicedByteBuf(AbstractByteBuf buffer, int index, int length) {
        super(buffer, index, length);
    }
    
    /**
     * ğŸ”¥ è·å–åº•å±‚å­—èŠ‚
     */
    @Override
    public byte getByte(int index) {
        checkIndex0(index, 1);
        return unwrap().getByte(idx(index));
    }
    
    /**
     * ğŸ”¥ è®¾ç½®åº•å±‚å­—èŠ‚
     */
    @Override
    public ByteBuf setByte(int index, int value) {
        checkIndex0(index, 1);
        unwrap().setByte(idx(index), value);
        return this;
    }
    
    /**
     * ğŸ”¥ è·å–å­—èŠ‚æ•°ç»„ - å¯èƒ½æ¶‰åŠæ‹·è´
     */
    @Override
    public ByteBuf getBytes(int index, byte[] dst, int dstIndex, int length) {
        checkIndex0(index, length);
        unwrap().getBytes(idx(index), dst, dstIndex, length);
        return this;
    }
    
    /**
     * ğŸ”¥ è·å–ByteBuffer - é›¶æ‹·è´
     */
    @Override
    public ByteBuffer nioBuffer(int index, int length) {
        checkIndex0(index, length);
        return unwrap().nioBuffer(idx(index), length);
    }
    
    /**
     * ğŸ”¥ å†…éƒ¨æ•°ç»„è®¿é—® - é›¶æ‹·è´
     */
    @Override
    public boolean hasArray() {
        return unwrap().hasArray();
    }
    
    @Override
    public byte[] array() {
        return unwrap().array();
    }
    
    @Override
    public int arrayOffset() {
        return idx(unwrap().arrayOffset());
    }
    
    /**
     * ğŸ”¥ å†…å­˜åœ°å€è®¿é—® - ç›´æ¥å†…å­˜
     */
    @Override
    public boolean hasMemoryAddress() {
        return unwrap().hasMemoryAddress();
    }
    
    @Override
    public long memoryAddress() {
        return unwrap().memoryAddress() + adjustment;
    }
    
    /**
     * ğŸ”¥ ç´¢å¼•è½¬æ¢
     */
    private int idx(int index) {
        return index + adjustment;
    }
}
```

### 2.3 UnpooledDuplicatedByteBufå®ç°

```java
/**
 * UnpooledDuplicatedByteBuf - é‡å¤ByteBufå®ç°
 * å…±äº«åº•å±‚å­˜å‚¨å’Œç´¢å¼•ï¼Œå®ç°é›¶æ‹·è´
 */
class UnpooledDuplicatedByteBuf extends DuplicatedByteBuf {
    
    /**
     * ğŸ”¥ æ„é€ å‡½æ•°
     */
    UnpooledDuplicatedByteBuf(AbstractByteBuf buffer) {
        super(buffer);
    }
    
    /**
     * ğŸ”¥ åˆ‡ç‰‡æ“ä½œ - ç»§ç»­é›¶æ‹·è´
     */
    @Override
    public ByteBuf slice(int index, int length) {
        checkIndex(index, length);
        return new UnpooledSlicedByteBuf(unwrap(), index, length);
    }
    
    /**
     * ğŸ”¥ é‡å¤æ“ä½œ - ç»§ç»­é›¶æ‹·è´
     */
    @Override
    public ByteBuf duplicate() {
        return new UnpooledDuplicatedByteBuf(unwrap());
    }
    
    /**
     * ğŸ”¥ ä¿ç•™åˆ‡ç‰‡
     */
    @Override
    public ByteBuf retainedSlice(int index, int length) {
        return slice(index, length).retain();
    }
    
    /**
     * ğŸ”¥ ä¿ç•™é‡å¤
     */
    @Override
    public ByteBuf retainedDuplicate() {
        return duplicate().retain();
    }
}
```

---

## 3. CompositeByteBufæºç è§£æ

### 3.1 CompositeByteBufæ ¸å¿ƒå®ç°

```java
/**
 * CompositeByteBuf - ç»„åˆByteBufå®ç°
 * é€»è¾‘ç»„åˆå¤šä¸ªByteBufï¼Œé¿å…å†…å­˜æ‹·è´
 */
public class CompositeByteBuf extends AbstractReferenceCountedByteBuf implements Iterable<ByteBuf> {
    
    private static final ByteBuffer EMPTY_NIO_BUFFER = Unpooled.EMPTY_BUFFER.nioBuffer();
    private static final Iterator<ByteBuf> EMPTY_ITERATOR = Collections.<ByteBuf>emptyList().iterator();
    
    // ğŸ”¥ ç»„ä»¶æ•°ç»„
    private Component[] components;
    private int componentCount;
    private boolean freed;
    
    // ğŸ”¥ ç»„ä»¶ç¼“å­˜
    private Component lastAccessed;
    
    /**
     * ğŸ”¥ ç»„ä»¶å†…éƒ¨ç±»
     */
    private static final class Component {
        final ByteBuf buf;
        final int length;
        int offset;
        int endOffset;
        
        Component(ByteBuf buf) {
            this.buf = buf;
            length = buf.readableBytes();
        }
        
        void freeIfNecessary() {
            buf.release();
        }
    }
    
    /**
     * ğŸ”¥ æ„é€ å‡½æ•°
     */
    public CompositeByteBuf(ByteBufAllocator alloc, boolean direct, int maxNumComponents) {
        super(Integer.MAX_VALUE);
        if (alloc == null) {
            throw new NullPointerException("alloc");
        }
        this.alloc = alloc;
        this.direct = direct;
        this.maxNumComponents = maxNumComponents;
        components = new Component[maxNumComponents];
    }
    
    /**
     * ğŸ”¥ æ·»åŠ ç»„ä»¶ - æ ¸å¿ƒæ–¹æ³•
     */
    public CompositeByteBuf addComponent(ByteBuf buffer) {
        return addComponent(false, buffer);
    }
    
    public CompositeByteBuf addComponent(boolean increaseWriterIndex, ByteBuf buffer) {
        checkNotNull(buffer, "buffer");
        addComponent0(increaseWriterIndex, componentCount, buffer);
        consolidateIfNeeded();
        return this;
    }
    
    /**
     * ğŸ”¥ æ·»åŠ ç»„ä»¶çš„å…·ä½“å®ç°
     */
    private int addComponent0(boolean increaseWriterIndex, int cIndex, ByteBuf buffer) {
        assert buffer != null;
        boolean wasAdded = false;
        try {
            checkComponentIndex(cIndex);
            
            int readableBytes = buffer.readableBytes();
            
            // ğŸ”¥ åˆ›å»ºç»„ä»¶
            Component c = new Component(buffer.order(ByteOrder.BIG_ENDIAN).slice());
            if (cIndex == componentCount) {
                wasAdded = components[cIndex] = c;
                if (cIndex == 0) {
                    c.endOffset = readableBytes;
                } else {
                    Component prev = components[cIndex - 1];
                    c.offset = prev.endOffset;
                    c.endOffset = c.offset + readableBytes;
                }
            } else {
                components = Arrays.copyOf(components, components.length + 1);
                System.arraycopy(components, cIndex, components, cIndex + 1, componentCount - cIndex);
                components[cIndex] = c;
                wasAdded = true;
                updateComponentOffsets(cIndex);
            }
            componentCount++;
            
            if (increaseWriterIndex) {
                writerIndex(writerIndex() + buffer.readableBytes());
            }
            return cIndex;
        } finally {
            if (!wasAdded) {
                buffer.release();
            }
        }
    }
    
    /**
     * ğŸ”¥ æŸ¥æ‰¾ç»„ä»¶ - äºŒåˆ†æŸ¥æ‰¾ä¼˜åŒ–
     */
    private Component findComponent(int offset) {
        Component la = lastAccessed;
        if (la != null && offset >= la.offset && offset < la.endOffset) {
            return la;
        }
        
        checkIndex(offset);
        
        return findIt(offset);
    }
    
    private Component findIt(int offset) {
        for (int low = 0, high = componentCount; low <= high;) {
            int mid = low + high >>> 1;
            Component c = components[mid];
            if (offset >= c.endOffset) {
                low = mid + 1;
            } else if (offset < c.offset) {
                high = mid - 1;
            } else {
                lastAccessed = c;
                return c;
            }
        }
        
        throw new Error("should not reach here");
    }
    
    /**
     * ğŸ”¥ è·å–å­—èŠ‚ - é›¶æ‹·è´è®¿é—®
     */
    @Override
    public byte getByte(int index) {
        Component c = findComponent(index);
        return c.buf.getByte(index - c.offset);
    }
    
    /**
     * ğŸ”¥ è·å–å­—èŠ‚æ•°ç»„ - å¯èƒ½æ¶‰åŠæ‹·è´
     */
    @Override
    public CompositeByteBuf getBytes(int index, byte[] dst, int dstIndex, int length) {
        checkDstIndex(index, length, dstIndex, dst.length);
        if (length == 0) {
            return this;
        }
        
        int i = toComponentIndex(index);
        while (length > 0) {
            Component c = components[i];
            ByteBuf s = c.buf;
            int adjustment = c.offset;
            int localLength = Math.min(length, s.capacity() - (index - adjustment));
            s.getBytes(index - adjustment, dst, dstIndex, localLength);
            index += localLength;
            dstIndex += localLength;
            length -= localLength;
            i++;
        }
        return this;
    }
    
    /**
     * ğŸ”¥ è·å–NIOç¼“å†²åŒº - é›¶æ‹·è´
     */
    @Override
    public ByteBuffer nioBuffer(int index, int length) {
        checkIndex(index, length);
        
        if (length == 0) {
            return EMPTY_NIO_BUFFER;
        }
        
        List<ByteBuffer> buffers = nioBuffers(index, length);
        if (buffers.size() == 1) {
            return buffers.get(0);
        }
        
        ByteBuffer merged = ByteBuffer.allocate(length).order(order());
        for (ByteBuffer buf : buffers) {
            merged.put(buf);
        }
        
        merged.flip();
        return merged;
    }
    
    /**
     * ğŸ”¥ è·å–å¤šä¸ªNIOç¼“å†²åŒº
     */
    @Override
    public ByteBuffer[] nioBuffers(int index, int length) {
        checkIndex(index, length);
        if (length == 0) {
            return new ByteBuffer[] { EMPTY_NIO_BUFFER };
        }
        
        List<ByteBuffer> buffers = new ArrayList<ByteBuffer>(componentCount);
        int i = toComponentIndex(index);
        while (length > 0) {
            Component c = components[i];
            ByteBuf s = c.buf;
            int adjustment = c.offset;
            int localLength = Math.min(length, s.capacity() - (index - adjustment));
            switch (s.nioBufferCount()) {
            case 0:
                throw new UnsupportedOperationException();
            case 1:
                buffers.add(s.nioBuffer(index - adjustment, localLength));
                break;
            default:
                Collections.addAll(buffers, s.nioBuffers(index - adjustment, localLength));
            }
            
            index += localLength;
            length -= localLength;
            i++;
        }
        
        return buffers.toArray(new ByteBuffer[buffers.size()]);
    }
    
    /**
     * ğŸ”¥ åˆå¹¶ç»„ä»¶ - ä¼˜åŒ–æ€§èƒ½
     */
    public CompositeByteBuf consolidate() {
        ensureAccessible();
        final int numComponents = componentCount;
        if (numComponents <= 1) {
            return this;
        }
        
        final Component last = components[numComponents - 1];
        final int capacity = last.endOffset;
        final ByteBuf consolidated = allocBuffer(capacity);
        
        for (int i = 0; i < numComponents; i++) {
            Component c = components[i];
            ByteBuf b = c.buf;
            consolidated.writeBytes(b);
            c.freeIfNecessary();
        }
        
        Component c = new Component(consolidated);
        c.endOffset = c.length;
        components[0] = c;
        componentCount = 1;
        
        return this;
    }
}
```

---

## 4. FileRegioné›¶æ‹·è´

### 4.1 FileRegionæ¥å£å®šä¹‰

```java
/**
 * FileRegion - æ–‡ä»¶åŒºåŸŸæ¥å£
 * æ”¯æŒé›¶æ‹·è´æ–‡ä»¶ä¼ è¾“
 */
public interface FileRegion extends ReferenceCounted {
    
    /**
     * ğŸ”¥ è·å–æ–‡ä»¶èµ·å§‹ä½ç½®
     */
    long position();
    
    /**
     * ğŸ”¥ è·å–å·²ä¼ è¾“å­—èŠ‚æ•°
     */
    long transferred();
    
    /**
     * ğŸ”¥ è·å–æ€»å­—èŠ‚æ•°
     */
    long count();
    
    /**
     * ğŸ”¥ ä¼ è¾“æ•°æ®åˆ°ç›®æ ‡é€šé“
     */
    long transferTo(WritableByteChannel target, long position) throws IOException;
    
    /**
     * ğŸ”¥ è·å–å…³è”çš„æ–‡ä»¶é€šé“
     */
    FileChannel openNewFileChannel() throws IOException;
}
```

### 4.2 DefaultFileRegionå®ç°

```java
/**
 * DefaultFileRegion - é»˜è®¤æ–‡ä»¶åŒºåŸŸå®ç°
 * ä½¿ç”¨FileChannel.transferToå®ç°é›¶æ‹·è´
 */
public class DefaultFileRegion extends AbstractReferenceCounted implements FileRegion {
    
    private static final InternalLogger logger = InternalLoggerFactory.getInstance(DefaultFileRegion.class);
    
    private final File f;
    private final long position;
    private final long count;
    private long transferred;
    private FileChannel file;
    
    /**
     * ğŸ”¥ æ„é€ å‡½æ•°
     */
    public DefaultFileRegion(FileChannel file, long position, long count) {
        if (file == null) {
            throw new NullPointerException("file");
        }
        if (position < 0) {
            throw new IllegalArgumentException("position must be >= 0 but was " + position);
        }
        if (count < 0) {
            throw new IllegalArgumentException("count must be >= 0 but was " + count);
        }
        this.file = file;
        this.position = position;
        this.count = count;
        f = null;
    }
    
    public DefaultFileRegion(File file, long position, long count) {
        if (file == null) {
            throw new NullPointerException("file");
        }
        if (position < 0) {
            throw new IllegalArgumentException("position must be >= 0 but was " + position);
        }
        if (count < 0) {
            throw new IllegalArgumentException("count must be >= 0 but was " + count);
        }
        this.f = file;
        this.position = position;
        this.count = count;
    }
    
    /**
     * ğŸ”¥ ä¼ è¾“æ•°æ® - é›¶æ‹·è´æ ¸å¿ƒæ–¹æ³•
     */
    @Override
    public long transferTo(WritableByteChannel target, long position) throws IOException {
        long count = this.count - position;
        if (count < 0 || position < 0) {
            throw new IllegalArgumentException(
                    "position out of range: " + position +
                    " (expected: 0 - " + (this.count - 1) + ')');
        }
        if (count == 0) {
            return 0L;
        }
        if (refCnt() == 0) {
            throw new IllegalReferenceCountException(0);
        }
        
        // ğŸ”¥ æ‰“å¼€æ–‡ä»¶é€šé“
        open();
        
        // ğŸ”¥ ä½¿ç”¨transferToè¿›è¡Œé›¶æ‹·è´ä¼ è¾“
        long written = file.transferTo(this.position + position, count, target);
        if (written > 0) {
            transferred += written;
        } else if (written == 0) {
            // ğŸ”¥ æŸäº›ç³»ç»Ÿå¯èƒ½è¿”å›0ï¼Œéœ€è¦éªŒè¯æ˜¯å¦çœŸçš„ä¼ è¾“äº†æ•°æ®
            validate(this, position);
        }
        return written;
    }
    
    /**
     * ğŸ”¥ æ‰“å¼€æ–‡ä»¶é€šé“
     */
    private void open() throws IOException {
        if (file == null) {
            file = new RandomAccessFile(f, "r").getChannel();
        }
    }
    
    /**
     * ğŸ”¥ éªŒè¯ä¼ è¾“
     */
    private static void validate(DefaultFileRegion region, long position) throws IOException {
        long size = region.file.size();
        long count = region.count - position;
        if (region.position + count + position > size) {
            throw new IOException("Underlying file size " + size + " smaller then requested count " + region.count);
        }
    }
    
    /**
     * ğŸ”¥ è·å–ä½ç½®
     */
    @Override
    public long position() {
        return position;
    }
    
    /**
     * ğŸ”¥ è·å–å·²ä¼ è¾“å­—èŠ‚æ•°
     */
    @Override
    public long transferred() {
        return transferred;
    }
    
    /**
     * ğŸ”¥ è·å–æ€»å­—èŠ‚æ•°
     */
    @Override
    public long count() {
        return count;
    }
    
    /**
     * ğŸ”¥ é‡Šæ”¾èµ„æº
     */
    @Override
    protected void deallocate() {
        FileChannel file = this.file;
        
        if (file == null) {
            return;
        }
        this.file = null;
        
        try {
            file.close();
        } catch (IOException e) {
            logger.warn("Failed to close a file.", e);
        }
    }
    
    /**
     * ğŸ”¥ æ‰“å¼€æ–°çš„æ–‡ä»¶é€šé“
     */
    @Override
    public FileChannel openNewFileChannel() throws IOException {
        FileChannel file = this.file;
        if (file != null) {
            return file;
        }
        return new RandomAccessFile(f, "r").getChannel();
    }
}
```

### 4.3 ChunkedFileå®ç°

```java
/**
 * ChunkedFile - åˆ†å—æ–‡ä»¶ä¼ è¾“
 * æ”¯æŒå¤§æ–‡ä»¶çš„é›¶æ‹·è´ä¼ è¾“
 */
public class ChunkedFile implements ChunkedInput<ByteBuf> {
    
    private final RandomAccessFile file;
    private final long startOffset;
    private final long endOffset;
    private final int chunkSize;
    private long offset;
    
    /**
     * ğŸ”¥ æ„é€ å‡½æ•°
     */
    public ChunkedFile(RandomAccessFile file) throws IOException {
        this(file, DEFAULT_CHUNK_SIZE);
    }
    
    public ChunkedFile(RandomAccessFile file, int chunkSize) throws IOException {
        this(file, 0, file.length(), chunkSize);
    }
    
    public ChunkedFile(RandomAccessFile file, long offset, long length, int chunkSize) throws IOException {
        if (file == null) {
            throw new NullPointerException("file");
        }
        if (offset < 0) {
            throw new IllegalArgumentException("offset: " + offset + " (expected: >= 0)");
        }
        if (length < 0) {
            throw new IllegalArgumentException("length: " + length + " (expected: >= 0)");
        }
        if (chunkSize <= 0) {
            throw new IllegalArgumentException("chunkSize: " + chunkSize + " (expected: a positive integer)");
        }
        
        this.file = file;
        this.startOffset = offset;
        this.endOffset = offset + length;
        this.chunkSize = chunkSize;
        this.offset = offset;
    }
    
    /**
     * ğŸ”¥ è·å–èµ·å§‹åç§»é‡
     */
    public long startOffset() {
        return startOffset;
    }
    
    /**
     * ğŸ”¥ è·å–ç»“æŸåç§»é‡
     */
    public long endOffset() {
        return endOffset;
    }
    
    /**
     * ğŸ”¥ è·å–å½“å‰åç§»é‡
     */
    public long currentOffset() {
        return offset;
    }
    
    /**
     * ğŸ”¥ åˆ¤æ–­æ˜¯å¦ç»“æŸ
     */
    @Override
    public boolean isEndOfInput() throws Exception {
        return offset >= endOffset && !file.getChannel().isOpen();
    }
    
    /**
     * ğŸ”¥ å…³é—­èµ„æº
     */
    @Override
    public void close() throws Exception {
        file.close();
    }
    
    /**
     * ğŸ”¥ è¯»å–ä¸‹ä¸€å—æ•°æ®
     */
    @Override
    @Deprecated
    public ByteBuf readChunk(ChannelHandlerContext ctx) throws Exception {
        return readChunk(ctx.alloc());
    }
    
    @Override
    public ByteBuf readChunk(ByteBufAllocator allocator) throws Exception {
        long offset = this.offset;
        if (offset >= endOffset) {
            return null;
        }
        
        int chunkSize = (int) Math.min(this.chunkSize, endOffset - offset);
        // ğŸ”¥ æ£€æŸ¥æ˜¯å¦æ”¯æŒé›¶æ‹·è´
        ByteBuf buf = allocator.buffer(chunkSize);
        boolean release = true;
        try {
            file.seek(offset);
            int readBytes = 0;
            for (;;) {
                int localReadBytes = buf.writeBytes(file.getChannel(), chunkSize - readBytes);
                if (localReadBytes < 0) {
                    break;
                }
                readBytes += localReadBytes;
                if (readBytes == chunkSize) {
                    break;
                }
            }
            this.offset = offset + readBytes;
            release = false;
            return buf;
        } finally {
            if (release) {
                buf.release();
            }
        }
    }
    
    /**
     * ğŸ”¥ è·å–é•¿åº¦
     */
    @Override
    public long length() {
        return endOffset - startOffset;
    }
    
    /**
     * ğŸ”¥ è·å–è¿›åº¦
     */
    @Override
    public long progress() {
        return offset - startOffset;
    }
}
```

---

## 5. DirectByteBufferä¼˜åŒ–

### 5.1 PooledDirectByteBufå®ç°

```java
/**
 * PooledDirectByteBuf - æ± åŒ–ç›´æ¥å†…å­˜ByteBuf
 * ä½¿ç”¨ç›´æ¥å†…å­˜é¿å…JVMå †æ‹·è´
 */
final class PooledDirectByteBuf extends PooledByteBuf<ByteBuffer> {
    
    private static final ObjectPool<PooledDirectByteBuf> RECYCLER = ObjectPool.newPool(
            new ObjectCreator<PooledDirectByteBuf>() {
                @Override
                public PooledDirectByteBuf newObject(Handle<PooledDirectByteBuf> handle) {
                    return new PooledDirectByteBuf(handle, 0);
                }
            });
    
    /**
     * ğŸ”¥ åˆ›å»ºå®ä¾‹
     */
    static PooledDirectByteBuf newInstance(int maxCapacity) {
        PooledDirectByteBuf buf = RECYCLER.get();
        buf.reuse(maxCapacity);
        return buf;
    }
    
    /**
     * ğŸ”¥ æ„é€ å‡½æ•°
     */
    private PooledDirectByteBuf(ObjectPool.Handle<PooledDirectByteBuf> recyclerHandle, int maxCapacity) {
        super(recyclerHandle, maxCapacity);
    }
    
    /**
     * ğŸ”¥ åˆå§‹åŒ–
     */
    @Override
    void init(PoolChunk<ByteBuffer> chunk, long handle, int offset, int length, int maxLength, PoolThreadCache cache) {
        super.init(chunk, handle, offset, length, maxLength, cache);
    }
    
    /**
     * ğŸ”¥ åˆå§‹åŒ–æœªæ± åŒ–
     */
    @Override
    void initUnpooled(PoolChunk<ByteBuffer> chunk, int length) {
        super.initUnpooled(chunk, length);
    }
    
    /**
     * ğŸ”¥ è·å–å†…å­˜åœ°å€
     */
    @Override
    public long memoryAddress() {
        return PlatformDependent.directBufferAddress(memory) + offset;
    }
    
    /**
     * ğŸ”¥ æ£€æŸ¥æ˜¯å¦æœ‰å†…å­˜åœ°å€
     */
    @Override
    public boolean hasMemoryAddress() {
        return true;
    }
    
    /**
     * ğŸ”¥ è·å–å­—èŠ‚ - ç›´æ¥å†…å­˜è®¿é—®
     */
    @Override
    public byte getByte(int index) {
        checkIndex(index);
        return _getByte(index);
    }
    
    @Override
    protected byte _getByte(int index) {
        return UnsafeByteBufUtil.getByte(addr(index));
    }
    
    /**
     * ğŸ”¥ è®¾ç½®å­—èŠ‚ - ç›´æ¥å†…å­˜è®¿é—®
     */
    @Override
    public ByteBuf setByte(int index, int value) {
        checkIndex(index);
        _setByte(index, value);
        return this;
    }
    
    @Override
    protected void _setByte(int index, int value) {
        UnsafeByteBufUtil.setByte(addr(index), value);
    }
    
    /**
     * ğŸ”¥ è·å–å†…å­˜åœ°å€
     */
    private long addr(int index) {
        return PlatformDependent.directBufferAddress(memory) + idx(index);
    }
    
    /**
     * ğŸ”¥ è·å–NIOç¼“å†²åŒº - é›¶æ‹·è´
     */
    @Override
    public ByteBuffer nioBuffer(int index, int length) {
        checkIndex(index, length);
        return ((ByteBuffer) memory.duplicate().position(idx(index)).limit(idx(index) + length)).slice();
    }
    
    /**
     * ğŸ”¥ è·å–å†…éƒ¨NIOç¼“å†²åŒº
     */
    @Override
    public ByteBuffer internalNioBuffer(int index, int length) {
        checkIndex(index, length);
        return (ByteBuffer) internalNioBuffer().clear().position(idx(index)).limit(idx(index) + length);
    }
    
    /**
     * ğŸ”¥ æ£€æŸ¥æ˜¯å¦æœ‰æ•°ç»„
     */
    @Override
    public boolean hasArray() {
        return false;
    }
    
    /**
     * ğŸ”¥ è·å–æ•°ç»„ - ä¸æ”¯æŒ
     */
    @Override
    public byte[] array() {
        throw new UnsupportedOperationException("direct buffer");
    }
    
    /**
     * ğŸ”¥ è·å–æ•°ç»„åç§»é‡ - ä¸æ”¯æŒ
     */
    @Override
    public int arrayOffset() {
        throw new UnsupportedOperationException("direct buffer");
    }
    
    /**
     * ğŸ”¥ åˆ›å»ºæ–°å®ä¾‹
     */
    @Override
    protected ByteBuf newInternalBuffer(int capacity) {
        return alloc().directBuffer(capacity);
    }
}
```

### 5.2 UnsafeByteBufUtilä¼˜åŒ–

```java
/**
 * UnsafeByteBufUtil - Unsafeå­—èŠ‚ç¼“å†²åŒºå·¥å…·ç±»
 * ä½¿ç”¨Unsafeè¿›è¡Œé«˜æ€§èƒ½å†…å­˜æ“ä½œ
 */
final class UnsafeByteBufUtil {
    
    private static final boolean UNALIGNED = PlatformDependent.isUnaligned();
    private static final Unsafe UNSAFE = PlatformDependent.getUnsafe();
    
    /**
     * ğŸ”¥ è·å–å­—èŠ‚
     */
    static byte getByte(long address) {
        return UNSAFE.getByte(address);
    }
    
    /**
     * ğŸ”¥ è®¾ç½®å­—èŠ‚
     */
    static void setByte(long address, int value) {
        UNSAFE.putByte(address, (byte) value);
    }
    
    /**
     * ğŸ”¥ è·å–çŸ­æ•´å‹
     */
    static short getShort(long address) {
        if (UNALIGNED) {
            short v = UNSAFE.getShort(address);
            return BIG_ENDIAN_NATIVE_ORDER ? v : Short.reverseBytes(v);
        }
        return (short) (UNSAFE.getByte(address) << 8 | UNSAFE.getByte(address + 1) & 0xFF);
    }
    
    /**
     * ğŸ”¥ è®¾ç½®çŸ­æ•´å‹
     */
    static void setShort(long address, int value) {
        if (UNALIGNED) {
            UNSAFE.putShort(address, BIG_ENDIAN_NATIVE_ORDER ? (short) value : Short.reverseBytes((short) value));
        } else {
            UNSAFE.putByte(address, (byte) (value >>> 8));
            UNSAFE.putByte(address + 1, (byte) value);
        }
    }
    
    /**
     * ğŸ”¥ è·å–æ•´å‹
     */
    static int getInt(long address) {
        if (UNALIGNED) {
            int v = UNSAFE.getInt(address);
            return BIG_ENDIAN_NATIVE_ORDER ? v : Integer.reverseBytes(v);
        }
        return UNSAFE.getByte(address) << 24 |
               (UNSAFE.getByte(address + 1) & 0xFF) << 16 |
               (UNSAFE.getByte(address + 2) & 0xFF) << 8 |
               UNSAFE.getByte(address + 3) & 0xFF;
    }
    
    /**
     * ğŸ”¥ è®¾ç½®æ•´å‹
     */
    static void setInt(long address, int value) {
        if (UNALIGNED) {
            UNSAFE.putInt(address, BIG_ENDIAN_NATIVE_ORDER ? value : Integer.reverseBytes(value));
        } else {
            UNSAFE.putByte(address, (byte) (value >>> 24));
            UNSAFE.putByte(address + 1, (byte) (value >>> 16));
            UNSAFE.putByte(address + 2, (byte) (value >>> 8));
            UNSAFE.putByte(address + 3, (byte) value);
        }
    }
    
    /**
     * ğŸ”¥ å†…å­˜æ‹·è´ - é«˜æ€§èƒ½
     */
    static void copyMemory(long srcAddr, long dstAddr, long length) {
        // ğŸ”¥ æŒ‰8å­—èŠ‚å¯¹é½æ‹·è´
        while (length >= 8) {
            UNSAFE.putLong(dstAddr, UNSAFE.getLong(srcAddr));
            srcAddr += 8;
            dstAddr += 8;
            length -= 8;
        }
        
        // ğŸ”¥ æ‹·è´å‰©ä½™å­—èŠ‚
        if (length >= 4) {
            UNSAFE.putInt(dstAddr, UNSAFE.getInt(srcAddr));
            srcAddr += 4;
            dstAddr += 4;
            length -= 4;
        }
        if (length >= 2) {
            UNSAFE.putShort(dstAddr, UNSAFE.getShort(srcAddr));
            srcAddr += 2;
            dstAddr += 2;
            length -= 2;
        }
        if (length == 1) {
            UNSAFE.putByte(dstAddr, UNSAFE.getByte(srcAddr));
        }
    }
    
    /**
     * ğŸ”¥ è®¾ç½®å†…å­˜
     */
    static void setMemory(long address, long bytes, byte value) {
        UNSAFE.setMemory(address, bytes, value);
    }
}
```

---

## 6. æ€§èƒ½æµ‹è¯•ä¸å¯¹æ¯”

### 6.1 é›¶æ‹·è´æ€§èƒ½æµ‹è¯•

```java
/**
 * é›¶æ‹·è´æ€§èƒ½æµ‹è¯•
 */
public class ZeroCopyBenchmark {
    
    private static final int BUFFER_SIZE = 1024 * 1024; // 1MB
    private static final int ITERATIONS = 1000;
    
    /**
     * ğŸ”¥ ä¼ ç»Ÿæ‹·è´æµ‹è¯•
     */
    @Benchmark
    public void traditionalCopy() {
        byte[] src = new byte[BUFFER_SIZE];
        byte[] dst = new byte[BUFFER_SIZE];
        
        long start = System.nanoTime();
        for (int i = 0; i < ITERATIONS; i++) {
            System.arraycopy(src, 0, dst, 0, BUFFER_SIZE);
        }
        long end = System.nanoTime();
        
        System.out.println("Traditional copy: " + (end - start) / 1_000_000 + " ms");
    }
    
    /**
     * ğŸ”¥ ByteBufåˆ‡ç‰‡æµ‹è¯•
     */
    @Benchmark
    public void byteBufSlice() {
        ByteBuf buffer = Unpooled.buffer(BUFFER_SIZE);
        buffer.writeBytes(new byte[BUFFER_SIZE]);
        
        long start = System.nanoTime();
        for (int i = 0; i < ITERATIONS; i++) {
            ByteBuf slice = buffer.slice();
            slice.release();
        }
        long end = System.nanoTime();
        
        buffer.release();
        System.out.println("ByteBuf slice: " + (end - start) / 1_000_000 + " ms");
    }
    
    /**
     * ğŸ”¥ CompositeByteBufæµ‹è¯•
     */
    @Benchmark
    public void compositeByteBuf() {
        ByteBuf buf1 = Unpooled.buffer(BUFFER_SIZE / 2);
        ByteBuf buf2 = Unpooled.buffer(BUFFER_SIZE / 2);
        buf1.writeBytes(new byte[BUFFER_SIZE / 2]);
        buf2.writeBytes(new byte[BUFFER_SIZE / 2]);
        
        long start = System.nanoTime();
        for (int i = 0; i < ITERATIONS; i++) {
            CompositeByteBuf composite = Unpooled.compositeBuffer();
            composite.addComponents(true, buf1.retain(), buf2.retain());
            composite.release();
        }
        long end = System.nanoTime();
        
        buf1.release();
        buf2.release();
        System.out.println("CompositeByteBuf: " + (end - start) / 1_000_000 + " ms");
    }
    
    /**
     * ğŸ”¥ ç›´æ¥å†…å­˜æµ‹è¯•
     */
    @Benchmark
    public void directMemory() {
        long start = System.nanoTime();
        for (int i = 0; i < ITERATIONS; i++) {
            ByteBuf buffer = Unpooled.directBuffer(BUFFER_SIZE);
            buffer.writeBytes(new byte[BUFFER_SIZE]);
            buffer.release();
        }
        long end = System.nanoTime();
        
        System.out.println("Direct memory: " + (end - start) / 1_000_000 + " ms");
    }
    
    /**
     * ğŸ”¥ æ–‡ä»¶ä¼ è¾“æµ‹è¯•
     */
    @Benchmark
    public void fileTransfer() throws IOException {
        File tempFile = File.createTempFile("test", ".dat");
        try (RandomAccessFile raf = new RandomAccessFile(tempFile, "rw")) {
            raf.write(new byte[BUFFER_SIZE]);
        }
        
        long start = System.nanoTime();
        for (int i = 0; i < ITERATIONS; i++) {
            try (FileChannel channel = new RandomAccessFile(tempFile, "r").getChannel()) {
                FileRegion region = new DefaultFileRegion(channel, 0, BUFFER_SIZE);
                // æ¨¡æ‹Ÿä¼ è¾“
                region.retain();
                region.release();
            }
        }
        long end = System.nanoTime();
        
        tempFile.delete();
        System.out.println("File transfer: " + (end - start) / 1_000_000 + " ms");
    }
    
    /**
     * ğŸ”¥ è¿è¡Œæ‰€æœ‰æµ‹è¯•
     */
    public static void main(String[] args) throws IOException {
        ZeroCopyBenchmark benchmark = new ZeroCopyBenchmark();
        
        // é¢„çƒ­
        for (int i = 0; i < 100; i++) {
            benchmark.traditionalCopy();
            benchmark.byteBufSlice();
            benchmark.compositeByteBuf();
            benchmark.directMemory();
        }
        
        // æ­£å¼æµ‹è¯•
        System.out.println("=== Zero Copy Performance Test ===");
        benchmark.traditionalCopy();
        benchmark.byteBufSlice();
        benchmark.compositeByteBuf();
        benchmark.directMemory();
        benchmark.fileTransfer();
    }
}
```

### 6.2 å†…å­˜ä½¿ç”¨å¯¹æ¯”

```java
/**
 * å†…å­˜ä½¿ç”¨å¯¹æ¯”æµ‹è¯•
 */
public class MemoryUsageComparison {
    
    /**
     * ğŸ”¥ å †å†…å­˜ vs ç›´æ¥å†…å­˜
     */
    public void heapVsDirectMemory() {
        int bufferSize = 1024 * 1024; // 1MB
        int bufferCount = 1000;
        
        // ğŸ”¥ å †å†…å­˜æµ‹è¯•
        long heapStart = getUsedMemory();
        List<ByteBuf> heapBuffers = new ArrayList<>();
        for (int i = 0; i < bufferCount; i++) {
            heapBuffers.add(Unpooled.buffer(bufferSize));
        }
        long heapEnd = getUsedMemory();
        
        // ğŸ”¥ ç›´æ¥å†…å­˜æµ‹è¯•
        long directStart = getUsedMemory();
        List<ByteBuf> directBuffers = new ArrayList<>();
        for (int i = 0; i < bufferCount; i++) {
            directBuffers.add(Unpooled.directBuffer(bufferSize));
        }
        long directEnd = getUsedMemory();
        
        System.out.println("Heap memory usage: " + (heapEnd - heapStart) / 1024 / 1024 + " MB");
        System.out.println("Direct memory usage: " + (directEnd - directStart) / 1024 / 1024 + " MB");
        
        // æ¸…ç†èµ„æº
        heapBuffers.forEach(ByteBuf::release);
        directBuffers.forEach(ByteBuf::release);
    }
    
    /**
     * ğŸ”¥ ä¼ ç»Ÿæ‹·è´ vs é›¶æ‹·è´
     */
    public void copyVsZeroCopy() {
        int bufferSize = 1024 * 1024; // 1MB
        byte[] data = new byte[bufferSize];
        
        // ğŸ”¥ ä¼ ç»Ÿæ‹·è´
        long copyStart = System.currentTimeMillis();
        ByteBuf buffer1 = Unpooled.buffer(bufferSize);
        ByteBuf buffer2 = Unpooled.buffer(bufferSize);
        buffer1.writeBytes(data);
        buffer2.writeBytes(buffer1, 0, bufferSize); // æ‹·è´æ•°æ®
        long copyEnd = System.currentTimeMillis();
        
        // ğŸ”¥ é›¶æ‹·è´
        long zeroCopyStart = System.currentTimeMillis();
        ByteBuf buffer3 = Unpooled.wrappedBuffer(data);
        ByteBuf slice = buffer3.slice(); // é›¶æ‹·è´åˆ‡ç‰‡
        long zeroCopyEnd = System.currentTimeMillis();
        
        System.out.println("Traditional copy time: " + (copyEnd - copyStart) + " ms");
        System.out.println("Zero copy time: " + (zeroCopyEnd - zeroCopyStart) + " ms");
        
        // æ¸…ç†èµ„æº
        buffer1.release();
        buffer2.release();
        buffer3.release();
    }
    
    /**
     * ğŸ”¥ è·å–å·²ä½¿ç”¨å†…å­˜
     */
    private long getUsedMemory() {
        Runtime runtime = Runtime.getRuntime();
        return runtime.totalMemory() - runtime.freeMemory();
    }
}
```

---

## 7. é¢è¯•è¦ç‚¹

### 7.1 æ ¸å¿ƒæ¦‚å¿µ

```
ğŸ¯ é›¶æ‹·è´é¢è¯•è¦ç‚¹

1. é›¶æ‹·è´å®šä¹‰
   Q: ä»€ä¹ˆæ˜¯é›¶æ‹·è´ï¼Ÿ
   A: 
   - é¿å…åœ¨ç”¨æˆ·ç©ºé—´å’Œå†…æ ¸ç©ºé—´ä¹‹é—´æ‹·è´æ•°æ®
   - å‡å°‘CPUå¼€é”€å’Œå†…å­˜å¸¦å®½æ¶ˆè€—
   - æé«˜I/Oæ€§èƒ½å’Œç³»ç»Ÿååé‡
   - åŒ…æ‹¬æ“ä½œç³»ç»Ÿçº§å’Œåº”ç”¨çº§é›¶æ‹·è´

2. Nettyé›¶æ‹·è´æŠ€æœ¯
   Q: Nettyæœ‰å“ªäº›é›¶æ‹·è´æŠ€æœ¯ï¼Ÿ
   A:
   - CompositeByteBufï¼šé€»è¾‘ç»„åˆå¤šä¸ªç¼“å†²åŒº
   - slice()æ“ä½œï¼šå…±äº«åº•å±‚å­˜å‚¨
   - DirectByteBufferï¼šç›´æ¥å†…å­˜ï¼Œå‡å°‘æ‹·è´
   - FileRegionï¼šæ–‡ä»¶ç›´æ¥ä¼ è¾“

3. CompositeByteBufåŸç†
   Q: CompositeByteBufå¦‚ä½•å®ç°é›¶æ‹·è´ï¼Ÿ
   A:
   - ç»´æŠ¤ç»„ä»¶æ•°ç»„ï¼Œé€»è¾‘ç»„åˆå¤šä¸ªByteBuf
   - é€šè¿‡åç§»é‡è®¡ç®—å®é™…ä½ç½®
   - é¿å…å®é™…çš„å†…å­˜æ‹·è´æ“ä½œ
   - æ”¯æŒåŠ¨æ€æ·»åŠ å’Œåˆ é™¤ç»„ä»¶

4. ç›´æ¥å†…å­˜ä¼˜åŠ¿
   Q: ç›´æ¥å†…å­˜æœ‰ä»€ä¹ˆä¼˜åŠ¿ï¼Ÿ
   A:
   - é¿å…JVMå †å†…å­˜æ‹·è´
   - å‡å°‘GCå‹åŠ›
   - æ›´æ¥è¿‘æ“ä½œç³»ç»Ÿï¼ŒI/Oæ•ˆç‡é«˜
   - æ”¯æŒå†…å­˜æ˜ å°„æ–‡ä»¶
```

### 7.2 å®é™…åº”ç”¨

```
ğŸ”§ å®é™…åº”ç”¨åœºæ™¯

1. å¤§æ–‡ä»¶ä¼ è¾“
   åœºæ™¯: ä¼ è¾“å¤§æ–‡ä»¶åˆ°å®¢æˆ·ç«¯
   æ–¹æ¡ˆ:
   - ä½¿ç”¨FileRegionè¿›è¡Œé›¶æ‹·è´ä¼ è¾“
   - åˆ†å—ä¼ è¾“é¿å…å†…å­˜å ç”¨è¿‡å¤§
   - ä½¿ç”¨ChunkedWriteHandlerå¤„ç†
   - ç›‘æ§ä¼ è¾“è¿›åº¦å’Œé”™è¯¯å¤„ç†

2. åè®®ç»„è£…
   åœºæ™¯: ç»„è£…å¤æ‚çš„ç½‘ç»œåè®®
   æ–¹æ¡ˆ:
   - ä½¿ç”¨CompositeByteBufç»„åˆå¤´éƒ¨å’Œæ•°æ®
   - é¿å…å¤šæ¬¡å†…å­˜æ‹·è´
   - æ”¯æŒåŠ¨æ€æ·»åŠ åè®®å­—æ®µ
   - æé«˜åè®®å¤„ç†æ€§èƒ½

3. æ•°æ®è½¬å‘
   åœºæ™¯: ä»£ç†æœåŠ¡å™¨è½¬å‘æ•°æ®
   æ–¹æ¡ˆ:
   - ä½¿ç”¨slice()åˆ›å»ºæ•°æ®è§†å›¾
   - é¿å…ä¸å¿…è¦çš„æ•°æ®æ‹·è´
   - ä¿æŒåŸå§‹æ•°æ®å¼•ç”¨
   - å®ç°é«˜æ€§èƒ½æ•°æ®è½¬å‘

4. ç¼“å­˜ç³»ç»Ÿ
   åœºæ™¯: å®ç°é«˜æ€§èƒ½ç¼“å­˜
   æ–¹æ¡ˆ:
   - ä½¿ç”¨ç›´æ¥å†…å­˜å­˜å‚¨æ•°æ®
   - å‡å°‘åºåˆ—åŒ–å¼€é”€
   - æ”¯æŒå†…å­˜æ˜ å°„æ–‡ä»¶
   - ä¼˜åŒ–å†…å­˜ä½¿ç”¨æ•ˆç‡
```

### 7.3 å¸¸è§é—®é¢˜

```
â“ å¸¸è§é¢è¯•é—®é¢˜

Q1: slice()å’Œduplicate()æœ‰ä»€ä¹ˆåŒºåˆ«ï¼Ÿ
A1: 
- slice()ï¼šåˆ›å»ºå½“å‰ç¼“å†²åŒºçš„åˆ‡ç‰‡ï¼Œå…±äº«æ•°æ®ä½†æœ‰ç‹¬ç«‹çš„è¯»å†™ç´¢å¼•
- duplicate()ï¼šåˆ›å»ºå½“å‰ç¼“å†²åŒºçš„å‰¯æœ¬ï¼Œå…±äº«æ•°æ®å’Œè¯»å†™ç´¢å¼•
- ä¸¤è€…éƒ½æ˜¯é›¶æ‹·è´æ“ä½œï¼Œå…±äº«åº•å±‚å­˜å‚¨

Q2: ç›´æ¥å†…å­˜æœ‰ä»€ä¹ˆç¼ºç‚¹ï¼Ÿ
A2:
- åˆ†é…å’Œé‡Šæ”¾æˆæœ¬è¾ƒé«˜
- ä¸å—JVMå †å¤§å°é™åˆ¶ï¼Œå¯èƒ½å¯¼è‡´OOM
- éš¾ä»¥è°ƒè¯•å’Œç›‘æ§
- éœ€è¦æ‰‹åŠ¨ç®¡ç†ç”Ÿå‘½å‘¨æœŸ

Q3: CompositeByteBufçš„æ€§èƒ½ç‰¹ç‚¹ï¼Ÿ
A3:
- ç»„åˆæ“ä½œæ˜¯O(1)æ—¶é—´å¤æ‚åº¦
- éšæœºè®¿é—®å¯èƒ½è¾ƒæ…¢ï¼ˆéœ€è¦æŸ¥æ‰¾ç»„ä»¶ï¼‰
- é€‚åˆé¡ºåºè®¿é—®å’Œè¿½åŠ æ“ä½œ
- å¯ä»¥é€šè¿‡consolidate()ä¼˜åŒ–æ€§èƒ½

Q4: FileRegioné€‚ç”¨äºä»€ä¹ˆåœºæ™¯ï¼Ÿ
A4:
- å¤§æ–‡ä»¶ä¼ è¾“ï¼ˆå¦‚æ–‡ä»¶ä¸‹è½½ï¼‰
- é™æ€èµ„æºæœåŠ¡
- æ—¥å¿—æ–‡ä»¶ä¼ è¾“
- ä¸é€‚åˆå°æ–‡ä»¶æˆ–éœ€è¦æ•°æ®å¤„ç†çš„åœºæ™¯

Q5: å¦‚ä½•é€‰æ‹©åˆé€‚çš„é›¶æ‹·è´æŠ€æœ¯ï¼Ÿ
A5:
- æ–‡ä»¶ä¼ è¾“ï¼šä½¿ç”¨FileRegion
- åè®®ç»„è£…ï¼šä½¿ç”¨CompositeByteBuf
- æ•°æ®åˆ‡åˆ†ï¼šä½¿ç”¨slice()
- é«˜æ€§èƒ½I/Oï¼šä½¿ç”¨DirectByteBuffer
```

### 7.3 æœ€ä½³å®è·µ

```
âœ… å¼€å‘æœ€ä½³å®è·µ

1. åˆç†é€‰æ‹©æŠ€æœ¯
   - æ ¹æ®ä½¿ç”¨åœºæ™¯é€‰æ‹©åˆé€‚çš„é›¶æ‹·è´æŠ€æœ¯
   - è€ƒè™‘æ€§èƒ½å’Œå†…å­˜ä½¿ç”¨çš„å¹³è¡¡
   - é¿å…è¿‡åº¦ä¼˜åŒ–
   - è¿›è¡Œæ€§èƒ½æµ‹è¯•éªŒè¯æ•ˆæœ

2. å†…å­˜ç®¡ç†
   - æ­£ç¡®ç®¡ç†ByteBufçš„ç”Ÿå‘½å‘¨æœŸ
   - åŠæ—¶é‡Šæ”¾ä¸å†ä½¿ç”¨çš„ç¼“å†²åŒº
   - ç›‘æ§ç›´æ¥å†…å­˜ä½¿ç”¨æƒ…å†µ
   - é¿å…å†…å­˜æ³„æ¼

3. æ€§èƒ½ä¼˜åŒ–
   - ä½¿ç”¨å¯¹è±¡æ± å‡å°‘åˆ†é…å¼€é”€
   - åˆç†è®¾ç½®ç¼“å†²åŒºå¤§å°
   - é¿å…é¢‘ç¹çš„å°å¯¹è±¡åˆ›å»º
   - ä½¿ç”¨æ‰¹é‡æ“ä½œæé«˜æ•ˆç‡

4. é”™è¯¯å¤„ç†
   - å¤„ç†é›¶æ‹·è´æ“ä½œçš„å¼‚å¸¸æƒ…å†µ
   - å®ç°é™çº§æ–¹æ¡ˆ
   - ç›‘æ§æ€§èƒ½æŒ‡æ ‡
   - è®°å½•è¯¦ç»†çš„é”™è¯¯æ—¥å¿—
```

---

## ğŸ“‹ æ€»ç»“

Nettyçš„é›¶æ‹·è´æŠ€æœ¯é€šè¿‡å¤šç§æœºåˆ¶å®ç°äº†é«˜æ€§èƒ½çš„æ•°æ®å¤„ç†ï¼ŒåŒ…æ‹¬CompositeByteBufçš„é€»è¾‘ç»„åˆã€sliceæ“ä½œçš„è§†å›¾å…±äº«ã€FileRegionçš„æ–‡ä»¶ç›´ä¼ å’ŒDirectByteBufferçš„ç›´æ¥å†…å­˜è®¿é—®ã€‚è¿™äº›æŠ€æœ¯å¤§å¤§å‡å°‘äº†ä¸å¿…è¦çš„å†…å­˜æ‹·è´ï¼Œæé«˜äº†ç½‘ç»œI/Oçš„æ€§èƒ½ã€‚

**æ ¸å¿ƒè¦ç‚¹**ï¼š
- **å¤šå±‚æ¬¡ä¼˜åŒ–**ï¼šä»æ“ä½œç³»ç»Ÿåˆ°åº”ç”¨å±‚çš„å…¨æ–¹ä½é›¶æ‹·è´ä¼˜åŒ–
- **çµæ´»ç»„åˆ**ï¼šä¸åŒåœºæ™¯ä½¿ç”¨ä¸åŒçš„é›¶æ‹·è´æŠ€æœ¯
- **æ€§èƒ½æå‡**ï¼šæ˜¾è‘—å‡å°‘CPUå¼€é”€å’Œå†…å­˜å¸¦å®½æ¶ˆè€—
- **èµ„æºç®¡ç†**ï¼šéœ€è¦æ­£ç¡®ç®¡ç†ç›´æ¥å†…å­˜å’Œå¼•ç”¨è®¡æ•°

æŒæ¡é›¶æ‹·è´æŠ€æœ¯çš„åŸç†å’Œåº”ç”¨ï¼Œæ˜¯æ„å»ºé«˜æ€§èƒ½ç½‘ç»œåº”ç”¨çš„é‡è¦æŠ€èƒ½ã€‚
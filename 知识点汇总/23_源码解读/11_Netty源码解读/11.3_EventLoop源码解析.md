# EventLoopæºç è§£æ

> ğŸ’¡ æ·±å…¥ç†è§£Nettyäº‹ä»¶å¾ªç¯æœºåˆ¶çš„æ ¸å¿ƒå®ç°

---

## ğŸ“‹ ç›®å½•

- [1. EventLoopæ¦‚è¿°](#1-eventloopæ¦‚è¿°)
- [2. ç»§æ‰¿ä½“ç³»](#2-ç»§æ‰¿ä½“ç³»)
- [3. NioEventLoopæ ¸å¿ƒå®ç°](#3-nioeventloopæ ¸å¿ƒå®ç°)
- [4. ä»»åŠ¡è°ƒåº¦æœºåˆ¶](#4-ä»»åŠ¡è°ƒåº¦æœºåˆ¶)
- [5. é¢è¯•è¦ç‚¹](#5-é¢è¯•è¦ç‚¹)

---

## 1. EventLoopæ¦‚è¿°

### 1.1 ä»€ä¹ˆæ˜¯EventLoop

```
EventLoopæ˜¯Nettyçš„æ ¸å¿ƒç»„ä»¶ï¼Œè´Ÿè´£ï¼š
1. å¤„ç†IOäº‹ä»¶ï¼ˆè¯»ã€å†™ã€è¿æ¥ã€æ¥æ”¶ï¼‰
2. æ‰§è¡Œæ™®é€šä»»åŠ¡ï¼ˆRunnableï¼‰
3. æ‰§è¡Œå®šæ—¶ä»»åŠ¡ï¼ˆScheduledFutureï¼‰

æ ¸å¿ƒç‰¹ç‚¹ï¼š
- å•çº¿ç¨‹æ‰§è¡Œï¼Œé¿å…å¹¶å‘é—®é¢˜
- ä¸€ä¸ªEventLoopå¯ä»¥å¤„ç†å¤šä¸ªChannel
- ä¸€ä¸ªChannelåªä¼šç»‘å®šä¸€ä¸ªEventLoop
```

### 1.2 EventLoopä¸Channelçš„å…³ç³»

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    EventLoopGroup                            â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”           â”‚
â”‚  â”‚ EventLoop-1 â”‚ â”‚ EventLoop-2 â”‚ â”‚ EventLoop-3 â”‚  ...      â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”  â”‚ â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”  â”‚ â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”  â”‚           â”‚
â”‚  â”‚  â”‚Channelâ”‚  â”‚ â”‚  â”‚Channelâ”‚  â”‚ â”‚  â”‚Channelâ”‚  â”‚           â”‚
â”‚  â”‚  â”‚Channelâ”‚  â”‚ â”‚  â”‚Channelâ”‚  â”‚ â”‚  â”‚Channelâ”‚  â”‚           â”‚
â”‚  â”‚  â”‚Channelâ”‚  â”‚ â”‚  â”‚Channelâ”‚  â”‚ â”‚  â”‚Channelâ”‚  â”‚           â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚ â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚ â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚           â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Channelåˆ†é…ç­–ç•¥ï¼š
- é»˜è®¤ä½¿ç”¨è½®è¯¢ï¼ˆRound-Robinï¼‰
- ä¿è¯è´Ÿè½½å‡è¡¡
```

---

## 2. ç»§æ‰¿ä½“ç³»

### 2.1 EventLoopGroupç»§æ‰¿ä½“ç³»

```
java.util.concurrent.Executor
â””â”€â”€ java.util.concurrent.ExecutorService
    â””â”€â”€ java.util.concurrent.ScheduledExecutorService
        â””â”€â”€ io.netty.util.concurrent.EventExecutorGroup
            â””â”€â”€ io.netty.channel.EventLoopGroup
                â””â”€â”€ io.netty.channel.MultithreadEventLoopGroup
                    â”œâ”€â”€ io.netty.channel.nio.NioEventLoopGroup
                    â”œâ”€â”€ io.netty.channel.epoll.EpollEventLoopGroup
                    â””â”€â”€ io.netty.channel.kqueue.KQueueEventLoopGroup
```

### 2.2 EventLoopç»§æ‰¿ä½“ç³»

```
java.util.concurrent.Executor
â””â”€â”€ io.netty.util.concurrent.EventExecutor
    â””â”€â”€ io.netty.util.concurrent.OrderedEventExecutor
        â””â”€â”€ io.netty.channel.EventLoop
            â””â”€â”€ io.netty.channel.SingleThreadEventLoop
                â”œâ”€â”€ io.netty.channel.nio.NioEventLoop
                â”œâ”€â”€ io.netty.channel.epoll.EpollEventLoop
                â””â”€â”€ io.netty.channel.kqueue.KQueueEventLoop
```

### 2.3 æ ¸å¿ƒæ¥å£

```java
// EventExecutorGroupï¼šäº‹ä»¶æ‰§è¡Œå™¨ç»„
public interface EventExecutorGroup extends ScheduledExecutorService, Iterable<EventExecutor> {
    // æ˜¯å¦æ­£åœ¨å…³é—­
    boolean isShuttingDown();
    
    // ä¼˜é›…å…³é—­
    Future<?> shutdownGracefully();
    
    // è·å–ä¸‹ä¸€ä¸ªEventExecutor
    EventExecutor next();
}

// EventLoopGroupï¼šäº‹ä»¶å¾ªç¯ç»„
public interface EventLoopGroup extends EventExecutorGroup {
    // è·å–ä¸‹ä¸€ä¸ªEventLoop
    @Override
    EventLoop next();
    
    // æ³¨å†ŒChannel
    ChannelFuture register(Channel channel);
    
    // æ³¨å†ŒChannelå¹¶è¿”å›Promise
    ChannelFuture register(ChannelPromise promise);
}

// EventLoopï¼šäº‹ä»¶å¾ªç¯
public interface EventLoop extends OrderedEventExecutor, EventLoopGroup {
    // è·å–æ‰€å±çš„EventLoopGroup
    @Override
    EventLoopGroup parent();
}
```

---

## 3. NioEventLoopæ ¸å¿ƒå®ç°

### 3.1 NioEventLoopç»“æ„

```java
public final class NioEventLoop extends SingleThreadEventLoop {
    
    // Selectoræä¾›è€…
    private final SelectorProvider provider;
    
    // Selector
    private Selector selector;
    private Selector unwrappedSelector;
    
    // é€‰æ‹©é”®é›†åˆ
    private SelectedSelectionKeySet selectedKeys;
    
    // æ˜¯å¦éœ€è¦å”¤é†’
    private final AtomicBoolean wakenUp = new AtomicBoolean();
    
    // IOæ¯”ç‡ï¼ˆIOä»»åŠ¡ä¸æ™®é€šä»»åŠ¡çš„æ—¶é—´æ¯”ï¼‰
    private volatile int ioRatio = 50;
    
    // å–æ¶ˆçš„é”®æ•°é‡
    private int cancelledKeys;
    
    // æ˜¯å¦éœ€è¦å†æ¬¡select
    private boolean needsToSelectAgain;
}
```

### 3.2 runæ–¹æ³•æ ¸å¿ƒé€»è¾‘

```java
@Override
protected void run() {
    int selectCnt = 0;
    for (;;) {
        try {
            int strategy;
            try {
                // 1. è®¡ç®—selectç­–ç•¥
                strategy = selectStrategy.calculateStrategy(selectNowSupplier, hasTasks());
                switch (strategy) {
                case SelectStrategy.CONTINUE:
                    continue;
                case SelectStrategy.BUSY_WAIT:
                    // NIOä¸æ”¯æŒbusy-wait
                case SelectStrategy.SELECT:
                    // 2. æ‰§è¡Œselect
                    long curDeadlineNanos = nextScheduledTaskDeadlineNanos();
                    if (curDeadlineNanos == -1L) {
                        curDeadlineNanos = NONE;
                    }
                    nextWakeupNanos.set(curDeadlineNanos);
                    try {
                        if (!hasTasks()) {
                            strategy = select(curDeadlineNanos);
                        }
                    } finally {
                        nextWakeupNanos.lazySet(AWAKE);
                    }
                default:
                }
            } catch (IOException e) {
                rebuildSelector0();
                selectCnt = 0;
                continue;
            }
            
            selectCnt++;
            cancelledKeys = 0;
            needsToSelectAgain = false;
            final int ioRatio = this.ioRatio;
            boolean ranTasks;
            
            // 3. å¤„ç†IOäº‹ä»¶å’Œä»»åŠ¡
            if (ioRatio == 100) {
                try {
                    if (strategy > 0) {
                        processSelectedKeys();
                    }
                } finally {
                    ranTasks = runAllTasks();
                }
            } else if (strategy > 0) {
                final long ioStartTime = System.nanoTime();
                try {
                    processSelectedKeys();
                } finally {
                    final long ioTime = System.nanoTime() - ioStartTime;
                    ranTasks = runAllTasks(ioTime * (100 - ioRatio) / ioRatio);
                }
            } else {
                ranTasks = runAllTasks(0);
            }
            
            if (ranTasks || strategy > 0) {
                if (selectCnt > MIN_PREMATURE_SELECTOR_RETURNS && logger.isDebugEnabled()) {
                    logger.debug("...");
                }
                selectCnt = 0;
            } else if (unexpectedSelectorWakeup(selectCnt)) {
                // 4. å¤„ç†ç©ºè½®è¯¢Bug
                selectCnt = 0;
            }
        } catch (CancelledKeyException e) {
            // å¿½ç•¥
        } catch (Throwable t) {
            handleLoopException(t);
        }
        
        // 5. æ£€æŸ¥æ˜¯å¦å…³é—­
        try {
            if (isShuttingDown()) {
                closeAll();
                if (confirmShutdown()) {
                    return;
                }
            }
        } catch (Throwable t) {
            handleLoopException(t);
        }
    }
}
```

### 3.3 selectæ–¹æ³•

```java
private int select(long deadlineNanos) throws IOException {
    if (deadlineNanos == NONE) {
        // æ— é™ç­‰å¾…
        return selector.select();
    }
    
    // è®¡ç®—è¶…æ—¶æ—¶é—´
    long timeoutMillis = deadlineToDelayNanos(deadlineNanos + 995000L) / 1000000L;
    return timeoutMillis <= 0 ? selector.selectNow() : selector.select(timeoutMillis);
}
```

### 3.4 processSelectedKeysæ–¹æ³•

```java
private void processSelectedKeys() {
    if (selectedKeys != null) {
        // ä¼˜åŒ–çš„æ–¹å¼ï¼šä½¿ç”¨æ•°ç»„
        processSelectedKeysOptimized();
    } else {
        // æ™®é€šæ–¹å¼ï¼šä½¿ç”¨Set
        processSelectedKeysPlain(selector.selectedKeys());
    }
}

private void processSelectedKeysOptimized() {
    for (int i = 0; i < selectedKeys.size; ++i) {
        final SelectionKey k = selectedKeys.keys[i];
        // æ¸…ç©ºå¼•ç”¨ï¼Œå¸®åŠ©GC
        selectedKeys.keys[i] = null;
        
        final Object a = k.attachment();
        
        if (a instanceof AbstractNioChannel) {
            // å¤„ç†Netty Channel
            processSelectedKey(k, (AbstractNioChannel) a);
        } else {
            // å¤„ç†NioTask
            NioTask<SelectableChannel> task = (NioTask<SelectableChannel>) a;
            processSelectedKey(k, task);
        }
        
        if (needsToSelectAgain) {
            selectedKeys.reset(i + 1);
            selectAgain();
            i = -1;
        }
    }
}

private void processSelectedKey(SelectionKey k, AbstractNioChannel ch) {
    final AbstractNioChannel.NioUnsafe unsafe = ch.unsafe();
    
    if (!k.isValid()) {
        // é”®æ— æ•ˆï¼Œå…³é—­Channel
        final EventLoop eventLoop;
        try {
            eventLoop = ch.eventLoop();
        } catch (Throwable ignored) {
            return;
        }
        if (eventLoop == this) {
            unsafe.close(unsafe.voidPromise());
        }
        return;
    }
    
    try {
        int readyOps = k.readyOps();
        
        // å¤„ç†è¿æ¥äº‹ä»¶
        if ((readyOps & SelectionKey.OP_CONNECT) != 0) {
            int ops = k.interestOps();
            ops &= ~SelectionKey.OP_CONNECT;
            k.interestOps(ops);
            unsafe.finishConnect();
        }
        
        // å¤„ç†å†™äº‹ä»¶
        if ((readyOps & SelectionKey.OP_WRITE) != 0) {
            ch.unsafe().forceFlush();
        }
        
        // å¤„ç†è¯»äº‹ä»¶ï¼ˆåŒ…æ‹¬Acceptï¼‰
        if ((readyOps & (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) != 0 || readyOps == 0) {
            unsafe.read();
        }
    } catch (CancelledKeyException ignored) {
        unsafe.close(unsafe.voidPromise());
    }
}
```

### 3.5 ç©ºè½®è¯¢Bugå¤„ç†

```java
private boolean unexpectedSelectorWakeup(int selectCnt) {
    if (Thread.interrupted()) {
        return true;
    }
    // æ£€æµ‹ç©ºè½®è¯¢
    if (SELECTOR_AUTO_REBUILD_THRESHOLD > 0 &&
            selectCnt >= SELECTOR_AUTO_REBUILD_THRESHOLD) {
        // é‡å»ºSelector
        logger.warn("Selector.select() returned prematurely {} times in a row; " +
                "rebuilding Selector {}.", selectCnt, selector);
        rebuildSelector();
        return true;
    }
    return false;
}

public void rebuildSelector() {
    if (!inEventLoop()) {
        execute(new Runnable() {
            @Override
            public void run() {
                rebuildSelector0();
            }
        });
        return;
    }
    rebuildSelector0();
}

private void rebuildSelector0() {
    final Selector oldSelector = selector;
    final SelectorTuple newSelectorTuple;
    
    if (oldSelector == null) {
        return;
    }
    
    try {
        // åˆ›å»ºæ–°Selector
        newSelectorTuple = openSelector();
    } catch (Exception e) {
        logger.warn("Failed to create a new Selector.", e);
        return;
    }
    
    // è¿ç§»æ‰€æœ‰Channelåˆ°æ–°Selector
    int nChannels = 0;
    for (SelectionKey key : oldSelector.keys()) {
        Object a = key.attachment();
        try {
            if (!key.isValid() || key.channel().keyFor(newSelectorTuple.unwrappedSelector) != null) {
                continue;
            }
            
            int interestOps = key.interestOps();
            key.cancel();
            SelectionKey newKey = key.channel().register(
                newSelectorTuple.unwrappedSelector, interestOps, a);
            if (a instanceof AbstractNioChannel) {
                ((AbstractNioChannel) a).selectionKey = newKey;
            }
            nChannels++;
        } catch (Exception e) {
            // å¤„ç†å¼‚å¸¸...
        }
    }
    
    selector = newSelectorTuple.selector;
    unwrappedSelector = newSelectorTuple.unwrappedSelector;
    
    try {
        oldSelector.close();
    } catch (Throwable t) {
        // å¿½ç•¥
    }
    
    logger.info("Migrated " + nChannels + " channel(s) to the new Selector.");
}
```


---

## 4. ä»»åŠ¡è°ƒåº¦æœºåˆ¶

### 4.1 ä»»åŠ¡é˜Ÿåˆ—

```java
// SingleThreadEventExecutorä¸­çš„ä»»åŠ¡é˜Ÿåˆ—
public abstract class SingleThreadEventExecutor extends AbstractScheduledEventExecutor {
    
    // æ™®é€šä»»åŠ¡é˜Ÿåˆ—
    private final Queue<Runnable> taskQueue;
    
    // å°¾éƒ¨ä»»åŠ¡é˜Ÿåˆ—ï¼ˆåœ¨æ¯æ¬¡äº‹ä»¶å¾ªç¯ç»“æŸæ—¶æ‰§è¡Œï¼‰
    private final Queue<Runnable> tailTasks;
    
    // åˆ›å»ºä»»åŠ¡é˜Ÿåˆ—
    protected Queue<Runnable> newTaskQueue(int maxPendingTasks) {
        return maxPendingTasks == Integer.MAX_VALUE ? 
            PlatformDependent.<Runnable>newMpscQueue() :
            PlatformDependent.<Runnable>newMpscQueue(maxPendingTasks);
    }
}
```

### 4.2 executeæ–¹æ³•

```java
@Override
public void execute(Runnable task) {
    ObjectUtil.checkNotNull(task, "task");
    execute(task, !(task instanceof LazyRunnable) && wakesUpForTask(task));
}

private void execute(Runnable task, boolean immediate) {
    boolean inEventLoop = inEventLoop();
    
    // æ·»åŠ ä»»åŠ¡åˆ°é˜Ÿåˆ—
    addTask(task);
    
    if (!inEventLoop) {
        // ä¸åœ¨EventLoopçº¿ç¨‹ï¼Œå¯åŠ¨çº¿ç¨‹
        startThread();
        if (isShutdown()) {
            boolean reject = false;
            try {
                if (removeTask(task)) {
                    reject = true;
                }
            } catch (UnsupportedOperationException e) {
                // å¿½ç•¥
            }
            if (reject) {
                reject();
            }
        }
    }
    
    if (!addTaskWakesUp && immediate) {
        // å”¤é†’Selector
        wakeup(inEventLoop);
    }
}

protected void addTask(Runnable task) {
    ObjectUtil.checkNotNull(task, "task");
    if (!offerTask(task)) {
        reject(task);
    }
}

final boolean offerTask(Runnable task) {
    if (isShutdown()) {
        reject();
    }
    return taskQueue.offer(task);
}
```

### 4.3 runAllTasksæ–¹æ³•

```java
protected boolean runAllTasks() {
    assert inEventLoop();
    boolean fetchedAll;
    boolean ranAtLeastOne = false;
    
    do {
        // ä»å®šæ—¶ä»»åŠ¡é˜Ÿåˆ—è·å–åˆ°æœŸä»»åŠ¡
        fetchedAll = fetchFromScheduledTaskQueue();
        // æ‰§è¡Œä»»åŠ¡
        if (runAllTasksFrom(taskQueue)) {
            ranAtLeastOne = true;
        }
    } while (!fetchedAll);
    
    if (ranAtLeastOne) {
        lastExecutionTime = ScheduledFutureTask.nanoTime();
    }
    
    // æ‰§è¡Œå°¾éƒ¨ä»»åŠ¡
    afterRunningAllTasks();
    return ranAtLeastOne;
}

protected boolean runAllTasks(long timeoutNanos) {
    // ä»å®šæ—¶ä»»åŠ¡é˜Ÿåˆ—è·å–åˆ°æœŸä»»åŠ¡
    fetchFromScheduledTaskQueue();
    
    Runnable task = pollTask();
    if (task == null) {
        afterRunningAllTasks();
        return false;
    }
    
    final long deadline = timeoutNanos > 0 ? 
        ScheduledFutureTask.nanoTime() + timeoutNanos : 0;
    long runTasks = 0;
    long lastExecutionTime;
    
    for (;;) {
        // æ‰§è¡Œä»»åŠ¡
        safeExecute(task);
        runTasks++;
        
        // æ¯64ä¸ªä»»åŠ¡æ£€æŸ¥ä¸€æ¬¡è¶…æ—¶
        if ((runTasks & 0x3F) == 0) {
            lastExecutionTime = ScheduledFutureTask.nanoTime();
            if (lastExecutionTime >= deadline) {
                break;
            }
        }
        
        task = pollTask();
        if (task == null) {
            lastExecutionTime = ScheduledFutureTask.nanoTime();
            break;
        }
    }
    
    afterRunningAllTasks();
    this.lastExecutionTime = lastExecutionTime;
    return true;
}
```

### 4.4 å®šæ—¶ä»»åŠ¡

```java
// AbstractScheduledEventExecutor
public abstract class AbstractScheduledEventExecutor extends AbstractEventExecutor {
    
    // å®šæ—¶ä»»åŠ¡é˜Ÿåˆ—ï¼ˆä¼˜å…ˆçº§é˜Ÿåˆ—ï¼‰
    PriorityQueue<ScheduledFutureTask<?>> scheduledTaskQueue;
    
    @Override
    public ScheduledFuture<?> schedule(Runnable command, long delay, TimeUnit unit) {
        ObjectUtil.checkNotNull(command, "command");
        ObjectUtil.checkNotNull(unit, "unit");
        if (delay < 0) {
            delay = 0;
        }
        validateScheduled0(delay, unit);
        
        return schedule(new ScheduledFutureTask<Void>(
            this, command, deadlineNanos(unit.toNanos(delay))));
    }
    
    <V> ScheduledFuture<V> schedule(final ScheduledFutureTask<V> task) {
        if (inEventLoop()) {
            scheduledTaskQueue().add(task.setId(++nextTaskId));
        } else {
            executeScheduledRunnable(new Runnable() {
                @Override
                public void run() {
                    scheduledTaskQueue().add(task.setId(++nextTaskId));
                }
            }, true, task.deadlineNanos());
        }
        return task;
    }
    
    // ä»å®šæ—¶ä»»åŠ¡é˜Ÿåˆ—è·å–åˆ°æœŸä»»åŠ¡
    private boolean fetchFromScheduledTaskQueue() {
        if (scheduledTaskQueue == null || scheduledTaskQueue.isEmpty()) {
            return true;
        }
        long nanoTime = AbstractScheduledEventExecutor.nanoTime();
        for (;;) {
            Runnable scheduledTask = pollScheduledTask(nanoTime);
            if (scheduledTask == null) {
                return true;
            }
            if (!taskQueue.offer(scheduledTask)) {
                // é˜Ÿåˆ—æ»¡äº†ï¼Œæ”¾å›å®šæ—¶ä»»åŠ¡é˜Ÿåˆ—
                scheduledTaskQueue.add((ScheduledFutureTask<?>) scheduledTask);
                return false;
            }
        }
    }
}
```

### 4.5 çº¿ç¨‹å¯åŠ¨

```java
private void startThread() {
    if (state == ST_NOT_STARTED) {
        if (STATE_UPDATER.compareAndSet(this, ST_NOT_STARTED, ST_STARTED)) {
            boolean success = false;
            try {
                doStartThread();
                success = true;
            } finally {
                if (!success) {
                    STATE_UPDATER.compareAndSet(this, ST_STARTED, ST_NOT_STARTED);
                }
            }
        }
    }
}

private void doStartThread() {
    assert thread == null;
    executor.execute(new Runnable() {
        @Override
        public void run() {
            thread = Thread.currentThread();
            if (interrupted) {
                thread.interrupt();
            }
            
            boolean success = false;
            updateLastExecutionTime();
            try {
                // æ‰§è¡Œäº‹ä»¶å¾ªç¯
                SingleThreadEventExecutor.this.run();
                success = true;
            } catch (Throwable t) {
                logger.warn("Unexpected exception from an event executor: ", t);
            } finally {
                // æ¸…ç†å·¥ä½œ...
            }
        }
    });
}
```

---

## 5. é¢è¯•è¦ç‚¹

### 5.1 é«˜é¢‘é—®é¢˜

**Q1: NioEventLoopçš„å·¥ä½œæµç¨‹ï¼Ÿ**
```
NioEventLoopçš„runæ–¹æ³•æ˜¯ä¸€ä¸ªæ— é™å¾ªç¯ï¼Œä¸»è¦åšä¸‰ä»¶äº‹ï¼š

1. select()ï¼šè½®è¯¢IOäº‹ä»¶
   - æ£€æŸ¥æ˜¯å¦æœ‰ä»»åŠ¡ï¼Œæœ‰åˆ™selectNow()
   - æ— ä»»åŠ¡åˆ™select(timeout)é˜»å¡ç­‰å¾…

2. processSelectedKeys()ï¼šå¤„ç†IOäº‹ä»¶
   - éå†selectedKeys
   - æ ¹æ®äº‹ä»¶ç±»å‹è°ƒç”¨å¯¹åº”çš„å¤„ç†æ–¹æ³•
   - OP_ACCEPT/OP_READ â†’ unsafe.read()
   - OP_WRITE â†’ unsafe.forceFlush()
   - OP_CONNECT â†’ unsafe.finishConnect()

3. runAllTasks()ï¼šæ‰§è¡Œä»»åŠ¡é˜Ÿåˆ—
   - ä»å®šæ—¶ä»»åŠ¡é˜Ÿåˆ—è·å–åˆ°æœŸä»»åŠ¡
   - æ‰§è¡Œæ™®é€šä»»åŠ¡é˜Ÿåˆ—ä¸­çš„ä»»åŠ¡
   - æ ¹æ®ioRatioæ§åˆ¶æ‰§è¡Œæ—¶é—´
```

**Q2: Nettyå¦‚ä½•è§£å†³JDK NIOçš„ç©ºè½®è¯¢Bugï¼Ÿ**
```
JDK NIOçš„Bugï¼š
- åœ¨Linuxä¸Šï¼ŒSelector.select()å¯èƒ½åœ¨æ²¡æœ‰äº‹ä»¶æ—¶è¿”å›
- å¯¼è‡´CPUç©ºè½¬ï¼Œå ç”¨100%

Nettyçš„è§£å†³æ–¹æ¡ˆï¼š
1. è®°å½•selectç©ºè½®è¯¢æ¬¡æ•°ï¼ˆselectCntï¼‰
2. å½“selectCntè¶…è¿‡é˜ˆå€¼ï¼ˆé»˜è®¤512ï¼‰
3. é‡å»ºSelector
4. å°†åŸæœ‰Channelé‡æ–°æ³¨å†Œåˆ°æ–°Selector

å…³é”®ä»£ç ï¼š
if (selectCnt >= SELECTOR_AUTO_REBUILD_THRESHOLD) {
    rebuildSelector();
    selectCnt = 0;
}
```

**Q3: ioRatioå‚æ•°çš„ä½œç”¨ï¼Ÿ**
```
ioRatioæ§åˆ¶IOä»»åŠ¡å’Œæ™®é€šä»»åŠ¡çš„æ—¶é—´æ¯”ä¾‹ï¼š

- ioRatio = 50ï¼ˆé»˜è®¤ï¼‰ï¼šIOå’Œä»»åŠ¡å„å 50%æ—¶é—´
- ioRatio = 100ï¼šå…ˆæ‰§è¡Œå®Œæ‰€æœ‰IOï¼Œå†æ‰§è¡Œæ‰€æœ‰ä»»åŠ¡
- ioRatio = 70ï¼šIOå 70%æ—¶é—´ï¼Œä»»åŠ¡å 30%æ—¶é—´

è®¡ç®—å…¬å¼ï¼š
taskTime = ioTime * (100 - ioRatio) / ioRatio

ä½¿ç”¨åœºæ™¯ï¼š
- IOå¯†é›†å‹ï¼šæé«˜ioRatio
- ä»»åŠ¡å¯†é›†å‹ï¼šé™ä½ioRatio
```

**Q4: ä¸ºä»€ä¹ˆä¸€ä¸ªChannelåªç»‘å®šä¸€ä¸ªEventLoopï¼Ÿ**
```
1. çº¿ç¨‹å®‰å…¨
   - å•çº¿ç¨‹å¤„ç†ï¼Œæ— éœ€åŠ é”
   - é¿å…å¹¶å‘é—®é¢˜

2. æœ‰åºæ€§ä¿è¯
   - äº‹ä»¶æŒ‰é¡ºåºå¤„ç†
   - ä¿è¯æ¶ˆæ¯é¡ºåº

3. ç®€åŒ–ç¼–ç¨‹æ¨¡å‹
   - Handlerä¸éœ€è¦è€ƒè™‘çº¿ç¨‹å®‰å…¨
   - é™ä½å¼€å‘å¤æ‚åº¦
```

**Q5: EventLoopå¦‚ä½•ä¿è¯ä»»åŠ¡çš„çº¿ç¨‹å®‰å…¨ï¼Ÿ**
```
1. åˆ¤æ–­å½“å‰çº¿ç¨‹
   if (inEventLoop()) {
       // ç›´æ¥æ‰§è¡Œ
   } else {
       // æäº¤åˆ°ä»»åŠ¡é˜Ÿåˆ—
       execute(task);
   }

2. ä½¿ç”¨MPSCé˜Ÿåˆ—
   - Multiple Producer Single Consumer
   - å¤šç”Ÿäº§è€…å•æ¶ˆè´¹è€…é˜Ÿåˆ—
   - æ— é”è®¾è®¡ï¼Œé«˜æ€§èƒ½

3. æ‰€æœ‰æ“ä½œéƒ½åœ¨EventLoopçº¿ç¨‹æ‰§è¡Œ
   - Channelçš„æ‰€æœ‰æ“ä½œ
   - Handlerçš„æ‰€æœ‰å›è°ƒ
```

### 5.2 æ ¸å¿ƒç±»æ€»ç»“

```
EventLoopGroupï¼š
- NioEventLoopGroupï¼šNIOäº‹ä»¶å¾ªç¯ç»„
- EpollEventLoopGroupï¼šLinux Epolläº‹ä»¶å¾ªç¯ç»„
- DefaultEventLoopGroupï¼šé»˜è®¤äº‹ä»¶å¾ªç¯ç»„

EventLoopï¼š
- NioEventLoopï¼šNIOäº‹ä»¶å¾ªç¯
- EpollEventLoopï¼šLinux Epolläº‹ä»¶å¾ªç¯
- DefaultEventLoopï¼šé»˜è®¤äº‹ä»¶å¾ªç¯

ä»»åŠ¡ç›¸å…³ï¼š
- ScheduledFutureTaskï¼šå®šæ—¶ä»»åŠ¡
- MpscQueueï¼šå¤šç”Ÿäº§è€…å•æ¶ˆè´¹è€…é˜Ÿåˆ—
```

---

## ğŸ“Š EventLoopæ‰§è¡Œæµç¨‹å›¾

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    NioEventLoop.run()                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚
                              â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    1. è®¡ç®—selectç­–ç•¥                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚  hasTasks() ? selectNow() : select(timeout)         â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚
                              â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    2. å¤„ç†IOäº‹ä»¶                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚  processSelectedKeys()                               â”‚   â”‚
â”‚  â”‚  - OP_ACCEPT â†’ unsafe.read()                        â”‚   â”‚
â”‚  â”‚  - OP_READ â†’ unsafe.read()                          â”‚   â”‚
â”‚  â”‚  - OP_WRITE â†’ unsafe.forceFlush()                   â”‚   â”‚
â”‚  â”‚  - OP_CONNECT â†’ unsafe.finishConnect()              â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚
                              â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    3. æ‰§è¡Œä»»åŠ¡                               â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚  runAllTasks(ioTime * (100 - ioRatio) / ioRatio)    â”‚   â”‚
â”‚  â”‚  - è·å–å®šæ—¶ä»»åŠ¡                                      â”‚   â”‚
â”‚  â”‚  - æ‰§è¡Œæ™®é€šä»»åŠ¡                                      â”‚   â”‚
â”‚  â”‚  - æ‰§è¡Œå°¾éƒ¨ä»»åŠ¡                                      â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚
                              â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    4. æ£€æŸ¥ç©ºè½®è¯¢                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚  selectCnt >= 512 ? rebuildSelector() : continue    â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚
                              â–¼
                         ç»§ç»­å¾ªç¯
```

---

**æ·±å…¥ç†è§£EventLoopï¼ŒæŒæ¡Nettyæ ¸å¿ƒï¼** ğŸš€

*æœ€åæ›´æ–°ï¼š2025-12-28*

# ChannelHandleræºç è§£æ

> ğŸ’¡ æ·±å…¥ç†è§£Nettyå¤„ç†å™¨é“¾çš„è®¾è®¡åŸç†å’Œå®ç°æœºåˆ¶

---

## ğŸ“š ç›®å½•

1. [ChannelHandleræ¦‚è¿°](#1-channelhandleræ¦‚è¿°)
2. [ChannelHandleræ¥å£ä½“ç³»](#2-channelhandleræ¥å£ä½“ç³»)
3. [ChannelHandlerContextæºç è§£æ](#3-channelhandlercontextæºç è§£æ)
4. [ChannelPipelineæºç è§£æ](#4-channelpipelineæºç è§£æ)
5. [äº‹ä»¶ä¼ æ’­æœºåˆ¶](#5-äº‹ä»¶ä¼ æ’­æœºåˆ¶)
6. [å†…ç½®Handleråˆ†æ](#6-å†…ç½®handleråˆ†æ)
7. [é¢è¯•è¦ç‚¹](#7-é¢è¯•è¦ç‚¹)

---

## 1. ChannelHandleræ¦‚è¿°

### 1.1 ChannelHandleræ¶æ„

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  ChannelHandleræ¶æ„                         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                             â”‚
â”‚  ChannelHandler (é¡¶å±‚æ¥å£)                                  â”‚
â”‚  â”œâ”€â”€ å¤„ç†I/Oäº‹ä»¶å’Œæ“ä½œ                                      â”‚
â”‚  â”œâ”€â”€ ç”Ÿå‘½å‘¨æœŸç®¡ç†                                           â”‚
â”‚  â””â”€â”€ å¼‚å¸¸å¤„ç†                                               â”‚
â”‚      â”‚                                                     â”‚
â”‚      â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                 â”‚
â”‚      â–¼                 â–¼                 â–¼                 â”‚
â”‚  ChannelInbound    ChannelOutbound   ChannelDuplex         â”‚
â”‚  Handler           Handler           Handler               â”‚
â”‚  (å…¥ç«™å¤„ç†)        (å‡ºç«™å¤„ç†)        (åŒå‘å¤„ç†)            â”‚
â”‚  â”œâ”€â”€ è¯»å–äº‹ä»¶       â”œâ”€â”€ å†™å…¥æ“ä½œ      â”œâ”€â”€ åŒæ—¶å¤„ç†å…¥ç«™å‡ºç«™  â”‚
â”‚  â”œâ”€â”€ è¿æ¥äº‹ä»¶       â”œâ”€â”€ ç»‘å®šæ“ä½œ      â””â”€â”€ ç¼–è§£ç å™¨å¸¸ç”¨      â”‚
â”‚  â””â”€â”€ å¼‚å¸¸äº‹ä»¶       â””â”€â”€ å…³é—­æ“ä½œ                           â”‚
â”‚                                                             â”‚
â”‚  Pipelineé“¾å¼å¤„ç†ï¼š                                          â”‚
â”‚  [Handler1] â†’ [Handler2] â†’ [Handler3] â†’ [TailHandler]      â”‚
â”‚      â†‘                                          â†“          â”‚
â”‚  [HeadHandler] â† [Handler6] â† [Handler5] â† [Handler4]      â”‚
â”‚                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 1.2 æ ¸å¿ƒè®¾è®¡ç†å¿µ

```java
/**
 * ChannelHandlerè®¾è®¡ç†å¿µ
 */
public class ChannelHandlerDesignPrinciples {
    
    /**
     * ğŸ”¥ è´£ä»»é“¾æ¨¡å¼
     * - æ¯ä¸ªHandlerå¤„ç†ç‰¹å®šèŒè´£
     * - æ”¯æŒåŠ¨æ€æ·»åŠ /åˆ é™¤Handler
     * - äº‹ä»¶åœ¨é“¾ä¸­ä¼ æ’­
     */
    public void chainOfResponsibility() {
        ChannelPipeline pipeline = channel.pipeline();
        
        // å…¥ç«™å¤„ç†é“¾
        pipeline.addLast("decoder", new StringDecoder());
        pipeline.addLast("business", new BusinessHandler());
        
        // å‡ºç«™å¤„ç†é“¾  
        pipeline.addFirst("encoder", new StringEncoder());
        pipeline.addFirst("logger", new LoggingHandler());
    }
    
    /**
     * ğŸ”¥ æ¨¡æ¿æ–¹æ³•æ¨¡å¼
     * - æŠ½è±¡ç±»å®šä¹‰å¤„ç†éª¨æ¶
     * - å­ç±»å®ç°å…·ä½“é€»è¾‘
     * - æä¾›é»˜è®¤å®ç°
     */
    public abstract class ChannelInboundHandlerAdapter 
            extends ChannelHandlerAdapter implements ChannelInboundHandler {
        
        // æ¨¡æ¿æ–¹æ³•ï¼Œæä¾›é»˜è®¤å®ç°
        @Override
        public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
            ctx.fireChannelRead(msg); // é»˜è®¤ä¼ æ’­äº‹ä»¶
        }
    }
    
    /**
     * ğŸ”¥ è£…é¥°å™¨æ¨¡å¼
     * - ChannelHandlerContextè£…é¥°Handler
     * - æä¾›é¢å¤–çš„åŠŸèƒ½å’Œä¸Šä¸‹æ–‡
     * - æ§åˆ¶äº‹ä»¶ä¼ æ’­
     */
    public interface ChannelHandlerContext {
        // è£…é¥°Handlerï¼Œæä¾›ä¸Šä¸‹æ–‡ä¿¡æ¯
        Channel channel();
        EventExecutor executor();
        ChannelHandler handler();
        
        // æ§åˆ¶äº‹ä»¶ä¼ æ’­
        ChannelHandlerContext fireChannelRead(Object msg);
    }
}
```

---

## 2. ChannelHandleræ¥å£ä½“ç³»

### 2.1 ChannelHandleræ ¸å¿ƒæ¥å£

```java
/**
 * ChannelHandler - é¡¶å±‚å¤„ç†å™¨æ¥å£
 * å®šä¹‰äº†å¤„ç†å™¨çš„åŸºæœ¬å¥‘çº¦
 */
@Sharable
public interface ChannelHandler {
    
    /**
     * ğŸ”¥ Handleræ·»åŠ åˆ°Pipelineæ—¶è°ƒç”¨
     */
    void handlerAdded(ChannelHandlerContext ctx) throws Exception;
    
    /**
     * ğŸ”¥ Handlerä»Pipelineç§»é™¤æ—¶è°ƒç”¨
     */
    void handlerRemoved(ChannelHandlerContext ctx) throws Exception;
    
    /**
     * ğŸ”¥ å¤„ç†å¼‚å¸¸
     */
    @Deprecated
    void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception;
    
    /**
     * ğŸ”¥ @Sharableæ³¨è§£
     * æ ‡è®°Handleræ˜¯å¦å¯ä»¥åœ¨å¤šä¸ªPipelineä¸­å…±äº«
     */
    @Inherited
    @Documented
    @Target(ElementType.TYPE)
    @Retention(RetentionPolicy.RUNTIME)
    @interface Sharable {
        // ç©ºæ³¨è§£ï¼Œä»…ä½œæ ‡è®°
    }
}
```

### 2.2 ChannelInboundHandlerå…¥ç«™å¤„ç†å™¨

```java
/**
 * ChannelInboundHandler - å…¥ç«™äº‹ä»¶å¤„ç†å™¨
 * å¤„ç†ä»å¤–éƒ¨åˆ°å†…éƒ¨çš„äº‹ä»¶
 */
public interface ChannelInboundHandler extends ChannelHandler {
    
    /**
     * ğŸ”¥ Channelæ³¨å†Œåˆ°EventLoopæ—¶è°ƒç”¨
     */
    void channelRegistered(ChannelHandlerContext ctx) throws Exception;
    
    /**
     * ğŸ”¥ Channelä»EventLoopæ³¨é”€æ—¶è°ƒç”¨
     */
    void channelUnregistered(ChannelHandlerContext ctx) throws Exception;
    
    /**
     * ğŸ”¥ Channelæ¿€æ´»æ—¶è°ƒç”¨ï¼ˆè¿æ¥å»ºç«‹ï¼‰
     */
    void channelActive(ChannelHandlerContext ctx) throws Exception;
    
    /**
     * ğŸ”¥ Channeléæ¿€æ´»æ—¶è°ƒç”¨ï¼ˆè¿æ¥æ–­å¼€ï¼‰
     */
    void channelInactive(ChannelHandlerContext ctx) throws Exception;
    
    /**
     * ğŸ”¥ è¯»å–æ•°æ®æ—¶è°ƒç”¨
     */
    void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception;
    
    /**
     * ğŸ”¥ è¯»å–å®Œæˆæ—¶è°ƒç”¨
     */
    void channelReadComplete(ChannelHandlerContext ctx) throws Exception;
    
    /**
     * ğŸ”¥ ç”¨æˆ·äº‹ä»¶è§¦å‘æ—¶è°ƒç”¨
     */
    void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception;
    
    /**
     * ğŸ”¥ Channelå¯å†™çŠ¶æ€æ”¹å˜æ—¶è°ƒç”¨
     */
    void channelWritabilityChanged(ChannelHandlerContext ctx) throws Exception;
}
```

### 2.3 ChannelOutboundHandlerå‡ºç«™å¤„ç†å™¨

```java
/**
 * ChannelOutboundHandler - å‡ºç«™æ“ä½œå¤„ç†å™¨
 * å¤„ç†ä»å†…éƒ¨åˆ°å¤–éƒ¨çš„æ“ä½œ
 */
public interface ChannelOutboundHandler extends ChannelHandler {
    
    /**
     * ğŸ”¥ ç»‘å®šåœ°å€æ“ä½œ
     */
    void bind(ChannelHandlerContext ctx, SocketAddress localAddress, ChannelPromise promise) throws Exception;
    
    /**
     * ğŸ”¥ è¿æ¥æ“ä½œ
     */
    void connect(ChannelHandlerContext ctx, SocketAddress remoteAddress,
                 SocketAddress localAddress, ChannelPromise promise) throws Exception;
    
    /**
     * ğŸ”¥ æ–­å¼€è¿æ¥æ“ä½œ
     */
    void disconnect(ChannelHandlerContext ctx, ChannelPromise promise) throws Exception;
    
    /**
     * ğŸ”¥ å…³é—­æ“ä½œ
     */
    void close(ChannelHandlerContext ctx, ChannelPromise promise) throws Exception;
    
    /**
     * ğŸ”¥ æ³¨é”€æ“ä½œ
     */
    void deregister(ChannelHandlerContext ctx, ChannelPromise promise) throws Exception;
    
    /**
     * ğŸ”¥ è¯»å–æ“ä½œ
     */
    void read(ChannelHandlerContext ctx) throws Exception;
    
    /**
     * ğŸ”¥ å†™å…¥æ“ä½œ - æœ€é‡è¦çš„æ–¹æ³•
     */
    void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception;
    
    /**
     * ğŸ”¥ åˆ·æ–°æ“ä½œ
     */
    void flush(ChannelHandlerContext ctx) throws Exception;
}
```

### 2.4 é€‚é…å™¨å®ç°

```java
/**
 * ChannelInboundHandlerAdapter - å…¥ç«™å¤„ç†å™¨é€‚é…å™¨
 * æä¾›é»˜è®¤å®ç°ï¼Œç®€åŒ–Handlerå¼€å‘
 */
public class ChannelInboundHandlerAdapter extends ChannelHandlerAdapter implements ChannelInboundHandler {
    
    /**
     * ğŸ”¥ é»˜è®¤å®ç°ï¼šä¼ æ’­äº‹ä»¶åˆ°ä¸‹ä¸€ä¸ªHandler
     */
    @Override
    public void channelRegistered(ChannelHandlerContext ctx) throws Exception {
        ctx.fireChannelRegistered();
    }
    
    @Override
    public void channelUnregistered(ChannelHandlerContext ctx) throws Exception {
        ctx.fireChannelUnregistered();
    }
    
    @Override
    public void channelActive(ChannelHandlerContext ctx) throws Exception {
        ctx.fireChannelActive();
    }
    
    @Override
    public void channelInactive(ChannelHandlerContext ctx) throws Exception {
        ctx.fireChannelInactive();
    }
    
    @Override
    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
        ctx.fireChannelRead(msg);
    }
    
    @Override
    public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {
        ctx.fireChannelReadComplete();
    }
    
    @Override
    public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception {
        ctx.fireUserEventTriggered(evt);
    }
    
    @Override
    public void channelWritabilityChanged(ChannelHandlerContext ctx) throws Exception {
        ctx.fireChannelWritabilityChanged();
    }
}

/**
 * ChannelOutboundHandlerAdapter - å‡ºç«™å¤„ç†å™¨é€‚é…å™¨
 */
public class ChannelOutboundHandlerAdapter extends ChannelHandlerAdapter implements ChannelOutboundHandler {
    
    /**
     * ğŸ”¥ é»˜è®¤å®ç°ï¼šä¼ æ’­æ“ä½œåˆ°ä¸‹ä¸€ä¸ªHandler
     */
    @Override
    public void bind(ChannelHandlerContext ctx, SocketAddress localAddress,
                     ChannelPromise promise) throws Exception {
        ctx.bind(localAddress, promise);
    }
    
    @Override
    public void connect(ChannelHandlerContext ctx, SocketAddress remoteAddress,
                        SocketAddress localAddress, ChannelPromise promise) throws Exception {
        ctx.connect(remoteAddress, localAddress, promise);
    }
    
    @Override
    public void disconnect(ChannelHandlerContext ctx, ChannelPromise promise) throws Exception {
        ctx.disconnect(promise);
    }
    
    @Override
    public void close(ChannelHandlerContext ctx, ChannelPromise promise) throws Exception {
        ctx.close(promise);
    }
    
    @Override
    public void deregister(ChannelHandlerContext ctx, ChannelPromise promise) throws Exception {
        ctx.deregister(promise);
    }
    
    @Override
    public void read(ChannelHandlerContext ctx) throws Exception {
        ctx.read();
    }
    
    @Override
    public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {
        ctx.write(msg, promise);
    }
    
    @Override
    public void flush(ChannelHandlerContext ctx) throws Exception {
        ctx.flush();
    }
}
```

---

## 3. ChannelHandlerContextæºç è§£æ

### 3.1 ChannelHandlerContextæ¥å£

```java
/**
 * ChannelHandlerContext - Handlerä¸Šä¸‹æ–‡
 * è¿æ¥Handlerå’ŒPipelineçš„æ¡¥æ¢
 */
public interface ChannelHandlerContext extends AttributeMap, ChannelInboundInvoker, ChannelOutboundInvoker {
    
    /**
     * ğŸ”¥ è·å–å…³è”çš„Channel
     */
    Channel channel();
    
    /**
     * ğŸ”¥ è·å–æ‰§è¡Œå™¨
     */
    EventExecutor executor();
    
    /**
     * ğŸ”¥ è·å–Handleråç§°
     */
    String name();
    
    /**
     * ğŸ”¥ è·å–Handlerå®ä¾‹
     */
    ChannelHandler handler();
    
    /**
     * ğŸ”¥ åˆ¤æ–­Handleræ˜¯å¦å·²ç§»é™¤
     */
    boolean isRemoved();
    
    /**
     * ğŸ”¥ å…¥ç«™äº‹ä»¶ä¼ æ’­æ–¹æ³•
     */
    ChannelHandlerContext fireChannelRegistered();
    ChannelHandlerContext fireChannelUnregistered();
    ChannelHandlerContext fireChannelActive();
    ChannelHandlerContext fireChannelInactive();
    ChannelHandlerContext fireExceptionCaught(Throwable cause);
    ChannelHandlerContext fireUserEventTriggered(Object evt);
    ChannelHandlerContext fireChannelRead(Object msg);
    ChannelHandlerContext fireChannelReadComplete();
    ChannelHandlerContext fireChannelWritabilityChanged();
    
    /**
     * ğŸ”¥ è·å–Pipeline
     */
    ChannelPipeline pipeline();
    
    /**
     * ğŸ”¥ è·å–ByteBufåˆ†é…å™¨
     */
    ByteBufAllocator alloc();
}
```

### 3.2 AbstractChannelHandlerContextå®ç°

```java
/**
 * AbstractChannelHandlerContext - ContextæŠ½è±¡å®ç°
 * å®ç°äº†åŒå‘é“¾è¡¨ç»“æ„å’Œäº‹ä»¶ä¼ æ’­é€»è¾‘
 */
abstract class AbstractChannelHandlerContext extends DefaultAttributeMap
        implements ChannelHandlerContext, ResourceLeakHint {
    
    private static final InternalLogger logger = InternalLoggerFactory.getInstance(AbstractChannelHandlerContext.class);
    
    // ğŸ”¥ åŒå‘é“¾è¡¨èŠ‚ç‚¹
    volatile AbstractChannelHandlerContext next;
    volatile AbstractChannelHandlerContext prev;
    
    // ğŸ”¥ Handleræ‰§è¡ŒçŠ¶æ€
    private static final AtomicIntegerFieldUpdater<AbstractChannelHandlerContext> HANDLER_STATE_UPDATER =
            AtomicIntegerFieldUpdater.newUpdater(AbstractChannelHandlerContext.class, "handlerState");
    
    private static final int ADD_PENDING = 1;
    private static final int ADD_COMPLETE = 2;
    private static final int REMOVE_COMPLETE = 3;
    private static final int INIT = 0;
    
    private volatile int handlerState = INIT;
    
    // ğŸ”¥ å…³è”çš„Pipeline
    private final DefaultChannelPipeline pipeline;
    private final String name;
    private final boolean ordered;
    
    // ğŸ”¥ æ‰§è¡Œå™¨
    final EventExecutor executor;
    
    /**
     * ğŸ”¥ æ„é€ å‡½æ•°
     */
    AbstractChannelHandlerContext(DefaultChannelPipeline pipeline, EventExecutor executor,
                                  String name, boolean inbound, boolean outbound) {
        this.name = ObjectUtil.checkNotNull(name, "name");
        this.pipeline = pipeline;
        this.executor = executor;
        this.inbound = inbound;
        this.outbound = outbound;
        this.ordered = executor == null || executor instanceof OrderedEventExecutor;
    }
    
    /**
     * ğŸ”¥ å…¥ç«™äº‹ä»¶ä¼ æ’­ - channelReadç¤ºä¾‹
     */
    @Override
    public ChannelHandlerContext fireChannelRead(final Object msg) {
        invokeChannelRead(findContextInbound(), msg);
        return this;
    }
    
    /**
     * ğŸ”¥ æŸ¥æ‰¾ä¸‹ä¸€ä¸ªå…¥ç«™Handler
     */
    private AbstractChannelHandlerContext findContextInbound() {
        AbstractChannelHandlerContext ctx = this;
        do {
            ctx = ctx.next;
        } while (!ctx.inbound);
        return ctx;
    }
    
    /**
     * ğŸ”¥ è°ƒç”¨channelReadæ–¹æ³•
     */
    static void invokeChannelRead(final AbstractChannelHandlerContext next, Object msg) {
        final Object m = next.pipeline.touch(ObjectUtil.checkNotNull(msg, "msg"), next);
        EventExecutor executor = next.executor();
        if (executor.inEventLoop()) {
            next.invokeChannelRead(m);
        } else {
            executor.execute(new Runnable() {
                @Override
                public void run() {
                    next.invokeChannelRead(m);
                }
            });
        }
    }
    
    /**
     * ğŸ”¥ å®é™…è°ƒç”¨Handlerçš„channelReadæ–¹æ³•
     */
    private void invokeChannelRead(Object msg) {
        if (invokeHandler()) {
            try {
                ((ChannelInboundHandler) handler()).channelRead(this, msg);
            } catch (Throwable t) {
                notifyHandlerException(t);
            }
        } else {
            fireChannelRead(msg);
        }
    }
    
    /**
     * ğŸ”¥ å‡ºç«™æ“ä½œä¼ æ’­ - writeç¤ºä¾‹
     */
    @Override
    public ChannelFuture write(Object msg) {
        return write(msg, newPromise());
    }
    
    @Override
    public ChannelFuture write(final Object msg, final ChannelPromise promise) {
        if (msg == null) {
            throw new NullPointerException("msg");
        }
        
        try {
            if (isNotValidPromise(promise, true)) {
                ReferenceCountUtil.release(msg);
                return promise;
            }
        } catch (RuntimeException e) {
            ReferenceCountUtil.release(msg);
            throw e;
        }
        
        write(msg, false, promise);
        return promise;
    }
    
    /**
     * ğŸ”¥ å†™å…¥æ“ä½œçš„å…·ä½“å®ç°
     */
    private void write(Object msg, boolean flush, ChannelPromise promise) {
        AbstractChannelHandlerContext next = findContextOutbound();
        final Object m = pipeline.touch(msg, next);
        EventExecutor executor = next.executor();
        if (executor.inEventLoop()) {
            if (flush) {
                next.invokeWriteAndFlush(m, promise);
            } else {
                next.invokeWrite(m, promise);
            }
        } else {
            AbstractWriteTask task;
            if (flush) {
                task = WriteAndFlushTask.newInstance(next, m, promise);
            } else {
                task = WriteTask.newInstance(next, m, promise);
            }
            safeExecute(executor, task, promise, m);
        }
    }
    
    /**
     * ğŸ”¥ æŸ¥æ‰¾ä¸‹ä¸€ä¸ªå‡ºç«™Handler
     */
    private AbstractChannelHandlerContext findContextOutbound() {
        AbstractChannelHandlerContext ctx = this;
        do {
            ctx = ctx.prev;
        } while (!ctx.outbound);
        return ctx;
    }
}
```

---

## 4. ChannelPipelineæºç è§£æ

### 4.1 ChannelPipelineæ¥å£

```java
/**
 * ChannelPipeline - å¤„ç†å™¨ç®¡é“
 * ç®¡ç†Handleré“¾è¡¨ï¼Œæ§åˆ¶äº‹ä»¶æµè½¬
 */
public interface ChannelPipeline extends ChannelInboundInvoker, ChannelOutboundInvoker, Iterable<Entry<String, ChannelHandler>> {
    
    /**
     * ğŸ”¥ æ·»åŠ Handleråˆ°é“¾è¡¨æœ«å°¾
     */
    ChannelPipeline addLast(String name, ChannelHandler handler);
    ChannelPipeline addLast(EventExecutorGroup group, String name, ChannelHandler handler);
    ChannelPipeline addLast(ChannelHandler... handlers);
    ChannelPipeline addLast(EventExecutorGroup group, ChannelHandler... handlers);
    
    /**
     * ğŸ”¥ æ·»åŠ Handleråˆ°é“¾è¡¨å¼€å¤´
     */
    ChannelPipeline addFirst(String name, ChannelHandler handler);
    ChannelPipeline addFirst(EventExecutorGroup group, String name, ChannelHandler handler);
    ChannelPipeline addFirst(ChannelHandler... handlers);
    ChannelPipeline addFirst(EventExecutorGroup group, ChannelHandler... handlers);
    
    /**
     * ğŸ”¥ åœ¨æŒ‡å®šHandlerå‰åæ·»åŠ 
     */
    ChannelPipeline addBefore(String baseName, String name, ChannelHandler handler);
    ChannelPipeline addAfter(String baseName, String name, ChannelHandler handler);
    
    /**
     * ğŸ”¥ ç§»é™¤Handler
     */
    ChannelPipeline remove(ChannelHandler handler);
    ChannelHandler remove(String name);
    <T extends ChannelHandler> T remove(Class<T> handlerType);
    
    /**
     * ğŸ”¥ æ›¿æ¢Handler
     */
    ChannelPipeline replace(ChannelHandler oldHandler, String newName, ChannelHandler newHandler);
    ChannelHandler replace(String oldName, String newName, ChannelHandler newHandler);
    <T extends ChannelHandler> T replace(Class<T> oldHandlerType, String newName, ChannelHandler newHandler);
    
    /**
     * ğŸ”¥ è·å–Handler
     */
    ChannelHandler get(String name);
    <T extends ChannelHandler> T get(Class<T> handlerType);
    
    /**
     * ğŸ”¥ è·å–Context
     */
    ChannelHandlerContext context(ChannelHandler handler);
    ChannelHandlerContext context(String name);
    ChannelHandlerContext context(Class<? extends ChannelHandler> handlerType);
    
    /**
     * ğŸ”¥ è·å–å…³è”çš„Channel
     */
    Channel channel();
    
    /**
     * ğŸ”¥ è·å–Handleråç§°åˆ—è¡¨
     */
    List<String> names();
    
    /**
     * ğŸ”¥ è½¬æ¢ä¸ºMap
     */
    Map<String, ChannelHandler> toMap();
}
```

### 4.2 DefaultChannelPipelineå®ç°

```java
/**
 * DefaultChannelPipeline - Pipelineé»˜è®¤å®ç°
 * ä½¿ç”¨åŒå‘é“¾è¡¨ç®¡ç†Handler
 */
public class DefaultChannelPipeline implements ChannelPipeline {
    
    static final InternalLogger logger = InternalLoggerFactory.getInstance(DefaultChannelPipeline.class);
    
    private static final String HEAD_NAME = generateName0(HeadContext.class);
    private static final String TAIL_NAME = generateName0(TailContext.class);
    
    // ğŸ”¥ å¤´å°¾èŠ‚ç‚¹
    final AbstractChannelHandlerContext head;
    final AbstractChannelHandlerContext tail;
    
    // ğŸ”¥ å…³è”çš„Channel
    private final Channel channel;
    
    // ğŸ”¥ æˆåŠŸå’Œå¤±è´¥çš„Future
    private final ChannelFuture succeededFuture;
    private final VoidChannelPromise voidPromise;
    
    // ğŸ”¥ Handleråç§°ç”Ÿæˆå™¨
    private Map<EventExecutorGroup, EventExecutor> childExecutors;
    private volatile MessageSizeEstimator.Handle estimatorHandle;
    private boolean firstRegistration = true;
    
    /**
     * ğŸ”¥ æ„é€ å‡½æ•°
     */
    protected DefaultChannelPipeline(Channel channel) {
        this.channel = ObjectUtil.checkNotNull(channel, "channel");
        succeededFuture = new SucceededChannelFuture(channel, null);
        voidPromise = new VoidChannelPromise(channel, true);
        
        // ğŸ”¥ åˆ›å»ºå¤´å°¾èŠ‚ç‚¹
        tail = new TailContext(this);
        head = new HeadContext(this);
        
        head.next = tail;
        tail.prev = head;
    }
    
    /**
     * ğŸ”¥ æ·»åŠ Handleråˆ°æœ«å°¾
     */
    @Override
    public final ChannelPipeline addLast(String name, ChannelHandler handler) {
        return addLast(null, name, handler);
    }
    
    @Override
    public final ChannelPipeline addLast(EventExecutorGroup group, String name, ChannelHandler handler) {
        final AbstractChannelHandlerContext newCtx;
        synchronized (this) {
            checkMultiplicity(handler);
            
            newCtx = newContext(group, filterName(name, handler), handler);
            
            addLast0(newCtx);
            
            if (!registered) {
                newCtx.setAddPending();
                callHandlerCallbackLater(newCtx, true);
                return this;
            }
            
            EventExecutor executor = newCtx.executor();
            if (!executor.inEventLoop()) {
                newCtx.setAddPending();
                executor.execute(new Runnable() {
                    @Override
                    public void run() {
                        callHandlerAdded0(newCtx);
                    }
                });
                return this;
            }
        }
        callHandlerAdded0(newCtx);
        return this;
    }
    
    /**
     * ğŸ”¥ æ·»åŠ åˆ°é“¾è¡¨æœ«å°¾çš„å…·ä½“å®ç°
     */
    private void addLast0(AbstractChannelHandlerContext newCtx) {
        AbstractChannelHandlerContext prev = tail.prev;
        newCtx.prev = prev;
        newCtx.next = tail;
        prev.next = newCtx;
        tail.prev = newCtx;
    }
    
    /**
     * ğŸ”¥ åˆ›å»ºæ–°çš„Context
     */
    private AbstractChannelHandlerContext newContext(EventExecutorGroup group, String name, ChannelHandler handler) {
        return new DefaultChannelHandlerContext(this, childExecutor(group), name, handler);
    }
    
    /**
     * ğŸ”¥ ç§»é™¤Handler
     */
    @Override
    public final ChannelHandler remove(String name) {
        return remove(getContextOrDie(name)).handler();
    }
    
    private AbstractChannelHandlerContext remove(final AbstractChannelHandlerContext ctx) {
        assert ctx != head && ctx != tail;
        
        synchronized (this) {
            remove0(ctx);
            
            if (!registered) {
                callHandlerCallbackLater(ctx, false);
                return ctx;
            }
            
            EventExecutor executor = ctx.executor();
            if (!executor.inEventLoop()) {
                executor.execute(new Runnable() {
                    @Override
                    public void run() {
                        callHandlerRemoved0(ctx);
                    }
                });
                return ctx;
            }
        }
        callHandlerRemoved0(ctx);
        return ctx;
    }
    
    /**
     * ğŸ”¥ ä»é“¾è¡¨ç§»é™¤çš„å…·ä½“å®ç°
     */
    private static void remove0(AbstractChannelHandlerContext ctx) {
        AbstractChannelHandlerContext prev = ctx.prev;
        AbstractChannelHandlerContext next = ctx.next;
        prev.next = next;
        next.prev = prev;
    }
}
```

### 4.3 HeadContextå’ŒTailContext

```java
/**
 * HeadContext - å¤´èŠ‚ç‚¹Context
 * å¤„ç†å‡ºç«™æ“ä½œï¼Œè¿æ¥åˆ°Unsafe
 */
final class HeadContext extends AbstractChannelHandlerContext
        implements ChannelOutboundHandler, ChannelInboundHandler {
    
    private final Unsafe unsafe;
    
    HeadContext(DefaultChannelPipeline pipeline) {
        super(pipeline, null, HEAD_NAME, false, true);
        unsafe = pipeline.channel().unsafe();
        setAddComplete();
    }
    
    @Override
    public ChannelHandler handler() {
        return this;
    }
    
    /**
     * ğŸ”¥ å¤„ç†ç»‘å®šæ“ä½œ
     */
    @Override
    public void bind(ChannelHandlerContext ctx, SocketAddress localAddress, ChannelPromise promise)
            throws Exception {
        unsafe.bind(localAddress, promise);
    }
    
    /**
     * ğŸ”¥ å¤„ç†è¿æ¥æ“ä½œ
     */
    @Override
    public void connect(ChannelHandlerContext ctx, SocketAddress remoteAddress,
                        SocketAddress localAddress, ChannelPromise promise) throws Exception {
        unsafe.connect(remoteAddress, localAddress, promise);
    }
    
    /**
     * ğŸ”¥ å¤„ç†å†™å…¥æ“ä½œ
     */
    @Override
    public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {
        unsafe.write(msg, promise);
    }
    
    /**
     * ğŸ”¥ å¤„ç†åˆ·æ–°æ“ä½œ
     */
    @Override
    public void flush(ChannelHandlerContext ctx) throws Exception {
        unsafe.flush();
    }
    
    /**
     * ğŸ”¥ å¤„ç†å¼‚å¸¸
     */
    @Override
    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
        ctx.fireExceptionCaught(cause);
    }
}

/**
 * TailContext - å°¾èŠ‚ç‚¹Context
 * å¤„ç†å…¥ç«™äº‹ä»¶çš„ç»ˆç‚¹
 */
final class TailContext extends AbstractChannelHandlerContext implements ChannelInboundHandler {
    
    TailContext(DefaultChannelPipeline pipeline) {
        super(pipeline, null, TAIL_NAME, true, false);
        setAddComplete();
    }
    
    @Override
    public ChannelHandler handler() {
        return this;
    }
    
    /**
     * ğŸ”¥ å¤„ç†æœªå¤„ç†çš„æ¶ˆæ¯
     */
    @Override
    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
        onUnhandledInboundMessage(msg);
    }
    
    /**
     * ğŸ”¥ å¤„ç†æœªå¤„ç†çš„å¼‚å¸¸
     */
    @Override
    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
        onUnhandledInboundException(cause);
    }
    
    /**
     * ğŸ”¥ é‡Šæ”¾æœªå¤„ç†çš„æ¶ˆæ¯
     */
    protected void onUnhandledInboundMessage(Object msg) {
        try {
            logger.debug("Discarded inbound message {} that reached at the tail of the pipeline. " +
                        "Please check your pipeline configuration.", msg);
        } finally {
            ReferenceCountUtil.release(msg);
        }
    }
    
    /**
     * ğŸ”¥ è®°å½•æœªå¤„ç†çš„å¼‚å¸¸
     */
    protected void onUnhandledInboundException(Throwable cause) {
        try {
            logger.warn("An exceptionCaught() event was fired, and it reached at the tail of the pipeline. " +
                       "It usually means the last handler in the pipeline did not handle the exception.", cause);
        } finally {
            ReferenceCountUtil.release(cause);
        }
    }
}
```

---

## 5. äº‹ä»¶ä¼ æ’­æœºåˆ¶

### 5.1 å…¥ç«™äº‹ä»¶ä¼ æ’­

```java
/**
 * å…¥ç«™äº‹ä»¶ä¼ æ’­æœºåˆ¶
 */
public class InboundEventPropagation {
    
    /**
     * ğŸ”¥ å…¥ç«™äº‹ä»¶ä¼ æ’­æµç¨‹
     */
    public void inboundEventFlow() {
        /*
        å…¥ç«™äº‹ä»¶ä¼ æ’­è·¯å¾„ï¼š
        HeadContext â†’ Handler1 â†’ Handler2 â†’ Handler3 â†’ TailContext
        
        äº‹ä»¶ç±»å‹ï¼š
        - channelRegistered: Channelæ³¨å†Œåˆ°EventLoop
        - channelActive: Channelæ¿€æ´»ï¼ˆè¿æ¥å»ºç«‹ï¼‰
        - channelRead: è¯»å–æ•°æ®
        - channelReadComplete: è¯»å–å®Œæˆ
        - channelInactive: Channeléæ¿€æ´»ï¼ˆè¿æ¥æ–­å¼€ï¼‰
        - channelUnregistered: Channelä»EventLoopæ³¨é”€
        - exceptionCaught: å¼‚å¸¸å¤„ç†
        - userEventTriggered: ç”¨æˆ·è‡ªå®šä¹‰äº‹ä»¶
        */
    }
    
    /**
     * ğŸ”¥ channelReadäº‹ä»¶ä¼ æ’­ç¤ºä¾‹
     */
    public class ChannelReadPropagation {
        
        // 1. HeadContextæ¥æ”¶åˆ°æ•°æ®
        public void headContextReceiveData(Object msg) {
            // HeadContext.channelRead()
            ctx.fireChannelRead(msg); // ä¼ æ’­åˆ°ä¸‹ä¸€ä¸ªå…¥ç«™Handler
        }
        
        // 2. ä¸šåŠ¡Handlerå¤„ç†æ•°æ®
        public class BusinessHandler extends ChannelInboundHandlerAdapter {
            @Override
            public void channelRead(ChannelHandlerContext ctx, Object msg) {
                // å¤„ç†ä¸šåŠ¡é€»è¾‘
                String data = (String) msg;
                String response = processData(data);
                
                // ç»§ç»­ä¼ æ’­æˆ–è€…ç»ˆæ­¢
                if (needContinue) {
                    ctx.fireChannelRead(response); // ç»§ç»­ä¼ æ’­
                }
                // ä¸è°ƒç”¨fireChannelReadåˆ™ç»ˆæ­¢ä¼ æ’­
            }
        }
        
        // 3. TailContextå¤„ç†æœªå¤„ç†çš„æ¶ˆæ¯
        public void tailContextHandleUnprocessed(Object msg) {
            // TailContext.channelRead()
            onUnhandledInboundMessage(msg); // é‡Šæ”¾èµ„æºå¹¶è®°å½•æ—¥å¿—
        }
    }
    
    /**
     * ğŸ”¥ å¼‚å¸¸ä¼ æ’­æœºåˆ¶
     */
    public class ExceptionPropagation {
        
        public class ExceptionHandler extends ChannelInboundHandlerAdapter {
            @Override
            public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {
                if (cause instanceof BusinessException) {
                    // å¤„ç†ä¸šåŠ¡å¼‚å¸¸
                    handleBusinessException((BusinessException) cause);
                } else {
                    // ç»§ç»­ä¼ æ’­å…¶ä»–å¼‚å¸¸
                    ctx.fireExceptionCaught(cause);
                }
            }
        }
        
        // å¼‚å¸¸ä¼ æ’­è§„åˆ™ï¼š
        // 1. å¼‚å¸¸ä»å‘ç”Ÿä½ç½®å¼€å§‹å‘åä¼ æ’­
        // 2. åªæœ‰ChannelInboundHandlerèƒ½å¤„ç†å¼‚å¸¸
        // 3. å¦‚æœæ²¡æœ‰Handlerå¤„ç†ï¼Œæœ€ç»ˆåˆ°è¾¾TailContextè®°å½•æ—¥å¿—
    }
}
```

### 5.2 å‡ºç«™æ“ä½œä¼ æ’­

```java
/**
 * å‡ºç«™æ“ä½œä¼ æ’­æœºåˆ¶
 */
public class OutboundOperationPropagation {
    
    /**
     * ğŸ”¥ å‡ºç«™æ“ä½œä¼ æ’­æµç¨‹
     */
    public void outboundOperationFlow() {
        /*
        å‡ºç«™æ“ä½œä¼ æ’­è·¯å¾„ï¼š
        TailContext â† Handler3 â† Handler2 â† Handler1 â† HeadContext
        
        æ“ä½œç±»å‹ï¼š
        - bind: ç»‘å®šåœ°å€
        - connect: è¿æ¥è¿œç¨‹åœ°å€
        - write: å†™å…¥æ•°æ®
        - flush: åˆ·æ–°ç¼“å†²åŒº
        - read: è¯»å–æ•°æ®
        - disconnect: æ–­å¼€è¿æ¥
        - close: å…³é—­Channel
        - deregister: æ³¨é”€Channel
        */
    }
    
    /**
     * ğŸ”¥ writeæ“ä½œä¼ æ’­ç¤ºä¾‹
     */
    public class WriteOperationPropagation {
        
        // 1. ä¸šåŠ¡Handlerå‘èµ·å†™æ“ä½œ
        public class BusinessHandler extends ChannelInboundHandlerAdapter {
            @Override
            public void channelRead(ChannelHandlerContext ctx, Object msg) {
                String response = processRequest((String) msg);
                
                // å‘èµ·å†™æ“ä½œï¼Œä»å½“å‰ä½ç½®å‘å‰ä¼ æ’­
                ctx.writeAndFlush(response);
            }
        }
        
        // 2. ç¼–ç Handlerå¤„ç†å†™æ“ä½œ
        public class EncoderHandler extends ChannelOutboundHandlerAdapter {
            @Override
            public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) {
                if (msg instanceof String) {
                    // ç¼–ç å­—ç¬¦ä¸²ä¸ºByteBuf
                    ByteBuf encoded = encodeString((String) msg);
                    ctx.write(encoded, promise); // ç»§ç»­ä¼ æ’­
                } else {
                    ctx.write(msg, promise); // ç›´æ¥ä¼ æ’­
                }
            }
        }
        
        // 3. HeadContextæ‰§è¡Œå®é™…å†™æ“ä½œ
        public void headContextWrite(Object msg, ChannelPromise promise) {
            // HeadContext.write()
            unsafe.write(msg, promise); // è°ƒç”¨åº•å±‚Unsafeå†™å…¥
        }
    }
    
    /**
     * ğŸ”¥ æ“ä½œä¼ æ’­æ§åˆ¶
     */
    public class OperationPropagationControl {
        
        /**
         * ä»å½“å‰Handlerå¼€å§‹ä¼ æ’­
         */
        public void propagateFromCurrent(ChannelHandlerContext ctx, Object msg) {
            ctx.writeAndFlush(msg); // ä»å½“å‰Handlerå‘å‰ä¼ æ’­
        }
        
        /**
         * ä»Pipelineå¼€å§‹ä¼ æ’­
         */
        public void propagateFromPipeline(ChannelHandlerContext ctx, Object msg) {
            ctx.channel().writeAndFlush(msg); // ä»Pipelineå°¾éƒ¨å¼€å§‹ä¼ æ’­
        }
        
        /**
         * è·³è¿‡å½“å‰Handlerä¼ æ’­
         */
        public void skipCurrentHandler(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) {
            ctx.write(msg, promise); // è·³è¿‡å½“å‰Handlerï¼Œä¼ æ’­ç»™ä¸‹ä¸€ä¸ª
        }
    }
}
```

---

## 6. å†…ç½®Handleråˆ†æ

### 6.1 ChannelInitializer

```java
/**
 * ChannelInitializer - åˆå§‹åŒ–å™¨
 * ç”¨äºåœ¨Channelæ³¨å†Œååˆå§‹åŒ–Pipeline
 */
@Sharable
public abstract class ChannelInitializer<C extends Channel> extends ChannelInboundHandlerAdapter {
    
    private static final InternalLogger logger = InternalLoggerFactory.getInstance(ChannelInitializer.class);
    
    // ğŸ”¥ å·²åˆå§‹åŒ–çš„Channelé›†åˆ
    private final ConcurrentMap<ChannelHandlerContext, Boolean> initMap = PlatformDependent.newConcurrentHashMap();
    
    /**
     * ğŸ”¥ æŠ½è±¡åˆå§‹åŒ–æ–¹æ³•ï¼Œå­ç±»å®ç°
     */
    protected abstract void initChannel(C ch) throws Exception;
    
    /**
     * ğŸ”¥ Channelæ³¨å†Œæ—¶è§¦å‘åˆå§‹åŒ–
     */
    @Override
    @SuppressWarnings("unchecked")
    public final void channelRegistered(ChannelHandlerContext ctx) throws Exception {
        if (initChannel(ctx)) {
            // åˆå§‹åŒ–æˆåŠŸï¼Œç§»é™¤è‡ªå·±
            ctx.pipeline().remove(this);
            
            // ç»§ç»­ä¼ æ’­äº‹ä»¶
            ctx.fireChannelRegistered();
        } else {
            // åˆå§‹åŒ–å¤±è´¥ï¼Œå…³é—­Channel
            ctx.close();
        }
    }
    
    /**
     * ğŸ”¥ æ‰§è¡Œåˆå§‹åŒ–
     */
    @SuppressWarnings("unchecked")
    private boolean initChannel(ChannelHandlerContext ctx) throws Exception {
        if (initMap.putIfAbsent(ctx, Boolean.TRUE) == null) {
            try {
                initChannel((C) ctx.channel());
            } catch (Throwable cause) {
                exceptionCaught(ctx, cause);
                return false;
            } finally {
                initMap.remove(ctx);
            }
            return true;
        }
        return false;
    }
    
    /**
     * ğŸ”¥ å¤„ç†åˆå§‹åŒ–å¼‚å¸¸
     */
    @Override
    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
        logger.warn("Failed to initialize a channel. Closing: " + ctx.channel(), cause);
        ctx.close();
    }
    
    /**
     * ğŸ”¥ ä½¿ç”¨ç¤ºä¾‹
     */
    public static class InitializerExample {
        
        public void setupPipeline() {
            ServerBootstrap bootstrap = new ServerBootstrap();
            bootstrap.childHandler(new ChannelInitializer<SocketChannel>() {
                @Override
                protected void initChannel(SocketChannel ch) throws Exception {
                    ChannelPipeline pipeline = ch.pipeline();
                    
                    // æ·»åŠ ç¼–è§£ç å™¨
                    pipeline.addLast("decoder", new StringDecoder());
                    pipeline.addLast("encoder", new StringEncoder());
                    
                    // æ·»åŠ ä¸šåŠ¡å¤„ç†å™¨
                    pipeline.addLast("handler", new BusinessHandler());
                }
            });
        }
    }
}
```

### 6.2 SimpleChannelInboundHandler

```java
/**
 * SimpleChannelInboundHandler - ç®€åŒ–çš„å…¥ç«™å¤„ç†å™¨
 * è‡ªåŠ¨å¤„ç†æ¶ˆæ¯ç±»å‹è½¬æ¢å’Œèµ„æºé‡Šæ”¾
 */
public abstract class SimpleChannelInboundHandler<I> extends ChannelInboundHandlerAdapter {
    
    private final TypeParameterMatcher matcher;
    private final boolean autoRelease;
    
    /**
     * ğŸ”¥ æ„é€ å‡½æ•°
     */
    protected SimpleChannelInboundHandler() {
        this(true);
    }
    
    protected SimpleChannelInboundHandler(boolean autoRelease) {
        matcher = TypeParameterMatcher.find(this, SimpleChannelInboundHandler.class, "I");
        this.autoRelease = autoRelease;
    }
    
    protected SimpleChannelInboundHandler(Class<? extends I> inboundMessageType) {
        this(inboundMessageType, true);
    }
    
    protected SimpleChannelInboundHandler(Class<? extends I> inboundMessageType, boolean autoRelease) {
        matcher = TypeParameterMatcher.get(inboundMessageType);
        this.autoRelease = autoRelease;
    }
    
    /**
     * ğŸ”¥ åˆ¤æ–­æ¶ˆæ¯æ˜¯å¦å¯æ¥å—
     */
    public boolean acceptInboundMessage(Object msg) throws Exception {
        return matcher.match(msg);
    }
    
    /**
     * ğŸ”¥ å¤„ç†channelReadäº‹ä»¶
     */
    @Override
    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
        boolean release = true;
        try {
            if (acceptInboundMessage(msg)) {
                @SuppressWarnings("unchecked")
                I imsg = (I) msg;
                channelRead0(ctx, imsg);
            } else {
                release = false;
                ctx.fireChannelRead(msg);
            }
        } finally {
            if (autoRelease && release) {
                ReferenceCountUtil.release(msg);
            }
        }
    }
    
    /**
     * ğŸ”¥ æŠ½è±¡å¤„ç†æ–¹æ³•ï¼Œå­ç±»å®ç°
     */
    protected abstract void channelRead0(ChannelHandlerContext ctx, I msg) throws Exception;
    
    /**
     * ğŸ”¥ ä½¿ç”¨ç¤ºä¾‹
     */
    public static class StringHandler extends SimpleChannelInboundHandler<String> {
        
        @Override
        protected void channelRead0(ChannelHandlerContext ctx, String msg) throws Exception {
            // å¤„ç†å­—ç¬¦ä¸²æ¶ˆæ¯ï¼Œæ— éœ€æ‰‹åŠ¨é‡Šæ”¾èµ„æº
            System.out.println("Received: " + msg);
            
            // å›å¤æ¶ˆæ¯
            ctx.writeAndFlush("Echo: " + msg);
        }
    }
}
```

### 6.3 LoggingHandler

```java
/**
 * LoggingHandler - æ—¥å¿—å¤„ç†å™¨
 * è®°å½•Channeläº‹ä»¶å’Œæ•°æ®ä¼ è¾“
 */
@Sharable
public class LoggingHandler extends ChannelDuplexHandler {
    
    private static final LogLevel DEFAULT_LEVEL = LogLevel.DEBUG;
    
    protected final InternalLogger logger;
    protected final InternalLogLevel internalLevel;
    
    private final LogLevel level;
    
    /**
     * ğŸ”¥ æ„é€ å‡½æ•°
     */
    public LoggingHandler() {
        this(DEFAULT_LEVEL);
    }
    
    public LoggingHandler(LogLevel level) {
        if (level == null) {
            throw new NullPointerException("level");
        }
        
        logger = InternalLoggerFactory.getInstance(getClass());
        this.level = level;
        internalLevel = level.toInternalLevel();
    }
    
    public LoggingHandler(Class<?> clazz) {
        this(clazz, DEFAULT_LEVEL);
    }
    
    public LoggingHandler(Class<?> clazz, LogLevel level) {
        if (clazz == null) {
            throw new NullPointerException("clazz");
        }
        if (level == null) {
            throw new NullPointerException("level");
        }
        
        logger = InternalLoggerFactory.getInstance(clazz);
        this.level = level;
        internalLevel = level.toInternalLevel();
    }
    
    /**
     * ğŸ”¥ è®°å½•Channelæ³¨å†Œäº‹ä»¶
     */
    @Override
    public void channelRegistered(ChannelHandlerContext ctx) throws Exception {
        if (logger.isEnabled(internalLevel)) {
            logger.log(internalLevel, format(ctx, "REGISTERED"));
        }
        ctx.fireChannelRegistered();
    }
    
    /**
     * ğŸ”¥ è®°å½•Channelæ¿€æ´»äº‹ä»¶
     */
    @Override
    public void channelActive(ChannelHandlerContext ctx) throws Exception {
        if (logger.isEnabled(internalLevel)) {
            logger.log(internalLevel, format(ctx, "ACTIVE"));
        }
        ctx.fireChannelActive();
    }
    
    /**
     * ğŸ”¥ è®°å½•æ•°æ®è¯»å–äº‹ä»¶
     */
    @Override
    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
        if (logger.isEnabled(internalLevel)) {
            logger.log(internalLevel, format(ctx, "READ", msg));
        }
        ctx.fireChannelRead(msg);
    }
    
    /**
     * ğŸ”¥ è®°å½•å†™å…¥æ“ä½œ
     */
    @Override
    public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {
        if (logger.isEnabled(internalLevel)) {
            logger.log(internalLevel, format(ctx, "WRITE", msg));
        }
        ctx.write(msg, promise);
    }
    
    /**
     * ğŸ”¥ è®°å½•å¼‚å¸¸äº‹ä»¶
     */
    @Override
    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
        if (logger.isEnabled(internalLevel)) {
            logger.log(internalLevel, format(ctx, "EXCEPTION", cause), cause);
        }
        ctx.fireExceptionCaught(cause);
    }
    
    /**
     * ğŸ”¥ æ ¼å¼åŒ–æ—¥å¿—æ¶ˆæ¯
     */
    protected String format(ChannelHandlerContext ctx, String eventName) {
        String chStr = ctx.channel().toString();
        return new StringBuilder(chStr.length() + 1 + eventName.length())
            .append(chStr)
            .append(' ')
            .append(eventName)
            .toString();
    }
    
    protected String format(ChannelHandlerContext ctx, String eventName, Object arg) {
        if (arg instanceof ByteBuf) {
            return formatByteBuf(ctx, eventName, (ByteBuf) arg);
        } else if (arg instanceof ByteBufHolder) {
            return formatByteBufHolder(ctx, eventName, (ByteBufHolder) arg);
        } else {
            return formatSimple(ctx, eventName, arg);
        }
    }
}
```

---

## 7. é¢è¯•è¦ç‚¹

### 7.1 æ ¸å¿ƒæ¦‚å¿µ

```
ğŸ¯ ChannelHandleré¢è¯•è¦ç‚¹

1. Handlerç±»å‹å’ŒèŒè´£
   Q: ChannelInboundHandlerå’ŒChannelOutboundHandleræœ‰ä»€ä¹ˆåŒºåˆ«ï¼Ÿ
   A: 
   - ChannelInboundHandlerï¼šå¤„ç†å…¥ç«™äº‹ä»¶ï¼ˆè¯»å–ã€è¿æ¥ç­‰ï¼‰
   - ChannelOutboundHandlerï¼šå¤„ç†å‡ºç«™æ“ä½œï¼ˆå†™å…¥ã€ç»‘å®šç­‰ï¼‰
   - äº‹ä»¶ä¼ æ’­æ–¹å‘ä¸åŒï¼šå…¥ç«™ä»headåˆ°tailï¼Œå‡ºç«™ä»tailåˆ°head

2. Pipelineæœºåˆ¶
   Q: ChannelPipelineæ˜¯å¦‚ä½•å·¥ä½œçš„ï¼Ÿ
   A:
   - åŒå‘é“¾è¡¨ç»“æ„ç®¡ç†Handler
   - HeadContextå’ŒTailContextä½œä¸ºå“¨å…µèŠ‚ç‚¹
   - æ”¯æŒåŠ¨æ€æ·»åŠ /åˆ é™¤Handler
   - äº‹ä»¶åœ¨Pipelineä¸­æœ‰åºä¼ æ’­

3. Contextä½œç”¨
   Q: ChannelHandlerContextçš„ä½œç”¨æ˜¯ä»€ä¹ˆï¼Ÿ
   A:
   - è¿æ¥Handlerå’ŒPipelineçš„æ¡¥æ¢
   - æä¾›Handleræ‰§è¡Œä¸Šä¸‹æ–‡
   - æ§åˆ¶äº‹ä»¶ä¼ æ’­ï¼ˆfireXxxæ–¹æ³•ï¼‰
   - ç®¡ç†Handlerç”Ÿå‘½å‘¨æœŸ

4. äº‹ä»¶ä¼ æ’­
   Q: å¦‚ä½•æ§åˆ¶äº‹ä»¶ä¼ æ’­ï¼Ÿ
   A:
   - ctx.fireXxx()ï¼šä¼ æ’­åˆ°ä¸‹ä¸€ä¸ªHandler
   - ä¸è°ƒç”¨fireæ–¹æ³•ï¼šç»ˆæ­¢ä¼ æ’­
   - ctx.channel().xxx()ï¼šä»Pipelineå¼€å§‹ä¼ æ’­
   - ctx.xxx()ï¼šä»å½“å‰Handlerå¼€å§‹ä¼ æ’­
```

### 7.2 å®é™…åº”ç”¨

```
ğŸ”§ å®é™…åº”ç”¨åœºæ™¯

1. åè®®å¤„ç†
   åœºæ™¯: HTTP/WebSocketåè®®å¤„ç†
   æ–¹æ¡ˆ:
   - è§£ç å™¨ï¼šå­—èŠ‚æµâ†’åè®®å¯¹è±¡
   - ç¼–ç å™¨ï¼šåè®®å¯¹è±¡â†’å­—èŠ‚æµ
   - ä¸šåŠ¡å¤„ç†å™¨ï¼šå¤„ç†åè®®é€»è¾‘
   - å¼‚å¸¸å¤„ç†å™¨ï¼šç»Ÿä¸€å¼‚å¸¸å¤„ç†

2. æ•°æ®è½¬æ¢
   åœºæ™¯: ä¸åŒæ•°æ®æ ¼å¼è½¬æ¢
   æ–¹æ¡ˆ:
   - ä½¿ç”¨MessageToMessageDecoder/Encoder
   - é“¾å¼è½¬æ¢ï¼šJSONâ†’Objectâ†’DTO
   - ç±»å‹å®‰å…¨çš„SimpleChannelInboundHandler
   - è‡ªåŠ¨èµ„æºç®¡ç†

3. å®‰å…¨è®¤è¯
   åœºæ™¯: ç”¨æˆ·è®¤è¯å’Œæˆæƒ
   æ–¹æ¡ˆ:
   - è®¤è¯HandleréªŒè¯ç”¨æˆ·èº«ä»½
   - æˆæƒHandleræ£€æŸ¥æƒé™
   - SSL/TLS Handlerå¤„ç†åŠ å¯†
   - å®¡è®¡Handlerè®°å½•æ“ä½œæ—¥å¿—

4. æ€§èƒ½ç›‘æ§
   åœºæ™¯: ç›‘æ§ç³»ç»Ÿæ€§èƒ½æŒ‡æ ‡
   æ–¹æ¡ˆ:
   - ç»Ÿè®¡Handlerè®°å½•QPSã€å»¶è¿Ÿ
   - é™æµHandleræ§åˆ¶è¯·æ±‚é€Ÿç‡
   - æ—¥å¿—Handlerè®°å½•å…³é”®äº‹ä»¶
   - å¥åº·æ£€æŸ¥Handlerç›‘æ§çŠ¶æ€
```

### 7.3 å¸¸è§é—®é¢˜

```
â“ å¸¸è§é¢è¯•é—®é¢˜

Q1: Handlerçš„æ‰§è¡Œé¡ºåºæ˜¯æ€æ ·çš„ï¼Ÿ
A1: 
- å…¥ç«™äº‹ä»¶ï¼šæŒ‰æ·»åŠ é¡ºåºæ‰§è¡Œï¼ˆfirstâ†’lastï¼‰
- å‡ºç«™æ“ä½œï¼šæŒ‰æ·»åŠ é¡ºåºé€†åºæ‰§è¡Œï¼ˆlastâ†’firstï¼‰
- åŒä¸€ä¸ªHandlerå¯ä»¥åŒæ—¶å¤„ç†å…¥ç«™å’Œå‡ºç«™

Q2: å¦‚ä½•å®ç°Handlerçš„çº¿ç¨‹å®‰å…¨ï¼Ÿ
A2:
- ä½¿ç”¨@Sharableæ³¨è§£æ ‡è®°æ— çŠ¶æ€Handler
- é¿å…åœ¨Handlerä¸­ä½¿ç”¨å®ä¾‹å˜é‡
- ä½¿ç”¨ChannelHandlerContextçš„å±æ€§å­˜å‚¨çŠ¶æ€
- å¿…è¦æ—¶ä½¿ç”¨åŒæ­¥æœºåˆ¶

Q3: ä»€ä¹ˆæ—¶å€™éœ€è¦æ‰‹åŠ¨é‡Šæ”¾æ¶ˆæ¯ï¼Ÿ
A3:
- ç»§æ‰¿ChannelInboundHandlerAdapteræ—¶éœ€è¦æ‰‹åŠ¨é‡Šæ”¾
- SimpleChannelInboundHandlerè‡ªåŠ¨é‡Šæ”¾
- æ¶ˆæ¯è¢«æ¶ˆè´¹åä¸å†ä¼ æ’­æ—¶éœ€è¦é‡Šæ”¾
- ä½¿ç”¨ReferenceCountUtil.release()é‡Šæ”¾

Q4: å¦‚ä½•å¤„ç†Handlerä¸­çš„å¼‚å¸¸ï¼Ÿ
A4:
- é‡å†™exceptionCaughtæ–¹æ³•å¤„ç†å¼‚å¸¸
- è°ƒç”¨ctx.fireExceptionCaught()ä¼ æ’­å¼‚å¸¸
- åœ¨Pipelineæœ«å°¾æ·»åŠ ç»Ÿä¸€å¼‚å¸¸å¤„ç†å™¨
- è®°å½•æ—¥å¿—å¹¶å…³é—­è¿æ¥

Q5: Pipelineçš„æ€§èƒ½ä¼˜åŒ–æ–¹æ³•ï¼Ÿ
A5:
- å‡å°‘Handleræ•°é‡ï¼Œåˆå¹¶ç›¸ä¼¼åŠŸèƒ½
- ä½¿ç”¨@Sharableé¿å…é‡å¤åˆ›å»ºHandler
- åˆç†è®¾ç½®EventExecutoré¿å…çº¿ç¨‹åˆ‡æ¢
- ä½¿ç”¨å¯¹è±¡æ± å‡å°‘GCå‹åŠ›
```

### 7.4 æœ€ä½³å®è·µ

```
âœ… å¼€å‘æœ€ä½³å®è·µ

1. Handlerè®¾è®¡
   - å•ä¸€èŒè´£ï¼šæ¯ä¸ªHandleråªå¤„ç†ä¸€ç§åŠŸèƒ½
   - æ— çŠ¶æ€è®¾è®¡ï¼šä½¿ç”¨@Sharableæé«˜å¤ç”¨æ€§
   - å¼‚å¸¸å¤„ç†ï¼šæ¯ä¸ªHandleréƒ½è¦å¤„ç†å¯èƒ½çš„å¼‚å¸¸
   - èµ„æºç®¡ç†ï¼šåŠæ—¶é‡Šæ”¾ByteBufç­‰èµ„æº

2. Pipelineé…ç½®
   - åˆç†é¡ºåºï¼šç¼–è§£ç å™¨â†’ä¸šåŠ¡å¤„ç†å™¨â†’å¼‚å¸¸å¤„ç†å™¨
   - åŠ¨æ€ç®¡ç†ï¼šæ ¹æ®åè®®ç‰ˆæœ¬åŠ¨æ€æ·»åŠ Handler
   - æ€§èƒ½ä¼˜åŒ–ï¼šé¿å…ä¸å¿…è¦çš„Handler
   - ç›‘æ§æ—¥å¿—ï¼šæ·»åŠ LoggingHandlerä¾¿äºè°ƒè¯•

3. äº‹ä»¶ä¼ æ’­
   - æ˜ç¡®ä¼ æ’­ï¼šçŸ¥é“ä½•æ—¶ä¼ æ’­ä½•æ—¶ç»ˆæ­¢
   - å¼‚å¸¸ä¼ æ’­ï¼šç¡®ä¿å¼‚å¸¸èƒ½è¢«æ­£ç¡®å¤„ç†
   - ä¸Šä¸‹æ–‡ä½¿ç”¨ï¼šæ­£ç¡®ä½¿ç”¨ctxå’Œchannel
   - çº¿ç¨‹å®‰å…¨ï¼šæ³¨æ„è·¨çº¿ç¨‹è®¿é—®é—®é¢˜

4. æµ‹è¯•éªŒè¯
   - å•å…ƒæµ‹è¯•ï¼šä½¿ç”¨EmbeddedChannelæµ‹è¯•Handler
   - é›†æˆæµ‹è¯•ï¼šæµ‹è¯•å®Œæ•´çš„Pipeline
   - æ€§èƒ½æµ‹è¯•ï¼šéªŒè¯Handleræ€§èƒ½å½±å“
   - å¼‚å¸¸æµ‹è¯•ï¼šéªŒè¯å¼‚å¸¸å¤„ç†é€»è¾‘
```

---

## ğŸ“‹ æ€»ç»“

ChannelHandleræ˜¯Nettyçš„æ ¸å¿ƒç»„ä»¶ï¼Œé€šè¿‡è´£ä»»é“¾æ¨¡å¼å®ç°äº†çµæ´»çš„äº‹ä»¶å¤„ç†æœºåˆ¶ã€‚Pipelineç®¡ç†Handleré“¾è¡¨ï¼ŒContextæä¾›æ‰§è¡Œä¸Šä¸‹æ–‡ï¼Œå…±åŒæ„æˆäº†Nettyå¼ºå¤§çš„å¤„ç†å™¨æ¡†æ¶ã€‚

**æ ¸å¿ƒè¦ç‚¹**ï¼š
- **è®¾è®¡æ¨¡å¼**ï¼šè´£ä»»é“¾æ¨¡å¼å®ç°äº‹ä»¶ä¼ æ’­ï¼Œæ¨¡æ¿æ–¹æ³•ç®€åŒ–å¼€å‘
- **åŒå‘å¤„ç†**ï¼šå…¥ç«™äº‹ä»¶å’Œå‡ºç«™æ“ä½œåˆ†åˆ«å¤„ç†ï¼Œæ”¯æŒåŒå‘ä¼ æ’­
- **åŠ¨æ€ç®¡ç†**ï¼šæ”¯æŒè¿è¡Œæ—¶åŠ¨æ€æ·»åŠ /åˆ é™¤Handler
- **èµ„æºç®¡ç†**ï¼šè‡ªåŠ¨æˆ–æ‰‹åŠ¨é‡Šæ”¾èµ„æºï¼Œé¿å…å†…å­˜æ³„æ¼

æŒæ¡ChannelHandlerçš„è®¾è®¡å’Œä½¿ç”¨ï¼Œæ˜¯å¼€å‘é«˜æ€§èƒ½ç½‘ç»œåº”ç”¨çš„å…³é”®æŠ€èƒ½ã€‚
# ç¼–è§£ç å™¨æºç è§£æ

> ğŸ’¡ æ·±å…¥ç†è§£Nettyç¼–è§£ç å™¨çš„è®¾è®¡åŸç†å’Œå®ç°æœºåˆ¶

---

## ğŸ“š ç›®å½•

1. [ç¼–è§£ç å™¨æ¦‚è¿°](#1-ç¼–è§£ç å™¨æ¦‚è¿°)
2. [ByteToMessageDecoderæºç è§£æ](#2-bytetomessagedecoderæºç è§£æ)
3. [MessageToByteEncoderæºç è§£æ](#3-messagetobyteencoderæºç è§£æ)
4. [MessageToMessageCodecæºç è§£æ](#4-messagetomessagecodecæºç è§£æ)
5. [å†…ç½®ç¼–è§£ç å™¨åˆ†æ](#5-å†…ç½®ç¼–è§£ç å™¨åˆ†æ)
6. [è‡ªå®šä¹‰ç¼–è§£ç å™¨å®ç°](#6-è‡ªå®šä¹‰ç¼–è§£ç å™¨å®ç°)
7. [é¢è¯•è¦ç‚¹](#7-é¢è¯•è¦ç‚¹)

---

## 1. ç¼–è§£ç å™¨æ¦‚è¿°

### 1.1 ç¼–è§£ç å™¨æ¶æ„

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  Nettyç¼–è§£ç å™¨æ¶æ„                           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                             â”‚
â”‚  æ•°æ®æµè½¬æ¢è¿‡ç¨‹ï¼š                                            â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚
â”‚  â”‚   ç½‘ç»œå­—èŠ‚   â”‚â”€â”€â”€â–¶â”‚   è§£ç å™¨     â”‚â”€â”€â”€â–¶â”‚  ä¸šåŠ¡å¯¹è±¡    â”‚     â”‚
â”‚  â”‚   ByteBuf   â”‚    â”‚  Decoder    â”‚    â”‚   POJO      â”‚     â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚
â”‚         â–²                                       â”‚          â”‚
â”‚         â”‚            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”            â–¼          â”‚
â”‚         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚   ç¼–ç å™¨     â”‚â—€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚
â”‚                      â”‚  Encoder    â”‚                       â”‚
â”‚                      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                       â”‚
â”‚                                                             â”‚
â”‚  ç¼–è§£ç å™¨åˆ†ç±»ï¼š                                              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚  ByteToMessage     â”‚  MessageToByte                 â”‚   â”‚
â”‚  â”‚  â”œâ”€â”€ å­—èŠ‚â†’å¯¹è±¡      â”‚  â”œâ”€â”€ å¯¹è±¡â†’å­—èŠ‚                  â”‚   â”‚
â”‚  â”‚  â”œâ”€â”€ åè®®è§£æ      â”‚  â”œâ”€â”€ åè®®å°è£…                  â”‚   â”‚
â”‚  â”‚  â””â”€â”€ ç²˜åŒ…æ‹†åŒ…      â”‚  â””â”€â”€ æ•°æ®åºåˆ—åŒ–                â”‚   â”‚
â”‚  â”‚                   â”‚                               â”‚   â”‚
â”‚  â”‚  MessageToMessage  â”‚  ByteToByteCodec              â”‚   â”‚
â”‚  â”‚  â”œâ”€â”€ å¯¹è±¡â†’å¯¹è±¡      â”‚  â”œâ”€â”€ å­—èŠ‚â†’å­—èŠ‚                  â”‚   â”‚
â”‚  â”‚  â”œâ”€â”€ æ ¼å¼è½¬æ¢      â”‚  â”œâ”€â”€ å‹ç¼©è§£å‹                  â”‚   â”‚
â”‚  â”‚  â””â”€â”€ æ•°æ®æ˜ å°„      â”‚  â””â”€â”€ åŠ å¯†è§£å¯†                  â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 1.2 æ ¸å¿ƒè®¾è®¡ç†å¿µ

```java
/**
 * ç¼–è§£ç å™¨è®¾è®¡ç†å¿µ
 */
public class CodecDesignPrinciples {
    
    /**
     * ğŸ”¥ æ¨¡æ¿æ–¹æ³•æ¨¡å¼
     * - æŠ½è±¡ç±»å®šä¹‰ç¼–è§£ç éª¨æ¶
     * - å­ç±»å®ç°å…·ä½“ç¼–è§£ç é€»è¾‘
     * - å¤„ç†ç¼“å†²åŒºç®¡ç†å’Œå¼‚å¸¸
     */
    public abstract class ByteToMessageDecoder extends ChannelInboundHandlerAdapter {
        // æ¨¡æ¿æ–¹æ³•
        protected void callDecode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) {
            while (in.isReadable()) {
                decode(ctx, in, out); // å­ç±»å®ç°
            }
        }
        
        // æŠ½è±¡æ–¹æ³•
        protected abstract void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) throws Exception;
    }
    
    /**
     * ğŸ”¥ ç­–ç•¥æ¨¡å¼
     * - ä¸åŒçš„ç¼–è§£ç ç­–ç•¥
     * - å¯æ’æ‹”çš„ç¼–è§£ç å™¨
     * - æ”¯æŒåè®®åˆ‡æ¢
     */
    public interface CodecStrategy {
        Object decode(ByteBuf buffer);
        ByteBuf encode(Object message);
    }
    
    /**
     * ğŸ”¥ è´£ä»»é“¾æ¨¡å¼
     * - å¤šçº§ç¼–è§£ç å¤„ç†
     - åè®®æ ˆåˆ†å±‚å¤„ç†
     * - å¯ç»„åˆçš„ç¼–è§£ç å™¨
     */
    public void codecChain() {
        pipeline.addLast("frameDecoder", new LengthFieldBasedFrameDecoder(1024, 0, 4));
        pipeline.addLast("protocolDecoder", new ProtocolDecoder());
        pipeline.addLast("businessDecoder", new BusinessDecoder());
    }
}
```

---

## 2. ByteToMessageDecoderæºç è§£æ

### 2.1 ByteToMessageDecoderæ ¸å¿ƒå®ç°

```java
/**
 * ByteToMessageDecoder - å­—èŠ‚åˆ°æ¶ˆæ¯è§£ç å™¨
 * å°†ByteBufè§£ç ä¸ºä¸šåŠ¡å¯¹è±¡
 */
public abstract class ByteToMessageDecoder extends ChannelInboundHandlerAdapter {
    
    /**
     * ğŸ”¥ ç´¯ç§¯å™¨æ¥å£ - ç®¡ç†æ•°æ®ç´¯ç§¯
     */
    public interface Cumulator {
        ByteBuf cumulate(ByteBufAllocator alloc, ByteBuf cumulation, ByteBuf in);
    }
    
    /**
     * ğŸ”¥ åˆå¹¶ç´¯ç§¯å™¨ - é»˜è®¤å®ç°
     */
    public static final Cumulator MERGE_CUMULATOR = new Cumulator() {
        @Override
        public ByteBuf cumulate(ByteBufAllocator alloc, ByteBuf cumulation, ByteBuf in) {
            final ByteBuf buffer;
            if (cumulation.writerIndex() > cumulation.maxCapacity() - in.readableBytes()
                || cumulation.refCnt() > 1 || cumulation.isReadOnly()) {
                // æ‰©å®¹æˆ–åˆ›å»ºæ–°ç¼“å†²åŒº
                buffer = expandCumulation(alloc, cumulation, in.readableBytes());
            } else {
                buffer = cumulation;
            }
            buffer.writeBytes(in);
            in.release();
            return buffer;
        }
    };
    
    /**
     * ğŸ”¥ ç»„åˆç´¯ç§¯å™¨ - ä½¿ç”¨CompositeByteBuf
     */
    public static final Cumulator COMPOSITE_CUMULATOR = new Cumulator() {
        @Override
        public ByteBuf cumulate(ByteBufAllocator alloc, ByteBuf cumulation, ByteBuf in) {
            ByteBuf buffer;
            if (cumulation.refCnt() > 1) {
                buffer = expandCumulation(alloc, cumulation, in.readableBytes());
                buffer.writeBytes(in);
                in.release();
            } else {
                CompositeByteBuf composite;
                if (cumulation instanceof CompositeByteBuf) {
                    composite = (CompositeByteBuf) cumulation;
                } else {
                    composite = alloc.compositeBuffer(Integer.MAX_VALUE);
                    composite.addComponent(true, cumulation);
                }
                composite.addComponent(true, in);
                buffer = composite;
            }
            return buffer;
        }
    };
    
    private static final byte STATE_INIT = 0;
    private static final byte STATE_CALLING_CHILD_DECODE = 1;
    private static final byte STATE_HANDLER_REMOVED_PENDING = 2;
    
    // ğŸ”¥ ç´¯ç§¯ç¼“å†²åŒº
    ByteBuf cumulation;
    private Cumulator cumulator = MERGE_CUMULATOR;
    private boolean singleDecode;
    private boolean decodeWasNull;
    private boolean first;
    private byte decodeState = STATE_INIT;
    private int discardAfterReads = 16;
    private int numReads;
    
    /**
     * ğŸ”¥ è®¾ç½®ç´¯ç§¯å™¨
     */
    public void setCumulator(Cumulator cumulator) {
        if (cumulator == null) {
            throw new NullPointerException("cumulator");
        }
        this.cumulator = cumulator;
    }
    
    /**
     * ğŸ”¥ è®¾ç½®å•æ¬¡è§£ç æ¨¡å¼
     */
    public void setSingleDecode(boolean singleDecode) {
        this.singleDecode = singleDecode;
    }
    
    /**
     * ğŸ”¥ å¤„ç†è¯»å–äº‹ä»¶ - æ ¸å¿ƒæ–¹æ³•
     */
    @Override
    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
        if (msg instanceof ByteBuf) {
            CodecOutputList out = CodecOutputList.newInstance();
            try {
                ByteBuf data = (ByteBuf) msg;
                first = cumulation == null;
                if (first) {
                    cumulation = data;
                } else {
                    cumulation = cumulator.cumulate(ctx.alloc(), cumulation, data);
                }
                callDecode(ctx, cumulation, out);
            } catch (DecoderException e) {
                throw e;
            } catch (Exception e) {
                throw new DecoderException(e);
            } finally {
                if (cumulation != null && !cumulation.isReadable()) {
                    numReads = 0;
                    cumulation.release();
                    cumulation = null;
                } else if (++ numReads >= discardAfterReads) {
                    numReads = 0;
                    discardSomeReadBytes();
                }
                
                int size = out.size();
                decodeWasNull = !out.insertSinceRecycled();
                fireChannelRead(ctx, out, size);
                out.recycle();
            }
        } else {
            ctx.fireChannelRead(msg);
        }
    }
    
    /**
     * ğŸ”¥ è°ƒç”¨è§£ç æ–¹æ³•
     */
    protected void callDecode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) {
        try {
            while (in.isReadable()) {
                int outSize = out.size();
                
                if (outSize > 0) {
                    fireChannelRead(ctx, out, outSize);
                    out.clear();
                    
                    if (ctx.isRemoved()) {
                        break;
                    }
                    outSize = 0;
                }
                
                int oldInputLength = in.readableBytes();
                decodeState = STATE_CALLING_CHILD_DECODE;
                decode(ctx, in, out);
                decodeState = STATE_INIT;
                
                if (ctx.isRemoved()) {
                    break;
                }
                
                if (outSize == out.size()) {
                    if (oldInputLength == in.readableBytes()) {
                        break;
                    } else {
                        continue;
                    }
                }
                
                if (oldInputLength == in.readableBytes()) {
                    throw new DecoderException(
                        StringUtil.simpleClassName(getClass()) +
                        ".decode() did not read anything but decoded a message.");
                }
                
                if (isSingleDecode()) {
                    break;
                }
            }
        } catch (DecoderException e) {
            throw e;
        } catch (Exception cause) {
            throw new DecoderException(cause);
        }
    }
    
    /**
     * ğŸ”¥ æŠ½è±¡è§£ç æ–¹æ³• - å­ç±»å®ç°
     */
    protected abstract void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) throws Exception;
    
    /**
     * ğŸ”¥ è§£ç æœ€åçš„æ•°æ®
     */
    protected void decodeLast(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) throws Exception {
        if (in.isReadable()) {
            decodeRemovalReentryProtection(ctx, in, out);
        }
    }
    
    /**
     * ğŸ”¥ ä¸¢å¼ƒå·²è¯»å­—èŠ‚
     */
    protected final void discardSomeReadBytes() {
        if (cumulation != null && !first && cumulation.refCnt() == 1) {
            cumulation.discardSomeReadBytes();
        }
    }
    
    /**
     * ğŸ”¥ Handlerç§»é™¤æ—¶çš„å¤„ç†
     */
    @Override
    public void handlerRemoved(ChannelHandlerContext ctx) throws Exception {
        if (decodeState == STATE_CALLING_CHILD_DECODE) {
            decodeState = STATE_HANDLER_REMOVED_PENDING;
            return;
        }
        ByteBuf buf = cumulation;
        if (buf != null) {
            cumulation = null;
            numReads = 0;
            int readable = buf.readableBytes();
            if (readable > 0) {
                ByteBuf bytes = buf.readBytes(readable);
                buf.release();
                ctx.fireChannelRead(bytes);
                ctx.fireChannelReadComplete();
            } else {
                buf.release();
            }
        }
    }
}
```

### 2.2 ReplayingDecoderå®ç°

```java
/**
 * ReplayingDecoder - é‡æ”¾è§£ç å™¨
 * ç®€åŒ–è§£ç é€»è¾‘ï¼Œè‡ªåŠ¨å¤„ç†æ•°æ®ä¸è¶³çš„æƒ…å†µ
 */
public abstract class ReplayingDecoder<S> extends ByteToMessageDecoder {
    
    static final Signal REPLAY = Signal.valueOf(ReplayingDecoder.class, "REPLAY");
    
    private final ReplayingDecoderByteBuf replayable = new ReplayingDecoderByteBuf();
    private S state;
    private int checkpoint = -1;
    
    /**
     * ğŸ”¥ æ„é€ å‡½æ•°
     */
    protected ReplayingDecoder() {
        this(null);
    }
    
    protected ReplayingDecoder(S initialState) {
        state = initialState;
    }
    
    /**
     * ğŸ”¥ è®¾ç½®æ£€æŸ¥ç‚¹
     */
    protected void checkpoint() {
        checkpoint = internalBuffer().readerIndex();
    }
    
    protected void checkpoint(S state) {
        checkpoint();
        state(state);
    }
    
    /**
     * ğŸ”¥ è·å–/è®¾ç½®çŠ¶æ€
     */
    protected S state() {
        return state;
    }
    
    protected S state(S newState) {
        S oldState = state;
        state = newState;
        return oldState;
    }
    
    /**
     * ğŸ”¥ è°ƒç”¨è§£ç æ–¹æ³• - é‡å†™çˆ¶ç±»æ–¹æ³•
     */
    @Override
    protected void callDecode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) {
        replayable.setCumulation(in);
        try {
            while (in.isReadable()) {
                int oldReaderIndex = checkpoint = in.readerIndex();
                int outSize = out.size();
                
                if (outSize > 0) {
                    fireChannelRead(ctx, out, outSize);
                    out.clear();
                    
                    if (ctx.isRemoved()) {
                        return;
                    }
                    outSize = 0;
                }
                
                S oldState = state;
                int oldInputLength = in.readableBytes();
                try {
                    decode(ctx, replayable, out);
                    
                    if (ctx.isRemoved()) {
                        return;
                    }
                    
                    if (outSize == out.size()) {
                        if (oldInputLength == in.readableBytes() && oldState == state) {
                            throw new DecoderException(
                                StringUtil.simpleClassName(getClass()) + 
                                ".decode() method must consume the inbound data or change its state if it did not decode anything.");
                        } else {
                            continue;
                        }
                    }
                } catch (Signal replay) {
                    replay.expect(REPLAY);
                    
                    if (ctx.isRemoved()) {
                        return;
                    }
                    
                    // ğŸ”¥ é‡æ”¾ï¼šå›åˆ°æ£€æŸ¥ç‚¹
                    int checkpoint = this.checkpoint;
                    if (checkpoint >= 0) {
                        in.readerIndex(checkpoint);
                    } else {
                        throw new DecoderException(
                            "cannot determine the buffer position where the partial message started");
                    }
                    break;
                }
                
                if (oldReaderIndex == in.readerIndex() && oldState == state) {
                    throw new DecoderException(
                        StringUtil.simpleClassName(getClass()) + 
                        ".decode() method must consume the inbound data or change its state if it did not decode anything.");
                }
                if (isSingleDecode()) {
                    break;
                }
            }
        } catch (DecoderException e) {
            throw e;
        } catch (Exception cause) {
            throw new DecoderException(cause);
        }
    }
    
    /**
     * ğŸ”¥ ä½¿ç”¨ç¤ºä¾‹
     */
    public static class IntegerHeaderFrameDecoder extends ReplayingDecoder<Void> {
        
        @Override
        protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) throws Exception {
            // ğŸ”¥ è¯»å–é•¿åº¦å­—æ®µï¼ˆ4å­—èŠ‚ï¼‰
            int length = in.readInt();
            
            // ğŸ”¥ è¯»å–æ•°æ®å†…å®¹
            ByteBuf frame = in.readBytes(length);
            out.add(frame);
        }
    }
}
```

---

## 3. MessageToByteEncoderæºç è§£æ

### 3.1 MessageToByteEncoderæ ¸å¿ƒå®ç°

```java
/**
 * MessageToByteEncoder - æ¶ˆæ¯åˆ°å­—èŠ‚ç¼–ç å™¨
 * å°†ä¸šåŠ¡å¯¹è±¡ç¼–ç ä¸ºByteBuf
 */
public abstract class MessageToByteEncoder<I> extends ChannelOutboundHandlerAdapter {
    
    private final TypeParameterMatcher matcher;
    private final boolean preferDirect;
    
    /**
     * ğŸ”¥ æ„é€ å‡½æ•°
     */
    protected MessageToByteEncoder() {
        this(true);
    }
    
    protected MessageToByteEncoder(boolean preferDirect) {
        matcher = TypeParameterMatcher.find(this, MessageToByteEncoder.class, "I");
        this.preferDirect = preferDirect;
    }
    
    protected MessageToByteEncoder(Class<? extends I> outboundMessageType) {
        this(outboundMessageType, true);
    }
    
    protected MessageToByteEncoder(Class<? extends I> outboundMessageType, boolean preferDirect) {
        matcher = TypeParameterMatcher.get(outboundMessageType);
        this.preferDirect = preferDirect;
    }
    
    /**
     * ğŸ”¥ åˆ¤æ–­æ¶ˆæ¯æ˜¯å¦å¯æ¥å—
     */
    public boolean acceptOutboundMessage(Object msg) throws Exception {
        return matcher.match(msg);
    }
    
    /**
     * ğŸ”¥ å¤„ç†å†™å…¥æ“ä½œ - æ ¸å¿ƒæ–¹æ³•
     */
    @Override
    public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {
        ByteBuf buf = null;
        try {
            if (acceptOutboundMessage(msg)) {
                @SuppressWarnings("unchecked")
                I cast = (I) msg;
                buf = allocateBuffer(ctx, cast, preferDirect);
                try {
                    encode(ctx, cast, buf);
                } finally {
                    ReferenceCountUtil.release(cast);
                }
                
                if (buf.isReadable()) {
                    ctx.write(buf, promise);
                } else {
                    buf.release();
                    ctx.write(Unpooled.EMPTY_BUFFER, promise);
                }
                buf = null;
            } else {
                ctx.write(msg, promise);
            }
        } catch (EncoderException e) {
            throw e;
        } catch (Throwable e) {
            throw new EncoderException(e);
        } finally {
            if (buf != null) {
                buf.release();
            }
        }
    }
    
    /**
     * ğŸ”¥ åˆ†é…ç¼“å†²åŒº
     */
    protected ByteBuf allocateBuffer(ChannelHandlerContext ctx, @SuppressWarnings("unused") I msg,
                               boolean preferDirect) throws Exception {
        if (preferDirect) {
            return ctx.alloc().ioBuffer();
        } else {
            return ctx.alloc().heapBuffer();
        }
    }
    
    /**
     * ğŸ”¥ æŠ½è±¡ç¼–ç æ–¹æ³• - å­ç±»å®ç°
     */
    protected abstract void encode(ChannelHandlerContext ctx, I msg, ByteBuf out) throws Exception;
    
    /**
     * ğŸ”¥ åˆ¤æ–­æ˜¯å¦ä¸ºç›´æ¥å†…å­˜
     */
    protected boolean isPreferDirect() {
        return preferDirect;
    }
}
```

### 3.2 MessageToMessageEncoderå®ç°

```java
/**
 * MessageToMessageEncoder - æ¶ˆæ¯åˆ°æ¶ˆæ¯ç¼–ç å™¨
 * å°†ä¸€ç§æ¶ˆæ¯ç±»å‹è½¬æ¢ä¸ºå¦ä¸€ç§æ¶ˆæ¯ç±»å‹
 */
public abstract class MessageToMessageEncoder<I> extends ChannelOutboundHandlerAdapter {
    
    private final TypeParameterMatcher matcher;
    
    /**
     * ğŸ”¥ æ„é€ å‡½æ•°
     */
    protected MessageToMessageEncoder() {
        matcher = TypeParameterMatcher.find(this, MessageToMessageEncoder.class, "I");
    }
    
    protected MessageToMessageEncoder(Class<? extends I> outboundMessageType) {
        matcher = TypeParameterMatcher.get(outboundMessageType);
    }
    
    /**
     * ğŸ”¥ åˆ¤æ–­æ¶ˆæ¯æ˜¯å¦å¯æ¥å—
     */
    public boolean acceptOutboundMessage(Object msg) throws Exception {
        return matcher.match(msg);
    }
    
    /**
     * ğŸ”¥ å¤„ç†å†™å…¥æ“ä½œ
     */
    @Override
    public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {
        CodecOutputList out = null;
        try {
            if (acceptOutboundMessage(msg)) {
                out = CodecOutputList.newInstance();
                @SuppressWarnings("unchecked")
                I cast = (I) msg;
                try {
                    encode(ctx, cast, out);
                } finally {
                    ReferenceCountUtil.release(cast);
                }
                
                if (out.isEmpty()) {
                    out.recycle();
                    out = null;
                    
                    throw new EncoderException(
                        StringUtil.simpleClassName(getClass()) + " must produce at least one message.");
                }
            } else {
                ctx.write(msg, promise);
            }
        } catch (EncoderException e) {
            throw e;
        } catch (Throwable t) {
            throw new EncoderException(t);
        } finally {
            if (out != null) {
                final int sizeMinusOne = out.size() - 1;
                if (sizeMinusOne == 0) {
                    ctx.write(out.get(0), promise);
                } else if (sizeMinusOne > 0) {
                    // ğŸ”¥ å¤šä¸ªæ¶ˆæ¯éœ€è¦åŒ…è£…Promise
                    ChannelPromise voidPromise = ctx.voidPromise();
                    boolean isVoidPromise = promise == voidPromise;
                    for (int i = 0; i < sizeMinusOne; i ++) {
                        ChannelPromise p;
                        if (isVoidPromise) {
                            p = voidPromise;
                        } else {
                            p = ctx.newPromise();
                        }
                        ctx.write(out.getUnsafe(i), p);
                    }
                    ctx.write(out.getUnsafe(sizeMinusOne), promise);
                }
                out.recycle();
            }
        }
    }
    
    /**
     * ğŸ”¥ æŠ½è±¡ç¼–ç æ–¹æ³• - å­ç±»å®ç°
     */
    protected abstract void encode(ChannelHandlerContext ctx, I msg, List<Object> out) throws Exception;
}
```

---

## 4. MessageToMessageCodecæºç è§£æ

### 4.1 MessageToMessageCodecå®ç°

```java
/**
 * MessageToMessageCodec - æ¶ˆæ¯åˆ°æ¶ˆæ¯ç¼–è§£ç å™¨
 * åŒæ—¶æ”¯æŒç¼–ç å’Œè§£ç åŠŸèƒ½
 */
public abstract class MessageToMessageCodec<INBOUND_IN, OUTBOUND_IN> extends ChannelDuplexHandler {
    
    private final MessageToMessageEncoder<Object> encoder = new MessageToMessageEncoder<Object>() {
        
        @Override
        public boolean acceptOutboundMessage(Object msg) throws Exception {
            return MessageToMessageCodec.this.acceptOutboundMessage(msg);
        }
        
        @Override
        @SuppressWarnings("unchecked")
        protected void encode(ChannelHandlerContext ctx, Object msg, List<Object> out) throws Exception {
            MessageToMessageCodec.this.encode(ctx, (OUTBOUND_IN) msg, out);
        }
    };
    
    private final MessageToMessageDecoder<Object> decoder = new MessageToMessageDecoder<Object>() {
        
        @Override
        public boolean acceptInboundMessage(Object msg) throws Exception {
            return MessageToMessageCodec.this.acceptInboundMessage(msg);
        }
        
        @Override
        @SuppressWarnings("unchecked")
        protected void decode(ChannelHandlerContext ctx, Object msg, List<Object> out) throws Exception {
            MessageToMessageCodec.this.decode(ctx, (INBOUND_IN) msg, out);
        }
    };
    
    private final TypeParameterMatcher inboundMsgMatcher;
    private final TypeParameterMatcher outboundMsgMatcher;
    
    /**
     * ğŸ”¥ æ„é€ å‡½æ•°
     */
    protected MessageToMessageCodec() {
        inboundMsgMatcher = TypeParameterMatcher.find(this, MessageToMessageCodec.class, "INBOUND_IN");
        outboundMsgMatcher = TypeParameterMatcher.find(this, MessageToMessageCodec.class, "OUTBOUND_IN");
    }
    
    protected MessageToMessageCodec(
            Class<? extends INBOUND_IN> inboundMessageType, Class<? extends OUTBOUND_IN> outboundMessageType) {
        inboundMsgMatcher = TypeParameterMatcher.get(inboundMessageType);
        outboundMsgMatcher = TypeParameterMatcher.get(outboundMessageType);
    }
    
    /**
     * ğŸ”¥ å¤„ç†è¯»å–äº‹ä»¶
     */
    @Override
    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
        decoder.channelRead(ctx, msg);
    }
    
    /**
     * ğŸ”¥ å¤„ç†å†™å…¥æ“ä½œ
     */
    @Override
    public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {
        encoder.write(ctx, msg, promise);
    }
    
    /**
     * ğŸ”¥ åˆ¤æ–­å…¥ç«™æ¶ˆæ¯æ˜¯å¦å¯æ¥å—
     */
    public boolean acceptInboundMessage(Object msg) throws Exception {
        return inboundMsgMatcher.match(msg);
    }
    
    /**
     * ğŸ”¥ åˆ¤æ–­å‡ºç«™æ¶ˆæ¯æ˜¯å¦å¯æ¥å—
     */
    public boolean acceptOutboundMessage(Object msg) throws Exception {
        return outboundMsgMatcher.match(msg);
    }
    
    /**
     * ğŸ”¥ æŠ½è±¡è§£ç æ–¹æ³•
     */
    protected abstract void encode(ChannelHandlerContext ctx, OUTBOUND_IN msg, List<Object> out) throws Exception;
    
    /**
     * ğŸ”¥ æŠ½è±¡ç¼–ç æ–¹æ³•
     */
    protected abstract void decode(ChannelHandlerContext ctx, INBOUND_IN msg, List<Object> out) throws Exception;
}
```

### 4.2 ByteToMessageCodecå®ç°

```java
/**
 * ByteToMessageCodec - å­—èŠ‚åˆ°æ¶ˆæ¯ç¼–è§£ç å™¨
 * ç»“åˆByteToMessageDecoderå’ŒMessageToByteEncoder
 */
public abstract class ByteToMessageCodec<I> extends ChannelDuplexHandler {
    
    private final TypeParameterMatcher outboundMsgMatcher;
    private final MessageToByteEncoder<I> encoder;
    
    private final ByteToMessageDecoder decoder = new ByteToMessageDecoder() {
        @Override
        public void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) throws Exception {
            ByteToMessageCodec.this.decode(ctx, in, out);
        }
        
        @Override
        protected void decodeLast(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) throws Exception {
            ByteToMessageCodec.this.decodeLast(ctx, in, out);
        }
    };
    
    /**
     * ğŸ”¥ æ„é€ å‡½æ•°
     */
    protected ByteToMessageCodec() {
        this(true);
    }
    
    protected ByteToMessageCodec(Class<? extends I> outboundMessageType) {
        this(outboundMessageType, true);
    }
    
    protected ByteToMessageCodec(boolean preferDirect) {
        outboundMsgMatcher = TypeParameterMatcher.find(this, ByteToMessageCodec.class, "I");
        encoder = new Encoder(preferDirect);
    }
    
    protected ByteToMessageCodec(Class<? extends I> outboundMessageType, boolean preferDirect) {
        outboundMsgMatcher = TypeParameterMatcher.get(outboundMessageType);
        encoder = new Encoder(preferDirect);
    }
    
    /**
     * ğŸ”¥ åˆ¤æ–­å‡ºç«™æ¶ˆæ¯æ˜¯å¦å¯æ¥å—
     */
    public boolean acceptOutboundMessage(Object msg) throws Exception {
        return outboundMsgMatcher.match(msg);
    }
    
    /**
     * ğŸ”¥ å¤„ç†è¯»å–äº‹ä»¶
     */
    @Override
    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
        decoder.channelRead(ctx, msg);
    }
    
    /**
     * ğŸ”¥ å¤„ç†å†™å…¥æ“ä½œ
     */
    @Override
    public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {
        encoder.write(ctx, msg, promise);
    }
    
    /**
     * ğŸ”¥ æŠ½è±¡è§£ç æ–¹æ³•
     */
    protected abstract void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) throws Exception;
    
    /**
     * ğŸ”¥ è§£ç æœ€åçš„æ•°æ®
     */
    protected void decodeLast(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) throws Exception {
        if (in.isReadable()) {
            decode(ctx, in, out);
        }
    }
    
    /**
     * ğŸ”¥ æŠ½è±¡ç¼–ç æ–¹æ³•
     */
    protected abstract void encode(ChannelHandlerContext ctx, I msg, ByteBuf out) throws Exception;
    
    /**
     * ğŸ”¥ å†…éƒ¨ç¼–ç å™¨å®ç°
     */
    private final class Encoder extends MessageToByteEncoder<I> {
        
        Encoder(boolean preferDirect) {
            super(preferDirect);
        }
        
        @Override
        public boolean acceptOutboundMessage(Object msg) throws Exception {
            return ByteToMessageCodec.this.acceptOutboundMessage(msg);
        }
        
        @Override
        protected void encode(ChannelHandlerContext ctx, I msg, ByteBuf out) throws Exception {
            ByteToMessageCodec.this.encode(ctx, msg, out);
        }
    }
}
```

---

## 5. å†…ç½®ç¼–è§£ç å™¨åˆ†æ

### 5.1 LengthFieldBasedFrameDecoder

```java
/**
 * LengthFieldBasedFrameDecoder - åŸºäºé•¿åº¦å­—æ®µçš„å¸§è§£ç å™¨
 * è§£å†³TCPç²˜åŒ…æ‹†åŒ…é—®é¢˜
 */
public class LengthFieldBasedFrameDecoder extends ByteToMessageDecoder {
    
    private final ByteOrder byteOrder;
    private final int maxFrameLength;
    private final int lengthFieldOffset;
    private final int lengthFieldLength;
    private final int lengthFieldEndOffset;
    private final int lengthAdjustment;
    private final int initialBytesToStrip;
    private final boolean failFast;
    private boolean discardingTooLongFrame;
    private long tooLongFrameLength;
    private long bytesToDiscard;
    
    /**
     * ğŸ”¥ æ„é€ å‡½æ•°
     * @param maxFrameLength æœ€å¤§å¸§é•¿åº¦
     * @param lengthFieldOffset é•¿åº¦å­—æ®µåç§»é‡
     * @param lengthFieldLength é•¿åº¦å­—æ®µé•¿åº¦
     * @param lengthAdjustment é•¿åº¦è°ƒæ•´å€¼
     * @param initialBytesToStrip åˆå§‹è·³è¿‡å­—èŠ‚æ•°
     */
    public LengthFieldBasedFrameDecoder(
            int maxFrameLength,
            int lengthFieldOffset, int lengthFieldLength,
            int lengthAdjustment, int initialBytesToStrip) {
        this(
            maxFrameLength, lengthFieldOffset, lengthFieldLength,
            lengthAdjustment, initialBytesToStrip, true);
    }
    
    public LengthFieldBasedFrameDecoder(
            int maxFrameLength,
            int lengthFieldOffset, int lengthFieldLength,
            int lengthAdjustment, int initialBytesToStrip, boolean failFast) {
        this(
            ByteOrder.BIG_ENDIAN, maxFrameLength, lengthFieldOffset,
            lengthFieldLength, lengthAdjustment, initialBytesToStrip, failFast);
    }
    
    public LengthFieldBasedFrameDecoder(
            ByteOrder byteOrder, int maxFrameLength,
            int lengthFieldOffset, int lengthFieldLength,
            int lengthAdjustment, int initialBytesToStrip, boolean failFast) {
        
        if (byteOrder == null) {
            throw new NullPointerException("byteOrder");
        }
        
        // ğŸ”¥ å‚æ•°æ ¡éªŒ
        if (maxFrameLength <= 0) {
            throw new IllegalArgumentException("maxFrameLength must be a positive integer: " + maxFrameLength);
        }
        
        if (lengthFieldOffset < 0) {
            throw new IllegalArgumentException("lengthFieldOffset must be a non-negative integer: " + lengthFieldOffset);
        }
        
        if (initialBytesToStrip < 0) {
            throw new IllegalArgumentException("initialBytesToStrip must be a non-negative integer: " + initialBytesToStrip);
        }
        
        if (lengthFieldOffset > maxFrameLength - lengthFieldLength) {
            throw new IllegalArgumentException("maxFrameLength (" + maxFrameLength + ") " +
                "must be equal to or greater than lengthFieldOffset (" + lengthFieldOffset + ") + lengthFieldLength (" + lengthFieldLength + ").");
        }
        
        this.byteOrder = byteOrder;
        this.maxFrameLength = maxFrameLength;
        this.lengthFieldOffset = lengthFieldOffset;
        this.lengthFieldLength = lengthFieldLength;
        this.lengthAdjustment = lengthAdjustment;
        lengthFieldEndOffset = lengthFieldOffset + lengthFieldLength;
        this.initialBytesToStrip = initialBytesToStrip;
        this.failFast = failFast;
    }
    
    /**
     * ğŸ”¥ è§£ç å®ç°
     */
    @Override
    protected final void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) throws Exception {
        Object decoded = decode(ctx, in);
        if (decoded != null) {
            out.add(decoded);
        }
    }
    
    /**
     * ğŸ”¥ è§£ç æ ¸å¿ƒé€»è¾‘
     */
    protected Object decode(ChannelHandlerContext ctx, ByteBuf in) throws Exception {
        if (discardingTooLongFrame) {
            discardingTooLongFrame(in);
        }
        
        if (in.readableBytes() < lengthFieldEndOffset) {
            return null;
        }
        
        int actualLengthFieldOffset = in.readerIndex() + lengthFieldOffset;
        long frameLength = getUnadjustedFrameLength(in, actualLengthFieldOffset, lengthFieldLength, byteOrder);
        
        if (frameLength < 0) {
            failOnNegativeLengthField(in, frameLength, lengthFieldEndOffset);
        }
        
        frameLength += lengthAdjustment + lengthFieldEndOffset;
        
        if (frameLength < lengthFieldEndOffset) {
            failOnFrameLengthLessThanLengthFieldEndOffset(in, frameLength, lengthFieldEndOffset);
        }
        
        if (frameLength > maxFrameLength) {
            exceededFrameLength(in, frameLength);
            return null;
        }
        
        // ğŸ”¥ æ£€æŸ¥æ˜¯å¦æœ‰è¶³å¤Ÿçš„æ•°æ®
        int frameLengthInt = (int) frameLength;
        if (in.readableBytes() < frameLengthInt) {
            return null;
        }
        
        // ğŸ”¥ è·³è¿‡åˆå§‹å­—èŠ‚
        if (initialBytesToStrip > frameLengthInt) {
            failOnFrameLengthLessThanInitialBytesToStrip(in, frameLength, initialBytesToStrip);
        }
        in.skipBytes(initialBytesToStrip);
        
        // ğŸ”¥ æå–å¸§æ•°æ®
        int readerIndex = in.readerIndex();
        int actualFrameLength = frameLengthInt - initialBytesToStrip;
        ByteBuf frame = extractFrame(ctx, in, readerIndex, actualFrameLength);
        in.readerIndex(readerIndex + actualFrameLength);
        return frame;
    }
    
    /**
     * ğŸ”¥ è·å–æœªè°ƒæ•´çš„å¸§é•¿åº¦
     */
    protected long getUnadjustedFrameLength(ByteBuf buf, int offset, int length, ByteOrder order) {
        buf = buf.order(order);
        long frameLength;
        switch (length) {
        case 1:
            frameLength = buf.getUnsignedByte(offset);
            break;
        case 2:
            frameLength = buf.getUnsignedShort(offset);
            break;
        case 3:
            frameLength = buf.getUnsignedMedium(offset);
            break;
        case 4:
            frameLength = buf.getUnsignedInt(offset);
            break;
        case 8:
            frameLength = buf.getLong(offset);
            break;
        default:
            throw new DecoderException("unsupported lengthFieldLength: " + lengthFieldLength + " (expected: 1, 2, 3, 4, or 8)");
        }
        return frameLength;
    }
    
    /**
     * ğŸ”¥ æå–å¸§æ•°æ®
     */
    protected ByteBuf extractFrame(ChannelHandlerContext ctx, ByteBuf buffer, int index, int length) {
        return buffer.retainedSlice(index, length);
    }
}
```

### 5.2 StringDecoderå’ŒStringEncoder

```java
/**
 * StringDecoder - å­—ç¬¦ä¸²è§£ç å™¨
 * å°†ByteBufè§£ç ä¸ºå­—ç¬¦ä¸²
 */
@Sharable
public class StringDecoder extends MessageToMessageDecoder<ByteBuf> {
    
    private final Charset charset;
    
    /**
     * ğŸ”¥ æ„é€ å‡½æ•°
     */
    public StringDecoder() {
        this(CharsetUtil.UTF_8);
    }
    
    public StringDecoder(Charset charset) {
        if (charset == null) {
            throw new NullPointerException("charset");
        }
        this.charset = charset;
    }
    
    /**
     * ğŸ”¥ è§£ç å®ç°
     */
    @Override
    protected void decode(ChannelHandlerContext ctx, ByteBuf msg, List<Object> out) throws Exception {
        out.add(msg.toString(charset));
    }
}

/**
 * StringEncoder - å­—ç¬¦ä¸²ç¼–ç å™¨
 * å°†å­—ç¬¦ä¸²ç¼–ç ä¸ºByteBuf
 */
@Sharable
public class StringEncoder extends MessageToByteEncoder<CharSequence> {
    
    private final Charset charset;
    
    /**
     * ğŸ”¥ æ„é€ å‡½æ•°
     */
    public StringEncoder() {
        this(CharsetUtil.UTF_8);
    }
    
    public StringEncoder(Charset charset) {
        if (charset == null) {
            throw new NullPointerException("charset");
        }
        this.charset = charset;
    }
    
    /**
     * ğŸ”¥ ç¼–ç å®ç°
     */
    @Override
    protected void encode(ChannelHandlerContext ctx, CharSequence msg, ByteBuf out) throws Exception {
        if (msg.length() == 0) {
            return;
        }
        
        out.writeCharSequence(msg, charset);
    }
}
```

---

## 6. è‡ªå®šä¹‰ç¼–è§£ç å™¨å®ç°

### 6.1 è‡ªå®šä¹‰åè®®ç¼–è§£ç å™¨

```java
/**
 * è‡ªå®šä¹‰åè®®æ¶ˆæ¯
 */
public class CustomMessage {
    private int type;
    private int length;
    private String content;
    
    // æ„é€ å‡½æ•°ã€getterã€setterçœç•¥
    
    public static final int HEADER_LENGTH = 8; // 4å­—èŠ‚type + 4å­—èŠ‚length
}

/**
 * è‡ªå®šä¹‰åè®®è§£ç å™¨
 */
public class CustomMessageDecoder extends ByteToMessageDecoder {
    
    /**
     * ğŸ”¥ è§£ç å®ç°
     */
    @Override
    protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) throws Exception {
        // ğŸ”¥ æ£€æŸ¥æ˜¯å¦æœ‰è¶³å¤Ÿçš„å¤´éƒ¨æ•°æ®
        if (in.readableBytes() < CustomMessage.HEADER_LENGTH) {
            return;
        }
        
        // ğŸ”¥ æ ‡è®°è¯»å–ä½ç½®
        in.markReaderIndex();
        
        // ğŸ”¥ è¯»å–æ¶ˆæ¯ç±»å‹
        int type = in.readInt();
        
        // ğŸ”¥ è¯»å–æ¶ˆæ¯é•¿åº¦
        int length = in.readInt();
        
        // ğŸ”¥ éªŒè¯é•¿åº¦
        if (length < 0 || length > 1024 * 1024) { // æœ€å¤§1MB
            throw new DecoderException("Invalid message length: " + length);
        }
        
        // ğŸ”¥ æ£€æŸ¥æ˜¯å¦æœ‰è¶³å¤Ÿçš„å†…å®¹æ•°æ®
        if (in.readableBytes() < length) {
            in.resetReaderIndex();
            return;
        }
        
        // ğŸ”¥ è¯»å–æ¶ˆæ¯å†…å®¹
        byte[] contentBytes = new byte[length];
        in.readBytes(contentBytes);
        String content = new String(contentBytes, StandardCharsets.UTF_8);
        
        // ğŸ”¥ åˆ›å»ºæ¶ˆæ¯å¯¹è±¡
        CustomMessage message = new CustomMessage(type, length, content);
        out.add(message);
    }
}

/**
 * è‡ªå®šä¹‰åè®®ç¼–ç å™¨
 */
public class CustomMessageEncoder extends MessageToByteEncoder<CustomMessage> {
    
    /**
     * ğŸ”¥ ç¼–ç å®ç°
     */
    @Override
    protected void encode(ChannelHandlerContext ctx, CustomMessage msg, ByteBuf out) throws Exception {
        // ğŸ”¥ è·å–å†…å®¹å­—èŠ‚
        byte[] contentBytes = msg.getContent().getBytes(StandardCharsets.UTF_8);
        
        // ğŸ”¥ å†™å…¥æ¶ˆæ¯ç±»å‹
        out.writeInt(msg.getType());
        
        // ğŸ”¥ å†™å…¥æ¶ˆæ¯é•¿åº¦
        out.writeInt(contentBytes.length);
        
        // ğŸ”¥ å†™å…¥æ¶ˆæ¯å†…å®¹
        out.writeBytes(contentBytes);
    }
}

/**
 * è‡ªå®šä¹‰åè®®ç¼–è§£ç å™¨ï¼ˆç»„åˆç‰ˆæœ¬ï¼‰
 */
public class CustomMessageCodec extends ByteToMessageCodec<CustomMessage> {
    
    /**
     * ğŸ”¥ è§£ç å®ç°
     */
    @Override
    protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) throws Exception {
        if (in.readableBytes() < CustomMessage.HEADER_LENGTH) {
            return;
        }
        
        in.markReaderIndex();
        
        int type = in.readInt();
        int length = in.readInt();
        
        if (length < 0 || length > 1024 * 1024) {
            throw new DecoderException("Invalid message length: " + length);
        }
        
        if (in.readableBytes() < length) {
            in.resetReaderIndex();
            return;
        }
        
        byte[] contentBytes = new byte[length];
        in.readBytes(contentBytes);
        String content = new String(contentBytes, StandardCharsets.UTF_8);
        
        CustomMessage message = new CustomMessage(type, length, content);
        out.add(message);
    }
    
    /**
     * ğŸ”¥ ç¼–ç å®ç°
     */
    @Override
    protected void encode(ChannelHandlerContext ctx, CustomMessage msg, ByteBuf out) throws Exception {
        byte[] contentBytes = msg.getContent().getBytes(StandardCharsets.UTF_8);
        
        out.writeInt(msg.getType());
        out.writeInt(contentBytes.length);
        out.writeBytes(contentBytes);
    }
}
```

### 6.2 JSONç¼–è§£ç å™¨

```java
/**
 * JSONè§£ç å™¨
 */
public class JsonDecoder extends MessageToMessageDecoder<String> {
    
    private final ObjectMapper objectMapper;
    private final Class<?> targetClass;
    
    /**
     * ğŸ”¥ æ„é€ å‡½æ•°
     */
    public JsonDecoder(Class<?> targetClass) {
        this.objectMapper = new ObjectMapper();
        this.targetClass = targetClass;
    }
    
    /**
     * ğŸ”¥ è§£ç å®ç°
     */
    @Override
    protected void decode(ChannelHandlerContext ctx, String msg, List<Object> out) throws Exception {
        try {
            Object obj = objectMapper.readValue(msg, targetClass);
            out.add(obj);
        } catch (JsonProcessingException e) {
            throw new DecoderException("Failed to decode JSON: " + msg, e);
        }
    }
}

/**
 * JSONç¼–ç å™¨
 */
public class JsonEncoder extends MessageToMessageEncoder<Object> {
    
    private final ObjectMapper objectMapper;
    
    /**
     * ğŸ”¥ æ„é€ å‡½æ•°
     */
    public JsonEncoder() {
        this.objectMapper = new ObjectMapper();
    }
    
    /**
     * ğŸ”¥ ç¼–ç å®ç°
     */
    @Override
    protected void encode(ChannelHandlerContext ctx, Object msg, List<Object> out) throws Exception {
        try {
            String json = objectMapper.writeValueAsString(msg);
            out.add(json);
        } catch (JsonProcessingException e) {
            throw new EncoderException("Failed to encode JSON: " + msg, e);
        }
    }
}

/**
 * ä½¿ç”¨ç¤ºä¾‹
 */
public class JsonCodecExample {
    
    public void setupPipeline(ChannelPipeline pipeline) {
        // ğŸ”¥ æ·»åŠ å¸§è§£ç å™¨ï¼ˆè§£å†³ç²˜åŒ…é—®é¢˜ï¼‰
        pipeline.addLast("frameDecoder", 
            new LengthFieldBasedFrameDecoder(1024 * 1024, 0, 4, 0, 4));
        pipeline.addLast("frameEncoder", 
            new LengthFieldPrepender(4));
        
        // ğŸ”¥ æ·»åŠ å­—ç¬¦ä¸²ç¼–è§£ç å™¨
        pipeline.addLast("stringDecoder", new StringDecoder(StandardCharsets.UTF_8));
        pipeline.addLast("stringEncoder", new StringEncoder(StandardCharsets.UTF_8));
        
        // ğŸ”¥ æ·»åŠ JSONç¼–è§£ç å™¨
        pipeline.addLast("jsonDecoder", new JsonDecoder(MyMessage.class));
        pipeline.addLast("jsonEncoder", new JsonEncoder());
        
        // ğŸ”¥ æ·»åŠ ä¸šåŠ¡å¤„ç†å™¨
        pipeline.addLast("businessHandler", new BusinessHandler());
    }
}
```

---

## 7. é¢è¯•è¦ç‚¹

### 7.1 æ ¸å¿ƒæ¦‚å¿µ

```
ğŸ¯ ç¼–è§£ç å™¨é¢è¯•è¦ç‚¹

1. ç¼–è§£ç å™¨åˆ†ç±»
   Q: Nettyæœ‰å“ªäº›ç±»å‹çš„ç¼–è§£ç å™¨ï¼Ÿ
   A: 
   - ByteToMessageDecoderï¼šå­—èŠ‚â†’å¯¹è±¡
   - MessageToByteEncoderï¼šå¯¹è±¡â†’å­—èŠ‚
   - MessageToMessageDecoderï¼šå¯¹è±¡â†’å¯¹è±¡
   - MessageToMessageEncoderï¼šå¯¹è±¡â†’å¯¹è±¡
   - ByteToMessageCodecï¼šåŒå‘å­—èŠ‚ç¼–è§£ç 
   - MessageToMessageCodecï¼šåŒå‘å¯¹è±¡ç¼–è§£ç 

2. ç²˜åŒ…æ‹†åŒ…é—®é¢˜
   Q: å¦‚ä½•è§£å†³TCPç²˜åŒ…æ‹†åŒ…é—®é¢˜ï¼Ÿ
   A:
   - å›ºå®šé•¿åº¦ï¼šFixedLengthFrameDecoder
   - åˆ†éš”ç¬¦ï¼šDelimiterBasedFrameDecoder
   - é•¿åº¦å­—æ®µï¼šLengthFieldBasedFrameDecoder
   - è‡ªå®šä¹‰åè®®ï¼šç»§æ‰¿ByteToMessageDecoder

3. ç´¯ç§¯ç¼“å†²åŒº
   Q: ByteToMessageDecoderå¦‚ä½•å¤„ç†æ•°æ®ç´¯ç§¯ï¼Ÿ
   A:
   - ä½¿ç”¨Cumulatoræ¥å£ç®¡ç†æ•°æ®ç´¯ç§¯
   - MERGE_CUMULATORï¼šåˆå¹¶åˆ°ç°æœ‰ç¼“å†²åŒº
   - COMPOSITE_CUMULATORï¼šä½¿ç”¨CompositeByteBuf
   - è‡ªåŠ¨å¤„ç†æ•°æ®ä¸è¶³çš„æƒ…å†µ

4. ReplayingDecoder
   Q: ReplayingDecoderæœ‰ä»€ä¹ˆç‰¹ç‚¹ï¼Ÿ
   A:
   - ç®€åŒ–è§£ç é€»è¾‘ï¼Œæ— éœ€æ£€æŸ¥æ•°æ®é•¿åº¦
   - ä½¿ç”¨æ£€æŸ¥ç‚¹æœºåˆ¶å¤„ç†æ•°æ®ä¸è¶³
   - æŠ›å‡ºREPLAYä¿¡å·é‡æ–°è§£ç 
   - æ€§èƒ½ç•¥ä½äºByteToMessageDecoder
```

### 7.2 å®é™…åº”ç”¨

```
ğŸ”§ å®é™…åº”ç”¨åœºæ™¯

1. HTTPåè®®å¤„ç†
   åœºæ™¯: å®ç°HTTPæœåŠ¡å™¨
   æ–¹æ¡ˆ:
   - HttpRequestDecoderè§£ç HTTPè¯·æ±‚
   - HttpResponseEncoderç¼–ç HTTPå“åº”
   - HttpObjectAggregatorèšåˆHTTPæ¶ˆæ¯
   - HttpContentCompressorå‹ç¼©å“åº”

2. è‡ªå®šä¹‰åè®®
   åœºæ™¯: è®¾è®¡ç§æœ‰é€šä¿¡åè®®
   æ–¹æ¡ˆ:
   - å®šä¹‰åè®®æ ¼å¼ï¼ˆå¤´éƒ¨+é•¿åº¦+å†…å®¹ï¼‰
   - å®ç°ByteToMessageDecoderè§£ç 
   - å®ç°MessageToByteEncoderç¼–ç 
   - å¤„ç†åè®®ç‰ˆæœ¬å…¼å®¹æ€§

3. åºåˆ—åŒ–æ¡†æ¶
   åœºæ™¯: é›†æˆProtobuf/JSONåºåˆ—åŒ–
   æ–¹æ¡ˆ:
   - ProtobufDecoder/ProtobufEncoder
   - è‡ªå®šä¹‰JSONç¼–è§£ç å™¨
   - å¤„ç†åºåˆ—åŒ–å¼‚å¸¸
   - ä¼˜åŒ–åºåˆ—åŒ–æ€§èƒ½

4. æ•°æ®å‹ç¼©
   åœºæ™¯: å‡å°‘ç½‘ç»œä¼ è¾“æ•°æ®é‡
   æ–¹æ¡ˆ:
   - JdkZlibEncoder/JdkZlibDecoder
   - é€‰æ‹©åˆé€‚çš„å‹ç¼©ç®—æ³•
   - å¹³è¡¡å‹ç¼©ç‡å’Œæ€§èƒ½
   - å¤„ç†å‹ç¼©å¼‚å¸¸
```

### 7.3 å¸¸è§é—®é¢˜

```
â“ å¸¸è§é¢è¯•é—®é¢˜

Q1: ç¼–è§£ç å™¨çš„æ‰§è¡Œé¡ºåºæ˜¯æ€æ ·çš„ï¼Ÿ
A1: 
- å…¥ç«™ï¼šæŒ‰æ·»åŠ é¡ºåºæ‰§è¡Œè§£ç å™¨
- å‡ºç«™ï¼šæŒ‰æ·»åŠ é¡ºåºé€†åºæ‰§è¡Œç¼–ç å™¨
- è§£ç å™¨åªå¤„ç†å…¥ç«™æ•°æ®ï¼Œç¼–ç å™¨åªå¤„ç†å‡ºç«™æ•°æ®

Q2: å¦‚ä½•å¤„ç†ç¼–è§£ç å¼‚å¸¸ï¼Ÿ
A2:
- æ•è·DecoderException/EncoderException
- è®°å½•è¯¦ç»†çš„é”™è¯¯æ—¥å¿—
- å…³é—­æœ‰é—®é¢˜çš„è¿æ¥
- å®ç°é™çº§å¤„ç†æœºåˆ¶

Q3: ç¼–è§£ç å™¨çš„æ€§èƒ½ä¼˜åŒ–æ–¹æ³•ï¼Ÿ
A3:
- ä½¿ç”¨@Sharableé¿å…é‡å¤åˆ›å»º
- é€‰æ‹©åˆé€‚çš„ç¼“å†²åŒºç±»å‹ï¼ˆç›´æ¥å†…å­˜vså †å†…å­˜ï¼‰
- å‡å°‘å†…å­˜æ‹·è´æ“ä½œ
- ä½¿ç”¨å¯¹è±¡æ± å¤ç”¨å¯¹è±¡

Q4: å¦‚ä½•å®ç°åè®®ç‰ˆæœ¬å…¼å®¹ï¼Ÿ
A4:
- åœ¨åè®®å¤´éƒ¨åŒ…å«ç‰ˆæœ¬ä¿¡æ¯
- æ ¹æ®ç‰ˆæœ¬é€‰æ‹©ä¸åŒçš„ç¼–è§£ç å™¨
- å‘åå…¼å®¹æ—§ç‰ˆæœ¬åè®®
- æä¾›åè®®å‡çº§æœºåˆ¶

Q5: LengthFieldBasedFrameDecoderçš„å‚æ•°å«ä¹‰ï¼Ÿ
A5:
- maxFrameLengthï¼šæœ€å¤§å¸§é•¿åº¦
- lengthFieldOffsetï¼šé•¿åº¦å­—æ®µåç§»é‡
- lengthFieldLengthï¼šé•¿åº¦å­—æ®µé•¿åº¦
- lengthAdjustmentï¼šé•¿åº¦è°ƒæ•´å€¼
- initialBytesToStripï¼šè·³è¿‡çš„åˆå§‹å­—èŠ‚æ•°
```

### 7.4 æœ€ä½³å®è·µ

```
âœ… å¼€å‘æœ€ä½³å®è·µ

1. ç¼–è§£ç å™¨è®¾è®¡
   - å•ä¸€èŒè´£ï¼šæ¯ä¸ªç¼–è§£ç å™¨åªå¤„ç†ä¸€ç§æ•°æ®æ ¼å¼
   - æ— çŠ¶æ€è®¾è®¡ï¼šä½¿ç”¨@Sharableæé«˜å¤ç”¨æ€§
   - å¼‚å¸¸å¤„ç†ï¼šå¦¥å–„å¤„ç†ç¼–è§£ç å¼‚å¸¸
   - æ€§èƒ½ä¼˜åŒ–ï¼šå‡å°‘ä¸å¿…è¦çš„å†…å­˜åˆ†é…

2. åè®®è®¾è®¡
   - åŒ…å«é•¿åº¦å­—æ®µè§£å†³ç²˜åŒ…é—®é¢˜
   - æ·»åŠ é­”æ•°å’Œç‰ˆæœ¬å·
   - è€ƒè™‘å­—èŠ‚åºé—®é¢˜
   - é¢„ç•™æ‰©å±•å­—æ®µ

3. ç¼“å†²åŒºç®¡ç†
   - åŠæ—¶é‡Šæ”¾ByteBufèµ„æº
   - é€‰æ‹©åˆé€‚çš„Cumulator
   - é¿å…å†…å­˜æ³„æ¼
   - ç›‘æ§å†…å­˜ä½¿ç”¨æƒ…å†µ

4. æµ‹è¯•éªŒè¯
   - ä½¿ç”¨EmbeddedChannelæµ‹è¯•ç¼–è§£ç å™¨
   - æµ‹è¯•è¾¹ç•Œæ¡ä»¶å’Œå¼‚å¸¸æƒ…å†µ
   - éªŒè¯åè®®å…¼å®¹æ€§
   - è¿›è¡Œæ€§èƒ½å‹æµ‹
```

---

## ğŸ“‹ æ€»ç»“

Nettyç¼–è§£ç å™¨æ˜¯ç½‘ç»œæ•°æ®å¤„ç†çš„æ ¸å¿ƒç»„ä»¶ï¼Œé€šè¿‡æ¨¡æ¿æ–¹æ³•æ¨¡å¼æä¾›äº†çµæ´»çš„æ•°æ®è½¬æ¢æ¡†æ¶ã€‚ä¸åŒç±»å‹çš„ç¼–è§£ç å™¨é€‚ç”¨äºä¸åŒçš„åœºæ™¯ï¼Œåˆç†é€‰æ‹©å’Œä½¿ç”¨ç¼–è§£ç å™¨æ˜¯æ„å»ºé«˜æ€§èƒ½ç½‘ç»œåº”ç”¨çš„å…³é”®ã€‚

**æ ¸å¿ƒè¦ç‚¹**ï¼š
- **åˆ†å±‚è®¾è®¡**ï¼šå­—èŠ‚çº§å’Œæ¶ˆæ¯çº§ç¼–è§£ç å™¨åˆ†å±‚å¤„ç†
- **æ¨¡æ¿æ–¹æ³•**ï¼šæŠ½è±¡ç±»æä¾›æ¡†æ¶ï¼Œå­ç±»å®ç°å…·ä½“é€»è¾‘
- **èµ„æºç®¡ç†**ï¼šè‡ªåŠ¨å¤„ç†ç¼“å†²åŒºç´¯ç§¯å’Œèµ„æºé‡Šæ”¾
- **å¼‚å¸¸å¤„ç†**ï¼šå®Œå–„çš„å¼‚å¸¸å¤„ç†å’Œé”™è¯¯æ¢å¤æœºåˆ¶

æŒæ¡ç¼–è§£ç å™¨çš„åŸç†å’Œä½¿ç”¨ï¼Œèƒ½å¤Ÿå¸®åŠ©æˆ‘ä»¬è®¾è®¡å‡ºé«˜æ•ˆã€å¯é çš„ç½‘ç»œé€šä¿¡åè®®ã€‚
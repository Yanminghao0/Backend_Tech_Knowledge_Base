# AQSæºç è§£æ

> AbstractQueuedSynchronizer - Javaå¹¶å‘çš„åŸºçŸ³

## ğŸ“‹ ç›®å½•
- [AQSæ¦‚è¿°](#aqsæ¦‚è¿°)
- [æ ¸å¿ƒç»“æ„](#æ ¸å¿ƒç»“æ„)
- [ç‹¬å æ¨¡å¼](#ç‹¬å æ¨¡å¼)
- [å…±äº«æ¨¡å¼](#å…±äº«æ¨¡å¼)
- [Conditionæ¡ä»¶é˜Ÿåˆ—](#conditionæ¡ä»¶é˜Ÿåˆ—)
- [é¢è¯•è¦ç‚¹](#é¢è¯•è¦ç‚¹)

---

## AQSæ¦‚è¿°

### ä»€ä¹ˆæ˜¯AQSï¼Ÿ

```java
/**
 * AQSï¼ˆAbstractQueuedSynchronizerï¼‰ï¼š
 * - æŠ½è±¡é˜Ÿåˆ—åŒæ­¥å™¨
 * - Javaå¹¶å‘åŒ…çš„åŸºç¡€æ¡†æ¶
 * - æä¾›äº†é”å’ŒåŒæ­¥å™¨çš„é€šç”¨å®ç°
 */

// åŸºäºAQSå®ç°çš„åŒæ­¥å™¨
ReentrantLock        // å¯é‡å…¥é”
ReentrantReadWriteLock // è¯»å†™é”
Semaphore            // ä¿¡å·é‡
CountDownLatch       // å€’è®¡æ—¶é—¨é—©
CyclicBarrier        // å¾ªç¯æ …æ ï¼ˆé—´æ¥ä½¿ç”¨ï¼‰
```

### AQSæ ¸å¿ƒæ€æƒ³

```
æ ¸å¿ƒæ€æƒ³ï¼š
  1. ç”¨ä¸€ä¸ªintå˜é‡è¡¨ç¤ºåŒæ­¥çŠ¶æ€ï¼ˆstateï¼‰
  2. ç”¨ä¸€ä¸ªFIFOé˜Ÿåˆ—ç®¡ç†ç­‰å¾…çº¿ç¨‹ï¼ˆCLHé˜Ÿåˆ—ï¼‰
  3. å­ç±»é€šè¿‡é‡å†™æ–¹æ³•å®šä¹‰è·å–/é‡Šæ”¾è§„åˆ™

æ¨¡æ¿æ–¹æ³•æ¨¡å¼ï¼š
  AQSå®šä¹‰äº†è·å–/é‡Šæ”¾çš„æµç¨‹
  å­ç±»åªéœ€å®ç°tryAcquire/tryReleaseç­‰æ–¹æ³•
```

---

## æ ¸å¿ƒç»“æ„

### åŒæ­¥çŠ¶æ€ state

```java
public abstract class AbstractQueuedSynchronizer {
    
    /**
     * åŒæ­¥çŠ¶æ€
     * - volatileä¿è¯å¯è§æ€§
     * - ä¸åŒå®ç°æœ‰ä¸åŒå«ä¹‰
     */
    private volatile int state;
    
    // è·å–çŠ¶æ€
    protected final int getState() {
        return state;
    }
    
    // è®¾ç½®çŠ¶æ€
    protected final void setState(int newState) {
        state = newState;
    }
    
    // CASè®¾ç½®çŠ¶æ€ï¼ˆåŸå­æ“ä½œï¼‰
    protected final boolean compareAndSetState(int expect, int update) {
        return unsafe.compareAndSwapInt(this, stateOffset, expect, update);
    }
}

// stateçš„å«ä¹‰ï¼ˆä¸åŒå®ç°ï¼‰ï¼š
// ReentrantLock: 0=æœªé”å®š, >0=é”å®šæ¬¡æ•°ï¼ˆå¯é‡å…¥ï¼‰
// Semaphore: å¯ç”¨è®¸å¯æ•°
// CountDownLatch: å‰©ä½™è®¡æ•°
// ReentrantReadWriteLock: é«˜16ä½=è¯»é”æ•°, ä½16ä½=å†™é”æ•°
```

### CLHé˜Ÿåˆ—ï¼ˆç­‰å¾…é˜Ÿåˆ—ï¼‰

```java
/**
 * CLHé˜Ÿåˆ—ï¼šåŒå‘é“¾è¡¨
 * - æ¯ä¸ªèŠ‚ç‚¹ä»£è¡¨ä¸€ä¸ªç­‰å¾…çº¿ç¨‹
 * - FIFOé¡ºåº
 */
static final class Node {
    
    // èŠ‚ç‚¹æ¨¡å¼
    static final Node SHARED = new Node();  // å…±äº«æ¨¡å¼
    static final Node EXCLUSIVE = null;     // ç‹¬å æ¨¡å¼
    
    // ç­‰å¾…çŠ¶æ€
    static final int CANCELLED =  1;  // å–æ¶ˆ
    static final int SIGNAL    = -1;  // éœ€è¦å”¤é†’åç»§
    static final int CONDITION = -2;  // åœ¨æ¡ä»¶é˜Ÿåˆ—ä¸­
    static final int PROPAGATE = -3;  // å…±äº«æ¨¡å¼ä¼ æ’­
    
    volatile int waitStatus;      // ç­‰å¾…çŠ¶æ€
    volatile Node prev;           // å‰é©±èŠ‚ç‚¹
    volatile Node next;           // åç»§èŠ‚ç‚¹
    volatile Thread thread;       // ç­‰å¾…çº¿ç¨‹
    Node nextWaiter;              // æ¡ä»¶é˜Ÿåˆ—ä¸‹ä¸€ä¸ªèŠ‚ç‚¹
}

// é˜Ÿåˆ—ç»“æ„
//  head                                    tail
//   â†“                                       â†“
// [dummy] â†â†’ [Node1] â†â†’ [Node2] â†â†’ [Node3]
//              â†‘          â†‘          â†‘
//           thread1    thread2    thread3
```

### waitStatusçŠ¶æ€è¯´æ˜

```
waitStatuså€¼ï¼š

CANCELLED (1)ï¼š
  - çº¿ç¨‹è¢«å–æ¶ˆæˆ–è¶…æ—¶
  - èŠ‚ç‚¹ä¸å†å‚ä¸ç«äº‰
  - éœ€è¦ä»é˜Ÿåˆ—ä¸­ç§»é™¤

SIGNAL (-1)ï¼š
  - åç»§èŠ‚ç‚¹éœ€è¦è¢«å”¤é†’
  - å½“å‰èŠ‚ç‚¹é‡Šæ”¾é”æ—¶ï¼Œéœ€è¦unparkåç»§

CONDITION (-2)ï¼š
  - èŠ‚ç‚¹åœ¨æ¡ä»¶é˜Ÿåˆ—ä¸­
  - ç­‰å¾…condition.signal()

PROPAGATE (-3)ï¼š
  - å…±äº«æ¨¡å¼ä¸‹ï¼Œé‡Šæ”¾éœ€è¦ä¼ æ’­
  - ç¡®ä¿åç»­èŠ‚ç‚¹èƒ½è·å–èµ„æº

0ï¼š
  - åˆå§‹çŠ¶æ€
  - æ–°èŠ‚ç‚¹å…¥é˜Ÿæ—¶çš„çŠ¶æ€
```

---

## ç‹¬å æ¨¡å¼

### acquire - è·å–é”

```java
/**
 * ç‹¬å æ¨¡å¼è·å–é”ï¼ˆä¸å“åº”ä¸­æ–­ï¼‰
 */
public final void acquire(int arg) {
    // 1. tryAcquireå°è¯•è·å–é”ï¼ˆå­ç±»å®ç°ï¼‰
    // 2. å¤±è´¥åˆ™åŠ å…¥é˜Ÿåˆ—å¹¶é˜»å¡
    if (!tryAcquire(arg) &&
        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
        selfInterrupt();
}

// æµç¨‹ï¼š
// 1. tryAcquire() - å°è¯•è·å–é”
//    â†“ å¤±è´¥
// 2. addWaiter() - åˆ›å»ºèŠ‚ç‚¹åŠ å…¥é˜Ÿåˆ—
//    â†“
// 3. acquireQueued() - è‡ªæ—‹+é˜»å¡ç­‰å¾…
//    â†“ è·å–æˆåŠŸ
// 4. è¿”å›
```

### addWaiter - åŠ å…¥ç­‰å¾…é˜Ÿåˆ—

```java
/**
 * åˆ›å»ºèŠ‚ç‚¹å¹¶åŠ å…¥é˜Ÿåˆ—å°¾éƒ¨
 */
private Node addWaiter(Node mode) {
    Node node = new Node(Thread.currentThread(), mode);
    
    // å¿«é€Ÿå°è¯•ï¼šç›´æ¥CASåŠ åˆ°å°¾éƒ¨
    Node pred = tail;
    if (pred != null) {
        node.prev = pred;
        if (compareAndSetTail(pred, node)) {
            pred.next = node;
            return node;
        }
    }
    
    // å¿«é€Ÿå¤±è´¥ï¼Œè¿›å…¥å®Œæ•´å…¥é˜Ÿæµç¨‹
    enq(node);
    return node;
}

/**
 * å®Œæ•´å…¥é˜Ÿï¼ˆè‡ªæ—‹+CASï¼‰
 */
private Node enq(final Node node) {
    for (;;) {  // è‡ªæ—‹
        Node t = tail;
        if (t == null) {
            // é˜Ÿåˆ—ä¸ºç©ºï¼Œåˆå§‹åŒ–ï¼ˆåˆ›å»ºdummyå¤´èŠ‚ç‚¹ï¼‰
            if (compareAndSetHead(new Node()))
                tail = head;
        } else {
            // åŠ å…¥å°¾éƒ¨
            node.prev = t;
            if (compareAndSetTail(t, node)) {
                t.next = node;
                return t;
            }
        }
    }
}
```

### acquireQueued - è‡ªæ—‹è·å–é”

```java
/**
 * åœ¨é˜Ÿåˆ—ä¸­è‡ªæ—‹è·å–é”
 * åªæœ‰å‰é©±æ˜¯headæ—¶æ‰å°è¯•è·å–
 */
final boolean acquireQueued(final Node node, int arg) {
    boolean failed = true;
    try {
        boolean interrupted = false;
        
        for (;;) {  // è‡ªæ—‹
            final Node p = node.predecessor();  // å‰é©±èŠ‚ç‚¹
            
            // å‰é©±æ˜¯headï¼Œå°è¯•è·å–é”
            if (p == head && tryAcquire(arg)) {
                setHead(node);  // è·å–æˆåŠŸï¼Œè®¾ä¸ºhead
                p.next = null;  // help GC
                failed = false;
                return interrupted;
            }
            
            // åˆ¤æ–­æ˜¯å¦éœ€è¦é˜»å¡
            if (shouldParkAfterFailedAcquire(p, node) &&
                parkAndCheckInterrupt())
                interrupted = true;
        }
    } finally {
        if (failed)
            cancelAcquire(node);
    }
}

/**
 * åˆ¤æ–­æ˜¯å¦éœ€è¦é˜»å¡
 */
private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {
    int ws = pred.waitStatus;
    
    if (ws == Node.SIGNAL)
        // å‰é©±çŠ¶æ€æ˜¯SIGNALï¼Œå¯ä»¥å®‰å…¨é˜»å¡
        return true;
        
    if (ws > 0) {
        // å‰é©±è¢«å–æ¶ˆï¼Œè·³è¿‡å–æ¶ˆçš„èŠ‚ç‚¹
        do {
            node.prev = pred = pred.prev;
        } while (pred.waitStatus > 0);
        pred.next = node;
    } else {
        // è®¾ç½®å‰é©±çŠ¶æ€ä¸ºSIGNAL
        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);
    }
    return false;
}

/**
 * é˜»å¡å½“å‰çº¿ç¨‹
 */
private final boolean parkAndCheckInterrupt() {
    LockSupport.park(this);  // é˜»å¡
    return Thread.interrupted();  // è¿”å›ä¸­æ–­çŠ¶æ€
}
```

### release - é‡Šæ”¾é”

```java
/**
 * ç‹¬å æ¨¡å¼é‡Šæ”¾é”
 */
public final boolean release(int arg) {
    if (tryRelease(arg)) {  // å­ç±»å®ç°
        Node h = head;
        if (h != null && h.waitStatus != 0)
            unparkSuccessor(h);  // å”¤é†’åç»§èŠ‚ç‚¹
        return true;
    }
    return false;
}

/**
 * å”¤é†’åç»§èŠ‚ç‚¹
 */
private void unparkSuccessor(Node node) {
    int ws = node.waitStatus;
    if (ws < 0)
        compareAndSetWaitStatus(node, ws, 0);
    
    // æ‰¾åˆ°éœ€è¦å”¤é†’çš„åç»§èŠ‚ç‚¹
    Node s = node.next;
    if (s == null || s.waitStatus > 0) {
        s = null;
        // ä»å°¾éƒ¨å‘å‰æ‰¾ï¼ˆå› ä¸ºnextå¯èƒ½è¿˜æ²¡è®¾ç½®ï¼‰
        for (Node t = tail; t != null && t != node; t = t.prev)
            if (t.waitStatus <= 0)
                s = t;
    }
    
    if (s != null)
        LockSupport.unpark(s.thread);  // å”¤é†’
}
```

### ç‹¬å æ¨¡å¼æµç¨‹å›¾

```
çº¿ç¨‹Aè·å–é”ï¼š
  tryAcquire() â†’ æˆåŠŸ â†’ æŒæœ‰é”
       â†“ å¤±è´¥
  addWaiter() â†’ åŠ å…¥é˜Ÿåˆ—
       â†“
  acquireQueued() â†’ è‡ªæ—‹
       â†“
  å‰é©±æ˜¯head? â†’ æ˜¯ â†’ tryAcquire() â†’ æˆåŠŸ â†’ æŒæœ‰é”
       â†“ å¦
  shouldPark? â†’ æ˜¯ â†’ parké˜»å¡
       â†“
  è¢«å”¤é†’ â†’ ç»§ç»­è‡ªæ—‹

çº¿ç¨‹Aé‡Šæ”¾é”ï¼š
  tryRelease() â†’ æˆåŠŸ
       â†“
  unparkSuccessor() â†’ å”¤é†’åç»§èŠ‚ç‚¹
```

---

## å…±äº«æ¨¡å¼

### acquireShared - å…±äº«è·å–

```java
/**
 * å…±äº«æ¨¡å¼è·å–
 */
public final void acquireShared(int arg) {
    if (tryAcquireShared(arg) < 0)  // å­ç±»å®ç°
        doAcquireShared(arg);
}

/**
 * tryAcquireSharedè¿”å›å€¼ï¼š
 * - è´Ÿæ•°ï¼šè·å–å¤±è´¥
 * - 0ï¼šè·å–æˆåŠŸï¼Œä½†åç»­çº¿ç¨‹ä¸èƒ½è·å–
 * - æ­£æ•°ï¼šè·å–æˆåŠŸï¼Œåç»­çº¿ç¨‹ä¹Ÿå¯èƒ½è·å–æˆåŠŸ
 */

private void doAcquireShared(int arg) {
    final Node node = addWaiter(Node.SHARED);  // å…±äº«æ¨¡å¼èŠ‚ç‚¹
    boolean failed = true;
    try {
        boolean interrupted = false;
        for (;;) {
            final Node p = node.predecessor();
            if (p == head) {
                int r = tryAcquireShared(arg);
                if (r >= 0) {
                    // è·å–æˆåŠŸï¼Œè®¾ç½®headå¹¶ä¼ æ’­
                    setHeadAndPropagate(node, r);
                    p.next = null;
                    if (interrupted)
                        selfInterrupt();
                    failed = false;
                    return;
                }
            }
            if (shouldParkAfterFailedAcquire(p, node) &&
                parkAndCheckInterrupt())
                interrupted = true;
        }
    } finally {
        if (failed)
            cancelAcquire(node);
    }
}

/**
 * è®¾ç½®headå¹¶ä¼ æ’­å”¤é†’
 */
private void setHeadAndPropagate(Node node, int propagate) {
    Node h = head;
    setHead(node);
    
    // ä¼ æ’­ï¼šå”¤é†’åç»­å…±äº«èŠ‚ç‚¹
    if (propagate > 0 || h == null || h.waitStatus < 0 ||
        (h = head) == null || h.waitStatus < 0) {
        Node s = node.next;
        if (s == null || s.isShared())
            doReleaseShared();
    }
}
```

### releaseShared - å…±äº«é‡Šæ”¾

```java
/**
 * å…±äº«æ¨¡å¼é‡Šæ”¾
 */
public final boolean releaseShared(int arg) {
    if (tryReleaseShared(arg)) {  // å­ç±»å®ç°
        doReleaseShared();
        return true;
    }
    return false;
}

private void doReleaseShared() {
    for (;;) {
        Node h = head;
        if (h != null && h != tail) {
            int ws = h.waitStatus;
            if (ws == Node.SIGNAL) {
                if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))
                    continue;
                unparkSuccessor(h);  // å”¤é†’åç»§
            }
            else if (ws == 0 &&
                     !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))
                continue;
        }
        if (h == head)
            break;
    }
}
```

### ç‹¬å  vs å…±äº«å¯¹æ¯”

```
ç‹¬å æ¨¡å¼ï¼ˆExclusiveï¼‰ï¼š
  - åŒä¸€æ—¶åˆ»åªæœ‰ä¸€ä¸ªçº¿ç¨‹æŒæœ‰
  - ä¾‹ï¼šReentrantLock
  - tryAcquire/tryRelease

å…±äº«æ¨¡å¼ï¼ˆSharedï¼‰ï¼š
  - åŒä¸€æ—¶åˆ»å¤šä¸ªçº¿ç¨‹å¯ä»¥æŒæœ‰
  - ä¾‹ï¼šSemaphoreã€CountDownLatchã€è¯»é”
  - tryAcquireShared/tryReleaseShared
  - è·å–æˆåŠŸåä¼šä¼ æ’­å”¤é†’åç»­å…±äº«èŠ‚ç‚¹
```

---

## Conditionæ¡ä»¶é˜Ÿåˆ—

### ConditionåŸç†

```java
/**
 * Conditionï¼šæ¡ä»¶é˜Ÿåˆ—
 * - ç±»ä¼¼Objectçš„wait/notify
 * - ä½†å¯ä»¥æœ‰å¤šä¸ªæ¡ä»¶é˜Ÿåˆ—
 */
public class ConditionObject implements Condition {
    
    // æ¡ä»¶é˜Ÿåˆ—ï¼ˆå•å‘é“¾è¡¨ï¼‰
    private transient Node firstWaiter;
    private transient Node lastWaiter;
    
    /**
     * awaitï¼šç­‰å¾…æ¡ä»¶
     */
    public final void await() throws InterruptedException {
        if (Thread.interrupted())
            throw new InterruptedException();
            
        // 1. åŠ å…¥æ¡ä»¶é˜Ÿåˆ—
        Node node = addConditionWaiter();
        
        // 2. é‡Šæ”¾é”ï¼ˆå®Œå…¨é‡Šæ”¾ï¼‰
        int savedState = fullyRelease(node);
        
        int interruptMode = 0;
        // 3. ç­‰å¾…è¢«è½¬ç§»åˆ°åŒæ­¥é˜Ÿåˆ—
        while (!isOnSyncQueue(node)) {
            LockSupport.park(this);  // é˜»å¡
            if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)
                break;
        }
        
        // 4. é‡æ–°è·å–é”
        if (acquireQueued(node, savedState) && interruptMode != THROW_IE)
            interruptMode = REINTERRUPT;
            
        // 5. æ¸…ç†å–æ¶ˆçš„èŠ‚ç‚¹
        if (node.nextWaiter != null)
            unlinkCancelledWaiters();
        if (interruptMode != 0)
            reportInterruptAfterWait(interruptMode);
    }
    
    /**
     * signalï¼šå”¤é†’ä¸€ä¸ªç­‰å¾…çº¿ç¨‹
     */
    public final void signal() {
        if (!isHeldExclusively())  // å¿…é¡»æŒæœ‰é”
            throw new IllegalMonitorStateException();
            
        Node first = firstWaiter;
        if (first != null)
            doSignal(first);  // è½¬ç§»åˆ°åŒæ­¥é˜Ÿåˆ—
    }
    
    private void doSignal(Node first) {
        do {
            if ((firstWaiter = first.nextWaiter) == null)
                lastWaiter = null;
            first.nextWaiter = null;
        } while (!transferForSignal(first) &&  // è½¬ç§»èŠ‚ç‚¹
                 (first = firstWaiter) != null);
    }
}

// ä¸¤ä¸ªé˜Ÿåˆ—ï¼š
// åŒæ­¥é˜Ÿåˆ—ï¼ˆCLHï¼‰ï¼šç­‰å¾…è·å–é”çš„çº¿ç¨‹
// æ¡ä»¶é˜Ÿåˆ—ï¼šè°ƒç”¨await()åç­‰å¾…signal()çš„çº¿ç¨‹

// awaitæµç¨‹ï¼š
// åŒæ­¥é˜Ÿåˆ— â†’ é‡Šæ”¾é” â†’ æ¡ä»¶é˜Ÿåˆ— â†’ signal â†’ åŒæ­¥é˜Ÿåˆ— â†’ è·å–é”
```

### Conditionä½¿ç”¨ç¤ºä¾‹

```java
public class BoundedBuffer<T> {
    private final Lock lock = new ReentrantLock();
    private final Condition notFull = lock.newCondition();
    private final Condition notEmpty = lock.newCondition();
    
    private final Object[] items = new Object[100];
    private int count, putIndex, takeIndex;
    
    public void put(T item) throws InterruptedException {
        lock.lock();
        try {
            while (count == items.length)
                notFull.await();  // ç­‰å¾…ä¸æ»¡
                
            items[putIndex] = item;
            if (++putIndex == items.length) putIndex = 0;
            count++;
            
            notEmpty.signal();  // é€šçŸ¥ä¸ç©º
        } finally {
            lock.unlock();
        }
    }
    
    public T take() throws InterruptedException {
        lock.lock();
        try {
            while (count == 0)
                notEmpty.await();  // ç­‰å¾…ä¸ç©º
                
            Object item = items[takeIndex];
            if (++takeIndex == items.length) takeIndex = 0;
            count--;
            
            notFull.signal();  // é€šçŸ¥ä¸æ»¡
            return (T) item;
        } finally {
            lock.unlock();
        }
    }
}
```

---

## é¢è¯•è¦ç‚¹

### 1. AQSæ ¸å¿ƒåŸç†

```
Q: AQSçš„æ ¸å¿ƒåŸç†æ˜¯ä»€ä¹ˆï¼Ÿ

A: AQSé€šè¿‡ä¸‰ä¸ªæ ¸å¿ƒæœºåˆ¶å®ç°åŒæ­¥ï¼š

1. åŒæ­¥çŠ¶æ€ï¼ˆstateï¼‰ï¼š
   - volatile intå˜é‡
   - CASåŸå­æ“ä½œä¿®æ”¹
   - ä¸åŒå®ç°æœ‰ä¸åŒå«ä¹‰

2. CLHé˜Ÿåˆ—ï¼š
   - åŒå‘é“¾è¡¨
   - FIFOé¡ºåº
   - å­˜å‚¨ç­‰å¾…çº¿ç¨‹

3. æ¨¡æ¿æ–¹æ³•æ¨¡å¼ï¼š
   - AQSå®šä¹‰è·å–/é‡Šæ”¾æµç¨‹
   - å­ç±»å®ç°tryAcquire/tryRelease
```

### 2. ä¸ºä»€ä¹ˆç”¨CLHé˜Ÿåˆ—ï¼Ÿ

```
Q: ä¸ºä»€ä¹ˆAQSä½¿ç”¨CLHé˜Ÿåˆ—ï¼Ÿ

A: CLHé˜Ÿåˆ—çš„ä¼˜åŠ¿ï¼š

1. å…¬å¹³æ€§ï¼š
   - FIFOé¡ºåº
   - å…ˆåˆ°å…ˆå¾—

2. è‡ªæ—‹ä¼˜åŒ–ï¼š
   - åªæœ‰headçš„åç»§æ‰å°è¯•è·å–é”
   - å‡å°‘æ— æ•ˆè‡ªæ—‹

3. å–æ¶ˆå¤„ç†ï¼š
   - åŒå‘é“¾è¡¨ä¾¿äºåˆ é™¤èŠ‚ç‚¹
   - ä»å°¾éƒ¨å‘å‰éå†æ›´å®‰å…¨

4. ä½å¼€é”€ï¼š
   - å…¥é˜Ÿåªéœ€CASæ“ä½œ
   - æ— éœ€å…¨å±€é”
```

### 3. ç‹¬å å’Œå…±äº«çš„åŒºåˆ«

```
Q: ç‹¬å æ¨¡å¼å’Œå…±äº«æ¨¡å¼æœ‰ä»€ä¹ˆåŒºåˆ«ï¼Ÿ

A: 
ç‹¬å æ¨¡å¼ï¼š
  - åŒä¸€æ—¶åˆ»åªæœ‰ä¸€ä¸ªçº¿ç¨‹æŒæœ‰
  - tryAcquireè¿”å›boolean
  - é‡Šæ”¾åªå”¤é†’ä¸€ä¸ªåç»§

å…±äº«æ¨¡å¼ï¼š
  - å¤šä¸ªçº¿ç¨‹å¯ä»¥åŒæ—¶æŒæœ‰
  - tryAcquireSharedè¿”å›int
  - è·å–æˆåŠŸåä¼ æ’­å”¤é†’åç»­å…±äº«èŠ‚ç‚¹
  - é€‚ç”¨äºè¯»é”ã€ä¿¡å·é‡ç­‰
```

### 4. Condition vs Object.wait

```
Q: Conditionå’ŒObject.wait/notifyçš„åŒºåˆ«ï¼Ÿ

A:
Object.wait/notifyï¼š
  - åªèƒ½æœ‰ä¸€ä¸ªç­‰å¾…é˜Ÿåˆ—
  - å¿…é¡»åœ¨synchronizedå—ä¸­
  - notifyéšæœºå”¤é†’

Conditionï¼š
  - å¯ä»¥æœ‰å¤šä¸ªæ¡ä»¶é˜Ÿåˆ—
  - å¿…é¡»åœ¨Lock.lock()åä½¿ç”¨
  - å¯ä»¥ç²¾ç¡®å”¤é†’æŒ‡å®šé˜Ÿåˆ—
  - æ”¯æŒè¶…æ—¶ã€ä¸å“åº”ä¸­æ–­ç­‰
```

### 5. ä¸ºä»€ä¹ˆä»å°¾éƒ¨å‘å‰éå†

```
Q: unparkSuccessorä¸ºä»€ä¹ˆä»å°¾éƒ¨å‘å‰éå†ï¼Ÿ

A: å› ä¸ºå…¥é˜Ÿæ“ä½œä¸æ˜¯åŸå­çš„ï¼š

node.prev = pred;           // 1. è®¾ç½®prev
compareAndSetTail(pred, node); // 2. CASè®¾ç½®tail
pred.next = node;           // 3. è®¾ç½®next

æ­¥éª¤2æˆåŠŸåï¼Œæ­¥éª¤3å¯èƒ½è¿˜æ²¡æ‰§è¡Œ
æ­¤æ—¶ä»headå‘åéå†å¯èƒ½æ‰¾ä¸åˆ°æ–°èŠ‚ç‚¹
ä½†ä»tailå‘å‰éå†ä¸€å®šèƒ½æ‰¾åˆ°ï¼ˆprevå…ˆè®¾ç½®ï¼‰
```

---

## ğŸ’¡ æ€»ç»“

```
AQSæ ¸å¿ƒè¦ç‚¹ï¼š

1. æ•°æ®ç»“æ„ï¼š
   - stateï¼šåŒæ­¥çŠ¶æ€
   - CLHé˜Ÿåˆ—ï¼šç­‰å¾…é˜Ÿåˆ—
   - Conditioné˜Ÿåˆ—ï¼šæ¡ä»¶é˜Ÿåˆ—

2. ä¸¤ç§æ¨¡å¼ï¼š
   - ç‹¬å ï¼šReentrantLock
   - å…±äº«ï¼šSemaphoreã€CountDownLatch

3. æ ¸å¿ƒæ–¹æ³•ï¼š
   - acquire/releaseï¼šç‹¬å è·å–/é‡Šæ”¾
   - acquireShared/releaseSharedï¼šå…±äº«è·å–/é‡Šæ”¾
   - await/signalï¼šæ¡ä»¶ç­‰å¾…/å”¤é†’

4. è®¾è®¡æ¨¡å¼ï¼š
   - æ¨¡æ¿æ–¹æ³•ï¼šå®šä¹‰æµç¨‹ï¼Œå­ç±»å®ç°ç»†èŠ‚
```

---

*æœ€åæ›´æ–°ï¼š2025-12-28*

# ThreadPoolExecutoræºç è§£æ

> çº¿ç¨‹æ± æ ¸å¿ƒå®ç°åŸç†æ·±åº¦è§£æ

## ğŸ“‹ ç›®å½•
- [æ•´ä½“æ¶æ„](#æ•´ä½“æ¶æ„)
- [æ ¸å¿ƒå±æ€§](#æ ¸å¿ƒå±æ€§)
- [executeæ‰§è¡Œæµç¨‹](#executeæ‰§è¡Œæµç¨‹)
- [Workerå·¥ä½œçº¿ç¨‹](#workerå·¥ä½œçº¿ç¨‹)
- [æ‹’ç»ç­–ç•¥](#æ‹’ç»ç­–ç•¥)
- [çº¿ç¨‹æ± çŠ¶æ€](#çº¿ç¨‹æ± çŠ¶æ€)
- [é¢è¯•è¦ç‚¹](#é¢è¯•è¦ç‚¹)

---

## æ•´ä½“æ¶æ„

### çº¿ç¨‹æ± ç±»å›¾

```
Executorï¼ˆæ¥å£ï¼‰
    â†“
ExecutorServiceï¼ˆæ¥å£ï¼‰
    â†“
AbstractExecutorServiceï¼ˆæŠ½è±¡ç±»ï¼‰
    â†“
ThreadPoolExecutorï¼ˆå®ç°ç±»ï¼‰
    â†“
ScheduledThreadPoolExecutorï¼ˆå®šæ—¶ä»»åŠ¡ï¼‰
```

### æ ¸å¿ƒç»„ä»¶

```java
public class ThreadPoolExecutor extends AbstractExecutorService {
    
    // 1. æ§åˆ¶çŠ¶æ€ï¼ˆé«˜3ä½ï¼šçŠ¶æ€ï¼Œä½29ä½ï¼šçº¿ç¨‹æ•°ï¼‰
    private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));
    
    // 2. ä»»åŠ¡é˜Ÿåˆ—
    private final BlockingQueue<Runnable> workQueue;
    
    // 3. å·¥ä½œçº¿ç¨‹é›†åˆ
    private final HashSet<Worker> workers = new HashSet<Worker>();
    
    // 4. é”ï¼ˆä¿æŠ¤workersï¼‰
    private final ReentrantLock mainLock = new ReentrantLock();
    
    // 5. æ ¸å¿ƒå‚æ•°
    private volatile int corePoolSize;      // æ ¸å¿ƒçº¿ç¨‹æ•°
    private volatile int maximumPoolSize;   // æœ€å¤§çº¿ç¨‹æ•°
    private volatile long keepAliveTime;    // ç©ºé—²æ—¶é—´
    private volatile ThreadFactory threadFactory;  // çº¿ç¨‹å·¥å‚
    private volatile RejectedExecutionHandler handler;  // æ‹’ç»ç­–ç•¥
}
```

---

## æ ¸å¿ƒå±æ€§

### ctlçŠ¶æ€æ§åˆ¶

```java
/**
 * ctlï¼šçº¿ç¨‹æ± æ§åˆ¶çŠ¶æ€
 * - é«˜3ä½ï¼šè¿è¡ŒçŠ¶æ€ï¼ˆrunStateï¼‰
 * - ä½29ä½ï¼šå·¥ä½œçº¿ç¨‹æ•°ï¼ˆworkerCountï¼‰
 */
private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));

// ä½æ•°
private static final int COUNT_BITS = Integer.SIZE - 3;  // 29

// æœ€å¤§çº¿ç¨‹æ•°ï¼š2^29 - 1 â‰ˆ 5äº¿
private static final int CAPACITY   = (1 << COUNT_BITS) - 1;

// è¿è¡ŒçŠ¶æ€ï¼ˆé«˜3ä½ï¼‰
private static final int RUNNING    = -1 << COUNT_BITS;  // 111ï¼šè¿è¡Œä¸­
private static final int SHUTDOWN   =  0 << COUNT_BITS;  // 000ï¼šå…³é—­
private static final int STOP       =  1 << COUNT_BITS;  // 001ï¼šåœæ­¢
private static final int TIDYING    =  2 << COUNT_BITS;  // 010ï¼šæ•´ç†
private static final int TERMINATED =  3 << COUNT_BITS;  // 011ï¼šç»ˆæ­¢

// è·å–è¿è¡ŒçŠ¶æ€
private static int runStateOf(int c)     { return c & ~CAPACITY; }

// è·å–å·¥ä½œçº¿ç¨‹æ•°
private static int workerCountOf(int c)  { return c & CAPACITY; }

// ç»„åˆçŠ¶æ€å’Œçº¿ç¨‹æ•°
private static int ctlOf(int rs, int wc) { return rs | wc; }
```

### 7ä¸ªæ ¸å¿ƒå‚æ•°

```java
public ThreadPoolExecutor(
    int corePoolSize,           // æ ¸å¿ƒçº¿ç¨‹æ•°
    int maximumPoolSize,        // æœ€å¤§çº¿ç¨‹æ•°
    long keepAliveTime,         // ç©ºé—²çº¿ç¨‹å­˜æ´»æ—¶é—´
    TimeUnit unit,              // æ—¶é—´å•ä½
    BlockingQueue<Runnable> workQueue,  // ä»»åŠ¡é˜Ÿåˆ—
    ThreadFactory threadFactory,        // çº¿ç¨‹å·¥å‚
    RejectedExecutionHandler handler    // æ‹’ç»ç­–ç•¥
) {
    // å‚æ•°æ ¡éªŒ
    if (corePoolSize < 0 ||
        maximumPoolSize <= 0 ||
        maximumPoolSize < corePoolSize ||
        keepAliveTime < 0)
        throw new IllegalArgumentException();
        
    if (workQueue == null || threadFactory == null || handler == null)
        throw new NullPointerException();
        
    this.corePoolSize = corePoolSize;
    this.maximumPoolSize = maximumPoolSize;
    this.workQueue = workQueue;
    this.keepAliveTime = unit.toNanos(keepAliveTime);
    this.threadFactory = threadFactory;
    this.handler = handler;
}

/**
 * å‚æ•°è¯´æ˜ï¼š
 * 
 * corePoolSizeï¼šæ ¸å¿ƒçº¿ç¨‹æ•°
 *   - å³ä½¿ç©ºé—²ä¹Ÿä¸ä¼šè¢«å›æ”¶ï¼ˆé™¤éallowCoreThreadTimeOutï¼‰
 *   - ä»»åŠ¡æ¥äº†ä¼˜å…ˆåˆ›å»ºæ ¸å¿ƒçº¿ç¨‹
 * 
 * maximumPoolSizeï¼šæœ€å¤§çº¿ç¨‹æ•°
 *   - é˜Ÿåˆ—æ»¡äº†æ‰ä¼šåˆ›å»ºéæ ¸å¿ƒçº¿ç¨‹
 *   - æ€»çº¿ç¨‹æ•°ä¸è¶…è¿‡æ­¤å€¼
 * 
 * keepAliveTimeï¼šç©ºé—²çº¿ç¨‹å­˜æ´»æ—¶é—´
 *   - éæ ¸å¿ƒçº¿ç¨‹ç©ºé—²è¶…è¿‡æ­¤æ—¶é—´ä¼šè¢«å›æ”¶
 *   - allowCoreThreadTimeOut=trueæ—¶æ ¸å¿ƒçº¿ç¨‹ä¹Ÿä¼šå›æ”¶
 * 
 * workQueueï¼šä»»åŠ¡é˜Ÿåˆ—
 *   - ArrayBlockingQueueï¼šæœ‰ç•Œé˜Ÿåˆ—
 *   - LinkedBlockingQueueï¼šæ— ç•Œé˜Ÿåˆ—ï¼ˆé»˜è®¤Integer.MAX_VALUEï¼‰
 *   - SynchronousQueueï¼šä¸å­˜å‚¨ä»»åŠ¡ï¼Œç›´æ¥äº¤ç»™çº¿ç¨‹
 *   - PriorityBlockingQueueï¼šä¼˜å…ˆçº§é˜Ÿåˆ—
 * 
 * threadFactoryï¼šçº¿ç¨‹å·¥å‚
 *   - åˆ›å»ºçº¿ç¨‹çš„å·¥å‚
 *   - å¯ä»¥è®¾ç½®çº¿ç¨‹åã€ä¼˜å…ˆçº§ç­‰
 * 
 * handlerï¼šæ‹’ç»ç­–ç•¥
 *   - é˜Ÿåˆ—æ»¡ä¸”çº¿ç¨‹æ•°è¾¾åˆ°æœ€å¤§æ—¶è§¦å‘
 */
```

---

## executeæ‰§è¡Œæµç¨‹

### executeæºç 

```java
public void execute(Runnable command) {
    if (command == null)
        throw new NullPointerException();
    
    int c = ctl.get();
    
    // 1. å·¥ä½œçº¿ç¨‹æ•° < æ ¸å¿ƒçº¿ç¨‹æ•°ï¼Œåˆ›å»ºæ ¸å¿ƒçº¿ç¨‹
    if (workerCountOf(c) < corePoolSize) {
        if (addWorker(command, true))  // trueè¡¨ç¤ºæ ¸å¿ƒçº¿ç¨‹
            return;
        c = ctl.get();
    }
    
    // 2. æ ¸å¿ƒçº¿ç¨‹å·²æ»¡ï¼Œå°è¯•åŠ å…¥é˜Ÿåˆ—
    if (isRunning(c) && workQueue.offer(command)) {
        int recheck = ctl.get();
        
        // åŒé‡æ£€æŸ¥ï¼šçº¿ç¨‹æ± å¯èƒ½è¢«å…³é—­
        if (!isRunning(recheck) && remove(command))
            reject(command);  // æ‹’ç»ä»»åŠ¡
        // å¯èƒ½æ‰€æœ‰çº¿ç¨‹éƒ½æ­»äº†ï¼Œåˆ›å»ºä¸€ä¸ª
        else if (workerCountOf(recheck) == 0)
            addWorker(null, false);
    }
    
    // 3. é˜Ÿåˆ—æ»¡äº†ï¼Œå°è¯•åˆ›å»ºéæ ¸å¿ƒçº¿ç¨‹
    else if (!addWorker(command, false))  // falseè¡¨ç¤ºéæ ¸å¿ƒçº¿ç¨‹
        // 4. åˆ›å»ºå¤±è´¥ï¼Œæ‰§è¡Œæ‹’ç»ç­–ç•¥
        reject(command);
}
```

### æ‰§è¡Œæµç¨‹å›¾

```
execute(task)
    â†“
workerCount < corePoolSize?
    â†“ æ˜¯                    â†“ å¦
åˆ›å»ºæ ¸å¿ƒçº¿ç¨‹æ‰§è¡Œ      workQueue.offer(task)
    â†“                       â†“
  æˆåŠŸ                 å…¥é˜ŸæˆåŠŸ?
    â†“                   â†“ æ˜¯        â†“ å¦
  è¿”å›              åŒé‡æ£€æŸ¥    workerCount < maxPoolSize?
                       â†“           â†“ æ˜¯        â†“ å¦
                    è¿”å›      åˆ›å»ºéæ ¸å¿ƒçº¿ç¨‹   æ‹’ç»ç­–ç•¥
                                   â†“
                                 æˆåŠŸ?
                               â†“ æ˜¯    â†“ å¦
                              è¿”å›   æ‹’ç»ç­–ç•¥

ç®€åŒ–ç‰ˆï¼š
1. çº¿ç¨‹æ•° < æ ¸å¿ƒæ•° â†’ åˆ›å»ºæ ¸å¿ƒçº¿ç¨‹
2. æ ¸å¿ƒçº¿ç¨‹æ»¡ â†’ åŠ å…¥é˜Ÿåˆ—
3. é˜Ÿåˆ—æ»¡ â†’ åˆ›å»ºéæ ¸å¿ƒçº¿ç¨‹
4. çº¿ç¨‹æ•°è¾¾åˆ°æœ€å¤§ â†’ æ‹’ç»ç­–ç•¥
```

### addWorkeråˆ›å»ºçº¿ç¨‹

```java
private boolean addWorker(Runnable firstTask, boolean core) {
    retry:
    for (;;) {
        int c = ctl.get();
        int rs = runStateOf(c);
        
        // 1. æ£€æŸ¥çº¿ç¨‹æ± çŠ¶æ€
        if (rs >= SHUTDOWN &&
            !(rs == SHUTDOWN && firstTask == null && !workQueue.isEmpty()))
            return false;
        
        // 2. CASå¢åŠ çº¿ç¨‹æ•°
        for (;;) {
            int wc = workerCountOf(c);
            if (wc >= CAPACITY ||
                wc >= (core ? corePoolSize : maximumPoolSize))
                return false;
            if (compareAndIncrementWorkerCount(c))
                break retry;
            c = ctl.get();
            if (runStateOf(c) != rs)
                continue retry;
        }
    }
    
    // 3. åˆ›å»ºWorker
    boolean workerStarted = false;
    boolean workerAdded = false;
    Worker w = null;
    try {
        w = new Worker(firstTask);
        final Thread t = w.thread;
        if (t != null) {
            final ReentrantLock mainLock = this.mainLock;
            mainLock.lock();
            try {
                int rs = runStateOf(ctl.get());
                if (rs < SHUTDOWN ||
                    (rs == SHUTDOWN && firstTask == null)) {
                    if (t.isAlive())
                        throw new IllegalThreadStateException();
                    workers.add(w);  // åŠ å…¥workersé›†åˆ
                    int s = workers.size();
                    if (s > largestPoolSize)
                        largestPoolSize = s;
                    workerAdded = true;
                }
            } finally {
                mainLock.unlock();
            }
            if (workerAdded) {
                t.start();  // å¯åŠ¨çº¿ç¨‹
                workerStarted = true;
            }
        }
    } finally {
        if (!workerStarted)
            addWorkerFailed(w);
    }
    return workerStarted;
}
```

---

## Workerå·¥ä½œçº¿ç¨‹

### Workerç±»

```java
/**
 * Workerï¼šå·¥ä½œçº¿ç¨‹
 * - ç»§æ‰¿AQSå®ç°ä¸å¯é‡å…¥é”
 * - å®ç°Runnable
 */
private final class Worker extends AbstractQueuedSynchronizer 
    implements Runnable {
    
    final Thread thread;      // å·¥ä½œçº¿ç¨‹
    Runnable firstTask;       // ç¬¬ä¸€ä¸ªä»»åŠ¡
    volatile long completedTasks;  // å®Œæˆçš„ä»»åŠ¡æ•°
    
    Worker(Runnable firstTask) {
        setState(-1);  // ç¦æ­¢ä¸­æ–­ç›´åˆ°runWorker
        this.firstTask = firstTask;
        this.thread = getThreadFactory().newThread(this);
    }
    
    public void run() {
        runWorker(this);
    }
    
    // AQSæ–¹æ³•ï¼šä¸å¯é‡å…¥é”
    protected boolean tryAcquire(int unused) {
        if (compareAndSetState(0, 1)) {
            setExclusiveOwnerThread(Thread.currentThread());
            return true;
        }
        return false;
    }
    
    protected boolean tryRelease(int unused) {
        setExclusiveOwnerThread(null);
        setState(0);
        return true;
    }
}
```

### runWorkeræ‰§è¡Œä»»åŠ¡

```java
final void runWorker(Worker w) {
    Thread wt = Thread.currentThread();
    Runnable task = w.firstTask;
    w.firstTask = null;
    w.unlock();  // å…è®¸ä¸­æ–­
    boolean completedAbruptly = true;
    
    try {
        // å¾ªç¯è·å–ä»»åŠ¡æ‰§è¡Œ
        while (task != null || (task = getTask()) != null) {
            w.lock();  // åŠ é”ï¼ˆæ ‡è®°æ­£åœ¨æ‰§è¡Œä»»åŠ¡ï¼‰
            
            // æ£€æŸ¥çº¿ç¨‹æ± çŠ¶æ€
            if ((runStateAtLeast(ctl.get(), STOP) ||
                 (Thread.interrupted() && runStateAtLeast(ctl.get(), STOP))) &&
                !wt.isInterrupted())
                wt.interrupt();
            
            try {
                beforeExecute(wt, task);  // é’©å­æ–¹æ³•
                Throwable thrown = null;
                try {
                    task.run();  // æ‰§è¡Œä»»åŠ¡
                } catch (RuntimeException x) {
                    thrown = x; throw x;
                } catch (Error x) {
                    thrown = x; throw x;
                } catch (Throwable x) {
                    thrown = x; throw new Error(x);
                } finally {
                    afterExecute(task, thrown);  // é’©å­æ–¹æ³•
                }
            } finally {
                task = null;
                w.completedTasks++;
                w.unlock();
            }
        }
        completedAbruptly = false;
    } finally {
        processWorkerExit(w, completedAbruptly);  // çº¿ç¨‹é€€å‡ºå¤„ç†
    }
}
```

### getTaskè·å–ä»»åŠ¡

```java
private Runnable getTask() {
    boolean timedOut = false;
    
    for (;;) {
        int c = ctl.get();
        int rs = runStateOf(c);
        
        // 1. æ£€æŸ¥çº¿ç¨‹æ± çŠ¶æ€
        if (rs >= SHUTDOWN && (rs >= STOP || workQueue.isEmpty())) {
            decrementWorkerCount();
            return null;  // è¿”å›nullï¼Œçº¿ç¨‹é€€å‡º
        }
        
        int wc = workerCountOf(c);
        
        // 2. æ˜¯å¦éœ€è¦è¶…æ—¶æ§åˆ¶
        boolean timed = allowCoreThreadTimeOut || wc > corePoolSize;
        
        // 3. æ£€æŸ¥æ˜¯å¦éœ€è¦å‡å°‘çº¿ç¨‹
        if ((wc > maximumPoolSize || (timed && timedOut))
            && (wc > 1 || workQueue.isEmpty())) {
            if (compareAndDecrementWorkerCount(c))
                return null;  // è¿”å›nullï¼Œçº¿ç¨‹é€€å‡º
            continue;
        }
        
        try {
            // 4. ä»é˜Ÿåˆ—è·å–ä»»åŠ¡
            Runnable r = timed ?
                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :  // è¶…æ—¶è·å–
                workQueue.take();  // é˜»å¡è·å–
            if (r != null)
                return r;
            timedOut = true;  // è¶…æ—¶äº†
        } catch (InterruptedException retry) {
            timedOut = false;
        }
    }
}

/**
 * getTaskè¿”å›nullçš„æƒ…å†µï¼š
 * 1. çº¿ç¨‹æ± çŠ¶æ€ >= STOP
 * 2. çº¿ç¨‹æ± çŠ¶æ€ = SHUTDOWN ä¸”é˜Ÿåˆ—ä¸ºç©º
 * 3. çº¿ç¨‹æ•°è¶…è¿‡maximumPoolSize
 * 4. éæ ¸å¿ƒçº¿ç¨‹ç©ºé—²è¶…æ—¶
 * 5. allowCoreThreadTimeOut=trueæ—¶æ ¸å¿ƒçº¿ç¨‹ç©ºé—²è¶…æ—¶
 */
```

---

## æ‹’ç»ç­–ç•¥

### å››ç§å†…ç½®ç­–ç•¥

```java
/**
 * 1. AbortPolicyï¼ˆé»˜è®¤ï¼‰ï¼šæŠ›å‡ºå¼‚å¸¸
 */
public static class AbortPolicy implements RejectedExecutionHandler {
    public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {
        throw new RejectedExecutionException(
            "Task " + r.toString() + " rejected from " + e.toString());
    }
}

/**
 * 2. CallerRunsPolicyï¼šè°ƒç”¨è€…æ‰§è¡Œ
 */
public static class CallerRunsPolicy implements RejectedExecutionHandler {
    public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {
        if (!e.isShutdown()) {
            r.run();  // è°ƒç”¨è€…çº¿ç¨‹æ‰§è¡Œ
        }
    }
}

/**
 * 3. DiscardPolicyï¼šç›´æ¥ä¸¢å¼ƒ
 */
public static class DiscardPolicy implements RejectedExecutionHandler {
    public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {
        // ä»€ä¹ˆéƒ½ä¸åšï¼Œç›´æ¥ä¸¢å¼ƒ
    }
}

/**
 * 4. DiscardOldestPolicyï¼šä¸¢å¼ƒæœ€è€çš„ä»»åŠ¡
 */
public static class DiscardOldestPolicy implements RejectedExecutionHandler {
    public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {
        if (!e.isShutdown()) {
            e.getQueue().poll();  // ä¸¢å¼ƒé˜Ÿå¤´ä»»åŠ¡
            e.execute(r);         // é‡æ–°æäº¤å½“å‰ä»»åŠ¡
        }
    }
}
```

### è‡ªå®šä¹‰æ‹’ç»ç­–ç•¥

```java
/**
 * è‡ªå®šä¹‰æ‹’ç»ç­–ç•¥ç¤ºä¾‹
 */
public class CustomRejectedHandler implements RejectedExecutionHandler {
    
    @Override
    public void rejectedExecution(Runnable r, ThreadPoolExecutor executor) {
        // 1. è®°å½•æ—¥å¿—
        log.warn("Task rejected: {}", r.toString());
        
        // 2. æŒä¹…åŒ–åˆ°æ•°æ®åº“/æ¶ˆæ¯é˜Ÿåˆ—
        saveToDatabase(r);
        
        // 3. å‘é€å‘Šè­¦
        sendAlert("çº¿ç¨‹æ± ä»»åŠ¡è¢«æ‹’ç»");
        
        // 4. å¯é€‰ï¼šé˜»å¡ç­‰å¾…
        try {
            executor.getQueue().put(r);  // é˜»å¡ç›´åˆ°é˜Ÿåˆ—æœ‰ç©ºé—´
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }
}
```

---

## çº¿ç¨‹æ± çŠ¶æ€

### çŠ¶æ€è½¬æ¢

```
RUNNINGï¼šè¿è¡Œä¸­
  - æ¥å—æ–°ä»»åŠ¡
  - å¤„ç†é˜Ÿåˆ—ä»»åŠ¡
    â†“ shutdown()
SHUTDOWNï¼šå…³é—­
  - ä¸æ¥å—æ–°ä»»åŠ¡
  - å¤„ç†é˜Ÿåˆ—ä»»åŠ¡
    â†“ é˜Ÿåˆ—ä¸ºç©ºä¸”çº¿ç¨‹æ•°ä¸º0
TIDYINGï¼šæ•´ç†ä¸­
  - æ‰€æœ‰ä»»åŠ¡å·²å®Œæˆ
  - çº¿ç¨‹æ•°ä¸º0
    â†“ terminated()æ‰§è¡Œå®Œ
TERMINATEDï¼šç»ˆæ­¢
  - çº¿ç¨‹æ± å½»åº•ç»ˆæ­¢

RUNNING â†’ SHUTDOWNï¼šè°ƒç”¨shutdown()
RUNNING â†’ STOPï¼šè°ƒç”¨shutdownNow()
SHUTDOWN â†’ STOPï¼šè°ƒç”¨shutdownNow()
SHUTDOWN â†’ TIDYINGï¼šé˜Ÿåˆ—å’Œçº¿ç¨‹éƒ½ä¸ºç©º
STOP â†’ TIDYINGï¼šçº¿ç¨‹æ•°ä¸º0
TIDYING â†’ TERMINATEDï¼šterminated()æ‰§è¡Œå®Œ
```

### shutdown vs shutdownNow

```java
/**
 * shutdownï¼šä¼˜é›…å…³é—­
 * - ä¸æ¥å—æ–°ä»»åŠ¡
 * - ç­‰å¾…å·²æäº¤ä»»åŠ¡æ‰§è¡Œå®Œ
 */
public void shutdown() {
    final ReentrantLock mainLock = this.mainLock;
    mainLock.lock();
    try {
        checkShutdownAccess();
        advanceRunState(SHUTDOWN);  // è®¾ç½®çŠ¶æ€
        interruptIdleWorkers();     // ä¸­æ–­ç©ºé—²çº¿ç¨‹
        onShutdown();               // é’©å­æ–¹æ³•
    } finally {
        mainLock.unlock();
    }
    tryTerminate();
}

/**
 * shutdownNowï¼šç«‹å³å…³é—­
 * - ä¸æ¥å—æ–°ä»»åŠ¡
 * - ä¸­æ–­æ­£åœ¨æ‰§è¡Œçš„ä»»åŠ¡
 * - è¿”å›æœªæ‰§è¡Œçš„ä»»åŠ¡åˆ—è¡¨
 */
public List<Runnable> shutdownNow() {
    List<Runnable> tasks;
    final ReentrantLock mainLock = this.mainLock;
    mainLock.lock();
    try {
        checkShutdownAccess();
        advanceRunState(STOP);      // è®¾ç½®çŠ¶æ€
        interruptWorkers();         // ä¸­æ–­æ‰€æœ‰çº¿ç¨‹
        tasks = drainQueue();       // æ¸…ç©ºé˜Ÿåˆ—
    } finally {
        mainLock.unlock();
    }
    tryTerminate();
    return tasks;
}
```

---

## é¢è¯•è¦ç‚¹

### 1. çº¿ç¨‹æ± æ‰§è¡Œæµç¨‹

```
Q: çº¿ç¨‹æ± çš„æ‰§è¡Œæµç¨‹æ˜¯ä»€ä¹ˆï¼Ÿ

A: 
1. çº¿ç¨‹æ•° < corePoolSizeï¼šåˆ›å»ºæ ¸å¿ƒçº¿ç¨‹æ‰§è¡Œ
2. çº¿ç¨‹æ•° >= corePoolSizeï¼šä»»åŠ¡åŠ å…¥é˜Ÿåˆ—
3. é˜Ÿåˆ—æ»¡äº†ï¼šåˆ›å»ºéæ ¸å¿ƒçº¿ç¨‹æ‰§è¡Œ
4. çº¿ç¨‹æ•° >= maximumPoolSizeï¼šæ‰§è¡Œæ‹’ç»ç­–ç•¥

è®°å¿†å£è¯€ï¼š
æ ¸å¿ƒçº¿ç¨‹ â†’ é˜Ÿåˆ— â†’ éæ ¸å¿ƒçº¿ç¨‹ â†’ æ‹’ç»
```

### 2. ä¸ºä»€ä¹ˆå…ˆå…¥é˜Ÿå†åˆ›å»ºéæ ¸å¿ƒçº¿ç¨‹

```
Q: ä¸ºä»€ä¹ˆä¸æ˜¯å…ˆåˆ›å»ºçº¿ç¨‹åˆ°æœ€å¤§ï¼Œå†å…¥é˜Ÿï¼Ÿ

A:
1. çº¿ç¨‹åˆ›å»ºå¼€é”€å¤§ï¼š
   - åˆ›å»ºçº¿ç¨‹éœ€è¦ç³»ç»Ÿè°ƒç”¨
   - å…¥é˜Ÿåªæ˜¯å†…å­˜æ“ä½œ

2. é˜Ÿåˆ—å¯ä»¥ç¼“å†²ï¼š
   - å‰Šå³°å¡«è°·
   - é¿å…é¢‘ç¹åˆ›å»ºé”€æ¯çº¿ç¨‹

3. èµ„æºæ§åˆ¶ï¼š
   - æ ¸å¿ƒçº¿ç¨‹å¤„ç†å¸¸è§„è´Ÿè½½
   - éæ ¸å¿ƒçº¿ç¨‹å¤„ç†çªå‘æµé‡
```

### 3. æ ¸å¿ƒçº¿ç¨‹ä¼šè¢«å›æ”¶å—

```
Q: æ ¸å¿ƒçº¿ç¨‹ä¼šè¢«å›æ”¶å—ï¼Ÿ

A:
é»˜è®¤ä¸ä¼šå›æ”¶ã€‚

ä½†å¯ä»¥è®¾ç½®ï¼š
executor.allowCoreThreadTimeOut(true);

è®¾ç½®åï¼š
- æ ¸å¿ƒçº¿ç¨‹ç©ºé—²è¶…è¿‡keepAliveTimeä¹Ÿä¼šè¢«å›æ”¶
- é€‚ç”¨äºä»»åŠ¡é‡æ³¢åŠ¨å¤§çš„åœºæ™¯
```

### 4. çº¿ç¨‹æ± å‚æ•°å¦‚ä½•è®¾ç½®

```
Q: çº¿ç¨‹æ± å‚æ•°å¦‚ä½•è®¾ç½®ï¼Ÿ

A:
1. CPUå¯†é›†å‹ï¼š
   - corePoolSize = CPUæ ¸å¿ƒæ•° + 1
   - å‡å°‘çº¿ç¨‹åˆ‡æ¢å¼€é”€

2. IOå¯†é›†å‹ï¼š
   - corePoolSize = CPUæ ¸å¿ƒæ•° * 2
   - æˆ– CPUæ ¸å¿ƒæ•° / (1 - é˜»å¡ç³»æ•°)
   - é˜»å¡ç³»æ•°ä¸€èˆ¬0.8~0.9

3. æ··åˆå‹ï¼š
   - æ‹†åˆ†ä¸ºCPUå¯†é›†å’ŒIOå¯†é›†
   - åˆ†åˆ«ä½¿ç”¨ä¸åŒçº¿ç¨‹æ± 

4. é˜Ÿåˆ—é€‰æ‹©ï¼š
   - æœ‰ç•Œé˜Ÿåˆ—ï¼šArrayBlockingQueue
   - æ— ç•Œé˜Ÿåˆ—ï¼šLinkedBlockingQueueï¼ˆæ…ç”¨ï¼‰
   - åŒæ­¥é˜Ÿåˆ—ï¼šSynchronousQueue

5. æ‹’ç»ç­–ç•¥ï¼š
   - æ ¹æ®ä¸šåŠ¡é€‰æ‹©
   - é‡è¦ä»»åŠ¡ï¼šCallerRunsPolicyæˆ–è‡ªå®šä¹‰
```

### 5. çº¿ç¨‹æ± çš„çŠ¶æ€

```
Q: çº¿ç¨‹æ± æœ‰å“ªäº›çŠ¶æ€ï¼Ÿ

A:
RUNNINGï¼šè¿è¡Œä¸­ï¼Œæ¥å—ä»»åŠ¡ï¼Œå¤„ç†ä»»åŠ¡
SHUTDOWNï¼šå…³é—­ä¸­ï¼Œä¸æ¥å—æ–°ä»»åŠ¡ï¼Œå¤„ç†å·²æœ‰ä»»åŠ¡
STOPï¼šåœæ­¢ä¸­ï¼Œä¸æ¥å—æ–°ä»»åŠ¡ï¼Œä¸å¤„ç†ä»»åŠ¡ï¼Œä¸­æ–­æ‰§è¡Œä¸­çš„ä»»åŠ¡
TIDYINGï¼šæ•´ç†ä¸­ï¼Œæ‰€æœ‰ä»»åŠ¡å®Œæˆï¼Œçº¿ç¨‹æ•°ä¸º0
TERMINATEDï¼šç»ˆæ­¢ï¼Œterminated()æ‰§è¡Œå®Œæ¯•
```

### 6. Workerä¸ºä»€ä¹ˆç»§æ‰¿AQS

```
Q: Workerä¸ºä»€ä¹ˆè¦ç»§æ‰¿AQSï¼Ÿ

A:
1. å®ç°ä¸å¯é‡å…¥é”ï¼š
   - é˜²æ­¢çº¿ç¨‹åœ¨æ‰§è¡Œä»»åŠ¡æ—¶è¢«ä¸­æ–­
   - shutdown()åªä¸­æ–­ç©ºé—²çº¿ç¨‹

2. åˆ¤æ–­çº¿ç¨‹æ˜¯å¦ç©ºé—²ï¼š
   - tryLock()æˆåŠŸï¼šçº¿ç¨‹ç©ºé—²
   - tryLock()å¤±è´¥ï¼šçº¿ç¨‹æ­£åœ¨æ‰§è¡Œä»»åŠ¡

3. ä¸ºä»€ä¹ˆä¸å¯é‡å…¥ï¼š
   - é˜²æ­¢çº¿ç¨‹åœ¨æ‰§è¡Œä»»åŠ¡æ—¶è°ƒç”¨setCorePoolSizeç­‰æ–¹æ³•
   - å¯¼è‡´è‡ªå·±è¢«ä¸­æ–­
```

---

## ğŸ’¡ æ€»ç»“

```
ThreadPoolExecutoræ ¸å¿ƒè¦ç‚¹ï¼š

1. 7ä¸ªå‚æ•°ï¼š
   - corePoolSizeã€maximumPoolSize
   - keepAliveTimeã€unit
   - workQueueã€threadFactoryã€handler

2. æ‰§è¡Œæµç¨‹ï¼š
   æ ¸å¿ƒçº¿ç¨‹ â†’ é˜Ÿåˆ— â†’ éæ ¸å¿ƒçº¿ç¨‹ â†’ æ‹’ç»

3. Workerï¼š
   - å·¥ä½œçº¿ç¨‹å°è£…
   - ç»§æ‰¿AQSå®ç°ä¸å¯é‡å…¥é”
   - å¾ªç¯ä»é˜Ÿåˆ—è·å–ä»»åŠ¡æ‰§è¡Œ

4. çŠ¶æ€ï¼š
   RUNNING â†’ SHUTDOWN â†’ TIDYING â†’ TERMINATED
            â†˜ STOP â†—

5. æ‹’ç»ç­–ç•¥ï¼š
   - AbortPolicyï¼ˆé»˜è®¤ï¼‰
   - CallerRunsPolicy
   - DiscardPolicy
   - DiscardOldestPolicy
```

---

*æœ€åæ›´æ–°ï¼š2025-12-28*

# ConcurrentHashMapæºç è§£æ

> JDK8 ConcurrentHashMapå®ç°åŸç†æ·±åº¦è§£æ

## ğŸ“‹ ç›®å½•
- [æ•´ä½“ç»“æ„](#æ•´ä½“ç»“æ„)
- [æ ¸å¿ƒå±æ€§](#æ ¸å¿ƒå±æ€§)
- [putæ“ä½œ](#putæ“ä½œ)
- [getæ“ä½œ](#getæ“ä½œ)
- [æ‰©å®¹æœºåˆ¶](#æ‰©å®¹æœºåˆ¶)
- [sizeè®¡ç®—](#sizeè®¡ç®—)
- [é¢è¯•è¦ç‚¹](#é¢è¯•è¦ç‚¹)

---

## æ•´ä½“ç»“æ„

### JDK7 vs JDK8

```
JDK7 ConcurrentHashMapï¼š
  - Segmentæ•°ç»„ + HashEntryæ•°ç»„
  - åˆ†æ®µé”ï¼ˆSegmentç»§æ‰¿ReentrantLockï¼‰
  - é»˜è®¤16ä¸ªSegmentï¼Œæœ€å¤§å¹¶å‘16
  
  ç»“æ„ï¼š
  Segment[] â†’ HashEntry[] â†’ HashEntryé“¾è¡¨
  
JDK8 ConcurrentHashMapï¼š
  - Nodeæ•°ç»„ + é“¾è¡¨/çº¢é»‘æ ‘
  - CAS + synchronizedï¼ˆé”å•ä¸ªæ¡¶ï¼‰
  - å¹¶å‘åº¦ç­‰äºæ•°ç»„é•¿åº¦
  
  ç»“æ„ï¼š
  Node[] â†’ Nodeé“¾è¡¨ / TreeNodeçº¢é»‘æ ‘
```

### æ•°æ®ç»“æ„

```java
/**
 * JDK8 ConcurrentHashMapç»“æ„
 */
public class ConcurrentHashMap<K,V> {
    
    // æ•°ç»„ï¼ˆæ¡¶ï¼‰
    transient volatile Node<K,V>[] table;
    
    // æ‰©å®¹æ—¶çš„æ–°æ•°ç»„
    private transient volatile Node<K,V>[] nextTable;
    
    // åŸºç¡€è®¡æ•°å€¼
    private transient volatile long baseCount;
    
    // è®¡æ•°å•å…ƒæ•°ç»„
    private transient volatile CounterCell[] counterCells;
    
    // æ§åˆ¶æ ‡è¯†
    // -1: æ­£åœ¨åˆå§‹åŒ–
    // -N: N-1ä¸ªçº¿ç¨‹æ­£åœ¨æ‰©å®¹
    // 0: æœªåˆå§‹åŒ–
    // >0: ä¸‹æ¬¡æ‰©å®¹é˜ˆå€¼
    private transient volatile int sizeCtl;
}

// æ™®é€šèŠ‚ç‚¹
static class Node<K,V> {
    final int hash;
    final K key;
    volatile V val;
    volatile Node<K,V> next;
}

// æ ‘èŠ‚ç‚¹
static final class TreeNode<K,V> extends Node<K,V> {
    TreeNode<K,V> parent;
    TreeNode<K,V> left;
    TreeNode<K,V> right;
    TreeNode<K,V> prev;
    boolean red;
}

// è½¬å‘èŠ‚ç‚¹ï¼ˆæ‰©å®¹æ—¶ä½¿ç”¨ï¼‰
static final class ForwardingNode<K,V> extends Node<K,V> {
    final Node<K,V>[] nextTable;
    
    ForwardingNode(Node<K,V>[] tab) {
        super(MOVED, null, null, null);  // hash = MOVED = -1
        this.nextTable = tab;
    }
}
```

---

## æ ¸å¿ƒå±æ€§

### é‡è¦å¸¸é‡

```java
// æœ€å¤§å®¹é‡
static final int MAXIMUM_CAPACITY = 1 << 30;

// é»˜è®¤å®¹é‡
static final int DEFAULT_CAPACITY = 16;

// é“¾è¡¨è½¬çº¢é»‘æ ‘é˜ˆå€¼
static final int TREEIFY_THRESHOLD = 8;

// çº¢é»‘æ ‘è½¬é“¾è¡¨é˜ˆå€¼
static final int UNTREEIFY_THRESHOLD = 6;

// æ ‘åŒ–çš„æœ€å°æ•°ç»„é•¿åº¦
static final int MIN_TREEIFY_CAPACITY = 64;

// æ‰©å®¹æ—¶æ¯ä¸ªçº¿ç¨‹æœ€å°‘è¿ç§»çš„æ¡¶æ•°
static final int MIN_TRANSFER_STRIDE = 16;

// hashå€¼ç‰¹æ®Šæ ‡è®°
static final int MOVED     = -1;  // ForwardingNodeçš„hash
static final int TREEBIN   = -2;  // TreeBinçš„hash
static final int RESERVED  = -3;  // ä¸´æ—¶ä¿ç•™
```

### sizeCtlè¯¦è§£

```java
/**
 * sizeCtlï¼šæ§åˆ¶æ ‡è¯†ç¬¦
 * 
 * -1ï¼šæ­£åœ¨åˆå§‹åŒ–
 * -(1 + nThreads)ï¼šæ­£åœ¨æ‰©å®¹ï¼ŒnThreadsä¸ªçº¿ç¨‹å‚ä¸
 * 0ï¼šæœªåˆå§‹åŒ–ï¼Œä½¿ç”¨é»˜è®¤å®¹é‡
 * >0ï¼š
 *   - æœªåˆå§‹åŒ–æ—¶ï¼šåˆå§‹å®¹é‡
 *   - åˆå§‹åŒ–åï¼šä¸‹æ¬¡æ‰©å®¹é˜ˆå€¼ï¼ˆcapacity * 0.75ï¼‰
 */
private transient volatile int sizeCtl;

// ç¤ºä¾‹ï¼š
// sizeCtl = 0ï¼šæœªåˆå§‹åŒ–
// sizeCtl = 16ï¼šåˆå§‹å®¹é‡16
// sizeCtl = -1ï¼šæ­£åœ¨åˆå§‹åŒ–
// sizeCtl = 12ï¼šä¸‹æ¬¡æ‰©å®¹é˜ˆå€¼ï¼ˆ16 * 0.75ï¼‰
// sizeCtl = -(1 + 2) = -3ï¼š2ä¸ªçº¿ç¨‹æ­£åœ¨æ‰©å®¹
```

---

## putæ“ä½œ

### putValæºç 

```java
public V put(K key, V value) {
    return putVal(key, value, false);
}

final V putVal(K key, V value, boolean onlyIfAbsent) {
    // 1. keyå’Œvalueä¸èƒ½ä¸ºnull
    if (key == null || value == null) throw new NullPointerException();
    
    // 2. è®¡ç®—hashï¼ˆspreadä¿è¯é«˜ä½å‚ä¸è¿ç®—ï¼‰
    int hash = spread(key.hashCode());
    int binCount = 0;
    
    // 3. è‡ªæ—‹
    for (Node<K,V>[] tab = table;;) {
        Node<K,V> f; int n, i, fh;
        
        // 4. æ•°ç»„æœªåˆå§‹åŒ–ï¼Œå…ˆåˆå§‹åŒ–
        if (tab == null || (n = tab.length) == 0)
            tab = initTable();
            
        // 5. æ¡¶ä¸ºç©ºï¼ŒCASç›´æ¥æ’å…¥
        else if ((f = tabAt(tab, i = (n - 1) & hash)) == null) {
            if (casTabAt(tab, i, null, new Node<K,V>(hash, key, value, null)))
                break;
        }
        
        // 6. æ­£åœ¨æ‰©å®¹ï¼Œå¸®åŠ©æ‰©å®¹
        else if ((fh = f.hash) == MOVED)
            tab = helpTransfer(tab, f);
            
        // 7. æ¡¶ä¸ä¸ºç©ºï¼ŒåŠ é”æ’å…¥
        else {
            V oldVal = null;
            synchronized (f) {  // é”ä½æ¡¶çš„å¤´èŠ‚ç‚¹
                if (tabAt(tab, i) == f) {  // åŒé‡æ£€æŸ¥
                    
                    // 7.1 é“¾è¡¨
                    if (fh >= 0) {
                        binCount = 1;
                        for (Node<K,V> e = f;; ++binCount) {
                            K ek;
                            // æ‰¾åˆ°ç›¸åŒkeyï¼Œæ›´æ–°value
                            if (e.hash == hash &&
                                ((ek = e.key) == key ||
                                 (ek != null && key.equals(ek)))) {
                                oldVal = e.val;
                                if (!onlyIfAbsent)
                                    e.val = value;
                                break;
                            }
                            // åˆ°è¾¾é“¾è¡¨å°¾éƒ¨ï¼Œæ’å…¥æ–°èŠ‚ç‚¹
                            Node<K,V> pred = e;
                            if ((e = e.next) == null) {
                                pred.next = new Node<K,V>(hash, key, value, null);
                                break;
                            }
                        }
                    }
                    
                    // 7.2 çº¢é»‘æ ‘
                    else if (f instanceof TreeBin) {
                        Node<K,V> p;
                        binCount = 2;
                        if ((p = ((TreeBin<K,V>)f).putTreeVal(hash, key, value)) != null) {
                            oldVal = p.val;
                            if (!onlyIfAbsent)
                                p.val = value;
                        }
                    }
                }
            }
            
            // 8. åˆ¤æ–­æ˜¯å¦éœ€è¦æ ‘åŒ–
            if (binCount != 0) {
                if (binCount >= TREEIFY_THRESHOLD)
                    treeifyBin(tab, i);  // é“¾è¡¨è½¬çº¢é»‘æ ‘
                if (oldVal != null)
                    return oldVal;
                break;
            }
        }
    }
    
    // 9. è®¡æ•°+1ï¼Œæ£€æŸ¥æ˜¯å¦éœ€è¦æ‰©å®¹
    addCount(1L, binCount);
    return null;
}
```

### putæµç¨‹å›¾

```
put(key, value)
    â†“
è®¡ç®—hash = spread(key.hashCode())
    â†“
tableä¸ºç©º? â†’ æ˜¯ â†’ initTable()åˆå§‹åŒ–
    â†“ å¦
æ¡¶ä¸ºç©º? â†’ æ˜¯ â†’ CASæ’å…¥æ–°èŠ‚ç‚¹
    â†“ å¦
æ­£åœ¨æ‰©å®¹? â†’ æ˜¯ â†’ helpTransfer()å¸®åŠ©æ‰©å®¹
    â†“ å¦
synchronizedé”ä½æ¡¶å¤´èŠ‚ç‚¹
    â†“
é“¾è¡¨? â†’ éå†é“¾è¡¨ï¼Œæ‰¾åˆ°åˆ™æ›´æ–°ï¼Œå¦åˆ™å°¾æ’
    â†“
çº¢é»‘æ ‘? â†’ putTreeVal()
    â†“
binCount >= 8? â†’ treeifyBin()æ ‘åŒ–
    â†“
addCount()è®¡æ•°+1ï¼Œæ£€æŸ¥æ‰©å®¹
```

### initTableåˆå§‹åŒ–

```java
private final Node<K,V>[] initTable() {
    Node<K,V>[] tab; int sc;
    
    while ((tab = table) == null || tab.length == 0) {
        // sizeCtl < 0ï¼Œå…¶ä»–çº¿ç¨‹æ­£åœ¨åˆå§‹åŒ–ï¼Œè®©å‡ºCPU
        if ((sc = sizeCtl) < 0)
            Thread.yield();
            
        // CASè®¾ç½®sizeCtlä¸º-1ï¼Œè¡¨ç¤ºæ­£åœ¨åˆå§‹åŒ–
        else if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) {
            try {
                if ((tab = table) == null || tab.length == 0) {
                    int n = (sc > 0) ? sc : DEFAULT_CAPACITY;
                    Node<K,V>[] nt = (Node<K,V>[])new Node<?,?>[n];
                    table = tab = nt;
                    sc = n - (n >>> 2);  // 0.75nï¼Œä¸‹æ¬¡æ‰©å®¹é˜ˆå€¼
                }
            } finally {
                sizeCtl = sc;
            }
            break;
        }
    }
    return tab;
}
```

---

## getæ“ä½œ

### getæºç 

```java
public V get(Object key) {
    Node<K,V>[] tab; Node<K,V> e, p; int n, eh; K ek;
    
    // 1. è®¡ç®—hash
    int h = spread(key.hashCode());
    
    // 2. æ•°ç»„ä¸ä¸ºç©ºä¸”æ¡¶ä¸ä¸ºç©º
    if ((tab = table) != null && (n = tab.length) > 0 &&
        (e = tabAt(tab, (n - 1) & h)) != null) {
        
        // 3. å¤´èŠ‚ç‚¹å°±æ˜¯ç›®æ ‡
        if ((eh = e.hash) == h) {
            if ((ek = e.key) == key || (ek != null && key.equals(ek)))
                return e.val;
        }
        
        // 4. hash < 0ï¼šçº¢é»‘æ ‘æˆ–ForwardingNode
        else if (eh < 0)
            return (p = e.find(h, key)) != null ? p.val : null;
        
        // 5. éå†é“¾è¡¨
        while ((e = e.next) != null) {
            if (e.hash == h &&
                ((ek = e.key) == key || (ek != null && key.equals(ek))))
                return e.val;
        }
    }
    return null;
}
```

### getç‰¹ç‚¹

```
getæ“ä½œç‰¹ç‚¹ï¼š

1. æ— é”ï¼š
   - ä¸éœ€è¦åŠ é”
   - é€šè¿‡volatileä¿è¯å¯è§æ€§

2. é«˜æ•ˆï¼š
   - ç›´æ¥å®šä½æ¡¶
   - éå†é“¾è¡¨æˆ–çº¢é»‘æ ‘

3. æ‰©å®¹æ—¶ä¹Ÿèƒ½è¯»ï¼š
   - ForwardingNode.find()
   - åˆ°æ–°æ•°ç»„ä¸­æŸ¥æ‰¾
```

---

## æ‰©å®¹æœºåˆ¶

### æ‰©å®¹è§¦å‘æ¡ä»¶

```java
// 1. å…ƒç´ æ•°é‡è¶…è¿‡é˜ˆå€¼
if (s >= (long)(sc = sizeCtl))
    transfer(tab, null);

// 2. é“¾è¡¨é•¿åº¦>=8ä½†æ•°ç»„é•¿åº¦<64
if (tab == null || (n = tab.length) < MIN_TREEIFY_CAPACITY)
    tryPresize(n << 1);  // æ‰©å®¹è€Œä¸æ˜¯æ ‘åŒ–
```

### transferæ‰©å®¹

```java
private final void transfer(Node<K,V>[] tab, Node<K,V>[] nextTab) {
    int n = tab.length, stride;
    
    // 1. è®¡ç®—æ¯ä¸ªçº¿ç¨‹è¿ç§»çš„æ¡¶æ•°ï¼ˆæœ€å°‘16ä¸ªï¼‰
    if ((stride = (NCPU > 1) ? (n >>> 3) / NCPU : n) < MIN_TRANSFER_STRIDE)
        stride = MIN_TRANSFER_STRIDE;
    
    // 2. åˆå§‹åŒ–æ–°æ•°ç»„ï¼ˆ2å€å¤§å°ï¼‰
    if (nextTab == null) {
        Node<K,V>[] nt = (Node<K,V>[])new Node<?,?>[n << 1];
        nextTab = nt;
        nextTable = nextTab;
        transferIndex = n;  // ä»åå‘å‰è¿ç§»
    }
    
    int nextn = nextTab.length;
    ForwardingNode<K,V> fwd = new ForwardingNode<K,V>(nextTab);
    boolean advance = true;
    boolean finishing = false;
    
    // 3. è‡ªæ—‹è¿ç§»
    for (int i = 0, bound = 0;;) {
        Node<K,V> f; int fh;
        
        // 3.1 é¢†å–ä»»åŠ¡ï¼ˆCASè·å–è¿ç§»åŒºé—´ï¼‰
        while (advance) {
            int nextIndex, nextBound;
            if (--i >= bound || finishing)
                advance = false;
            else if ((nextIndex = transferIndex) <= 0) {
                i = -1;
                advance = false;
            }
            else if (U.compareAndSwapInt(this, TRANSFERINDEX, nextIndex,
                      nextBound = (nextIndex > stride ? nextIndex - stride : 0))) {
                bound = nextBound;
                i = nextIndex - 1;
                advance = false;
            }
        }
        
        // 3.2 è¿ç§»å®Œæˆæ£€æŸ¥
        if (i < 0 || i >= n || i + n >= nextn) {
            int sc;
            if (finishing) {
                nextTable = null;
                table = nextTab;
                sizeCtl = (n << 1) - (n >>> 1);  // æ–°é˜ˆå€¼
                return;
            }
            // ...
        }
        
        // 3.3 æ¡¶ä¸ºç©ºï¼Œæ”¾ç½®ForwardingNode
        else if ((f = tabAt(tab, i)) == null)
            advance = casTabAt(tab, i, null, fwd);
        
        // 3.4 å·²ç»æ˜¯ForwardingNodeï¼Œè·³è¿‡
        else if ((fh = f.hash) == MOVED)
            advance = true;
        
        // 3.5 è¿ç§»æ¡¶
        else {
            synchronized (f) {
                if (tabAt(tab, i) == f) {
                    Node<K,V> ln, hn;  // ä½ä½é“¾è¡¨ã€é«˜ä½é“¾è¡¨
                    
                    // é“¾è¡¨è¿ç§»
                    if (fh >= 0) {
                        int runBit = fh & n;
                        Node<K,V> lastRun = f;
                        
                        // æ‰¾åˆ°æœ€åä¸€æ®µè¿ç»­ç›¸åŒä½ç½®çš„èŠ‚ç‚¹
                        for (Node<K,V> p = f.next; p != null; p = p.next) {
                            int b = p.hash & n;
                            if (b != runBit) {
                                runBit = b;
                                lastRun = p;
                            }
                        }
                        
                        if (runBit == 0) {
                            ln = lastRun;
                            hn = null;
                        } else {
                            hn = lastRun;
                            ln = null;
                        }
                        
                        // åˆ†ç¦»é«˜ä½ä½èŠ‚ç‚¹
                        for (Node<K,V> p = f; p != lastRun; p = p.next) {
                            int ph = p.hash; K pk = p.key; V pv = p.val;
                            if ((ph & n) == 0)
                                ln = new Node<K,V>(ph, pk, pv, ln);
                            else
                                hn = new Node<K,V>(ph, pk, pv, hn);
                        }
                        
                        // æ”¾ç½®åˆ°æ–°æ•°ç»„
                        setTabAt(nextTab, i, ln);      // ä½ä½
                        setTabAt(nextTab, i + n, hn);  // é«˜ä½
                        setTabAt(tab, i, fwd);         // åŸä½ç½®æ”¾ForwardingNode
                        advance = true;
                    }
                    
                    // çº¢é»‘æ ‘è¿ç§»
                    else if (f instanceof TreeBin) {
                        // ç±»ä¼¼é“¾è¡¨ï¼Œåˆ†ç¦»é«˜ä½ä½
                        // ...
                    }
                }
            }
        }
    }
}
```

### æ‰©å®¹æµç¨‹å›¾

```
æ‰©å®¹è§¦å‘
    â†“
åˆ›å»ºæ–°æ•°ç»„ï¼ˆ2å€å¤§å°ï¼‰
    â†“
è®¡ç®—æ¯ä¸ªçº¿ç¨‹è¿ç§»çš„æ¡¶æ•°ï¼ˆstrideï¼‰
    â†“
å¤šçº¿ç¨‹å¹¶è¡Œè¿ç§»ï¼š
    â†“
é¢†å–ä»»åŠ¡ï¼ˆCASè·å–è¿ç§»åŒºé—´ï¼‰
    â†“
éå†è´Ÿè´£çš„æ¡¶ï¼š
    â†“
æ¡¶ä¸ºç©º? â†’ æ”¾ç½®ForwardingNode
    â†“
å·²è¿ç§»? â†’ è·³è¿‡
    â†“
synchronizedé”ä½æ¡¶
    â†“
é“¾è¡¨: åˆ†ç¦»é«˜ä½ä½ï¼Œæ”¾åˆ°æ–°æ•°ç»„
çº¢é»‘æ ‘: ç±»ä¼¼å¤„ç†
    â†“
åŸä½ç½®æ”¾ForwardingNode
    â†“
æ‰€æœ‰æ¡¶è¿ç§»å®Œæˆ
    â†“
table = nextTab
```

### å¤šçº¿ç¨‹ååŠ©æ‰©å®¹

```java
/**
 * å¸®åŠ©æ‰©å®¹
 */
final Node<K,V>[] helpTransfer(Node<K,V>[] tab, Node<K,V> f) {
    Node<K,V>[] nextTab; int sc;
    
    if (tab != null && (f instanceof ForwardingNode) &&
        (nextTab = ((ForwardingNode<K,V>)f).nextTable) != null) {
        
        int rs = resizeStamp(tab.length);
        
        while (nextTab == nextTable && table == tab &&
               (sc = sizeCtl) < 0) {
            // æ£€æŸ¥æ˜¯å¦è¿˜éœ€è¦å¸®åŠ©
            if ((sc >>> RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 ||
                sc == rs + MAX_RESIZERS || transferIndex <= 0)
                break;
            // CASå¢åŠ æ‰©å®¹çº¿ç¨‹æ•°
            if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1)) {
                transfer(tab, nextTab);
                break;
            }
        }
        return nextTab;
    }
    return table;
}
```

---

## sizeè®¡ç®—

### addCountè®¡æ•°

```java
/**
 * è®¡æ•°æœºåˆ¶ï¼šbaseCount + CounterCell[]
 * ç±»ä¼¼LongAdderçš„åˆ†æ®µè®¡æ•°
 */
private final void addCount(long x, int check) {
    CounterCell[] as; long b, s;
    
    // 1. å°è¯•CASæ›´æ–°baseCount
    if ((as = counterCells) != null ||
        !U.compareAndSwapLong(this, BASECOUNT, b = baseCount, s = b + x)) {
        
        CounterCell a; long v; int m;
        boolean uncontended = true;
        
        // 2. CASå¤±è´¥ï¼Œä½¿ç”¨CounterCell
        if (as == null || (m = as.length - 1) < 0 ||
            (a = as[ThreadLocalRandom.getProbe() & m]) == null ||
            !(uncontended = U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))) {
            // 3. CounterCellä¹Ÿå¤±è´¥ï¼Œè¿›å…¥fullAddCount
            fullAddCount(x, uncontended);
            return;
        }
        if (check <= 1)
            return;
        s = sumCount();
    }
    
    // 4. æ£€æŸ¥æ˜¯å¦éœ€è¦æ‰©å®¹
    if (check >= 0) {
        // ...
    }
}

/**
 * è®¡ç®—size
 */
public int size() {
    long n = sumCount();
    return ((n < 0L) ? 0 :
            (n > (long)Integer.MAX_VALUE) ? Integer.MAX_VALUE :
            (int)n);
}

final long sumCount() {
    CounterCell[] as = counterCells; CounterCell a;
    long sum = baseCount;
    if (as != null) {
        for (int i = 0; i < as.length; ++i) {
            if ((a = as[i]) != null)
                sum += a.value;
        }
    }
    return sum;
}
```

### è®¡æ•°åŸç†

```
è®¡æ•°æœºåˆ¶ï¼ˆç±»ä¼¼LongAdderï¼‰ï¼š

1. ä½å¹¶å‘ï¼š
   - ç›´æ¥CASæ›´æ–°baseCount
   
2. é«˜å¹¶å‘ï¼š
   - CASå¤±è´¥ï¼Œä½¿ç”¨CounterCellæ•°ç»„
   - æ¯ä¸ªçº¿ç¨‹æ˜ å°„åˆ°ä¸åŒçš„Cell
   - å‡å°‘ç«äº‰

3. è®¡ç®—sizeï¼š
   - sum = baseCount + Î£(counterCells[i].value)

ä¼˜åŠ¿ï¼š
  - åˆ†æ•£ç«äº‰
  - é«˜å¹¶å‘ä¸‹æ€§èƒ½å¥½
  - ç±»ä¼¼åˆ†æ®µé”æ€æƒ³
```

---

## é¢è¯•è¦ç‚¹

### 1. JDK7 vs JDK8åŒºåˆ«

```
Q: ConcurrentHashMapåœ¨JDK7å’ŒJDK8æœ‰ä»€ä¹ˆåŒºåˆ«ï¼Ÿ

A:
JDK7ï¼š
  - æ•°æ®ç»“æ„ï¼šSegment[] + HashEntry[]
  - é”æœºåˆ¶ï¼šåˆ†æ®µé”ï¼ˆSegmentç»§æ‰¿ReentrantLockï¼‰
  - å¹¶å‘åº¦ï¼šé»˜è®¤16ï¼ˆSegmentæ•°é‡ï¼‰
  - æŸ¥è¯¢ï¼šä¸¤æ¬¡hashå®šä½

JDK8ï¼š
  - æ•°æ®ç»“æ„ï¼šNode[] + é“¾è¡¨/çº¢é»‘æ ‘
  - é”æœºåˆ¶ï¼šCAS + synchronizedï¼ˆé”å•ä¸ªæ¡¶ï¼‰
  - å¹¶å‘åº¦ï¼šæ•°ç»„é•¿åº¦
  - æŸ¥è¯¢ï¼šä¸€æ¬¡hashå®šä½
  - ä¼˜åŒ–ï¼šé“¾è¡¨é•¿åº¦>=8è½¬çº¢é»‘æ ‘
```

### 2. putæ“ä½œçº¿ç¨‹å®‰å…¨

```
Q: ConcurrentHashMapçš„putå¦‚ä½•ä¿è¯çº¿ç¨‹å®‰å…¨ï¼Ÿ

A:
1. æ¡¶ä¸ºç©ºï¼šCASæ’å…¥
   - æ— é”æ“ä½œ
   - å¤±è´¥åˆ™è‡ªæ—‹é‡è¯•

2. æ¡¶ä¸ä¸ºç©ºï¼šsynchronizedé”ä½æ¡¶å¤´èŠ‚ç‚¹
   - åªé”ä¸€ä¸ªæ¡¶ï¼Œç²’åº¦å°
   - å…¶ä»–æ¡¶ä¸å—å½±å“

3. æ‰©å®¹æ—¶ï¼šå¸®åŠ©æ‰©å®¹
   - å‘ç°ForwardingNode
   - è°ƒç”¨helpTransfer()
```

### 3. getä¸ºä»€ä¹ˆä¸åŠ é”

```
Q: ConcurrentHashMapçš„getä¸ºä»€ä¹ˆä¸éœ€è¦åŠ é”ï¼Ÿ

A:
1. volatileä¿è¯å¯è§æ€§ï¼š
   - Nodeçš„valå’Œnextæ˜¯volatile
   - tableæ•°ç»„æ˜¯volatile
   - å†™æ“ä½œå¯¹è¯»ç«‹å³å¯è§

2. æ•°ç»„å…ƒç´ è·å–ç”¨Unsafeï¼š
   - tabAt()ä½¿ç”¨volatileè¯­ä¹‰è¯»å–
   - ä¿è¯è¯»åˆ°æœ€æ–°å€¼

3. æ‰©å®¹æ—¶ä¹Ÿèƒ½è¯»ï¼š
   - ForwardingNode.find()
   - è½¬å‘åˆ°æ–°æ•°ç»„æŸ¥æ‰¾
```

### 4. æ‰©å®¹æœºåˆ¶

```
Q: ConcurrentHashMapå¦‚ä½•æ‰©å®¹ï¼Ÿ

A:
1. è§¦å‘æ¡ä»¶ï¼š
   - å…ƒç´ æ•°é‡è¶…è¿‡é˜ˆå€¼ï¼ˆ0.75 * capacityï¼‰
   - é“¾è¡¨é•¿åº¦>=8ä½†æ•°ç»„<64

2. æ‰©å®¹è¿‡ç¨‹ï¼š
   - åˆ›å»º2å€å¤§å°çš„æ–°æ•°ç»„
   - å¤šçº¿ç¨‹å¹¶è¡Œè¿ç§»
   - æ¯ä¸ªçº¿ç¨‹è´Ÿè´£ä¸€æ®µæ¡¶ï¼ˆstrideï¼‰
   - è¿ç§»å®Œçš„æ¡¶æ”¾ForwardingNode

3. ååŠ©æ‰©å®¹ï¼š
   - putæ—¶å‘ç°ForwardingNode
   - è°ƒç”¨helpTransfer()å¸®åŠ©è¿ç§»
```

### 5. sizeå¦‚ä½•è®¡ç®—

```
Q: ConcurrentHashMapçš„size()å¦‚ä½•å®ç°ï¼Ÿ

A:
é‡‡ç”¨åˆ†æ®µè®¡æ•°ï¼ˆç±»ä¼¼LongAdderï¼‰ï¼š

1. baseCountï¼šåŸºç¡€è®¡æ•°
2. CounterCell[]ï¼šè®¡æ•°å•å…ƒæ•°ç»„

è®¡æ•°è¿‡ç¨‹ï¼š
  - å…ˆCASæ›´æ–°baseCount
  - å¤±è´¥åˆ™æ›´æ–°å¯¹åº”çš„CounterCell
  - å‡å°‘ç«äº‰

è®¡ç®—sizeï¼š
  sum = baseCount + Î£(counterCells[i].value)

æ³¨æ„ï¼š
  - size()ä¸æ˜¯ç²¾ç¡®å€¼
  - å¹¶å‘ä¿®æ”¹æ—¶å¯èƒ½ä¸å‡†ç¡®
  - ä½†æ€§èƒ½å¥½
```

### 6. ä¸ºä»€ä¹ˆkeyå’Œvalueä¸èƒ½ä¸ºnull

```
Q: ConcurrentHashMapä¸ºä»€ä¹ˆä¸å…è®¸null keyå’Œnull valueï¼Ÿ

A:
1. æ­§ä¹‰é—®é¢˜ï¼š
   - get(key)è¿”å›null
   - æ— æ³•åŒºåˆ†ï¼škeyä¸å­˜åœ¨ vs valueæ˜¯null

2. å¹¶å‘åœºæ™¯ï¼š
   - HashMapå•çº¿ç¨‹å¯ä»¥ç”¨containsKey()åˆ¤æ–­
   - ConcurrentHashMapå¹¶å‘ä¸‹containsKey()å’Œget()ä¹‹é—´å¯èƒ½è¢«ä¿®æ”¹

3. è®¾è®¡é€‰æ‹©ï¼š
   - ä½œè€…Doug Leaè®¤ä¸ºnullä¼šå¸¦æ¥æ­§ä¹‰
   - æ˜ç¡®ç¦æ­¢ï¼Œé¿å…é—®é¢˜
```

---

## ğŸ’¡ æ€»ç»“

```
ConcurrentHashMapæ ¸å¿ƒè¦ç‚¹ï¼š

1. æ•°æ®ç»“æ„ï¼š
   - Nodeæ•°ç»„ + é“¾è¡¨/çº¢é»‘æ ‘
   - é“¾è¡¨é•¿åº¦>=8è½¬çº¢é»‘æ ‘
   - çº¢é»‘æ ‘èŠ‚ç‚¹<=6è½¬é“¾è¡¨

2. çº¿ç¨‹å®‰å…¨ï¼š
   - CASï¼šæ¡¶ä¸ºç©ºæ—¶æ’å…¥
   - synchronizedï¼šæ¡¶ä¸ä¸ºç©ºæ—¶é”å¤´èŠ‚ç‚¹
   - volatileï¼šä¿è¯å¯è§æ€§

3. æ‰©å®¹ï¼š
   - å¤šçº¿ç¨‹å¹¶è¡Œè¿ç§»
   - ForwardingNodeæ ‡è®°å·²è¿ç§»
   - ååŠ©æ‰©å®¹æœºåˆ¶

4. è®¡æ•°ï¼š
   - baseCount + CounterCell[]
   - åˆ†æ®µè®¡æ•°å‡å°‘ç«äº‰
```

---

*æœ€åæ›´æ–°ï¼š2025-12-28*

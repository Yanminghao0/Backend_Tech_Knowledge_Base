# ReentrantLockæºç è§£æ

> å¯é‡å…¥é”å®ç°åŸç†æ·±åº¦è§£æ

## ğŸ“‹ ç›®å½•
- [æ•´ä½“ç»“æ„](#æ•´ä½“ç»“æ„)
- [éå…¬å¹³é”](#éå…¬å¹³é”)
- [å…¬å¹³é”](#å…¬å¹³é”)
- [å¯é‡å…¥å®ç°](#å¯é‡å…¥å®ç°)
- [Conditionå®ç°](#conditionå®ç°)
- [é¢è¯•è¦ç‚¹](#é¢è¯•è¦ç‚¹)

---

## æ•´ä½“ç»“æ„

### ç±»ç»“æ„

```java
public class ReentrantLock implements Lock {
    
    // åŒæ­¥å™¨ï¼ˆæ ¸å¿ƒï¼‰
    private final Sync sync;
    
    // æŠ½è±¡åŒæ­¥å™¨
    abstract static class Sync extends AbstractQueuedSynchronizer {
        abstract void lock();
        // ...
    }
    
    // éå…¬å¹³é”
    static final class NonfairSync extends Sync {
        // ...
    }
    
    // å…¬å¹³é”
    static final class FairSync extends Sync {
        // ...
    }
    
    // é»˜è®¤éå…¬å¹³é”
    public ReentrantLock() {
        sync = new NonfairSync();
    }
    
    // æŒ‡å®šå…¬å¹³/éå…¬å¹³
    public ReentrantLock(boolean fair) {
        sync = fair ? new FairSync() : new NonfairSync();
    }
}
```

### stateå«ä¹‰

```java
/**
 * AQSçš„stateåœ¨ReentrantLockä¸­çš„å«ä¹‰ï¼š
 * - 0ï¼šé”æœªè¢«æŒæœ‰
 * - 1ï¼šé”è¢«æŒæœ‰ä¸€æ¬¡
 * - >1ï¼šé”è¢«é‡å…¥çš„æ¬¡æ•°
 */

// è·å–é”ï¼šstate + 1
// é‡Šæ”¾é”ï¼šstate - 1
// state = 0æ—¶ï¼Œé”å®Œå…¨é‡Šæ”¾
```

---

## éå…¬å¹³é”

### lockè·å–é”

```java
static final class NonfairSync extends Sync {
    
    final void lock() {
        // 1. ç›´æ¥CASå°è¯•è·å–é”ï¼ˆæ’é˜Ÿï¼‰
        if (compareAndSetState(0, 1))
            setExclusiveOwnerThread(Thread.currentThread());
        else
            // 2. å¤±è´¥åˆ™èµ°AQSæµç¨‹
            acquire(1);
    }
    
    protected final boolean tryAcquire(int acquires) {
        return nonfairTryAcquire(acquires);
    }
}

// Syncä¸­çš„éå…¬å¹³è·å–
final boolean nonfairTryAcquire(int acquires) {
    final Thread current = Thread.currentThread();
    int c = getState();
    
    // 1. é”æœªè¢«æŒæœ‰
    if (c == 0) {
        // ç›´æ¥CASè·å–ï¼ˆä¸æ£€æŸ¥é˜Ÿåˆ—ï¼‰
        if (compareAndSetState(0, acquires)) {
            setExclusiveOwnerThread(current);
            return true;
        }
    }
    // 2. å½“å‰çº¿ç¨‹å·²æŒæœ‰é”ï¼ˆé‡å…¥ï¼‰
    else if (current == getExclusiveOwnerThread()) {
        int nextc = c + acquires;
        if (nextc < 0)
            throw new Error("Maximum lock count exceeded");
        setState(nextc);  // ä¸éœ€è¦CASï¼Œå› ä¸ºæ˜¯å½“å‰çº¿ç¨‹
        return true;
    }
    
    return false;
}
```

### éå…¬å¹³é”æµç¨‹

```
lock()
    â†“
CAS(0, 1)å°è¯•è·å–
    â†“ æˆåŠŸ          â†“ å¤±è´¥
è®¾ç½®owner      acquire(1)
    â†“               â†“
  è¿”å›        tryAcquire()
                  â†“
            state==0? â†’ CASè·å–
                  â†“ å¦
            æ˜¯å½“å‰çº¿ç¨‹? â†’ é‡å…¥(state+1)
                  â†“ å¦
            åŠ å…¥é˜Ÿåˆ—ç­‰å¾…
```

---

## å…¬å¹³é”

### lockè·å–é”

```java
static final class FairSync extends Sync {
    
    final void lock() {
        // ä¸æ’é˜Ÿï¼Œç›´æ¥èµ°AQSæµç¨‹
        acquire(1);
    }
    
    protected final boolean tryAcquire(int acquires) {
        final Thread current = Thread.currentThread();
        int c = getState();
        
        if (c == 0) {
            // å…³é”®ï¼šå…ˆæ£€æŸ¥é˜Ÿåˆ—ä¸­æ˜¯å¦æœ‰ç­‰å¾…çº¿ç¨‹
            if (!hasQueuedPredecessors() &&
                compareAndSetState(0, acquires)) {
                setExclusiveOwnerThread(current);
                return true;
            }
        }
        else if (current == getExclusiveOwnerThread()) {
            int nextc = c + acquires;
            if (nextc < 0)
                throw new Error("Maximum lock count exceeded");
            setState(nextc);
            return true;
        }
        return false;
    }
}

/**
 * æ£€æŸ¥æ˜¯å¦æœ‰å‰é©±èŠ‚ç‚¹ï¼ˆæ˜¯å¦æœ‰äººåœ¨æ’é˜Ÿï¼‰
 */
public final boolean hasQueuedPredecessors() {
    Node t = tail;
    Node h = head;
    Node s;
    // é˜Ÿåˆ—ä¸ä¸ºç©º ä¸” ç¬¬ä¸€ä¸ªç­‰å¾…çš„ä¸æ˜¯å½“å‰çº¿ç¨‹
    return h != t &&
        ((s = h.next) == null || s.thread != Thread.currentThread());
}
```

### å…¬å¹³ vs éå…¬å¹³å¯¹æ¯”

```
éå…¬å¹³é”ï¼š
  lock() â†’ ç›´æ¥CASå°è¯• â†’ å¤±è´¥å†æ’é˜Ÿ
  tryAcquire() â†’ state==0ç›´æ¥CAS
  
  ä¼˜ç‚¹ï¼šååé‡é«˜ï¼ˆå‡å°‘çº¿ç¨‹åˆ‡æ¢ï¼‰
  ç¼ºç‚¹ï¼šå¯èƒ½é¥¥é¥¿

å…¬å¹³é”ï¼š
  lock() â†’ ç›´æ¥æ’é˜Ÿ
  tryAcquire() â†’ å…ˆæ£€æŸ¥é˜Ÿåˆ—ï¼Œæ²¡äººæ’é˜Ÿæ‰CAS
  
  ä¼˜ç‚¹ï¼šå…¬å¹³ï¼Œä¸ä¼šé¥¥é¥¿
  ç¼ºç‚¹ï¼šååé‡ä½ï¼ˆæ¯æ¬¡éƒ½è¦æ£€æŸ¥é˜Ÿåˆ—ï¼‰

é»˜è®¤éå…¬å¹³çš„åŸå› ï¼š
  1. æ€§èƒ½æ›´å¥½
  2. å¤§å¤šæ•°åœºæ™¯ä¸éœ€è¦ä¸¥æ ¼å…¬å¹³
  3. é¥¥é¥¿é—®é¢˜åœ¨å®é™…ä¸­å¾ˆå°‘å‘ç”Ÿ
```

---

## å¯é‡å…¥å®ç°

### é‡å…¥åŸç†

```java
/**
 * å¯é‡å…¥ï¼šåŒä¸€çº¿ç¨‹å¯ä»¥å¤šæ¬¡è·å–åŒä¸€æŠŠé”
 */

// è·å–é”æ—¶
if (current == getExclusiveOwnerThread()) {
    // å½“å‰çº¿ç¨‹å·²æŒæœ‰é”
    int nextc = c + acquires;  // state + 1
    setState(nextc);
    return true;
}

// é‡Šæ”¾é”æ—¶
protected final boolean tryRelease(int releases) {
    int c = getState() - releases;  // state - 1
    
    if (Thread.currentThread() != getExclusiveOwnerThread())
        throw new IllegalMonitorStateException();
    
    boolean free = false;
    if (c == 0) {
        // stateå‡åˆ°0ï¼Œé”å®Œå…¨é‡Šæ”¾
        free = true;
        setExclusiveOwnerThread(null);
    }
    setState(c);
    return free;
}
```

### é‡å…¥ç¤ºä¾‹

```java
ReentrantLock lock = new ReentrantLock();

public void methodA() {
    lock.lock();  // state = 1
    try {
        methodB();  // é‡å…¥
    } finally {
        lock.unlock();  // state = 0
    }
}

public void methodB() {
    lock.lock();  // state = 2ï¼ˆé‡å…¥æˆåŠŸï¼‰
    try {
        // ä¸šåŠ¡é€»è¾‘
    } finally {
        lock.unlock();  // state = 1
    }
}

// è°ƒç”¨methodA()ï¼š
// lock() â†’ state=1
// methodB().lock() â†’ state=2ï¼ˆé‡å…¥ï¼‰
// methodB().unlock() â†’ state=1
// unlock() â†’ state=0ï¼ˆå®Œå…¨é‡Šæ”¾ï¼‰
```

---

## Conditionå®ç°

### ConditionåŸç†

```java
/**
 * Conditionï¼šæ¡ä»¶å˜é‡
 * - ç±»ä¼¼Object.wait/notify
 * - ä½†å¯ä»¥æœ‰å¤šä¸ªæ¡ä»¶é˜Ÿåˆ—
 */
public class ConditionObject implements Condition {
    
    // æ¡ä»¶é˜Ÿåˆ—ï¼ˆå•å‘é“¾è¡¨ï¼‰
    private transient Node firstWaiter;
    private transient Node lastWaiter;
    
    /**
     * awaitï¼šç­‰å¾…æ¡ä»¶
     */
    public final void await() throws InterruptedException {
        if (Thread.interrupted())
            throw new InterruptedException();
        
        // 1. åŠ å…¥æ¡ä»¶é˜Ÿåˆ—
        Node node = addConditionWaiter();
        
        // 2. å®Œå…¨é‡Šæ”¾é”ï¼ˆè¿”å›é‡Šæ”¾å‰çš„stateï¼‰
        int savedState = fullyRelease(node);
        
        int interruptMode = 0;
        // 3. ç­‰å¾…è¢«è½¬ç§»åˆ°åŒæ­¥é˜Ÿåˆ—
        while (!isOnSyncQueue(node)) {
            LockSupport.park(this);
            if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)
                break;
        }
        
        // 4. é‡æ–°è·å–é”ï¼ˆä½¿ç”¨ä¹‹å‰çš„stateï¼‰
        if (acquireQueued(node, savedState) && interruptMode != THROW_IE)
            interruptMode = REINTERRUPT;
        
        if (node.nextWaiter != null)
            unlinkCancelledWaiters();
        if (interruptMode != 0)
            reportInterruptAfterWait(interruptMode);
    }
    
    /**
     * signalï¼šå”¤é†’ä¸€ä¸ªç­‰å¾…çº¿ç¨‹
     */
    public final void signal() {
        // å¿…é¡»æŒæœ‰é”
        if (!isHeldExclusively())
            throw new IllegalMonitorStateException();
        
        Node first = firstWaiter;
        if (first != null)
            doSignal(first);
    }
    
    private void doSignal(Node first) {
        do {
            if ((firstWaiter = first.nextWaiter) == null)
                lastWaiter = null;
            first.nextWaiter = null;
        } while (!transferForSignal(first) &&
                 (first = firstWaiter) != null);
    }
}
```

### Conditionä½¿ç”¨ç¤ºä¾‹

```java
public class BoundedQueue<T> {
    private final Lock lock = new ReentrantLock();
    private final Condition notFull = lock.newCondition();
    private final Condition notEmpty = lock.newCondition();
    
    private final Object[] items;
    private int count, putIndex, takeIndex;
    
    public BoundedQueue(int capacity) {
        items = new Object[capacity];
    }
    
    public void put(T item) throws InterruptedException {
        lock.lock();
        try {
            while (count == items.length)
                notFull.await();  // ç­‰å¾…ä¸æ»¡
            
            items[putIndex] = item;
            if (++putIndex == items.length) putIndex = 0;
            count++;
            
            notEmpty.signal();  // é€šçŸ¥ä¸ç©º
        } finally {
            lock.unlock();
        }
    }
    
    public T take() throws InterruptedException {
        lock.lock();
        try {
            while (count == 0)
                notEmpty.await();  // ç­‰å¾…ä¸ç©º
            
            Object item = items[takeIndex];
            if (++takeIndex == items.length) takeIndex = 0;
            count--;
            
            notFull.signal();  // é€šçŸ¥ä¸æ»¡
            return (T) item;
        } finally {
            lock.unlock();
        }
    }
}
```

---

## é¢è¯•è¦ç‚¹

### 1. ReentrantLock vs synchronized

```
Q: ReentrantLockå’Œsynchronizedæœ‰ä»€ä¹ˆåŒºåˆ«ï¼Ÿ

A:
| å¯¹æ¯”é¡¹ | synchronized | ReentrantLock |
|--------|--------------|---------------|
| å®ç° | JVMå†…ç½® | Java API |
| é”è·å– | è‡ªåŠ¨ | æ‰‹åŠ¨lock/unlock |
| å…¬å¹³æ€§ | éå…¬å¹³ | å¯é€‰å…¬å¹³/éå…¬å¹³ |
| æ¡ä»¶å˜é‡ | 1ä¸ªï¼ˆwait/notifyï¼‰| å¤šä¸ªCondition |
| å¯ä¸­æ–­ | ä¸å¯ | lockInterruptibly() |
| è¶…æ—¶ | ä¸å¯ | tryLock(timeout) |
| æ€§èƒ½ | JDK6åä¼˜åŒ–ï¼Œå·®ä¸å¤š | å·®ä¸å¤š |

ä½¿ç”¨å»ºè®®ï¼š
- ç®€å•åœºæ™¯ï¼šsynchronizedï¼ˆç®€æ´ï¼‰
- å¤æ‚åœºæ™¯ï¼šReentrantLockï¼ˆåŠŸèƒ½å¤šï¼‰
```

### 2. å…¬å¹³é”å’Œéå…¬å¹³é”

```
Q: å…¬å¹³é”å’Œéå…¬å¹³é”çš„åŒºåˆ«ï¼Ÿ

A:
å…¬å¹³é”ï¼š
  - æŒ‰ç…§è¯·æ±‚é¡ºåºè·å–é”
  - å…ˆæ£€æŸ¥é˜Ÿåˆ—ï¼Œæœ‰äººæ’é˜Ÿå°±æ’é˜Ÿ
  - ä¸ä¼šé¥¥é¥¿
  - ååé‡ä½

éå…¬å¹³é”ï¼š
  - å¯ä»¥æ’é˜Ÿ
  - ç›´æ¥CASå°è¯•è·å–
  - å¯èƒ½é¥¥é¥¿
  - ååé‡é«˜

ä¸ºä»€ä¹ˆé»˜è®¤éå…¬å¹³ï¼Ÿ
  - å‡å°‘çº¿ç¨‹åˆ‡æ¢
  - æé«˜ååé‡
  - å®é™…é¥¥é¥¿å¾ˆå°‘å‘ç”Ÿ
```

### 3. å¯é‡å…¥åŸç†

```
Q: ReentrantLockå¦‚ä½•å®ç°å¯é‡å…¥ï¼Ÿ

A:
1. è®°å½•æŒæœ‰é”çš„çº¿ç¨‹ï¼š
   exclusiveOwnerThread

2. è·å–é”æ—¶åˆ¤æ–­ï¼š
   if (current == getExclusiveOwnerThread()) {
       state++;  // é‡å…¥æ¬¡æ•°+1
   }

3. é‡Šæ”¾é”æ—¶åˆ¤æ–­ï¼š
   state--;
   if (state == 0) {
       // å®Œå…¨é‡Šæ”¾
       exclusiveOwnerThread = null;
   }
```

### 4. tryLockå®ç°

```java
/**
 * tryLockï¼šå°è¯•è·å–é”ï¼ˆéé˜»å¡ï¼‰
 */
public boolean tryLock() {
    return sync.nonfairTryAcquire(1);
}

/**
 * tryLock(timeout)ï¼šè¶…æ—¶è·å–é”
 */
public boolean tryLock(long timeout, TimeUnit unit) throws InterruptedException {
    return sync.tryAcquireNanos(1, unit.toNanos(timeout));
}

// AQSä¸­çš„è¶…æ—¶è·å–
private boolean doAcquireNanos(int arg, long nanosTimeout) {
    if (nanosTimeout <= 0L)
        return false;
    
    final long deadline = System.nanoTime() + nanosTimeout;
    final Node node = addWaiter(Node.EXCLUSIVE);
    
    try {
        for (;;) {
            final Node p = node.predecessor();
            if (p == head && tryAcquire(arg)) {
                setHead(node);
                p.next = null;
                return true;
            }
            
            nanosTimeout = deadline - System.nanoTime();
            if (nanosTimeout <= 0L) {
                cancelAcquire(node);
                return false;  // è¶…æ—¶
            }
            
            if (shouldParkAfterFailedAcquire(p, node) &&
                nanosTimeout > SPIN_FOR_TIMEOUT_THRESHOLD)
                LockSupport.parkNanos(this, nanosTimeout);
            
            if (Thread.interrupted())
                throw new InterruptedException();
        }
    } catch (Throwable t) {
        cancelAcquire(node);
        throw t;
    }
}
```

### 5. lockInterruptiblyå®ç°

```java
/**
 * lockInterruptiblyï¼šå¯ä¸­æ–­è·å–é”
 */
public void lockInterruptibly() throws InterruptedException {
    sync.acquireInterruptibly(1);
}

// AQSä¸­çš„å¯ä¸­æ–­è·å–
public final void acquireInterruptibly(int arg) throws InterruptedException {
    if (Thread.interrupted())
        throw new InterruptedException();
    if (!tryAcquire(arg))
        doAcquireInterruptibly(arg);
}

private void doAcquireInterruptibly(int arg) throws InterruptedException {
    final Node node = addWaiter(Node.EXCLUSIVE);
    try {
        for (;;) {
            final Node p = node.predecessor();
            if (p == head && tryAcquire(arg)) {
                setHead(node);
                p.next = null;
                return;
            }
            if (shouldParkAfterFailedAcquire(p, node) &&
                parkAndCheckInterrupt())
                throw new InterruptedException();  // å“åº”ä¸­æ–­
        }
    } catch (Throwable t) {
        cancelAcquire(node);
        throw t;
    }
}
```

---

## ğŸ’¡ æ€»ç»“

```
ReentrantLockæ ¸å¿ƒè¦ç‚¹ï¼š

1. åŸºäºAQSå®ç°ï¼š
   - stateè¡¨ç¤ºé‡å…¥æ¬¡æ•°
   - exclusiveOwnerThreadè®°å½•æŒæœ‰çº¿ç¨‹

2. å…¬å¹³/éå…¬å¹³ï¼š
   - éå…¬å¹³ï¼šç›´æ¥CASå°è¯•
   - å…¬å¹³ï¼šå…ˆæ£€æŸ¥é˜Ÿåˆ—

3. å¯é‡å…¥ï¼š
   - åŒä¸€çº¿ç¨‹å¯å¤šæ¬¡è·å–
   - stateç´¯åŠ ï¼Œé‡Šæ”¾æ—¶é€’å‡

4. Conditionï¼š
   - å¤šä¸ªæ¡ä»¶é˜Ÿåˆ—
   - await/signal

5. é«˜çº§åŠŸèƒ½ï¼š
   - tryLockï¼šéé˜»å¡
   - tryLock(timeout)ï¼šè¶…æ—¶
   - lockInterruptiblyï¼šå¯ä¸­æ–­
```

---

*æœ€åæ›´æ–°ï¼š2025-12-28*

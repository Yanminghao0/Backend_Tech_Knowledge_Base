# 背包问题

> 背包问题是研究在有限容量下，如何选择物品使得价值最大化的经典动态规划问题，主要包括0-1背包、完全背包、多重背包等类型

---

## 📋 基本信息

- **定义**：解决在资源有限条件下，如何选择物品以获得最大价值的一类动态规划问题
- **核心类型**：0-1背包、完全背包、多重背包、分组背包、二维背包等
- **时间复杂度**：O(n*C)，其中n为物品数量，C为背包容量
- **空间复杂度**：可优化至O(C)，通过滚动数组实现

## 🎯 问题分析

### 适用场景
背包问题适用于解决具有以下特征的优化问题：
1. **资源分配问题**：如预算有限时的项目选择、投资组合优化
2. **组合优化问题**：如从多个选项中选择最佳组合，满足约束条件
3. **装载问题**：如集装箱装载、货物配载等物流优化
4. **选择问题**：如特征选择、课程安排等带有约束条件的选择问题
5. **资源受限的决策问题**：如时间有限情况下的任务安排

### 问题分类
| 类型 | 特点 | 典型应用 |
|------|------|----------|
| 0-1背包 | 每种物品只能选择一次 | 项目投资决策、特征选择 |
| 完全背包 | 每种物品可以选择无限次 | 货币找零、资源无限的采购 |
| 多重背包 | 每种物品有固定数量限制 | 库存有限的商品选择 |
| 分组背包 | 物品分成组，每组只能选一个 | 套餐选择、类别受限的采购 |
| 二维背包 | 有两个约束条件（如重量和体积） | 物流运输（重量和体积限制） |

## 💻 代码实现

### 1. 0-1背包（基础实现）
```java
public int knapsack01(int[] weights, int[] values, int capacity) {
    int n = weights.length;
    int[][] dp = new int[n+1][capacity+1];
    
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= capacity; j++) {
            if (j >= weights[i-1]) {
                // 选择当前物品或不选择，取最大值
                dp[i][j] = Math.max(dp[i-1][j], 
                                   dp[i-1][j-weights[i-1]] + values[i-1]);
            } else {
                // 背包容量不足，无法选择当前物品
                dp[i][j] = dp[i-1][j];
            }
        }
    }
    return dp[n][capacity];
}
```

### 2. 0-1背包（空间优化版）
```java
public int knapsack01Optimized(int[] weights, int[] values, int capacity) {
    int n = weights.length;
    int[] dp = new int[capacity+1];
    
    for (int i = 0; i < n; i++) {
        // 从后往前遍历，避免重复选择
        for (int j = capacity; j >= weights[i]; j--) {
            dp[j] = Math.max(dp[j], dp[j-weights[i]] + values[i]);
        }
    }
    return dp[capacity];
}
```

### 3. 完全背包（空间优化版）
```java
public int unboundedKnapsack(int[] weights, int[] values, int capacity) {
    int n = weights.length;
    int[] dp = new int[capacity+1];
    
    for (int i = 0; i < n; i++) {
        // 从前往后遍历，允许重复选择
        for (int j = weights[i]; j <= capacity; j++) {
            dp[j] = Math.max(dp[j], dp[j-weights[i]] + values[i]);
        }
    }
    return dp[capacity];
}
```

### 4. 多重背包（二进制优化）
```java
public int multipleKnapsack(int[] weights, int[] values, int[] counts, int capacity) {
    // 将多重背包转换为0-1背包
    List<Integer> newWeights = new ArrayList<>();
    List<Integer> newValues = new ArrayList<>();
    
    for (int i = 0; i < weights.length; i++) {
        int count = counts[i];
        // 二进制分解
        for (int j = 1; j <= count; j *= 2) {
            newWeights.add(weights[i] * j);
            newValues.add(values[i] * j);
            count -= j;
        }
        if (count > 0) {
            newWeights.add(weights[i] * count);
            newValues.add(values[i] * count);
        }
    }
    
    // 使用0-1背包求解
    int[] dp = new int[capacity+1];
    for (int i = 0; i < newWeights.size(); i++) {
        int w = newWeights.get(i);
        int v = newValues.get(i);
        for (int j = capacity; j >= w; j--) {
            dp[j] = Math.max(dp[j], dp[j-w] + v);
        }
    }
    return dp[capacity];
}
```

## 📊 状态转移方程

### 1. 0-1背包
- **状态定义**：`dp[i][j]` 表示前i个物品在容量j下的最大价值
- **转移方程**：`dp[i][j] = max(dp[i-1][j], dp[i-1][j-w[i]] + v[i])`（当j >= w[i]）
- **初始状态**：`dp[0][j] = 0` 对所有j成立，`dp[i][0] = 0` 对所有i成立
- **空间优化**：`dp[j] = max(dp[j], dp[j-w[i]] + v[i])`（从后往前更新）

### 2. 完全背包
- **状态定义**：`dp[j]` 表示容量j下的最大价值
- **转移方程**：`dp[j] = max(dp[j], dp[j-w[i]] + v[i])`（从前往后更新）
- **初始状态**：`dp[0] = 0`

### 3. 多重背包
- **核心思想**：将物品按二进制分解为多个0-1背包物品
- **转移方程**：同0-1背包

## 🔍 经典题目

| 题目 | 类型 | 难度 | 考点 |
|------|------|------|------|
| [LeetCode 416. 分割等和子集](https://leetcode-cn.com/problems/partition-equal-subset-sum/) | 0-1背包 | 中等 | 子集和问题 |
| [LeetCode 518. 零钱兑换II](https://leetcode-cn.com/problems/coin-change-ii/) | 完全背包 | 中等 | 组合数计算 |
| [LeetCode 322. 零钱兑换](https://leetcode-cn.com/problems/coin-change/) | 完全背包 | 中等 | 最少物品数 |
| [LeetCode 474. 一和零](https://leetcode-cn.com/problems/ones-and-zeroes/) | 二维背包 | 中等 | 双约束条件 |
| [LeetCode 1049. 最后一块石头的重量II](https://leetcode-cn.com/problems/last-stone-weight-ii/) | 0-1背包 | 中等 | 最小差值分割 |
| [LeetCode 279. 完全平方数](https://leetcode-cn.com/problems/perfect-squares/) | 完全背包 | 中等 | 最小数量组合 |

## ⚠️ 注意事项

1. **状态定义的一致性**：明确dp数组的含义，是"恰好装满"还是"最多装到"容量j
2. **遍历顺序**：0-1背包需逆序遍历容量，完全背包需正序遍历，避免混淆
3. **初始化处理**：根据问题要求设置初始值，求最大值通常初始化为0，求最小值初始化为无穷大
4. **空间优化**：熟练掌握滚动数组技巧，将二维空间优化为一维
5. **多重背包优化**：小规模数据可用暴力拆分，大规模数据需使用二进制拆分或单调队列优化
6. **边界条件**：注意处理物品重量为0或价值为0的特殊情况

## 🎓 最佳实践

1. **问题类型识别**：准确判断背包问题类型是解决问题的关键
2. **状态定义技巧**：根据问题目标定义dp数组，如"最大价值"、"方案数量"或"最小数量"
3. **优化策略选择**：根据数据规模选择合适的优化方法，平衡时间和空间复杂度
4. **多维背包处理**：将二维及以上背包问题转化为一维处理，降低复杂度
5. **实际应用建模**：学会将实际问题抽象为背包模型，如将"时间"、"空间"等作为背包容量
6. **代码模板化**：建立各类背包问题的通用代码模板，提高解题效率

---

> **已完成**：本文档已包含背包问题的完整知识点，包括各类背包的原理、实现及应用场景
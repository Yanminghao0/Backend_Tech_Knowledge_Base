# 线性DP

> 线性动态规划是状态之间呈线性关系的动态规划问题，其核心是找到状态转移的线性规律

---

## 📋 基本信息

- **定义**：状态之间呈线性关系的动态规划问题，状态转移通常只依赖于前一个或前几个状态
- **核心特征**：问题可以分解为按顺序排列的子问题，且子问题的解可以按线性顺序计算
- **时间复杂度**：通常为O(n)或O(n²)，取决于状态转移的复杂度
- **空间复杂度**：可优化至O(1)或O(n)，根据是否需要保存所有状态

## 🎯 问题分析

### 适用场景
线性DP适用于解决具有以下特征的问题：
1. **序列优化问题**：如最长递增子序列、最长公共子序列等
2. **区间优化问题**：如最大子数组和、环形子数组和等
3. **计数问题**：如不同路径数量、解码方法数量等
4. **资源分配问题**：如分割等和子集、划分数组为连续子序列等

### 典型特征
- 问题的解可以表示为一系列按顺序排列的状态
- 每个状态只依赖于之前的有限个状态
- 可以按线性顺序（通常是从左到右）计算所有状态

## 💻 代码实现

### 1. 最长递增子序列 (LIS)
```java
public int lengthOfLIS(int[] nums) {
    if (nums == null || nums.length == 0) return 0;
    int[] dp = new int[nums.length];
    int maxLen = 1;
    Arrays.fill(dp, 1);
    
    for (int i = 1; i < nums.length; i++) {
        for (int j = 0; j < i; j++) {
            if (nums[i] > nums[j]) {
                dp[i] = Math.max(dp[i], dp[j] + 1);
                maxLen = Math.max(maxLen, dp[i]);
            }
        }
    }
    return maxLen;
}
```

### 2. 最大子数组和 (Kadane算法)
```java
public int maxSubArray(int[] nums) {
    int maxSum = nums[0];
    int currentSum = nums[0];
    
    for (int i = 1; i < nums.length; i++) {
        currentSum = Math.max(nums[i], currentSum + nums[i]);
        maxSum = Math.max(maxSum, currentSum);
    }
    return maxSum;
}
```

### 3. 爬楼梯问题
```java
public int climbStairs(int n) {
    if (n <= 2) return n;
    int prevPrev = 1; // f(n-2)
    int prev = 2;    // f(n-1)
    int current = 0;
    
    for (int i = 3; i <= n; i++) {
        current = prevPrev + prev;
        prevPrev = prev;
        prev = current;
    }
    return current;
}
```

## 📊 状态转移方程

### 1. 最长递增子序列
- **状态定义**：`dp[i]` 表示以第i个元素结尾的最长递增子序列长度
- **转移方程**：`dp[i] = max(dp[j] + 1) for j < i and nums[i] > nums[j]`
- **初始状态**：`dp[i] = i` 对所有i成立

### 2. 最大子数组和
- **状态定义**：`dp[i]` 表示以第i个元素结尾的最大子数组和
- **转移方程**：`dp[i] = max(nums[i], dp[i-1] + nums[i])`
- **初始状态**：`dp[0] = nums[0]`

### 3. 爬楼梯问题
- **状态定义**：`dp[i]` 表示爬到第i级台阶的方法数
- **转移方程**：`dp[i] = dp[i-1] + dp[i-2]`
- **初始状态**：`dp[1] = 1, dp[2] = 2`

## 🔍 经典题目

| 题目 | 难度 | 考点 |
|------|------|------|
| [LeetCode 300. 最长递增子序列](https://leetcode-cn.com/problems/longest-increasing-subsequence/) | 中等 | 基础LIS实现与优化 |
| [LeetCode 53. 最大子数组和](https://leetcode-cn.com/problems/maximum-subarray/) | 简单 | Kadane算法 |
| [LeetCode 70. 爬楼梯](https://leetcode-cn.com/problems/climbing-stairs/) | 简单 | 基础线性DP |
| [LeetCode 152. 乘积最大子数组](https://leetcode-cn.com/problems/maximum-product-subarray/) | 中等 | 考虑正负值的DP |
| [LeetCode 198. 打家劫舍](https://leetcode-cn.com/problems/house-robber/) | 中等 | 相邻状态限制 |
| [LeetCode 338. 比特位计数](https://leetcode-cn.com/problems/counting-bits/) | 简单 | 位运算DP |

## ⚠️ 注意事项

1. **状态定义的准确性**：状态定义直接影响问题能否正确解决，需确保定义清晰且包含必要信息
2. **边界条件处理**：初始状态的设置要准确，避免数组越界或计算错误
3. **空间优化**：当状态只依赖于前几个状态时，可使用滚动数组将空间复杂度从O(n)降至O(1)
4. **计算顺序**：确保按正确顺序计算状态，避免依赖未计算的状态
5. **子问题重叠**：确认问题存在重叠子问题，避免盲目使用DP

## 🎓 最佳实践

1. **从简单问题入手**：先解决基础问题，再尝试优化和处理复杂变体
2. **可视化状态转移**：使用表格或图表辅助理解状态之间的关系
3. **掌握空间优化技巧**：熟练运用滚动数组、状态压缩等方法减少空间消耗
4. **多维度思考**：尝试从不同角度定义状态，寻找更优的状态转移方程
5. **归纳总结**：将相似问题归类，总结通用解题模板

---

> **已完成**：本文档已包含线性DP的完整知识点
# 状态压缩DP

> 状态压缩动态规划是使用二进制表示状态的动态规划方法，适用于解决状态数量较少的组合优化问题

---

## 📋 基本信息

- **定义**：使用二进制或其他压缩方式表示状态的动态规划方法，通过位运算优化状态转移
- **核心特征**：将集合、状态等复杂信息压缩为整数表示，利用位运算高效处理
- **适用条件**：状态数量较少（通常不超过20-25个元素），适合用二进制表示
- **时间复杂度**：O(n×2ⁿ)或O(n²×2ⁿ)，其中n为状态元素数量
- **空间复杂度**：O(2ⁿ)，主要用于存储压缩状态

## 🎯 问题分析

### 适用场景
状态压缩DP适用于解决具有以下特征的问题：
1. **子集选择问题**：如集合覆盖、子集划分、旅行商问题
2. **状态标记问题**：如棋盘覆盖、国王放置、独立集问题
3. **组合优化问题**：如最小顶点覆盖、最短哈密顿路径
4. **状态转换问题**：如开关问题、灯的开关状态转换
5. **资源分配问题**：如任务分配、设备调度

### 核心技术
1. **二进制状态表示**：用整数的二进制位表示元素是否被选中或状态
2. **位运算操作**：使用与(&)、或(|)、异或(^)、移位(<<, >>)等操作处理状态
3. **状态压缩技巧**：利用掩码(Mask)过滤无效状态，减少计算量
4. **预处理优化**：预计算有效状态或状态间的转换关系

## 💻 代码实现

### 1. 旅行商问题 (TSP)
```java
public int tsp(int[][] distance) {
    int n = distance.length;
    int fullMask = (1 << n) - 1; // 全选状态掩码
    int[][] dp = new int[n][1 << n];
    
    // 初始化所有状态为无穷大
    for (int i = 0; i < n; i++) {
        Arrays.fill(dp[i], Integer.MAX_VALUE / 2); // 避免溢出
    }
    dp[0][1] = 0; // 从城市0出发，已访问城市0
    
    // 枚举所有状态
    for (int mask = 1; mask < (1 << n); mask++) {
        for (int u = 0; u < n; u++) {
            if ((mask & (1 << u)) == 0) continue; // u不在当前状态中
            
            for (int v = 0; v < n; v++) {
                if ((mask & (1 << v)) != 0) continue; // v已在当前状态中
                
                int newMask = mask | (1 << v);
                dp[v][newMask] = Math.min(dp[v][newMask], dp[u][mask] + distance[u][v]);
            }
        }
    }
    
    return dp[n-1][fullMask]; // 返回从0出发到达n-1且访问所有城市的最短路径
}
```

### 2. 蒙德里安的梦想 (棋盘覆盖问题)
```java
public int countWays(int n, int m) {
    // 预处理：计算所有合法的行状态
    List<Integer> validStates = new ArrayList<>();
    for (int i = 0; i < (1 << m); i++) {
        if ((i & (i << 1)) == 0) { // 没有相邻的1
            validStates.add(i);
        }
    }
    
    // 预处理：计算状态间的兼容关系
    Map<Integer, List<Integer>> compatible = new HashMap<>();
    for (int a : validStates) {
        compatible.put(a, new ArrayList<>());
        for (int b : validStates) {
            if ((a & b) == 0 && ((a | b) & ((a | b) << 1)) == 0) {
                compatible.get(a).add(b);
            }
        }
    }
    
    // DP表：dp[i][j]表示第i行状态为j时的方案数
    int[][] dp = new int[n+1][1 << m];
    dp[0][0] = 1;
    
    for (int i = 1; i <= n; i++) {
        for (int curr : validStates) {
            for (int prev : compatible.get(curr)) {
                dp[i][curr] += dp[i-1][prev];
            }
        }
    }
    
    return dp[n][0];
}
```

### 3. 最短哈密顿路径
```java
public int shortestHamiltonPath(int[][] graph) {
    int n = graph.length;
    int[][] dp = new int[1 << n][n];
    
    // 初始化所有状态为无穷大
    for (int i = 0; i < (1 << n); i++) {
        Arrays.fill(dp[i], Integer.MAX_VALUE / 2);
    }
    dp[1][0] = 0; // 从节点0出发
    
    // 枚举所有状态
    for (int mask = 1; mask < (1 << n); mask++) {
        for (int u = 0; u < n; u++) {
            if ((mask & (1 << u)) == 0) continue;
            
            for (int v = 0; v < n; v++) {
                if ((mask & (1 << v)) != 0) continue;
                
                int newMask = mask | (1 << v);
                dp[newMask][v] = Math.min(dp[newMask][v], dp[mask][u] + graph[u][v]);
            }
        }
    }
    
    // 找到到达最后一个节点的最短路径
    return dp[(1 << n) - 1][n-1];
}
```

## 📊 状态压缩技术

### 1. 二进制状态表示
- **基本思想**：用整数的二进制位表示集合状态，第i位为1表示元素i被选中
- **常用操作**：
  - 判断元素是否存在：`(mask & (1 << i)) != 0`
  - 添加元素：`mask | (1 << i)`
  - 移除元素：`mask & ~(1 << i)`
  - 翻转元素：`mask ^ (1 << i)`
  - 统计元素个数：`Integer.bitCount(mask)`
  - 枚举子集：`for (int s = mask; s > 0; s = (s-1) & mask)`

### 2. 状态压缩技巧
- **掩码过滤**：预计算有效状态，减少状态空间
- **状态合并**：将多个相关状态合并为一个整数表示
- **位运算优化**：利用位运算代替集合操作，提高效率
- **滚动数组**：当状态只依赖前一阶段时，使用滚动数组减少空间

## 📊 状态转移方程

### 1. 旅行商问题
- **状态定义**：`dp[mask][u]`表示访问过mask中的节点，当前在节点u的最短路径
- **转移方程**：`dp[mask | (1<<v)][v] = min(dp[mask | (1<<v)][v], dp[mask][u] + graph[u][v])`
- **初始状态**：`dp[1<<start][start] = 0`
- **最终结果**：`dp[(1<<n)-1][end]`

### 2. 子集和问题
- **状态定义**：`dp[mask]`表示子集mask的元素之和
- **转移方程**：`dp[mask | (1<<i)] = dp[mask] + nums[i]`
- **初始状态**：`dp[0] = 0`
- **判断条件**：检查是否存在mask使得`dp[mask] = target`

### 3. 国王放置问题
- **状态定义**：`dp[i][mask]`表示第i行国王放置状态为mask时的方案数
- **转移方程**：`dp[i][curr] += dp[i-1][prev]`（curr和prev状态不冲突）
- **冲突条件**：`(curr & prev) != 0 || (curr & (prev << 1)) != 0 || (curr & (prev >> 1)) != 0`

## 🔍 经典题目

| 题目 | 难度 | 考点 |
|------|------|------|
| [LeetCode 464. 我能赢吗](https://leetcode-cn.com/problems/can-i-win/) | 中等 | 博弈型状态压缩 |
| [LeetCode 526. 优美的排列](https://leetcode-cn.com/problems/beautiful-arrangement/) | 中等 | 排列型状态压缩 |
| [LeetCode 698. 划分为k个相等的子集](https://leetcode-cn.com/problems/partition-to-k-equal-sum-subsets/) | 中等 | 子集划分问题 |
| [LeetCode 935. 骑士拨号器](https://leetcode-cn.com/problems/knight-dialer/) | 中等 | 状态转移优化 |
| [LeetCode 1349. 参加考试的最大学生数](https://leetcode-cn.com/problems/maximum-students-taking-exam/) | 困难 | 矩阵状态压缩 |
| [LeetCode 1434. 每个人戴不同帽子的方案数](https://leetcode-cn.com/problems/number-of-ways-to-wear-different-hats-to-each-other/) | 困难 | 状态压缩与容斥 |

## ⚠️ 注意事项

1. **状态数量限制**：状态压缩DP的时间复杂度随状态数量指数增长，通常n≤20时适用
2. **位运算优先级**：位运算优先级低于比较运算符，注意添加括号
3. **状态预处理**：预计算有效状态可大幅减少计算量
4. **内存优化**：使用滚动数组或位运算优化内存使用
5. **状态表示选择**：根据问题特点选择合适的状态表示方式，不一定总是二进制
6. **初始化处理**：注意初始状态的正确设置，避免溢出或错误累加
7. **枚举顺序**：确保状态枚举顺序正确，避免依赖未计算的状态

## 🎓 最佳实践

1. **状态设计**：
   - 选择最小化状态空间的表示方式
   - 区分必要状态和冗余状态
   - 使用位运算简化状态转换

2. **效率优化**：
   - 预计算有效状态集合
   - 使用位运算代替集合操作
   - 利用对称性减少重复计算
   - 使用哈希表存储稀疏状态

3. **问题转化**：
   - 将实际问题抽象为状态压缩模型
   - 识别问题中的状态元素和约束条件
   - 将约束条件转化为位运算表达式

4. **调试技巧**：
   - 使用二进制打印调试状态
   - 小数据量手动模拟验证
   - 逐步构建状态转移关系

---

> **已完成**：本文档已包含状态压缩DP的完整知识点，包括二进制状态表示、位运算操作、典型问题实现及应用场景
# 区间DP

> 区间动态规划是状态定义在区间上的动态规划问题，通过枚举区间长度和端点来求解最优子结构

---

## 📋 基本信息

- **定义**：状态定义在区间上的动态规划问题，通常需要枚举区间长度和端点
- **核心特征**：问题的最优解由子区间的最优解构成，区间长度通常从小到大扩展
- **时间复杂度**：通常为O(n³)，其中n为区间长度
- **空间复杂度**：O(n²)，需要二维数组存储区间状态

## 🎯 问题分析

### 适用场景
区间DP适用于解决具有以下特征的问题：
1. **区间优化问题**：如最长回文子序列、矩阵连乘最小代价
2. **合并问题**：如石子合并、戳气球、 burst balloons
3. **区间划分问题**：如最优二叉搜索树、字符串分割
4. **区间最值问题**：如区间最大子数组、区间最大公约数
5. **游戏问题**：如石子游戏、戳气球得分最大化

### 解题步骤
1. **定义状态**：`dp[i][j]`表示区间[i,j]的最优解
2. **确定区间长度**：通常从长度为1的小区间开始，逐步扩展到长度为n的大区间
3. **枚举区间端点**：对于每个长度l，枚举所有可能的起点i，计算终点j=i+l-1
4. **寻找分割点**：在区间[i,j]内寻找最优分割点k，将区间分为[i,k]和[k+1,j]
5. **状态转移**：根据子区间的解计算当前区间的解

## 💻 代码实现

### 1. 石子合并问题
```java
public int stoneGame(int[] stones) {
    int n = stones.length;
    int[][] dp = new int[n][n];
    int[] prefixSum = new int[n+1];
    
    // 计算前缀和
    for (int i = 0; i < n; i++) {
        prefixSum[i+1] = prefixSum[i] + stones[i];
    }
    
    // 区间长度从2到n
    for (int len = 2; len <= n; len++) {
        // 枚举起点
        for (int i = 0; i <= n - len; i++) {
            int j = i + len - 1;
            dp[i][j] = Integer.MAX_VALUE;
            // 枚举分割点
            for (int k = i; k < j; k++) {
                int cost = dp[i][k] + dp[k+1][j] + prefixSum[j+1] - prefixSum[i];
                dp[i][j] = Math.min(dp[i][j], cost);
            }
        }
    }
    return dp[0][n-1];
}
```

### 2. 最长回文子序列
```java
public int longestPalindromeSubseq(String s) {
    int n = s.length();
    int[][] dp = new int[n][n];
    
    // 区间长度为1
    for (int i = 0; i < n; i++) {
        dp[i][i] = 1;
    }
    
    // 区间长度从2到n
    for (int len = 2; len <= n; len++) {
        for (int i = 0; i <= n - len; i++) {
            int j = i + len - 1;
            if (s.charAt(i) == s.charAt(j)) {
                dp[i][j] = dp[i+1][j-1] + 2;
            } else {
                dp[i][j] = Math.max(dp[i+1][j], dp[i][j-1]);
            }
        }
    }
    return dp[0][n-1];
}
```

### 3. 矩阵连乘问题
```java
public int matrixChainOrder(int[] p) {
    int n = p.length - 1; // 矩阵数量
    int[][] dp = new int[n+1][n+1];
    int[][] split = new int[n+1][n+1];
    
    // 区间长度从2到n
    for (int len = 2; len <= n; len++) {
        for (int i = 1; i <= n - len + 1; i++) {
            int j = i + len - 1;
            dp[i][j] = Integer.MAX_VALUE;
            for (int k = i; k < j; k++) {
                int cost = dp[i][k] + dp[k+1][j] + p[i-1] * p[k] * p[j];
                if (cost < dp[i][j]) {
                    dp[i][j] = cost;
                    split[i][j] = k;
                }
            }
        }
    }
    return dp[1][n];
}
```

## 📊 状态转移方程

### 1. 石子合并问题
- **状态定义**：`dp[i][j]`表示合并区间[i,j]的石子所需的最小代价
- **转移方程**：`dp[i][j] = min(dp[i][k] + dp[k+1][j] + sum(i,j))` for k ∈ [i,j-1]
- **初始状态**：`dp[i][i] = 0`（单个石子无需合并）
- **区间和计算**：`sum(i,j) = prefixSum[j+1] - prefixSum[i]`

### 2. 最长回文子序列
- **状态定义**：`dp[i][j]`表示区间[i,j]的最长回文子序列长度
- **转移方程**：
  - 若s[i] == s[j]：`dp[i][j] = dp[i+1][j-1] + 2`
  - 否则：`dp[i][j] = max(dp[i+1][j], dp[i][j-1])`
- **初始状态**：`dp[i][i] = 1`（单个字符是长度为1的回文）

### 3. 矩阵连乘问题
- **状态定义**：`dp[i][j]`表示计算矩阵链A[i..j]所需的最小乘法次数
- **转移方程**：`dp[i][j] = min(dp[i][k] + dp[k+1][j] + p[i-1]*p[k]*p[j])` for k ∈ [i,j-1]
- **初始状态**：`dp[i][i] = 0`（单个矩阵无需乘法）

## 🔍 经典题目

| 题目 | 难度 | 考点 |
|------|------|------|
| [LeetCode 516. 最长回文子序列](https://leetcode-cn.com/problems/longest-palindromic-subsequence/) | 中等 | 区间长度扩展 |
| [LeetCode 312. 戳气球](https://leetcode-cn.com/problems/burst-balloons/) | 困难 | 区间划分与状态定义 |
| [LeetCode 1039. 多边形三角剖分的最低得分](https://leetcode-cn.com/problems/minimum-score-triangulation-of-polygon/) | 中等 | 多边形分割 |
| [LeetCode 664. 奇怪的打印机](https://leetcode-cn.com/problems/strange-printer/) | 困难 | 区间DP与字符匹配 |
| [LeetCode 375. 猜数字大小 II](https://leetcode-cn.com/problems/guess-number-higher-or-lower-ii/) | 中等 | 博弈型区间DP |
| [LeetCode 1246. 删除回文子数组](https://leetcode-cn.com/problems/palindrome-removal/) | 困难 | 区间删除问题 |

## ⚠️ 注意事项

1. **区间遍历顺序**：必须先计算小区间，再计算大区间，通常按区间长度递增遍历
2. **状态定义准确性**：明确`dp[i][j]`代表的具体含义，是区间[i,j]的最大值、最小值还是数量
3. **分割点枚举**：确保分割点k的取值范围正确，通常是[i,j-1]或[i+1,j]
4. **边界条件处理**：注意区间长度为1或2的特殊情况，避免数组越界
5. **空间优化**：某些问题可通过滚动数组将空间复杂度从O(n²)降至O(n)，但会增加代码复杂度
6. **前缀和优化**：对于需要频繁计算区间和的问题，使用前缀和数组减少重复计算

## 🎓 最佳实践

1. **区间长度优先**：始终从长度为1的区间开始计算，逐步增加到目标区间长度
2. **状态可视化**：使用表格辅助理解状态转移过程，特别是二维DP数组的填充顺序
3. **记忆化搜索**：对于复杂区间问题，可考虑使用递归+记忆化的方式实现，代码更简洁
4. **分割点优化**：某些问题存在最优分割点的单调性，可使用四边形不等式优化时间复杂度
5. **问题转化**：将实际问题抽象为区间模型，如将字符串问题转化为区间[i,j]的子串问题
6. **多维度思考**：尝试从不同角度定义区间状态，寻找更高效的状态转移方程

---

> **已完成**：本文档已包含区间DP的完整知识点，包括核心原理、实现方法和应用场景
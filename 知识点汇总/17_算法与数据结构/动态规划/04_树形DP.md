# 树形DP

> 树形动态规划是在树结构上进行的动态规划，通过后序遍历自底向上计算子树状态，进而得到整棵树的最优解

---

## 📋 基本信息

- **定义**：在树结构上定义状态并进行动态规划的方法，通常通过后序遍历计算子树状态
- **核心特征**：状态定义在树节点或子树上，利用树的递归结构自底向上计算
- **时间复杂度**：O(n)，其中n为树的节点数量
- **空间复杂度**：O(n)，主要用于存储状态和递归栈

## 🎯 问题分析

### 适用场景
树形DP适用于解决具有以下特征的树结构问题：
1. **树的优化问题**：如树的最大独立集、最大权路径
2. **节点选择问题**：如打家劫舍III、监控二叉树
3. **子树统计问题**：如二叉树的坡度、求二叉树的所有路径和
4. **树的构造问题**：如不同的二叉搜索树、重构二叉树
5. **树的属性计算**：如树的直径、树的中心、最近公共祖先

### 解题步骤
1. **定义状态**：通常在节点上定义状态，如`dp[node][state]`表示节点node在state状态下的最优解
2. **后序遍历**：先递归处理子节点，再根据子节点状态计算当前节点状态
3. **状态转移**：根据子节点的状态组合计算当前节点的状态值
4. **根节点结果**：最终结果通常存储在根节点的状态中

## 💻 代码实现

### 1. 树的最大独立集
```java
class TreeNode {
    int val;
    TreeNode left, right;
    TreeNode(int x) { val = x; }
}

public int treeIndependentSet(TreeNode root) {
    int[] result = dfs(root);
    return Math.max(result[0], result[1]);
}

// 返回值：[不选当前节点的最大独立集, 选当前节点的最大独立集]
private int[] dfs(TreeNode node) {
    if (node == null) return new int[]{0, 0};
    
    int[] left = dfs(node.left);
    int[] right = dfs(node.right);
    
    // 不选当前节点：左右子节点可选可不选，取最大值
    int notSelect = Math.max(left[0], left[1]) + Math.max(right[0], right[1]);
    // 选当前节点：左右子节点都不能选
    int select = node.val + left[0] + right[0];
    
    return new int[]{notSelect, select};
}
```

### 2. 树的直径
```java
public int treeDiameter(TreeNode root) {
    int[] diameter = new int[1];
    dfsDiameter(root, diameter);
    return diameter[0];
}

// 返回以当前节点为根的子树的最大深度
private int dfsDiameter(TreeNode node, int[] diameter) {
    if (node == null) return 0;
    
    int leftDepth = dfsDiameter(node.left, diameter);
    int rightDepth = dfsDiameter(node.right, diameter);
    
    // 更新直径：当前节点左右子树深度之和
    diameter[0] = Math.max(diameter[0], leftDepth + rightDepth);
    
    return Math.max(leftDepth, rightDepth) + 1;
}
```

### 3. 二叉树中的最大路径和
```java
public int maxPathSum(TreeNode root) {
    int[] maxSum = new int[1];
    maxSum[0] = Integer.MIN_VALUE;
    dfsMaxPathSum(root, maxSum);
    return maxSum[0];
}

// 返回以当前节点为起点的最大路径和
private int dfsMaxPathSum(TreeNode node, int[] maxSum) {
    if (node == null) return 0;
    
    // 左子树最大路径和（若为负则不取）
    int left = Math.max(0, dfsMaxPathSum(node.left, maxSum));
    // 右子树最大路径和（若为负则不取）
    int right = Math.max(0, dfsMaxPathSum(node.right, maxSum));
    
    // 更新最大路径和：当前节点值+左右子树最大路径和
    maxSum[0] = Math.max(maxSum[0], node.val + left + right);
    
    // 返回当前节点能提供给父节点的最大路径和
    return node.val + Math.max(left, right);
}
```

## 📊 状态转移方程

### 1. 树的最大独立集
- **状态定义**：`dp[node][0]`表示不选节点node的最大独立集，`dp[node][1]`表示选择节点node的最大独立集
- **转移方程**：
  - `dp[node][0] += max(dp[child][0], dp[child][1])`（不选当前节点，子节点可选可不选）
  - `dp[node][1] += dp[child][0]`（选择当前节点，子节点不能选）
- **初始状态**：叶节点`dp[leaf][0] = 0`，`dp[leaf][1] = leaf.val`
- **最终结果**：`max(dp[root][0], dp[root][1])`

### 2. 树的直径
- **状态定义**：以节点node为根的子树的最大深度`depth[node]`
- **转移方程**：`depth[node] = max(depth[left], depth[right]) + 1`
- **直径计算**：`diameter = max(diameter, depth[left] + depth[right])`（对所有节点计算）
- **初始状态**：空节点深度为0

### 3. 二叉树中的最大路径和
- **状态定义**：以节点node为起点的最大路径和`maxPath[node]`
- **转移方程**：`maxPath[node] = node.val + max(0, maxPath[left], maxPath[right])`
- **路径和计算**：`maxSum = max(maxSum, node.val + max(0, maxPath[left]) + max(0, maxPath[right]))`
- **初始状态**：空节点路径和为0

## 🔍 经典题目

| 题目 | 难度 | 考点 |
|------|------|------|
| [LeetCode 337. 打家劫舍III](https://leetcode-cn.com/problems/house-robber-iii/) | 中等 | 树上节点选择 |
| [LeetCode 543. 二叉树的直径](https://leetcode-cn.com/problems/diameter-of-binary-tree/) | 简单 | 树的最长路径 |
| [LeetCode 124. 二叉树中的最大路径和](https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/) | 困难 | 树的路径和优化 |
| [LeetCode 968. 监控二叉树](https://leetcode-cn.com/problems/binary-tree-cameras/) | 困难 | 多状态树形DP |
| [LeetCode 687. 最长同值路径](https://leetcode-cn.com/problems/longest-univalue-path/) | 简单 | 同值路径计算 |
| [LeetCode 2246. 相邻字符不同的最长路径](https://leetcode-cn.com/problems/longest-path-with-different-adjacent-characters/) | 困难 | 多叉树路径优化 |

## ⚠️ 注意事项

1. **状态定义清晰化**：明确状态代表的是节点本身还是子树，避免混淆
2. **后序遍历顺序**：确保先处理所有子节点，再处理当前节点
3. **边界条件处理**：空节点或叶节点的状态值设置要准确
4. **多状态管理**：对于需要多个状态的问题（如选择/不选择、不同颜色等），确保状态转移覆盖所有情况
5. **递归深度控制**：对于深度较大的树，考虑使用迭代后序遍历避免栈溢出
6. **子树独立性**：利用树的无环特性，确保子树状态计算相互独立

## 🎓 最佳实践

1. **树的表示**：根据问题选择合适的树表示方式（邻接表、二叉树节点等）
2. **状态可视化**：通过画图辅助理解节点状态和子树关系
3. **后序遍历模板**：掌握递归和迭代两种后序遍历方法，灵活应对不同场景
4. **状态压缩**：对于简单状态，可使用变量直接传递而非数组存储
5. **多叉树处理**：将多叉树转化为二叉树处理，或通过循环遍历子节点
6. **问题转化**：将实际问题抽象为树模型，如公司层级关系、社交网络关系等

---

> **已完成**：本文档已包含树形DP的完整知识点，包括树结构状态定义、后序遍历计算及典型树问题
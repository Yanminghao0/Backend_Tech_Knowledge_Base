# 堆

堆（Heap）是一种特殊的完全二叉树数据结构，它满足父节点与子节点之间的特定大小关系。堆通常用于实现优先队列，是高效解决Top-K问题和排序问题的基础数据结构。

---

## 📋 基本信息

| 项目 | 说明 |
|------|------|
| 数据结构类型 | 完全二叉树 |
| 存储结构 | 数组（为主）、链式存储 |
| 核心操作 | 插入、删除、堆化、提取最值 |
| 时间复杂度 | 建堆：O(n)，插入/删除：O(log n)，查找最值：O(1) |
| 空间复杂度 | O(n) |
| 特点 | 父节点值大于等于子节点值（大顶堆）或小于等于子节点值（小顶堆） |

## 🎯 核心特性

1. **完全二叉树结构**：除最后一层外，其余层均填满，最后一层节点从左向右填充
2. **堆序性**：
   - 大顶堆：每个父节点的值大于或等于其子节点的值
   - 小顶堆：每个父节点的值小于或等于其子节点的值
3. **数组实现优势**：通过数组下标计算父子节点位置，无需指针
4. **高效最值访问**：堆顶元素始终为最大值（大顶堆）或最小值（小顶堆）
5. **动态调整**：插入和删除操作后通过堆化（sift up/sift down）维持堆特性

## 💻 代码实现

### 1. 大顶堆实现
```java
public class MaxHeap {
    private int[] heap;
    private int size;
    private int capacity;

    // 构造函数
    public MaxHeap(int capacity) {
        this.capacity = capacity;
        this.size = 0;
        this.heap = new int[capacity + 1]; // 索引从1开始，方便计算
        heap[0] = Integer.MAX_VALUE; // 哨兵节点
    }

    // 获取父节点索引
    private int parent(int pos) {
        return pos / 2;
    }

    // 获取左子节点索引
    private int leftChild(int pos) {
        return 2 * pos;
    }

    // 获取右子节点索引
    private int rightChild(int pos) {
        return 2 * pos + 1;
    }

    // 判断是否为叶子节点
    private boolean isLeaf(int pos) {
        return pos > size / 2 && pos <= size;
    }

    // 交换两个节点值
    private void swap(int pos1, int pos2) {
        int temp = heap[pos1];
        heap[pos1] = heap[pos2];
        heap[pos2] = temp;
    }

    // 堆化（下沉操作）
    private void maxHeapify(int pos) {
        if (isLeaf(pos)) return;

        // 如果当前节点小于子节点，则需要下沉
        if (heap[pos] < heap[leftChild(pos)] || heap[pos] < heap[rightChild(pos)]) {
            // 与较大的子节点交换
            if (heap[leftChild(pos)] > heap[rightChild(pos)]) {
                swap(pos, leftChild(pos));
                maxHeapify(leftChild(pos));
            } else {
                swap(pos, rightChild(pos));
                maxHeapify(rightChild(pos));
            }
        }
    }

    // 插入元素
    public void insert(int element) {
        if (size >= capacity) return;

        heap[++size] = element;
        int current = size;

        // 上浮操作：与父节点比较并交换
        while (heap[current] > heap[parent(current)]) {
            swap(current, parent(current));
            current = parent(current);
        }
    }

    // 提取堆顶元素（最大值）
    public int extractMax() {
        int maxElement = heap[1];
        heap[1] = heap[size--];
        maxHeapify(1);
        return maxElement;
    }

    // 构建堆
    public void buildHeap() {
        for (int i = size / 2; i > 0; i--)
            maxHeapify(i);
    }

    // 打印堆
    public void printHeap() {
        for (int i = 1; i <= size / 2; i++) {
            System.out.print("父节点: " + heap[i]);
            if (leftChild(i) <= size)
                System.out.print(" 左子节点: " + heap[leftChild(i)]);
            if (rightChild(i) <= size)
                System.out.print(" 右子节点: " + heap[rightChild(i)]);
            System.out.println();
        }
    }
}
```

### 2. 优先队列实现（基于堆）
```java
import java.util.Arrays;
import java.util.Comparator;

public class PriorityQueue<E> {
    private E[] heap;
    private int size;
    private Comparator<? super E> comparator;
    private static final int DEFAULT_CAPACITY = 11;

    // 构造函数
    public PriorityQueue(Comparator<? super E> comparator) {
        this.heap = (E[]) new Object[DEFAULT_CAPACITY];
        this.comparator = comparator;
        this.size = 0;
    }

    // 扩容
    private void grow(int minCapacity) {
        int oldCapacity = heap.length;
        int newCapacity = oldCapacity < 64 ?
                         (oldCapacity + 2) :
                         (oldCapacity << 1);
        heap = Arrays.copyOf(heap, newCapacity);
    }

    // 添加元素
    public boolean add(E e) {
        if (e == null) throw new NullPointerException();
        if (size >= heap.length - 1) grow(size + 1);
        size++;
        if (size == 1) {
            heap[1] = e;
        } else {
            siftUp(size, e);
        }
        return true;
    }

    // 上浮操作
    private void siftUp(int k, E x) {
        while (k > 1) {
            int parent = (k << 1) - 1; // k/2
            E e = heap[parent];
            if (comparator.compare(x, e) >= 0) break;
            heap[k] = e;
            k = parent;
        }
        heap[k] = x;
    }

    // 提取队首元素
    public E poll() {
        if (size == 0) return null;
        int s = --size;
        E result = heap[1];
        E x = heap[s + 1];
        heap[s + 1] = null;
        if (s != 0) {
            siftDown(1, x);
        }
        return result;
    }

    // 下沉操作
    private void siftDown(int k, E x) {
        int half = size >> 1;
        while (k <= half) {
            int child = (k << 1);
            int right = child + 1;
            E c = heap[child];
            if (right <= size && comparator.compare(c, heap[right]) > 0) {
                c = heap[child = right];
            }
            if (comparator.compare(x, c) <= 0) break;
            heap[k] = c;
            k = child;
        }
        heap[k] = x;
    }
}
```

### 3. 堆排序实现
```java
public class HeapSort {
    // 堆排序主函数
    public void sort(int arr[]) {
        int n = arr.length;

        // 构建最大堆
        for (int i = n / 2 - 1; i >= 0; i--)
            heapify(arr, n, i);

        // 提取元素并重新堆化
        for (int i = n - 1; i > 0; i--) {
            // 交换根节点与当前末尾元素
            int temp = arr[0];
            arr[0] = arr[i];
            arr[i] = temp;

            // 对剩余元素堆化
            heapify(arr, i, 0);
        }
    }

    // 堆化函数
    void heapify(int arr[], int n, int i) {
        int largest = i; // 初始化最大值为根节点
        int left = 2 * i + 1; // 左子节点
        int right = 2 * i + 2; // 右子节点

        // 如果左子节点大于根节点
        if (left < n && arr[left] > arr[largest])
            largest = left;

        // 如果右子节点大于当前最大值
        if (right < n && arr[right] > arr[largest])
            largest = right;

        // 如果最大值不是根节点
        if (largest != i) {
            int swap = arr[i];
            arr[i] = arr[largest];
            arr[largest] = swap;

            // 递归堆化受影响的子树
            heapify(arr, n, largest);
        }
    }
}
```

## 📊 复杂度分析

| 操作 | 时间复杂度 | 空间复杂度 | 说明 |
|------|------------|------------|------|
| 插入 | O(log n) | O(1) | 需上浮操作，树高为log n |
| 删除 | O(log n) | O(1) | 需下沉操作，树高为log n |
| 建堆 | O(n) | O(n) | 从底层向上堆化，优于n log n |
| 堆排序 | O(n log n) | O(1) | 原地排序，不稳定 |
| 查找最值 | O(1) | O(1) | 直接访问堆顶元素 |

> 注：n为堆中元素个数。建堆操作的时间复杂度看似O(n log n)，实际严格证明为O(n)。

## 🔍 应用场景

1. **优先队列**：操作系统任务调度、线程池任务优先级管理
2. **Top-K问题**：从大量数据中找出最大/最小的K个元素
3. **堆排序**：高效排序算法，时间复杂度O(n log n)
4. **中位数查找**：使用两个堆（大顶堆+小顶堆）维护动态数据的中位数
5. **Dijkstra算法**：图最短路径算法中用于高效获取下一个节点
6. **Huffman编码**：构建最优前缀码时用于选择频率最低的节点
7. **合并K个有序数组**：利用小顶堆实现高效合并

## ⚠️ 注意事项

1. **堆与树的区别**：堆是完全二叉树，但不一定是二叉搜索树，不支持范围查询
2. **数组实现细节**：通常从索引1开始存储数据，便于计算父子节点位置
3. **堆的稳定性**：堆排序是不稳定排序，相同元素的相对顺序可能改变
4. **初始容量选择**：预估数据量选择合适容量，避免频繁扩容
5. **自定义比较器**：对象类型需提供比较器，确保堆序性
6. **内存考虑**：大规模数据时需考虑堆的内存占用，避免OOM
7. **删除任意元素**：标准堆不支持高效删除任意元素，需额外标记或使用索引表

## 🎓 最佳实践

1. **选择合适的堆类型**：
   - 最大值优先：大顶堆
   - 最小值优先：小顶堆
   - 自定义优先级：使用带比较器的优先队列

2. **Top-K问题优化**：
   - 求最大K个元素：使用小顶堆，复杂度O(n log K)
   - 求最小K个元素：使用大顶堆，避免全部排序

3. **避免重复造轮子**：Java中优先使用`java.util.PriorityQueue`，而非自定义实现

4. **堆排序适用场景**：
   - 适合大数据量排序
   - 不适合对稳定性有要求的场景
   - 内存受限环境（原地排序）

5. **多堆协同应用**：
   - 双堆法：维护两个堆解决中位数问题
   - 延迟删除：标记删除元素，提取时才真正移除

### 代码示例：Top-K问题解决
```java
public class TopK {
    // 找出数组中最大的K个元素
    public int[] findTopK(int[] nums, int k) {
        if (k <= 0 || k > nums.length)
            throw new IllegalArgumentException("Invalid k value");

        // 使用小顶堆，保持堆大小为k
        PriorityQueue<Integer> minHeap = new PriorityQueue<>();

        for (int num : nums) {
            if (minHeap.size() < k) {
                minHeap.add(num);
            } else if (num > minHeap.peek()) {
                minHeap.poll();
                minHeap.add(num);
            }
        }

        // 转换为数组
        int[] result = new int[k];
        for (int i = 0; i < k; i++)
            result[i] = minHeap.poll();

        return result;
    }
}
```

---

> **完成状态**：本文档已完善堆的基本概念、实现代码、排序算法、复杂度分析、应用场景及最佳实践，包含Java实现的最大堆、优先队列和堆排序，可作为堆数据结构的完整学习参考。
# 字典树

> 字典树（Trie），也称为前缀树或单词查找树，是一种树形数据结构，专门用于高效存储和检索字符串数据集中的键。它的设计初衷是利用字符串的公共前缀来减少查询时间，最大限度地减少无谓的字符串比较，常用于搜索引擎自动补全、拼写检查、IP路由等场景。

---

## 📋 基本信息

| 属性 | 说明 |
|------|------|
| 数据结构类型 | 树形结构 |
| 存储结构 | 数组/链表组合 |
| 核心操作 | 插入、查找、删除、前缀匹配 |
| 时间复杂度 | 插入: O(L)，查找: O(L)，删除: O(L)，其中L是字符串长度 |
| 空间复杂度 | O(N×L×C)，其中N是字符串数量，L是平均长度，C是字符集大小 |
| 特点 | 利用公共前缀共享存储空间，查询效率高于哈希表 |

## 🎯 核心特性

1. **前缀共享**：所有具有相同前缀的字符串共享树的前缀节点，极大节省存储空间
2. **高效查询**：查询时间仅与字符串长度相关，不受数据集大小影响
3. **字典序排列**：中序遍历可得到所有字符串的字典序排列
4. **支持前缀匹配**：天然支持前缀搜索和自动补全功能
5. **结构清晰**：每个节点包含指向子节点的指针数组和一个标记（表示是否为字符串结尾）

## 💻 代码实现

### 字典树节点定义
```java
class TrieNode {
    // 子节点数组，假设只处理小写字母
    private TrieNode[] children;
    // 标记该节点是否为字符串的结尾
    private boolean isEndOfWord;

    public TrieNode() {
        children = new TrieNode[26]; // 26个小写英文字母
        isEndOfWord = false;
    }

    public TrieNode[] getChildren() {
        return children;
    }

    public boolean isEndOfWord() {
        return isEndOfWord;
    }

    public void setEndOfWord(boolean endOfWord) {
        isEndOfWord = endOfWord;
    }
}
```

### 字典树实现
```java
public class Trie {
    private TrieNode root;

    public Trie() {
        root = new TrieNode();
    }

    /**
     * 插入字符串到字典树
     */
    public void insert(String word) {
        TrieNode current = root;
        for (int i = 0; i < word.length(); i++) {
            char ch = word.charAt(i);
            int index = ch - 'a';
            if (current.getChildren()[index] == null) {
                current.getChildren()[index] = new TrieNode();
            }
            current = current.getChildren()[index];
        }
        current.setEndOfWord(true);
    }

    /**
     * 查找字符串是否存在于字典树
     */
    public boolean search(String word) {
        TrieNode current = root;
        for (int i = 0; i < word.length(); i++) {
            char ch = word.charAt(i);
            int index = ch - 'a';
            if (current.getChildren()[index] == null) {
                return false; // 字符串不存在
            }
            current = current.getChildren()[index];
        }
        return current.isEndOfWord();
    }

    /**
     * 检查是否有以指定前缀开头的字符串
     */
    public boolean startsWith(String prefix) {
        TrieNode current = root;
        for (int i = 0; i < prefix.length(); i++) {
            char ch = prefix.charAt(i);
            int index = ch - 'a';
            if (current.getChildren()[index] == null) {
                return false;
            }
            current = current.getChildren()[index];
        }
        return true;
    }

    /**
     * 删除字符串（递归实现）
     */
    public boolean delete(String word) {
        return delete(root, word, 0);
    }

    private boolean delete(TrieNode current, String word, int index) {
        // 基本情况：到达单词末尾
        if (index == word.length()) {
            // 如果不是单词结尾，无法删除
            if (!current.isEndOfWord()) {
                return false;
            }
            // 标记为不是单词结尾
            current.setEndOfWord(false);
            // 如果没有子节点，可以删除该节点
            return hasNoChildren(current);
        }

        char ch = word.charAt(index);
        int childrenIndex = ch - 'a';
        TrieNode child = current.getChildren()[childrenIndex];
        if (child == null) {
            return false; // 单词不存在
        }

        // 递归删除
        boolean shouldDeleteChild = delete(child, word, index + 1);

        // 如果应该删除子节点
        if (shouldDeleteChild) {
            current.getChildren()[childrenIndex] = null;
            // 如果当前节点不是单词结尾且没有其他子节点，则可以删除
            return !current.isEndOfWord() && hasNoChildren(current);
        }

        return false;
    }

    // 检查节点是否没有子节点
    private boolean hasNoChildren(TrieNode node) {
        for (TrieNode child : node.getChildren()) {
            if (child != null) {
                return false;
            }
        }
        return true;
    }
}
```

### 字典树应用：自动补全功能
```java
import java.util.ArrayList;
import java.util.List;

public class AutocompleteSystem {
    private Trie trie;
    private StringBuilder prefix;

    public AutocompleteSystem() {
        trie = new Trie();
        prefix = new StringBuilder();
    }

    /**
     * 根据前缀获取所有匹配的单词
     */
    public List<String> getSuggestions(String prefix) {
        List<String> result = new ArrayList<>();
        TrieNode current = trie.getRoot();

        // 先到达前缀的最后一个节点
        for (int i = 0; i < prefix.length(); i++) {
            char ch = prefix.charAt(i);
            int index = ch - 'a';
            if (current.getChildren()[index] == null) {
                return result; // 没有匹配的单词
            }
            current = current.getChildren()[index];
        }

        // 从当前节点开始深度优先搜索，收集所有单词
        collectWords(current, new StringBuilder(prefix), result);
        return result;
    }

    private void collectWords(TrieNode node, StringBuilder currentWord, List<String> result) {
        if (node.isEndOfWord()) {
            result.add(currentWord.toString());
        }

        for (char c = 'a'; c <= 'z'; c++) {
            int index = c - 'a';
            if (node.getChildren()[index] != null) {
                currentWord.append(c);
                collectWords(node.getChildren()[index], currentWord, result);
                currentWord.deleteCharAt(currentWord.length() - 1); // 回溯
            }
        }
    }
}
```

## 📊 复杂度分析

| 操作 | 时间复杂度 | 空间复杂度 | 说明 |
|------|------------|------------|------|
| 插入 | O(L) | O(L) | L是字符串长度，最坏情况下需要创建L个新节点 |
| 查找 | O(L) | O(1) | 只需遍历字符串长度的路径 |
| 删除 | O(L) | O(1) | 需要遍历字符串并可能回溯删除节点 |
| 前缀匹配 | O(P) | O(N) | P是前缀长度，N是匹配的单词数量 |

## 🔍 应用场景

1. **搜索引擎自动补全**：如Google搜索时的关键词提示功能
2. **拼写检查**：如Word文档的拼写错误提示
3. **IP路由表**：用于快速查找路由路径
4. **字符串排序**：利用字典树的中序遍历实现字符串排序
5. **单词游戏**：如Scrabble中的单词验证
6. **DNA序列分析**：生物信息学中用于存储和分析DNA序列
7. **编译器设计**：用于词法分析和符号表管理

## ⚠️ 注意事项

1. **字符集选择**：根据实际需求选择合适的字符集（如ASCII、Unicode），过大会浪费空间，过小则功能受限
2. **内存消耗**：当字符串较短或公共前缀较少时，字典树可能比哈希表占用更多内存
3. **删除操作复杂**：删除操作需要递归回溯，实现较为复杂
4. **不适合短字符串**：对于极短字符串，哈希表可能更高效
5. **多语言支持**：处理多语言字符时需要特殊设计节点结构
6. **平衡问题**：某些情况下可能出现深度不平衡的树，影响性能

## 🎓 最佳实践

1. **选择合适的节点实现**：根据字符集大小选择数组或哈希表存储子节点
   - 小字符集（如英文26字母）：数组实现效率更高
   - 大字符集（如Unicode）：哈希表实现更节省空间

2. **结合其他数据结构优化**：
   - 与优先级队列结合实现带权重的自动补全
   - 与哈希表结合处理频繁访问的热门词汇

3. **内存优化技巧**：
   - 使用压缩字典树（Compact Trie）减少节点数量
   - 对于静态数据，考虑使用双数组字典树（Double-Array Trie）

4. **性能调优**：
   - 预分配节点数组提升插入性能
   - 实现节点池减少频繁内存分配开销

5. **应用特定优化**：
   - 对于前缀查询密集型应用，可缓存热门前缀结果
   - 实现模糊匹配时，限制编辑距离以保证性能

---

> **已完成**：本文档已完善，包含字典树的核心概念、Java实现代码、复杂度分析、应用场景和最佳实践，可作为字典树学习的完整参考资料
# 二叉搜索树

二叉搜索树（Binary Search Tree，简称BST）是一种特殊的二叉树数据结构，它满足左子树所有节点值小于根节点值，右子树所有节点值大于根节点值的特性。这种结构使得查找、插入和删除操作可以高效进行，平均时间复杂度为O(log n)。

---

## 📋 基本信息

| 项目 | 说明 |
|------|------|
| 数据结构类型 | 有序二叉树 |
| 存储结构 | 链式存储 |
| 核心操作 | 插入、删除、查找、遍历 |
| 时间复杂度 | 平均：O(log n)，最坏：O(n) |
| 空间复杂度 | O(n) |
| 特点 | 左子树所有节点值 < 根节点值 < 右子树所有节点值，中序遍历结果为有序序列 |

## 🎯 核心特性

1. **有序性**：对于任意节点，其左子树所有节点值小于该节点值，右子树所有节点值大于该节点值
2. **中序遍历有序**：中序遍历二叉搜索树可得到一个递增的有序序列
3. **唯一查找路径**：从根节点到任意节点有且仅有一条路径
4. **动态平衡性**：普通BST不保证平衡性，可能退化为链表
5. **无重复节点**：标准BST通常不允许重复节点（或通过特殊方式处理重复值）

## 💻 代码实现

### 1. 二叉搜索树节点定义
```java
public class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;
    TreeNode() {}
    TreeNode(int val) { this.val = val; }
    TreeNode(int val, TreeNode left, TreeNode right) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}
```

### 2. 基本操作实现
```java
public class BinarySearchTree {
    private TreeNode root;

    // 插入节点
    public void insert(int val) {
        root = insertRecursive(root, val);
    }

    private TreeNode insertRecursive(TreeNode node, int val) {
        // 如果当前节点为空，创建新节点
        if (node == null) {
            return new TreeNode(val);
        }

        // 否则递归向下查找插入位置
        if (val < node.val) {
            node.left = insertRecursive(node.left, val);
        } else if (val > node.val) {
            node.right = insertRecursive(node.right, val);
        }
        // 不处理重复值
        return node;
    }

    // 查找节点
    public boolean search(int val) {
        return searchRecursive(root, val);
    }

    private boolean searchRecursive(TreeNode node, int val) {
        // 节点为空或找到值
        if (node == null) return false;
        if (val == node.val) return true;

        // 递归查找左子树或右子树
        return val < node.val ? 
               searchRecursive(node.left, val) : 
               searchRecursive(node.right, val);
    }

    // 删除节点
    public void delete(int val) {
        root = deleteRecursive(root, val);
    }

    private TreeNode deleteRecursive(TreeNode node, int val) {
        // 节点为空，返回null
        if (node == null) return null;

        // 递归查找要删除的节点
        if (val < node.val) {
            node.left = deleteRecursive(node.left, val);
        } else if (val > node.val) {
            node.right = deleteRecursive(node.right, val);
        } else {
            // 找到要删除的节点
            // 情况1：叶子节点
            if (node.left == null && node.right == null) {
                return null;
            }
            // 情况2：只有一个子节点
            else if (node.left == null) {
                return node.right;
            } else if (node.right == null) {
                return node.left;
            }
            // 情况3：有两个子节点
            else {
                // 找到右子树中的最小值节点
                int minValue = findMinValue(node.right);
                // 用最小值替换当前节点
                node.val = minValue;
                // 删除那个最小值节点
                node.right = deleteRecursive(node.right, minValue);
            }
        }
        return node;
    }

    // 查找最小值节点
    private int findMinValue(TreeNode node) {
        return node.left == null ? node.val : findMinValue(node.left);
    }

    // 查找最大值节点
    private int findMaxValue(TreeNode node) {
        return node.right == null ? node.val : findMaxValue(node.right);
    }

    // 中序遍历（升序）
    public void inorderTraversal() {
        inorderRecursive(root);
        System.out.println();
    }

    private void inorderRecursive(TreeNode node) {
        if (node != null) {
            inorderRecursive(node.left);
            System.out.print(node.val + " ");
            inorderRecursive(node.right);
        }
    }

    // 获取树的高度
    public int getHeight() {
        return calculateHeight(root);
    }

    private int calculateHeight(TreeNode node) {
        if (node == null) return 0;
        return Math.max(calculateHeight(node.left), calculateHeight(node.right)) + 1;
    }
}
```

### 3. 迭代式查找与插入
```java
// 迭代式查找
public boolean iterativeSearch(int val) {
    TreeNode current = root;
    while (current != null) {
        if (val == current.val) return true;
        current = val < current.val ? current.left : current.right;
    }
    return false;
}

// 迭代式插入
public void iterativeInsert(int val) {
    if (root == null) {
        root = new TreeNode(val);
        return;
    }

    TreeNode current = root;
    TreeNode parent = null;

    while (current != null) {
        parent = current;
        if (val < current.val) {
            current = current.left;
        } else if (val > current.val) {
            current = current.right;
        } else {
            // 重复值，不插入
            return;
        }
    }

    // 插入新节点
    if (val < parent.val) {
        parent.left = new TreeNode(val);
    } else {
        parent.right = new TreeNode(val);
    }
}
```

## 📊 复杂度分析

| 操作 | 平均时间复杂度 | 最坏时间复杂度 | 空间复杂度 |
|------|--------------|--------------|------------|
| 插入 | O(log n)     | O(n)         | O(log n)   |
| 删除 | O(log n)     | O(n)         | O(log n)   |
| 查找 | O(log n)     | O(n)         | O(log n)   |
| 遍历 | O(n)         | O(n)         | O(n)       |
| 获取高度 | O(log n)    | O(n)         | O(log n)   |

> 注：
> - 平均情况基于平衡的二叉搜索树
> - 最坏情况发生在树退化为链表时（如插入有序数据）
> - 空间复杂度主要指递归调用栈的空间

## 🔍 应用场景

1. **动态查找表**：需要频繁插入、删除和查找的场景
2. **数据库索引**：早期数据库使用BST作为索引结构（现在多使用B+树）
3. **有序数据维护**：需要保持数据有序并支持高效操作的场景
4. **表达式解析**：抽象语法树的构建和遍历
5. **范围查询**：查找一定范围内的数据（如查找50-100之间的所有值）
6. **优先队列实现**：某些优先队列实现基于二叉搜索树
7. **路由表**：网络路由算法中使用二叉搜索树管理路由信息

## ⚠️ 注意事项

1. **平衡性问题**：普通BST在插入有序数据时会退化为链表，导致性能下降
2. **重复值处理**：标准BST不支持重复值，需特殊处理（如允许重复值放在右子树）
3. **递归深度**：递归实现可能导致栈溢出，深度较大时建议使用迭代方式
4. **删除操作复杂性**：删除有两个子节点的节点时需要找到中序后继或前驱
5. **线程安全**：基本实现不是线程安全的，多线程环境需额外同步
6. **内存开销**：每个节点需要额外空间存储左右指针
7. **不适合频繁范围查询**：范围查询效率不如B+树等结构

## 🎓 最佳实践

1. **处理平衡问题**：
   - 对于频繁插入删除的场景，考虑使用平衡二叉搜索树（如AVL树、红黑树）
   - 或使用自平衡数据结构如TreeSet/TreeMap（Java）

2. **优化查找性能**：
   - 对静态数据，可预先构建最优二叉搜索树
   - 对动态数据，考虑使用跳表等替代结构

3. **实现技巧**：
   - 优先使用迭代实现而非递归，避免栈溢出
   - 添加父指针可简化某些操作，但增加内存开销
   - 实现时考虑泛型以支持多种数据类型

4. **重复值处理策略**：
   - 方法1：不允许重复值，插入重复值时忽略或抛出异常
   - 方法2：每个节点存储计数值，相同值时增加计数
   - 方法3：将重复值放在右子树（或左子树）

5. **扩展功能**：
   - 添加范围查询方法（查找[min, max]区间的所有值）
   - 实现Kth最小/最大元素查找
   - 添加前驱和后继节点查找

### 代码示例：范围查询实现
```java
// 查找指定范围内的所有值
public List<Integer> rangeQuery(int min, int max) {
    List<Integer> result = new ArrayList<>();
    rangeQueryRecursive(root, min, max, result);
    return result;
}

private void rangeQueryRecursive(TreeNode node, int min, int max, List<Integer> result) {
    if (node == null) return;

    // 如果当前节点值大于min，搜索左子树
    if (node.val > min) {
        rangeQueryRecursive(node.left, min, max, result);
    }

    // 如果当前节点值在范围内，添加到结果
    if (node.val >= min && node.val <= max) {
        result.add(node.val);
    }

    // 如果当前节点值小于max，搜索右子树
    if (node.val < max) {
        rangeQueryRecursive(node.right, min, max, result);
    }
}
```

---

> **完成状态**：本文档已完善二叉搜索树的基本概念、Java实现代码（包括节点定义、插入、删除、查找等核心操作）、复杂度分析、应用场景、注意事项及最佳实践，包含迭代与递归两种实现方式，可作为二叉搜索树数据结构的完整学习参考。
# 并查集

> 并查集（Union-Find），也称为 disjoint-set 数据结构，是一种用于管理元素分组的数据结构。它支持高效的查找（Find）和合并（Union）操作，主要用于解决元素之间的动态连通性问题。并查集通过森林（多个树）来表示元素集合，每个树代表一个集合，树的根节点代表集合的标识。

---

## 📋 基本信息

| 属性 | 说明 |
|------|------|
| 数据结构类型 | 集合型数据结构 |
| 存储结构 | 数组 |
| 核心操作 | 查找（Find）、合并（Union）、初始化（Init） |
| 时间复杂度 | 查找: 几乎O(1)，合并: 几乎O(1) |
| 空间复杂度 | O(n) | n为元素数量
| 特点 | 路径压缩和按秩合并优化，高效处理动态连通性问题 |

## 🎯 核心特性

1. **高效合并**：通过按秩（或大小）合并策略，保持树的深度较小
2. **路径压缩**：查找操作时压缩路径，使后续操作更快
3. **森林表示**：每个集合用一棵树表示，根节点唯一标识集合
4. **无交集**：集合之间没有交集，每个元素仅属于一个集合
5. **动态连通性**：能够实时跟踪和修改元素间的连通关系
6. **简洁实现**：使用数组实现，结构简单，易于理解和实现
7. **几乎常数时间**：经过优化的并查集操作时间复杂度接近O(1)

## 💻 代码实现

### 基本实现（路径压缩 + 按秩合并）
```java
public class UnionFind {
    private int[] parent; // 父节点数组
    private int[] rank;   // 秩数组，用于按秩合并
    private int count;    // 集合数量

    // 初始化并查集
    public UnionFind(int size) {
        if (size <= 0) {
            throw new IllegalArgumentException("大小必须为正数");
        }

        parent = new int[size];
        rank = new int[size];
        count = size;

        // 初始时每个元素自成一个集合
        for (int i = 0; i < size; i++) {
            parent[i] = i;  // 父节点指向自身
            rank[i] = 1;    // 每个集合的秩初始化为1
        }
    }

    // 查找元素所属集合的根节点（带路径压缩）
    public int find(int x) {
        // 非递归版本路径压缩（迭代）
        if (parent[x] != x) {
            int root = x;
            // 找到根节点
            while (parent[root] != root) {
                root = parent[root];
            }
            // 路径压缩
            while (parent[x] != root) {
                int next = parent[x];
                parent[x] = root;
                x = next;
            }
        }
        return parent[x];
    }

    // 合并两个元素所在的集合（按秩合并）
    public void union(int x, int y) {
        int rootX = find(x);
        int rootY = find(y);

        // 如果已经属于同一个集合，无需合并
        if (rootX == rootY) {
            return;
        }

        // 按秩合并：将秩较小的树合并到秩较大的树的根节点下
        if (rank[rootX] < rank[rootY]) {
            parent[rootX] = rootY;
        } else if (rank[rootX] > rank[rootY]) {
            parent[rootY] = rootX;
        } else {
            // 秩相等时，合并后秩加1
            parent[rootY] = rootX;
            rank[rootX]++;
        }
        count--;
    }

    // 检查两个元素是否属于同一个集合
    public boolean isConnected(int x, int y) {
        return find(x) == find(y);
    }

    // 获取集合数量
    public int getCount() {
        return count;
    }
}
```

### 按大小合并实现
```java
public class UnionFindBySize {
    private int[] parent; // 父节点数组
    private int[] size;   // 大小数组，记录每个集合的大小
    private int count;    // 集合数量

    // 初始化并查集
    public UnionFindBySize(int size) {
        if (size <= 0) {
            throw new IllegalArgumentException("大小必须为正数");
        }

        parent = new int[size];
        this.size = new int[size];
        count = size;

        // 初始时每个元素自成一个集合
        for (int i = 0; i < size; i++) {
            parent[i] = i;   // 父节点指向自身
            this.size[i] = 1; // 每个集合的大小初始化为1
        }
    }

    // 查找元素所属集合的根节点（带路径压缩）
    public int find(int x) {
        if (parent[x] != x) {
            parent[x] = find(parent[x]); // 路径压缩
        }
        return parent[x];
    }

    // 合并两个元素所在的集合（按大小合并）
    public void union(int x, int y) {
        int rootX = find(x);
        int rootY = find(y);

        // 如果已经属于同一个集合，无需合并
        if (rootX == rootY) {
            return;
        }

        // 按大小合并：将较小的集合合并到较大的集合中
        if (size[rootX] < size[rootY]) {
            parent[rootX] = rootY;
            size[rootY] += size[rootX];
        } else {
            parent[rootY] = rootX;
            size[rootX] += size[rootY];
        }
        count--;
    }

    // 检查两个元素是否属于同一个集合
    public boolean isConnected(int x, int y) {
        return find(x) == find(y);
    }

    // 获取集合数量
    public int getCount() {
        return count;
    }

    // 获取集合大小
    public int getSetSize(int x) {
        int root = find(x);
        return size[root];
    }
}
```

### 并查集应用：解决岛屿数量问题
```java
public class NumberOfIslands {
    public int numIslands(char[][] grid) {
        if (grid == null || grid.length == 0) {
            return 0;
        }

        int rows = grid.length;
        int cols = grid[0].length;
        UnionFind uf = new UnionFind(rows * cols);
        int waterCount = 0;

        // 初始化并查集
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                if (grid[i][j] == '0') {
                    waterCount++;
                } else {
                    // 当前是陆地，将其与右方和下方的陆地合并
                    if (i + 1 < rows && grid[i+1][j] == '1') {
                        uf.union(getIndex(i, j, cols), getIndex(i+1, j, cols));
                    }
                    if (j + 1 < cols && grid[i][j+1] == '1') {
                        uf.union(getIndex(i, j, cols), getIndex(i, j+1, cols));
                    }
                }
            }
        }

        // 岛屿数量 = 总集合数 - 水域数量
        return uf.getCount() - waterCount;
    }

    // 将二维坐标转换为一维索引
    private int getIndex(int i, int j, int cols) {
        return i * cols + j;
    }
}
```

## 📊 复杂度分析

| 操作 | 时间复杂度 | 空间复杂度 | 说明 |
|------|------------|------------|------|
| 初始化 | O(n) | O(n) | 初始化父数组和秩/大小数组 |
| 查找(未优化) | O(n) | O(1) | 最坏情况，树退化为链表 |
| 查找(路径压缩) | O(α(n)) | O(1) | α是反阿克曼函数，近乎常数 |
| 合并(未优化) | O(n) | O(1) | 最坏情况 |
| 合并(按秩/大小) | O(α(n)) | O(1) | 几乎常数时间 |
| 判连通 | O(α(n)) | O(1) | 两次查找操作 |

> **反阿克曼函数α(n)**：是一个增长极其缓慢的函数，对于实际应用中的n值（如n≤10^600），α(n)都小于5，因此可以认为并查集的操作是常数时间的。

## 🔍 应用场景

1. **连通分量检测**：如判断无向图中的连通分量数量
2. **最小生成树算法**：Kruskal算法中用于检测边是否形成环
3. **动态连通性问题**：网络连接问题、电路连接判断
4. **元素分组管理**：如朋友圈问题、分类问题
5. **图像处理**：连通区域标记和分析
6. **编译器设计**：符号表管理和类型检查
7. **机器学习**：聚类算法中的数据分组
8. **游戏开发**：碰撞检测、区域划分
9. **血缘关系验证**：判断两个人是否有共同祖先
10. **求解方程等价类**：如变量替换后的等价方程判断

## ⚠️ 注意事项

1. **初始化大小**：必须正确设置初始大小，通常为元素总数
2. **索引映射**：非整数元素需要先映射为整数索引
3. **路径压缩实现**：递归实现简洁但可能栈溢出，大规模数据建议用迭代实现
4. **合并策略选择**：按秩合并和按大小合并效率相近，选择一种即可
5. **重复合并**：多次合并同一对元素不会影响结果，但会浪费时间
6. **删除操作**：标准并查集不支持高效的元素删除操作
7. **线程安全**：基本实现不是线程安全的，多线程环境需加锁
8. **集合标识**：根节点可能会变化，不要缓存根节点结果
9. **内存使用**：对于大规模数据，需考虑数组的内存占用
10. **初始化顺序**：确保在使用前完成初始化

## 🎓 最佳实践

1. **同时使用路径压缩和按秩/大小合并**：这是并查集的标准优化方式，能获得几乎常数的时间复杂度
2. **迭代式路径压缩**：对于数据规模大的场景，优先使用迭代式路径压缩避免栈溢出
3. **预分配足够空间**：初始化时分配足够大的数组，避免动态扩容
4. **封装常用操作**：将并查集封装为工具类，提供清晰的API
5. **处理大规模数据**：对于超大规模数据，考虑使用稀疏表示或分布式并查集

---

> **已完成**：本文档已完善，包含并查集的核心概念、Java实现代码（路径压缩和按秩/大小合并）、复杂度分析（含反阿克曼函数说明）、应用场景和最佳实践，可作为并查集学习的完整参考资料
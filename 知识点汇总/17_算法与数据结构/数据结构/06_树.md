# 树

树是一种重要的非线性数据结构，它由n(n≥0)个有限节点组成一个具有层次关系的集合。把它叫做"树"是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。

---

## 📋 基本信息

| 项目 | 说明 |
|------|------|
| 数据结构类型 | 非线性结构 |
| 存储结构 | 链式存储（为主） |
| 核心操作 | 创建、插入、删除、遍历、查找 |
| 时间复杂度 | 插入/删除/查找：O(log n) ~ O(n)（取决于树的类型和平衡性） |
| 空间复杂度 | O(n) |
| 特点 | 每个节点有零个或多个子节点；没有父节点的节点称为根节点；每一个非根节点有且只有一个父节点 |

## 🎯 核心特性

1. **层次结构**：树具有明显的层次关系，根在最顶层，叶子在最底层
2. **唯一路径**：任意两个节点之间有且仅有一条路径
3. **无环结构**：树中不存在回路
4. **递归定义**：树的每个子树仍然是树
5. **一对多关系**：一个父节点可以有多个子节点，但每个子节点只有一个父节点

## 💻 代码实现

### 基本树节点定义

```java
public class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;
    TreeNode() {}
    TreeNode(int val) { this.val = val; }
    TreeNode(int val, TreeNode left, TreeNode right) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}
```

### 二叉树的遍历

```java
import java.util.*;

public class TreeTraversal {
    // 前序遍历 - 递归
    public void preorderRecursive(TreeNode root) {
        if (root == null) return;
        System.out.print(root.val + " ");
        preorderRecursive(root.left);
        preorderRecursive(root.right);
    }

    // 中序遍历 - 递归
    public void inorderRecursive(TreeNode root) {
        if (root == null) return;
        inorderRecursive(root.left);
        System.out.print(root.val + " ");
        inorderRecursive(root.right);
    }

    // 后序遍历 - 递归
    public void postorderRecursive(TreeNode root) {
        if (root == null) return;
        postorderRecursive(root.left);
        postorderRecursive(root.right);
        System.out.print(root.val + " ");
    }

    // 层序遍历
    public void levelOrder(TreeNode root) {
        if (root == null) return;
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        while (!queue.isEmpty()) {
            TreeNode node = queue.poll();
            System.out.print(node.val + " ");
            if (node.left != null) queue.offer(node.left);
            if (node.right != null) queue.offer(node.right);
        }
    }
}
```

### 二叉搜索树实现

```java
public class BinarySearchTree {
    private TreeNode root;

    // 插入节点
    public void insert(int val) {
        root = insertRecursive(root, val);
    }

    private TreeNode insertRecursive(TreeNode root, int val) {
        if (root == null) {
            return new TreeNode(val);
        }

        if (val < root.val) {
            root.left = insertRecursive(root.left, val);
        } else if (val > root.val) {
            root.right = insertRecursive(root.right, val);
        }

        return root;
    }

    // 查找节点
    public boolean search(int val) {
        return searchRecursive(root, val);
    }

    private boolean searchRecursive(TreeNode root, int val) {
        if (root == null) return false;
        if (val == root.val) return true;
        return val < root.val ? searchRecursive(root.left, val) : searchRecursive(root.right, val);
    }

    // 删除节点
    public void delete(int val) {
        root = deleteRecursive(root, val);
    }

    private TreeNode deleteRecursive(TreeNode root, int val) {
        if (root == null) return null;

        if (val < root.val) {
            root.left = deleteRecursive(root.left, val);
        } else if (val > root.val) {
            root.right = deleteRecursive(root.right, val);
        } else {
            // 找到要删除的节点
            // 情况1: 叶子节点
            if (root.left == null && root.right == null) {
                return null;
            }
            // 情况2: 只有一个子节点
            else if (root.left == null) {
                return root.right;
            } else if (root.right == null) {
                return root.left;
            }
            // 情况3: 有两个子节点
            else {
                // 找到右子树中的最小值
                int minValue = findMinValue(root.right);
                root.val = minValue;
                // 删除那个最小值节点
                root.right = deleteRecursive(root.right, minValue);
            }
        }
        return root;
    }

    private int findMinValue(TreeNode node) {
        return node.left == null ? node.val : findMinValue(node.left);
    }
}
```

## 📊 复杂度分析

| 操作 | 平均时间复杂度 | 最坏时间复杂度 | 空间复杂度 |
|------|--------------|--------------|------------|
| 插入 | O(log n)     | O(n)         | O(log n)   |
| 删除 | O(log n)     | O(n)         | O(log n)   |
| 查找 | O(log n)     | O(n)         | O(log n)   |
| 遍历 | O(n)         | O(n)         | O(n)       |

> 注：平均情况基于平衡二叉树，最坏情况发生在树退化为链表时

## 🔍 应用场景

1. **数据库索引**：许多数据库使用B树或B+树作为索引结构
2. **文件系统**：操作系统中的文件系统通常采用树结构进行组织
3. **表达式解析**：编译器使用抽象语法树(AST)解析表达式
4. **路由算法**：网络路由算法使用树结构
5. **决策分析**：决策树用于机器学习和数据挖掘
6. **层级数据展示**：如组织结构图、目录结构等

## ⚠️ 注意事项

1. **树的平衡性**：不平衡的树会导致性能下降，考虑使用平衡树结构（如AVL树、红黑树）
2. **遍历顺序**：不同的遍历顺序（前序、中序、后序、层序）适用于不同场景
3. **递归深度**：递归实现可能导致栈溢出，对于大型树考虑使用迭代方式
4. **内存占用**：树结构的内存占用通常比数组和链表高
5. **删除操作**：树的删除操作相对复杂，需要处理多种情况

## 🎓 最佳实践

1. **选择合适的树类型**：根据应用场景选择最合适的树结构
   - 有序数据：二叉搜索树
   - 频繁插入删除：平衡树（如红黑树）
   - 大数据量存储：B树/B+树
   - 优先级操作：堆

2. **考虑迭代实现**：对于深度较大的树，优先使用迭代而非递归

3. **缓存常用节点**：对于频繁访问的节点，可以考虑添加缓存机制

4. **实现时考虑泛型**：使树结构可以存储任意类型的数据

5. **添加必要的辅助方法**：如获取树的高度、节点数量、判断是否为空等

---

已完成：树数据结构文档的详细内容补充，包括基本概念、Java实现代码、复杂度分析、应用场景等内容。
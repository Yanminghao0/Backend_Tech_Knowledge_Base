# çº¿æ®µæ ‘

> çº¿æ®µæ ‘ï¼ˆSegment Treeï¼‰æ˜¯ä¸€ç§é«˜æ•ˆå¤„ç†åŒºé—´æŸ¥è¯¢å’ŒåŒºé—´æ›´æ–°çš„æ•°æ®ç»“æ„ã€‚å®ƒå°†ä¸€ä¸ªåŒºé—´åˆ’åˆ†ä¸ºè‹¥å¹²ä¸ªå­åŒºé—´ï¼Œæ¯ä¸ªèŠ‚ç‚¹ä»£è¡¨ä¸€ä¸ªå­åŒºé—´ï¼Œé€šè¿‡æ ‘çŠ¶ç»“æ„å­˜å‚¨åŒºé—´ä¿¡æ¯ï¼Œæ”¯æŒåœ¨O(log n)æ—¶é—´å†…å®ŒæˆåŒºé—´æŸ¥è¯¢å’Œå•ç‚¹/åŒºé—´æ›´æ–°æ“ä½œã€‚çº¿æ®µæ ‘å¹¿æ³›åº”ç”¨äºèŒƒå›´æœ€å€¼æŸ¥è¯¢ã€åŒºé—´å’Œè®¡ç®—ã€åŒºé—´è¦†ç›–ç­‰åœºæ™¯ã€‚

---

## ğŸ“‹ åŸºæœ¬ä¿¡æ¯

| å±æ€§ | è¯´æ˜ |
|------|------|
| æ•°æ®ç»“æ„ç±»å‹ | æ ‘å½¢æ•°æ®ç»“æ„ |
| å­˜å‚¨ç»“æ„ | æ•°ç»„æˆ–é“¾è¡¨ |
| æ ¸å¿ƒæ“ä½œ | æ„å»ºï¼ˆBuildï¼‰ã€æŸ¥è¯¢ï¼ˆQueryï¼‰ã€æ›´æ–°ï¼ˆUpdateï¼‰ |
| æ—¶é—´å¤æ‚åº¦ | æ„å»º: O(n)ï¼ŒæŸ¥è¯¢: O(log n)ï¼Œæ›´æ–°: O(log n) |
| ç©ºé—´å¤æ‚åº¦ | O(4n) | é€šå¸¸éœ€è¦4å€äºåŸæ•°ç»„å¤§å°çš„ç©ºé—´ |
| ç‰¹ç‚¹ | é«˜æ•ˆå¤„ç†åŒºé—´é—®é¢˜ï¼Œæ”¯æŒå¤šç§åŒºé—´æ“ä½œï¼Œå®ç°çµæ´» |

## ğŸ¯ æ ¸å¿ƒç‰¹æ€§

1. **åŒºé—´è¦†ç›–**ï¼šæ¯ä¸ªèŠ‚ç‚¹ä»£è¡¨ä¸€ä¸ªåŒºé—´ï¼Œæ ¹èŠ‚ç‚¹ä»£è¡¨æ•´ä¸ªåŒºé—´ï¼Œå¶å­èŠ‚ç‚¹ä»£è¡¨å•ä¸ªå…ƒç´ 
2. **äºŒå‰ç»“æ„**ï¼šé€šå¸¸ä¸ºå®Œå…¨äºŒå‰æ ‘ï¼Œå·¦å­èŠ‚ç‚¹è¦†ç›–å·¦åŠåŒºé—´ï¼Œå³å­èŠ‚ç‚¹è¦†ç›–å³åŠåŒºé—´
3. **ä¿¡æ¯èšåˆ**ï¼šæ¯ä¸ªèŠ‚ç‚¹å­˜å‚¨åŒºé—´çš„èšåˆä¿¡æ¯ï¼ˆå¦‚å’Œã€æœ€å€¼ã€æ•°é‡ç­‰ï¼‰
4. **é«˜æ•ˆæŸ¥è¯¢**ï¼šæ”¯æŒåŒºé—´æŸ¥è¯¢ï¼Œæ—¶é—´å¤æ‚åº¦ä¸ºO(log n)
5. **çµæ´»æ›´æ–°**ï¼šæ”¯æŒå•ç‚¹æ›´æ–°å’ŒåŒºé—´æ›´æ–°ï¼Œæ—¶é—´å¤æ‚åº¦ä¸ºO(log n)
6. **åŠ¨æ€ç»´æŠ¤**ï¼šèƒ½å¤ŸåŠ¨æ€ç»´æŠ¤åŒºé—´ä¿¡æ¯ï¼Œé€‚åº”æ•°æ®å˜åŒ–
7. **ç©ºé—´å†—ä½™**ï¼šä¸ºä¿è¯ç»“æ„å®Œæ•´æ€§ï¼Œé€šå¸¸éœ€è¦4å€äºåŸæ•°ç»„çš„å­˜å‚¨ç©ºé—´

## ğŸ’» ä»£ç å®ç°

### åŸºç¡€çº¿æ®µæ ‘ï¼ˆåŒºé—´æ±‚å’Œä¸å•ç‚¹æ›´æ–°ï¼‰
```java
public class SegmentTree {
    private int[] tree;  // çº¿æ®µæ ‘æ•°ç»„
    private int[] data;  // åŸå§‹æ•°æ®æ•°ç»„
    private int n;       // æ•°æ®é•¿åº¦

    // æ„é€ å‡½æ•°ï¼Œåˆå§‹åŒ–çº¿æ®µæ ‘
    public SegmentTree(int[] nums) {
        if (nums == null || nums.length == 0) {
            return;
        }
        n = nums.length;
        data = Arrays.copyOf(nums, n);
        tree = new int[4 * n];  // å¼€è¾Ÿ4å€ç©ºé—´
        build(0, 0, n - 1);     // æ„å»ºçº¿æ®µæ ‘
    }

    // æ„å»ºçº¿æ®µæ ‘
    private void build(int node, int start, int end) {
        if (start == end) {
            // å¶å­èŠ‚ç‚¹ï¼Œç›´æ¥èµ‹å€¼
            tree[node] = data[start];
            return;
        }

        int mid = (start + end) / 2;
        int leftChild = 2 * node + 1;  // å·¦å­èŠ‚ç‚¹ç´¢å¼•
        int rightChild = 2 * node + 2; // å³å­èŠ‚ç‚¹ç´¢å¼•

        // é€’å½’æ„å»ºå·¦å³å­æ ‘
        build(leftChild, start, mid);
        build(rightChild, mid + 1, end);

        // å½“å‰èŠ‚ç‚¹å€¼ä¸ºå·¦å³å­èŠ‚ç‚¹ä¹‹å’Œ
        tree[node] = tree[leftChild] + tree[rightChild];
    }

    // å•ç‚¹æ›´æ–°
    public void update(int index, int val) {
        if (index < 0 || index >= n) {
            throw new IllegalArgumentException("ç´¢å¼•è¶Šç•Œ");
        }
        data[index] = val;                // æ›´æ–°åŸå§‹æ•°æ®
        update(0, 0, n - 1, index, val);  // é€’å½’æ›´æ–°çº¿æ®µæ ‘
    }

    // é€’å½’æ›´æ–°çº¿æ®µæ ‘
    private void update(int node, int start, int end, int index, int val) {
        if (start == end) {
            // æ‰¾åˆ°å¶å­èŠ‚ç‚¹ï¼Œæ›´æ–°å€¼
            tree[node] = val;
            return;
        }

        int mid = (start + end) / 2;
        int leftChild = 2 * node + 1;
        int rightChild = 2 * node + 2;

        if (index <= mid) {
            // ç´¢å¼•åœ¨å·¦å­æ ‘ï¼Œæ›´æ–°å·¦å­æ ‘
            update(leftChild, start, mid, index, val);
        } else {
            // ç´¢å¼•åœ¨å³å­æ ‘ï¼Œæ›´æ–°å³å­æ ‘
            update(rightChild, mid + 1, end, index, val);
        }

        // æ›´æ–°å½“å‰èŠ‚ç‚¹å€¼
        tree[node] = tree[leftChild] + tree[rightChild];
    }

    // åŒºé—´æŸ¥è¯¢ï¼ˆæ±‚å’Œï¼‰
    public int query(int l, int r) {
        if (l < 0 || r >= n || l > r) {
            throw new IllegalArgumentException("æŸ¥è¯¢åŒºé—´æ— æ•ˆ");
        }
        return query(0, 0, n - 1, l, r);
    }

    // é€’å½’åŒºé—´æŸ¥è¯¢
    private int query(int node, int start, int end, int l, int r) {
        if (r < start || end < l) {
            // æŸ¥è¯¢åŒºé—´ä¸å½“å‰èŠ‚ç‚¹åŒºé—´æ— äº¤é›†ï¼Œè¿”å›0
            return 0;
        }

        if (l <= start && end <= r) {
            // æŸ¥è¯¢åŒºé—´å®Œå…¨è¦†ç›–å½“å‰èŠ‚ç‚¹åŒºé—´ï¼Œè¿”å›å½“å‰èŠ‚ç‚¹å€¼
            return tree[node];
        }

        // éƒ¨åˆ†äº¤é›†ï¼Œé€’å½’æŸ¥è¯¢å·¦å³å­æ ‘
        int mid = (start + end) / 2;
        int leftChild = 2 * node + 1;
        int rightChild = 2 * node + 2;

        int leftSum = query(leftChild, start, mid, l, r);
        int rightSum = query(rightChild, mid + 1, end, l, r);

        return leftSum + rightSum;
    }
}
```

### çº¿æ®µæ ‘ï¼ˆåŒºé—´æœ€å€¼æŸ¥è¯¢ï¼‰
```java
public class SegmentTreeForMax {
    private int[] tree;  // çº¿æ®µæ ‘æ•°ç»„
    private int[] data;  // åŸå§‹æ•°æ®æ•°ç»„
    private int n;       // æ•°æ®é•¿åº¦

    // æ„é€ å‡½æ•°ï¼Œåˆå§‹åŒ–çº¿æ®µæ ‘
    public SegmentTreeForMax(int[] nums) {
        if (nums == null || nums.length == 0) {
            return;
        }
        n = nums.length;
        data = Arrays.copyOf(nums, n);
        tree = new int[4 * n];  // å¼€è¾Ÿ4å€ç©ºé—´
        build(0, 0, n - 1);     // æ„å»ºçº¿æ®µæ ‘
    }

    // æ„å»ºçº¿æ®µæ ‘
    private void build(int node, int start, int end) {
        if (start == end) {
            tree[node] = data[start];
            return;
        }

        int mid = (start + end) / 2;
        int leftChild = 2 * node + 1;
        int rightChild = 2 * node + 2;

        build(leftChild, start, mid);
        build(rightChild, mid + 1, end);

        // å½“å‰èŠ‚ç‚¹å€¼ä¸ºå·¦å³å­èŠ‚ç‚¹çš„æœ€å¤§å€¼
        tree[node] = Math.max(tree[leftChild], tree[rightChild]);
    }

    // å•ç‚¹æ›´æ–°
    public void update(int index, int val) {
        if (index < 0 || index >= n) {
            throw new IllegalArgumentException("ç´¢å¼•è¶Šç•Œ");
        }
        data[index] = val;
        update(0, 0, n - 1, index, val);
    }

    // é€’å½’æ›´æ–°çº¿æ®µæ ‘
    private void update(int node, int start, int end, int index, int val) {
        if (start == end) {
            tree[node] = val;
            return;
        }

        int mid = (start + end) / 2;
        int leftChild = 2 * node + 1;
        int rightChild = 2 * node + 2;

        if (index <= mid) {
            update(leftChild, start, mid, index, val);
        } else {
            update(rightChild, mid + 1, end, index, val);
        }

        // æ›´æ–°å½“å‰èŠ‚ç‚¹ä¸ºå·¦å³å­èŠ‚ç‚¹çš„æœ€å¤§å€¼
        tree[node] = Math.max(tree[leftChild], tree[rightChild]);
    }

    // åŒºé—´æŸ¥è¯¢æœ€å¤§å€¼
    public int queryMax(int l, int r) {
        if (l < 0 || r >= n || l > r) {
            throw new IllegalArgumentException("æŸ¥è¯¢åŒºé—´æ— æ•ˆ");
        }
        return queryMax(0, 0, n - 1, l, r);
    }

    // é€’å½’åŒºé—´æŸ¥è¯¢æœ€å¤§å€¼
    private int queryMax(int node, int start, int end, int l, int r) {
        if (r < start || end < l) {
            return Integer.MIN_VALUE;  // æ— äº¤é›†ï¼Œè¿”å›è´Ÿæ— ç©·
        }

        if (l <= start && end <= r) {
            return tree[node];  // å®Œå…¨è¦†ç›–ï¼Œè¿”å›å½“å‰èŠ‚ç‚¹å€¼
        }

        int mid = (start + end) / 2;
        int leftChild = 2 * node + 1;
        int rightChild = 2 * node + 2;

        int leftMax = queryMax(leftChild, start, mid, l, r);
        int rightMax = queryMax(rightChild, mid + 1, end, l, r);

        return Math.max(leftMax, rightMax);
    }
}
```

### æ‡’æ ‡è®°çº¿æ®µæ ‘ï¼ˆåŒºé—´æ›´æ–°ï¼‰
```java
public class LazySegmentTree {
    private int[] tree;   // çº¿æ®µæ ‘æ•°ç»„
    private int[] lazy;   // æ‡’æ ‡è®°æ•°ç»„
    private int[] data;   // åŸå§‹æ•°æ®æ•°ç»„
    private int n;        // æ•°æ®é•¿åº¦

    // æ„é€ å‡½æ•°
    public LazySegmentTree(int[] nums) {
        if (nums == null || nums.length == 0) {
            return;
        }
        n = nums.length;
        data = Arrays.copyOf(nums, n);
        tree = new int[4 * n];
        lazy = new int[4 * n];  // åˆå§‹åŒ–æ‡’æ ‡è®°æ•°ç»„
        build(0, 0, n - 1);
    }

    // æ„å»ºçº¿æ®µæ ‘
    private void build(int node, int start, int end) {
        if (start == end) {
            tree[node] = data[start];
            return;
        }

        int mid = (start + end) / 2;
        int leftChild = 2 * node + 1;
        int rightChild = 2 * node + 2;

        build(leftChild, start, mid);
        build(rightChild, mid + 1, end);

        tree[node] = tree[leftChild] + tree[rightChild];
    }

    // ä¸‹ä¼ æ‡’æ ‡è®°
    private void pushDown(int node, int start, int end) {
        if (lazy[node] != 0 && start != end) {
            int mid = (start + end) / 2;
            int leftChild = 2 * node + 1;
            int rightChild = 2 * node + 2;

            // æ›´æ–°å·¦å­æ ‘
            lazy[leftChild] += lazy[node];
            tree[leftChild] += lazy[node] * (mid - start + 1);

            // æ›´æ–°å³å­æ ‘
            lazy[rightChild] += lazy[node];
            tree[rightChild] += lazy[node] * (end - mid);

            // æ¸…é™¤å½“å‰èŠ‚ç‚¹çš„æ‡’æ ‡è®°
            lazy[node] = 0;
        }
    }

    // åŒºé—´æ›´æ–°ï¼ˆåŠ æ³•ï¼‰
    public void rangeAdd(int l, int r, int val) {
        if (l < 0 || r >= n || l > r) {
            throw new IllegalArgumentException("æ›´æ–°åŒºé—´æ— æ•ˆ");
        }
        rangeAdd(0, 0, n - 1, l, r, val);
    }

    // é€’å½’åŒºé—´æ›´æ–°
    private void rangeAdd(int node, int start, int end, int l, int r, int val) {
        if (r < start || end < l) {
            return;  // æ— äº¤é›†
        }

        if (l <= start && end <= r) {
            // å®Œå…¨è¦†ç›–ï¼Œæ›´æ–°æ‡’æ ‡è®°å’Œå½“å‰èŠ‚ç‚¹å€¼
            lazy[node] += val;
            tree[node] += val * (end - start + 1);
            return;
        }

        // ä¸‹ä¼ æ‡’æ ‡è®°
        pushDown(node, start, end);

        int mid = (start + end) / 2;
        int leftChild = 2 * node + 1;
        int rightChild = 2 * node + 2;

        rangeAdd(leftChild, start, mid, l, r, val);
        rangeAdd(rightChild, mid + 1, end, l, r, val);

        tree[node] = tree[leftChild] + tree[rightChild];
    }

    // åŒºé—´æŸ¥è¯¢ï¼ˆæ±‚å’Œï¼‰
    public int querySum(int l, int r) {
        if (l < 0 || r >= n || l > r) {
            throw new IllegalArgumentException("æŸ¥è¯¢åŒºé—´æ— æ•ˆ");
        }
        return querySum(0, 0, n - 1, l, r);
    }

    // é€’å½’åŒºé—´æŸ¥è¯¢
    private int querySum(int node, int start, int end, int l, int r) {
        if (r < start || end < l) {
            return 0;
        }

        if (l <= start && end <= r) {
            return tree[node];
        }

        // ä¸‹ä¼ æ‡’æ ‡è®°
        pushDown(node, start, end);

        int mid = (start + end) / 2;
        int leftChild = 2 * node + 1;
        int rightChild = 2 * node + 2;

        int leftSum = querySum(leftChild, start, mid, l, r);
        int rightSum = querySum(rightChild, mid + 1, end, l, r);

        return leftSum + rightSum;
    }
}
```

## ğŸ“Š å¤æ‚åº¦åˆ†æ

| æ“ä½œ | æ—¶é—´å¤æ‚åº¦ | ç©ºé—´å¤æ‚åº¦ | è¯´æ˜ |
|------|------------|------------|------|
| æ„å»º | O(n) | O(4n) | éœ€éå†æ‰€æœ‰èŠ‚ç‚¹æ„å»ºæ ‘ï¼Œç©ºé—´ä¸ºåŸæ•°ç»„4å€ |
| å•ç‚¹æŸ¥è¯¢ | O(log n) | O(1) | ä»æ ¹åˆ°å¶çš„è·¯å¾„é•¿åº¦ |
| åŒºé—´æŸ¥è¯¢ | O(log n) | O(1) | æœ€åæƒ…å†µéœ€è®¿é—®O(log n)ä¸ªèŠ‚ç‚¹ |
| å•ç‚¹æ›´æ–° | O(log n) | O(1) | æ›´æ–°è·¯å¾„ä¸Šçš„æ‰€æœ‰ç›¸å…³èŠ‚ç‚¹ |
| åŒºé—´æ›´æ–°(æ™®é€š) | O(n) | O(1) | æœ€åæƒ…å†µéœ€æ›´æ–°æ‰€æœ‰èŠ‚ç‚¹ |
| åŒºé—´æ›´æ–°(æ‡’æ ‡è®°) | O(log n) | O(n) | éœ€é¢å¤–O(n)ç©ºé—´å­˜å‚¨æ‡’æ ‡è®° |

## ğŸ” åº”ç”¨åœºæ™¯

1. **èŒƒå›´æŸ¥è¯¢é—®é¢˜**ï¼šå¦‚åŒºé—´æ±‚å’Œã€åŒºé—´æœ€å€¼ã€åŒºé—´ä¹˜ç§¯ç­‰
2. **åŒºé—´æ›´æ–°æ“ä½œ**ï¼šå¦‚åŒºé—´åŠ å‡ã€åŒºé—´èµ‹å€¼ç­‰
3. **æ•°æ®ç»Ÿè®¡åˆ†æ**ï¼šå¦‚é¢‘ç‡ç»Ÿè®¡ã€å‰ç¼€å’Œè®¡ç®—
4. **çº¿æ®µè¦†ç›–é—®é¢˜**ï¼šå¦‚åŒºé—´è¦†ç›–è®¡æ•°ã€åŒºé—´é‡å æ£€æµ‹
5. **åŠ¨æ€è§„åˆ’ä¼˜åŒ–**ï¼šæŸäº›DPé—®é¢˜å¯é€šè¿‡çº¿æ®µæ ‘ä¼˜åŒ–æŸ¥è¯¢æ•ˆç‡
6. **å‡ ä½•é—®é¢˜**ï¼šå¦‚åŒºé—´äº¤é›†ã€çŸ©å½¢é¢ç§¯è®¡ç®—
7. **åœ¨çº¿ç®—æ³•**ï¼šéœ€è¦å®æ—¶å“åº”æŸ¥è¯¢å’Œæ›´æ–°çš„åœºæ™¯
8. **ç¼–è¯‘å™¨å®ç°**ï¼šè¯­æ³•åˆ†æä¸­çš„åŒºé—´åŒ¹é…
9. **æ¸¸æˆå¼€å‘**ï¼šç¢°æ’æ£€æµ‹ã€åŒºåŸŸçŠ¶æ€ç®¡ç†
10. **è‚¡ç¥¨åˆ†æ**ï¼šåŒºé—´å†…æœ€é«˜ä»·ã€æœ€ä½ä»·æŸ¥è¯¢

## âš ï¸ æ³¨æ„äº‹é¡¹

1. **ç©ºé—´åˆ†é…**ï¼šé€šå¸¸éœ€è¦åˆ†é…4å€äºåŸæ•°ç»„å¤§å°çš„ç©ºé—´ï¼Œé¿å…æ•°ç»„è¶Šç•Œ
2. **ç´¢å¼•å¤„ç†**ï¼šæ³¨æ„åŒºåˆ†çº¿æ®µæ ‘èŠ‚ç‚¹ç´¢å¼•å’ŒåŸæ•°ç»„ç´¢å¼•
3. **æ‡’æ ‡è®°ç®¡ç†**ï¼šä½¿ç”¨æ‡’æ ‡è®°æ—¶å¿…é¡»æ­£ç¡®å®ç°pushDownæ“ä½œï¼Œé¿å…æ›´æ–°é—æ¼
4. **è¾¹ç•Œæ¡ä»¶**ï¼šæ„å»ºå’ŒæŸ¥è¯¢æ—¶éœ€æ­£ç¡®å¤„ç†åŒºé—´è¾¹ç•Œï¼Œé¿å…é‡å¤æˆ–é—æ¼å…ƒç´ 
5. **éé€’å½’å®ç°**ï¼šé€’å½’å®ç°ç®€æ´ä½†å¯èƒ½æ ˆæº¢å‡ºï¼Œå¤§è§„æ¨¡æ•°æ®å»ºè®®ç”¨éé€’å½’å®ç°
6. **åˆå§‹å€¼è®¾ç½®**ï¼šæ ¹æ®ä¸šåŠ¡éœ€æ±‚è®¾ç½®åˆé€‚çš„åˆå§‹å€¼ï¼ˆå¦‚æœ€å€¼æŸ¥è¯¢ç”¨æ­£è´Ÿæ— ç©·ï¼‰
7. **å¤šç»´åº¦æ‰©å±•**ï¼šé«˜ç»´çº¿æ®µæ ‘å®ç°å¤æ‚ï¼Œéœ€è°¨æ…è®¾è®¡æ•°æ®ç»“æ„
8. **å†…å­˜ä¼˜åŒ–**ï¼šå¯¹äºç¨€ç–æ•°æ®ï¼Œå¯è€ƒè™‘åŠ¨æ€çº¿æ®µæ ‘å‡å°‘ç©ºé—´æµªè´¹

## ğŸ“ æœ€ä½³å®è·µ

1. **æŒ‰éœ€é€‰æ‹©å®ç°**ï¼šæ ¹æ®éœ€æ±‚é€‰æ‹©åŸºç¡€çº¿æ®µæ ‘ã€æ‡’æ ‡è®°çº¿æ®µæ ‘æˆ–å…¶ä»–å˜ä½“
2. **å°è£…å¤ç”¨**ï¼šå°†çº¿æ®µæ ‘å°è£…ä¸ºé€šç”¨ç±»ï¼Œæ”¯æŒä¸åŒèšåˆæ“ä½œï¼ˆå’Œã€æœ€å€¼ç­‰ï¼‰
3. **é¢„åˆ†é…ç©ºé—´**ï¼šåˆå§‹åŒ–æ—¶ä¸€æ¬¡æ€§åˆ†é…è¶³å¤Ÿç©ºé—´ï¼Œé¿å…åŠ¨æ€æ‰©å®¹
4. **æ‡’æ ‡è®°ä¼˜åŒ–**ï¼šåŒºé—´æ›´æ–°åœºæ™¯å¿…é¡»ä½¿ç”¨æ‡’æ ‡è®°ï¼Œå¦åˆ™æ€§èƒ½ä¸‹é™åˆ°O(n)
5. **è¾¹ç•Œæµ‹è¯•**ï¼šé‡ç‚¹æµ‹è¯•è¾¹ç•Œæƒ…å†µï¼ˆå¦‚ç©ºæ•°ç»„ã€å•å…ƒç´ ã€å…¨åŒºé—´æ“ä½œï¼‰
6. **éé€’å½’å®ç°**ï¼šå¯¹æ€§èƒ½è¦æ±‚é«˜çš„åœºæ™¯ï¼Œé‡‡ç”¨éé€’å½’å®ç°é¿å…æ ˆå¼€é”€
7. **ç»“åˆå®é™…éœ€æ±‚**ï¼šå¦‚åªéœ€å‰ç¼€å’ŒæŸ¥è¯¢ï¼Œå¯ä½¿ç”¨æ›´ç®€å•çš„å‰ç¼€å’Œæ•°ç»„

---

> **å·²å®Œæˆ**ï¼šæœ¬æ–‡æ¡£å·²å®Œå–„ï¼ŒåŒ…å«çº¿æ®µæ ‘çš„æ ¸å¿ƒæ¦‚å¿µã€Javaå®ç°ä»£ç ï¼ˆåŸºç¡€çº¿æ®µæ ‘ã€æœ€å€¼çº¿æ®µæ ‘ã€æ‡’æ ‡è®°çº¿æ®µæ ‘ï¼‰ã€å¤æ‚åº¦åˆ†æã€åº”ç”¨åœºæ™¯å’Œæœ€ä½³å®è·µï¼Œå¯ä½œä¸ºçº¿æ®µæ ‘å­¦ä¹ çš„å®Œæ•´å‚è€ƒèµ„æ–™
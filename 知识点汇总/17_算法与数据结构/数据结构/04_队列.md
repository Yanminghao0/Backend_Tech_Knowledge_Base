# é˜Ÿåˆ—

> é˜Ÿåˆ—ï¼ˆQueueï¼‰æ˜¯ä¸€ç§å…ˆè¿›å…ˆå‡ºï¼ˆFIFO, First In First Outï¼‰çš„çº¿æ€§æ•°æ®ç»“æ„ï¼Œå®ƒåªå…è®¸åœ¨è¡¨çš„å‰ç«¯ï¼ˆé˜Ÿå¤´ï¼‰è¿›è¡Œåˆ é™¤æ“ä½œï¼Œè€Œåœ¨è¡¨çš„åç«¯ï¼ˆé˜Ÿå°¾ï¼‰è¿›è¡Œæ’å…¥æ“ä½œã€‚é˜Ÿåˆ—åœ¨è®¡ç®—æœºç§‘å­¦ä¸­æœ‰ç€å¹¿æ³›çš„åº”ç”¨ï¼Œå¦‚ä»»åŠ¡è°ƒåº¦ã€ç¼“å†²å¤„ç†ã€å¹¿åº¦ä¼˜å…ˆæœç´¢ç­‰åœºæ™¯ã€‚

---

## ğŸ“‹ åŸºæœ¬ä¿¡æ¯

| é¡¹ç›®                | è¯´æ˜                                                                 |
|---------------------|----------------------------------------------------------------------|
| **æ•°æ®ç»“æ„ç±»å‹**    | çº¿æ€§è¡¨                                                               |
| **å­˜å‚¨ç»“æ„**        | æ•°ç»„ï¼ˆé¡ºåºé˜Ÿåˆ—ï¼‰ã€é“¾è¡¨ï¼ˆé“¾å¼é˜Ÿåˆ—ï¼‰                                   |
| **æ ¸å¿ƒæ“ä½œ**        | å…¥é˜Ÿï¼ˆEnqueueï¼‰ã€å‡ºé˜Ÿï¼ˆDequeueï¼‰ã€æŸ¥çœ‹é˜Ÿå¤´ï¼ˆPeekï¼‰ã€åˆ¤ç©ºï¼ˆIsEmptyï¼‰   |
| **æ—¶é—´å¤æ‚åº¦**      | å…¥é˜Ÿ/å‡ºé˜Ÿ/æŸ¥çœ‹é˜Ÿå¤´ï¼šO(1)ï¼ˆä½¿ç”¨å¾ªç¯é˜Ÿåˆ—æˆ–é“¾è¡¨å®ç°ï¼‰                   |
| **ç©ºé—´å¤æ‚åº¦**      | O(n)ï¼Œå…¶ä¸­nä¸ºé˜Ÿåˆ—å®¹é‡                                               |
| **ç‰¹ç‚¹**            | å…ˆè¿›å…ˆå‡ºï¼Œåªå…è®¸åœ¨ä¸¤ç«¯æ“ä½œ                                           |
| **å¸¸è§å®ç°**        | é¡ºåºé˜Ÿåˆ—ã€å¾ªç¯é˜Ÿåˆ—ã€é“¾å¼é˜Ÿåˆ—ã€åŒç«¯é˜Ÿåˆ—ã€ä¼˜å…ˆé˜Ÿåˆ—ã€é˜»å¡é˜Ÿåˆ—           |

## ğŸ¯ æ ¸å¿ƒç‰¹æ€§

1. **å…ˆè¿›å…ˆå‡ºï¼ˆFIFOï¼‰**ï¼šæœ€æ—©è¿›å…¥é˜Ÿåˆ—çš„å…ƒç´ æœ€å…ˆè¢«å–å‡º
2. **æ“ä½œå—é™**ï¼šåªå…è®¸åœ¨é˜Ÿå°¾æ’å…¥ï¼Œé˜Ÿå¤´åˆ é™¤
3. **åŠ¨æ€å¤§å°**ï¼šé“¾å¼é˜Ÿåˆ—å¯åŠ¨æ€è°ƒæ•´å¤§å°ï¼Œé¡ºåºé˜Ÿåˆ—æœ‰å›ºå®šå®¹é‡é™åˆ¶
4. **åŒç«¯æ‰©å±•**ï¼šåŒç«¯é˜Ÿåˆ—å…è®¸åœ¨ä¸¤ç«¯è¿›è¡Œæ’å…¥å’Œåˆ é™¤æ“ä½œ
5. **ä¼˜å…ˆçº§æ”¯æŒ**ï¼šä¼˜å…ˆé˜Ÿåˆ—å¯æ ¹æ®å…ƒç´ ä¼˜å…ˆçº§è¿›è¡Œæ’åºï¼Œä¸ä¸¥æ ¼éµå¾ªFIFO

## ğŸ’» ä»£ç å®ç°

### 1. é¡ºåºé˜Ÿåˆ—ï¼ˆåŸºäºæ•°ç»„ï¼‰
```java
public class ArrayQueue {
    private int[] queue;    // å­˜å‚¨é˜Ÿåˆ—å…ƒç´ çš„æ•°ç»„
    private int front;      // é˜Ÿå¤´æŒ‡é’ˆï¼ŒæŒ‡å‘é˜Ÿå¤´å…ƒç´ 
    private int rear;       // é˜Ÿå°¾æŒ‡é’ˆï¼ŒæŒ‡å‘é˜Ÿå°¾å…ƒç´ çš„ä¸‹ä¸€ä¸ªä½ç½®
    private int size;       // å½“å‰é˜Ÿåˆ—å…ƒç´ ä¸ªæ•°
    private int capacity;   // é˜Ÿåˆ—å®¹é‡

    // åˆå§‹åŒ–é˜Ÿåˆ—
    public ArrayQueue(int capacity) {
        this.capacity = capacity;
        queue = new int[capacity];
        front = 0;
        rear = 0;
        size = 0;
    }

    // å…¥é˜Ÿæ“ä½œ
    public boolean enqueue(int item) {
        if (isFull()) {
            System.out.println("é˜Ÿåˆ—å·²æ»¡ï¼Œæ— æ³•å…¥é˜Ÿ");
            return false;
        }
        queue[rear] = item;
        rear = (rear + 1) % capacity;  // å¾ªç¯ç§»åŠ¨é˜Ÿå°¾æŒ‡é’ˆ
        size++;
        return true;
    }

    // å‡ºé˜Ÿæ“ä½œ
    public Integer dequeue() {
        if (isEmpty()) {
            System.out.println("é˜Ÿåˆ—ä¸ºç©ºï¼Œæ— æ³•å‡ºé˜Ÿ");
            return null;
        }
        int item = queue[front];
        front = (front + 1) % capacity;  // å¾ªç¯ç§»åŠ¨é˜Ÿå¤´æŒ‡é’ˆ
        size--;
        return item;
    }

    // æŸ¥çœ‹é˜Ÿå¤´å…ƒç´ 
    public Integer peek() {
        if (isEmpty()) {
            System.out.println("é˜Ÿåˆ—ä¸ºç©º");
            return null;
        }
        return queue[front];
    }

    // åˆ¤æ–­é˜Ÿåˆ—æ˜¯å¦ä¸ºç©º
    public boolean isEmpty() {
        return size == 0;
    }

    // åˆ¤æ–­é˜Ÿåˆ—æ˜¯å¦å·²æ»¡
    public boolean isFull() {
        return size == capacity;
    }

    // è·å–é˜Ÿåˆ—å¤§å°
    public int size() {
        return size;
    }
}
```

### 2. é“¾å¼é˜Ÿåˆ—ï¼ˆåŸºäºé“¾è¡¨ï¼‰
```java
public class LinkedQueue {
    // èŠ‚ç‚¹ç±»
    private static class Node {
        int data;
        Node next;

        Node(int data) {
            this.data = data;
            this.next = null;
        }
    }

    private Node front;  // é˜Ÿå¤´æŒ‡é’ˆ
    private Node rear;   // é˜Ÿå°¾æŒ‡é’ˆ
    private int size;    // é˜Ÿåˆ—å¤§å°

    // åˆå§‹åŒ–é˜Ÿåˆ—
    public LinkedQueue() {
        front = null;
        rear = null;
        size = 0;
    }

    // å…¥é˜Ÿæ“ä½œ
    public void enqueue(int item) {
        Node newNode = new Node(item);
        if (isEmpty()) {
            front = newNode;
            rear = newNode;
        } else {
            rear.next = newNode;
            rear = newNode;
        }
        size++;
    }

    // å‡ºé˜Ÿæ“ä½œ
    public Integer dequeue() {
        if (isEmpty()) {
            System.out.println("é˜Ÿåˆ—ä¸ºç©ºï¼Œæ— æ³•å‡ºé˜Ÿ");
            return null;
        }
        int item = front.data;
        front = front.next;
        size--;
        // å¦‚æœé˜Ÿåˆ—ä¸ºç©ºï¼Œå°†rearä¹Ÿç½®ä¸ºnull
        if (isEmpty()) {
            rear = null;
        }
        return item;
    }

    // æŸ¥çœ‹é˜Ÿå¤´å…ƒç´ 
    public Integer peek() {
        if (isEmpty()) {
            System.out.println("é˜Ÿåˆ—ä¸ºç©º");
            return null;
        }
        return front.data;
    }

    // åˆ¤æ–­é˜Ÿåˆ—æ˜¯å¦ä¸ºç©º
    public boolean isEmpty() {
        return size == 0;
    }

    // è·å–é˜Ÿåˆ—å¤§å°
    public int size() {
        return size;
    }
}
```

### 3. åŒç«¯é˜Ÿåˆ—ï¼ˆæ”¯æŒä¸¤ç«¯æ’å…¥åˆ é™¤ï¼‰
```java
public class Deque {
    private int[] deque;
    private int front;
    private int rear;
    private int size;
    private int capacity;

    public Deque(int capacity) {
        this.capacity = capacity;
        deque = new int[capacity];
        front = 0;
        rear = 0;
        size = 0;
    }

    // é˜Ÿå¤´å…¥é˜Ÿ
    public boolean addFirst(int item) {
        if (isFull()) return false;
        front = (front - 1 + capacity) % capacity;
        deque[front] = item;
        size++;
        return true;
    }

    // é˜Ÿå°¾å…¥é˜Ÿ
    public boolean addLast(int item) {
        if (isFull()) return false;
        deque[rear] = item;
        rear = (rear + 1) % capacity;
        size++;
        return true;
    }

    // é˜Ÿå¤´å‡ºé˜Ÿ
    public Integer removeFirst() {
        if (isEmpty()) return null;
        int item = deque[front];
        front = (front + 1) % capacity;
        size--;
        return item;
    }

    // é˜Ÿå°¾å‡ºé˜Ÿ
    public Integer removeLast() {
        if (isEmpty()) return null;
        rear = (rear - 1 + capacity) % capacity;
        int item = deque[rear];
        size--;
        return item;
    }

    // æŸ¥çœ‹é˜Ÿå¤´å…ƒç´ 
    public Integer peekFirst() {
        if (isEmpty()) return null;
        return deque[front];
    }

    // æŸ¥çœ‹é˜Ÿå°¾å…ƒç´ 
    public Integer peekLast() {
        if (isEmpty()) return null;
        return deque[(rear - 1 + capacity) % capacity];
    }

    public boolean isEmpty() { return size == 0; }
    public boolean isFull() { return size == capacity; }
    public int size() { return size; }
}
```

### 4. ä¼˜å…ˆé˜Ÿåˆ—ï¼ˆåŸºäºå †å®ç°ï¼‰
```java
import java.util.Arrays;

public class PriorityQueue {
    private int[] heap;
    private int size;
    private int capacity;
    private boolean isMaxHeap;

    // åˆå§‹åŒ–ä¼˜å…ˆé˜Ÿåˆ—
    public PriorityQueue(int capacity, boolean isMaxHeap) {
        this.capacity = capacity;
        this.isMaxHeap = isMaxHeap;
        heap = new int[capacity + 1];  // ç´¢å¼•ä»1å¼€å§‹
        size = 0;
    }

    // å…¥é˜Ÿæ“ä½œ
    public void enqueue(int item) {
        if (size >= capacity) {
            throw new RuntimeException("ä¼˜å…ˆé˜Ÿåˆ—å·²æ»¡");
        }
        size++;
        heap[size] = item;
        // ä»ä¸‹å¾€ä¸Šè°ƒæ•´å †
        int i = size;
        while (i > 1) {
            int parent = i / 2;
            if (compare(heap[i], heap[parent])) {
                swap(i, parent);
                i = parent;
            } else {
                break;
            }
        }
    }

    // å‡ºé˜Ÿæ“ä½œ
    public int dequeue() {
        if (size == 0) {
            throw new RuntimeException("ä¼˜å…ˆé˜Ÿåˆ—ä¸ºç©º");
        }
        int top = heap[1];
        heap[1] = heap[size];
        size--;
        // ä»ä¸Šå¾€ä¸‹è°ƒæ•´å †
        heapify(1);
        return top;
    }

    // å †åŒ–æ“ä½œ
    private void heapify(int i) {
        int left = 2 * i;
        int right = 2 * i + 1;
        int target = i;

        if (left <= size && compare(heap[left], heap[target])) {
            target = left;
        }
        if (right <= size && compare(heap[right], heap[target])) {
            target = right;
        }

        if (target != i) {
            swap(i, target);
            heapify(target);
        }
    }

    // æ¯”è¾ƒå‡½æ•°
    private boolean compare(int a, int b) {
        return isMaxHeap ? (a > b) : (a < b);
    }

    // äº¤æ¢å…ƒç´ 
    private void swap(int i, int j) {
        int temp = heap[i];
        heap[i] = heap[j];
        heap[j] = temp;
    }

    public int size() { return size; }
    public boolean isEmpty() { return size == 0; }
    public int peek() { return size > 0 ? heap[1] : -1; }
}
```

## ğŸ“Š å¤æ‚åº¦åˆ†æ

| æ“ä½œ         | é¡ºåºé˜Ÿåˆ— | é“¾å¼é˜Ÿåˆ— | åŒç«¯é˜Ÿåˆ— | ä¼˜å…ˆé˜Ÿåˆ— |
|--------------|----------|----------|----------|----------|
| å…¥é˜Ÿï¼ˆEnqueueï¼‰ | O(1)     | O(1)     | O(1)     | O(log n) |
| å‡ºé˜Ÿï¼ˆDequeueï¼‰ | O(1)     | O(1)     | O(1)     | O(log n) |
| æŸ¥çœ‹é˜Ÿå¤´ï¼ˆPeekï¼‰| O(1)     | O(1)     | O(1)     | O(1)     |
| ç©ºé—´å¤æ‚åº¦   | O(n)     | O(n)     | O(n)     | O(n)     |

> æ³¨æ„ï¼š
> - é¡ºåºé˜Ÿåˆ—å¦‚æœä¸ä½¿ç”¨å¾ªç¯å®ç°ï¼Œå‡ºé˜Ÿæ“ä½œçš„æ—¶é—´å¤æ‚åº¦ä¼šé€€åŒ–ä¸ºO(n)
> - ä¼˜å…ˆé˜Ÿåˆ—çš„å…¥é˜Ÿå’Œå‡ºé˜Ÿæ“ä½œæ—¶é—´å¤æ‚åº¦ä¸ºO(log n)ï¼Œå› ä¸ºéœ€è¦ç»´æŠ¤å †ç»“æ„
> - é“¾å¼é˜Ÿåˆ—çš„ç©ºé—´åˆ©ç”¨ç‡æ›´é«˜ï¼Œä¸éœ€è¦é¢„å…ˆåˆ†é…å›ºå®šå¤§å°çš„å†…å­˜

## ğŸ” åº”ç”¨åœºæ™¯

1. **ä»»åŠ¡è°ƒåº¦ç³»ç»Ÿ**ï¼š
   - æ“ä½œç³»ç»Ÿä¸­çš„è¿›ç¨‹è°ƒåº¦
   - æ‰“å°ä»»åŠ¡é˜Ÿåˆ—
   - çº¿ç¨‹æ± ä»»åŠ¡é˜Ÿåˆ—

2. **ç¼“å†²å¤„ç†**ï¼š
   - ç½‘ç»œæ•°æ®ä¼ è¾“ä¸­çš„ç¼“å†²åŒº
   - é”®ç›˜è¾“å…¥ç¼“å†²åŒº
   - è§†é¢‘æ’­æ”¾ç¼“å†²åŒº

3. **å¹¿åº¦ä¼˜å…ˆæœç´¢ï¼ˆBFSï¼‰**ï¼š
   - å›¾çš„å±‚æ¬¡éå†
   - æœ€çŸ­è·¯å¾„ç®—æ³•
   - è¿·å®«æ±‚è§£

4. **æ¶ˆæ¯é˜Ÿåˆ—**ï¼š
   - å¼‚æ­¥é€šä¿¡ç³»ç»Ÿ
   - è§£è€¦ç³»ç»Ÿç»„ä»¶
   - å‰Šå³°å¡«è°·

5. **ç‰¹æ®Šåº”ç”¨**ï¼š
   - åŒç«¯é˜Ÿåˆ—ï¼šå®ç°undo/redoåŠŸèƒ½
   - ä¼˜å…ˆé˜Ÿåˆ—ï¼šDijkstraç®—æ³•ã€Huffmanç¼–ç 
   - é˜»å¡é˜Ÿåˆ—ï¼šå¤šçº¿ç¨‹é—´çš„å®‰å…¨é€šä¿¡

## âš ï¸ æ³¨æ„äº‹é¡¹

1. **é˜Ÿåˆ—æº¢å‡º**ï¼š
   - é¡ºåºé˜Ÿåˆ—éœ€è¦æ³¨æ„åˆ¤æ–­é˜Ÿåˆ—æ˜¯å¦å·²æ»¡
   - é“¾å¼é˜Ÿåˆ—ç†è®ºä¸Šä¸ä¼šæº¢å‡ºï¼Œä½†éœ€æ³¨æ„å†…å­˜é™åˆ¶

2. **ç©ºé˜Ÿåˆ—æ“ä½œ**ï¼š
   - å¯¹ç©ºé˜Ÿåˆ—æ‰§è¡Œå‡ºé˜Ÿæˆ–æŸ¥çœ‹æ“ä½œä¼šå¯¼è‡´é”™è¯¯
   - å®ç°æ—¶åº”è¿”å›ç‰¹æ®Šå€¼æˆ–æŠ›å‡ºå¼‚å¸¸

3. **å¾ªç¯é˜Ÿåˆ—å®ç°**ï¼š
   - æ³¨æ„åŒºåˆ†é˜Ÿç©ºå’Œé˜Ÿæ»¡çš„åˆ¤æ–­æ¡ä»¶
   - å¸¸ç”¨çš„è§£å†³æ–¹æ³•ï¼š
     - å°‘ç”¨ä¸€ä¸ªå…ƒç´ ç©ºé—´
     - å¢åŠ sizeå˜é‡è®°å½•å…ƒç´ ä¸ªæ•°
     - ä½¿ç”¨æ ‡è®°ä½

4. **å¹¶å‘å®‰å…¨**ï¼š
   - æ™®é€šé˜Ÿåˆ—ä¸æ˜¯çº¿ç¨‹å®‰å…¨çš„
   - å¤šçº¿ç¨‹ç¯å¢ƒä¸‹åº”ä½¿ç”¨ConcurrentLinkedQueueæˆ–BlockingQueue

5. **å†…å­˜ç®¡ç†**ï¼š
   - é“¾å¼é˜Ÿåˆ—é¢‘ç¹çš„å…¥é˜Ÿå‡ºé˜Ÿå¯èƒ½å¯¼è‡´å†…å­˜ç¢ç‰‡
   - é•¿æ—¶é—´è¿è¡Œçš„ç³»ç»Ÿåº”è€ƒè™‘å†…å­˜å›æ”¶

## ğŸ“ æœ€ä½³å®è·µ

### ä½¿ç”¨å»ºè®®

1. **æ•°æ®è§„æ¨¡é€‰æ‹©**ï¼š
   - æ•°æ®é‡å›ºå®šä¸”å·²çŸ¥ï¼šé¡ºåºé˜Ÿåˆ—
   - æ•°æ®é‡åŠ¨æ€å˜åŒ–ï¼šé“¾å¼é˜Ÿåˆ—
   - éœ€è¦ä¸¤ç«¯æ“ä½œï¼šåŒç«¯é˜Ÿåˆ—
   - éœ€è¦ä¼˜å…ˆçº§æ’åºï¼šä¼˜å…ˆé˜Ÿåˆ—

2. **Javaä¸­çš„é˜Ÿåˆ—å®ç°**ï¼š
   ```java
   // æ™®é€šé˜Ÿåˆ—
   Queue<Integer> queue = new LinkedList<>();
   Queue<Integer> arrayQueue = new ArrayDeque<>();
   
   // åŒç«¯é˜Ÿåˆ—
   Deque<Integer> deque = new ArrayDeque<>();
   
   // ä¼˜å…ˆé˜Ÿåˆ—
   PriorityQueue<Integer> maxHeap = new PriorityQueue<>(Collections.reverseOrder());
   PriorityQueue<Integer> minHeap = new PriorityQueue<>();
   
   // å¹¶å‘å®‰å…¨é˜Ÿåˆ—
   Queue<Integer> concurrentQueue = new ConcurrentLinkedQueue<>();
   BlockingQueue<Integer> blockingQueue = new ArrayBlockingQueue<>(10);
   ```

3. **æ€§èƒ½ä¼˜åŒ–**ï¼š
   - é¢„ä¼°æ•°æ®é‡ï¼Œåˆç†è®¾ç½®é¡ºåºé˜Ÿåˆ—å®¹é‡
   - é¢‘ç¹æ“ä½œæ—¶ä¼˜å…ˆé€‰æ‹©ArrayDequeè€ŒéLinkedList
   - å¤šçº¿ç¨‹ç¯å¢ƒä¸‹ä½¿ç”¨å¹¶å‘é˜Ÿåˆ—è€Œéæ‰‹åŠ¨åŠ é”

4. **é¿å…å¸¸è§é”™è¯¯**ï¼š
   - ä¸è¦åœ¨éå†é˜Ÿåˆ—æ—¶è¿›è¡Œä¿®æ”¹æ“ä½œ
   - ä¼˜å…ˆé˜Ÿåˆ—ä¸æ˜¯æ’åºå®¹å™¨ï¼Œéå†ç»“æœä¸ä¿è¯æœ‰åº
   - æ³¨æ„ArrayDequeçš„addFirst/addLastä¸offerFirst/offerLastçš„åŒºåˆ«

### å®ç°æŠ€å·§

1. **å¾ªç¯é˜Ÿåˆ—ä¼˜åŒ–**ï¼š
   ```java
   // é˜Ÿç©ºæ¡ä»¶ï¼šfront == rear && size == 0
   // é˜Ÿæ»¡æ¡ä»¶ï¼šfront == rear && size == capacity
   // è¿™ç§å®ç°å¯ä»¥å……åˆ†åˆ©ç”¨æ•°ç»„ç©ºé—´
   ```

2. **åŒç«¯é˜Ÿåˆ—å®ç°æ ˆ**ï¼š
   ```java
   class MyStack {
       private Deque<Integer> deque;
       
       public MyStack() {
           deque = new ArrayDeque<>();
       }
       
       public void push(int x) {
           deque.addLast(x);
       }
       
       public int pop() {
           return deque.removeLast();
       }
       
       public int top() {
           return deque.getLast();
       }
       
       public boolean empty() {
           return deque.isEmpty();
       }
   }
   ```

3. **åŒç«¯é˜Ÿåˆ—å®ç°æ™®é€šé˜Ÿåˆ—**ï¼š
   ```java
   class MyQueue {
       private Deque<Integer> deque;
       
       public MyQueue() {
           deque = new ArrayDeque<>();
       }
       
       public void push(int x) {
           deque.addLast(x);
       }
       
       public int pop() {
           return deque.removeFirst();
       }
       
       public int peek() {
           return deque.getFirst();
       }
       
       public boolean empty() {
           return deque.isEmpty();
       }
   }
   ```

---

> **å®ŒæˆçŠ¶æ€**ï¼šæœ¬æ–‡æ¡£å·²å®Œå–„é˜Ÿåˆ—çš„åŸºæœ¬æ¦‚å¿µã€å¤šç§å®ç°æ–¹å¼ã€å¤æ‚åº¦åˆ†æã€åº”ç”¨åœºæ™¯åŠæœ€ä½³å®è·µï¼Œå¯ä½œä¸ºé˜Ÿåˆ—æ•°æ®ç»“æ„çš„å®Œæ•´å­¦ä¹ å‚è€ƒã€‚
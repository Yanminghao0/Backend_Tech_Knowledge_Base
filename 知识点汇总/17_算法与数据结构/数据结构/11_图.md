# å›¾

> å›¾ï¼ˆGraphï¼‰æ˜¯ç”±é¡¶ç‚¹ï¼ˆVertexï¼‰å’Œè¾¹ï¼ˆEdgeï¼‰ç»„æˆçš„éçº¿æ€§æ•°æ®ç»“æ„ï¼Œç”¨äºè¡¨ç¤ºå¯¹è±¡ä¹‹é—´çš„å¤šå¯¹å¤šå…³ç³»ã€‚ä¸æ ‘ç»“æ„ä¸åŒï¼Œå›¾ä¸­å…è®¸å­˜åœ¨å›è·¯å’Œå¤šæ¡è¾¹ï¼Œæ˜¯æè¿°å¤æ‚å…³ç³»çš„å¼ºå¤§å·¥å…·ã€‚å›¾å¯åˆ†ä¸ºæœ‰å‘å›¾å’Œæ— å‘å›¾ï¼Œå¹¿æ³›åº”ç”¨äºç¤¾äº¤ç½‘ç»œã€è·¯çº¿è§„åˆ’ã€ç”µè·¯è®¾è®¡ç­‰é¢†åŸŸã€‚

---

## ğŸ“‹ åŸºæœ¬ä¿¡æ¯

| å±æ€§ | è¯´æ˜ |
|------|------|
| æ•°æ®ç»“æ„ç±»å‹ | éçº¿æ€§ç»“æ„ |
| å­˜å‚¨ç»“æ„ | é‚»æ¥çŸ©é˜µã€é‚»æ¥è¡¨ã€é‚»æ¥å¤šé‡è¡¨ |
| æ ¸å¿ƒæ“ä½œ | éå†ï¼ˆDFS/BFSï¼‰ã€æœ€çŸ­è·¯å¾„ã€è¿é€šæ€§åˆ¤æ–­ã€æ‹“æ‰‘æ’åº |
| æ—¶é—´å¤æ‚åº¦ | éå†: O(V+E)ï¼Œæœ€çŸ­è·¯å¾„: O(E log V)ï¼Œæ‹“æ‰‘æ’åº: O(V+E) |
| ç©ºé—´å¤æ‚åº¦ | é‚»æ¥çŸ©é˜µ: O(VÂ²)ï¼Œé‚»æ¥è¡¨: O(V+E) |
| ç‰¹ç‚¹ | ä»»æ„é¡¶ç‚¹é—´å¯ç›´æ¥å…³è”ï¼Œå…è®¸å›è·¯å’Œå¤šé‡è¾¹ |

## ğŸ¯ æ ¸å¿ƒç‰¹æ€§

1. **å¤šå¯¹å¤šå…³ç³»**ï¼šä»»æ„ä¸¤ä¸ªé¡¶ç‚¹ä¹‹é—´éƒ½å¯ä»¥å­˜åœ¨å…³ç³»ï¼ˆè¾¹ï¼‰ï¼Œçªç ´äº†æ ‘çš„å±‚æ¬¡é™åˆ¶
2. **é¡¶ç‚¹ä¸è¾¹**ï¼šç”±é¡¶ç‚¹é›†åˆå’Œè¾¹é›†åˆç»„æˆï¼Œè¾¹å¯ä»¥å¸¦æƒé‡å’Œæ–¹å‘
3. **è¿é€šæ€§**ï¼šå›¾å¯ä»¥æ˜¯è¿é€šçš„æˆ–éè¿é€šçš„ï¼Œè¿é€šå›¾ä¸­ä»»æ„ä¸¤é¡¶ç‚¹é—´æœ‰è·¯å¾„
4. **å›è·¯ä¸ç¯**ï¼šå…è®¸é¡¶ç‚¹é€šè¿‡è¾¹å½¢æˆå›è·¯ï¼Œè¿™æ˜¯ä¸æ ‘ç»“æ„çš„ä¸»è¦åŒºåˆ«
5. **è¡¨ç¤ºæ–¹æ³•å¤šæ ·**ï¼šæ ¹æ®ä¸åŒåœºæ™¯é€‰æ‹©é‚»æ¥çŸ©é˜µï¼ˆç¨ å¯†å›¾ï¼‰æˆ–é‚»æ¥è¡¨ï¼ˆç¨€ç–å›¾ï¼‰
6. **å­å›¾ç‰¹æ€§**ï¼šå¯ä»¥ä»åŸå›¾ä¸­æå–å­å›¾è¿›è¡Œåˆ†æ
7. **æœ‰å‘æ€§**ï¼šæœ‰å‘å›¾çš„è¾¹å…·æœ‰æ–¹å‘ï¼Œåæ˜ ä¸å¯¹ç§°å…³ç³»

## ğŸ’» ä»£ç å®ç°

### 1. å›¾çš„è¡¨ç¤ºæ–¹æ³•

#### é‚»æ¥çŸ©é˜µå®ç°
```java
public class GraphMatrix {
    private int[][] adjMatrix; // é‚»æ¥çŸ©é˜µ
    private int numVertices;   // é¡¶ç‚¹æ•°é‡
    private boolean isDirected; // æ˜¯å¦ä¸ºæœ‰å‘å›¾

    public GraphMatrix(int numVertices, boolean isDirected) {
        this.numVertices = numVertices;
        this.isDirected = isDirected;
        this.adjMatrix = new int[numVertices][numVertices];
    }

    // æ·»åŠ è¾¹
    public void addEdge(int source, int destination) {
        addEdge(source, destination, 1); // é»˜è®¤æƒé‡ä¸º1
    }

    // æ·»åŠ å¸¦æƒé‡çš„è¾¹
    public void addEdge(int source, int destination, int weight) {
        if (source < 0 || source >= numVertices || destination < 0 || destination >= numVertices) {
            throw new IllegalArgumentException("é¡¶ç‚¹ç´¢å¼•è¶…å‡ºèŒƒå›´");
        }
        adjMatrix[source][destination] = weight;
        if (!isDirected) {
            adjMatrix[destination][source] = weight; // æ— å‘å›¾å¯¹ç§°
        }
    }

    // ç§»é™¤è¾¹
    public void removeEdge(int source, int destination) {
        if (source < 0 || source >= numVertices || destination < 0 || destination >= numVertices) {
            throw new IllegalArgumentException("é¡¶ç‚¹ç´¢å¼•è¶…å‡ºèŒƒå›´");
        }
        adjMatrix[source][destination] = 0;
        if (!isDirected) {
            adjMatrix[destination][source] = 0;
        }
    }

    // æ£€æŸ¥è¾¹æ˜¯å¦å­˜åœ¨
    public boolean hasEdge(int source, int destination) {
        if (source < 0 || source >= numVertices || destination < 0 || destination >= numVertices) {
            return false;
        }
        return adjMatrix[source][destination] != 0;
    }

    // è·å–è¾¹çš„æƒé‡
    public int getEdgeWeight(int source, int destination) {
        if (source < 0 || source >= numVertices || destination < 0 || destination >= numVertices) {
            return 0;
        }
        return adjMatrix[source][destination];
    }

    // è·å–é¡¶ç‚¹çš„é‚»æ¥é¡¶ç‚¹
    public List<Integer> getNeighbors(int vertex) {
        List<Integer> neighbors = new ArrayList<>();
        if (vertex < 0 || vertex >= numVertices) {
            return neighbors;
        }

        for (int i = 0; i < numVertices; i++) {
            if (adjMatrix[vertex][i] != 0) {
                neighbors.add(i);
            }
        }
        return neighbors;
    }

    // è·å–é¡¶ç‚¹æ•°é‡
    public int getNumVertices() {
        return numVertices;
    }
}
```

#### é‚»æ¥è¡¨å®ç°
```java
public class GraphList {
    private int numVertices;          // é¡¶ç‚¹æ•°é‡
    private boolean isDirected;       // æ˜¯å¦ä¸ºæœ‰å‘å›¾
    private List<List<Edge>> adjList; // é‚»æ¥è¡¨

    // è¾¹çš„å†…éƒ¨ç±»
    private static class Edge {
        int destination; // ç›®æ ‡é¡¶ç‚¹
        int weight;      // æƒé‡

        Edge(int destination, int weight) {
            this.destination = destination;
            this.weight = weight;
        }
    }

    public GraphList(int numVertices, boolean isDirected) {
        this.numVertices = numVertices;
        this.isDirected = isDirected;
        this.adjList = new ArrayList<>();

        // åˆå§‹åŒ–é‚»æ¥è¡¨
        for (int i = 0; i < numVertices; i++) {
            adjList.add(new ArrayList<Edge>());
        }
    }

    // æ·»åŠ è¾¹
    public void addEdge(int source, int destination) {
        addEdge(source, destination, 1);
    }

    // æ·»åŠ å¸¦æƒé‡çš„è¾¹
    public void addEdge(int source, int destination, int weight) {
        if (source < 0 || source >= numVertices || destination < 0 || destination >= numVertices) {
            throw new IllegalArgumentException("é¡¶ç‚¹ç´¢å¼•è¶…å‡ºèŒƒå›´");
        }
        adjList.get(source).add(new Edge(destination, weight));
        if (!isDirected) {
            adjList.get(destination).add(new Edge(source, weight)); // æ— å‘å›¾å¯¹ç§°æ·»åŠ 
        }
    }

    // ç§»é™¤è¾¹
    public void removeEdge(int source, int destination) {
        if (source < 0 || source >= numVertices || destination < 0 || destination >= numVertices) {
            throw new IllegalArgumentException("é¡¶ç‚¹ç´¢å¼•è¶…å‡ºèŒƒå›´");
        }

        // ç§»é™¤æºé¡¶ç‚¹åˆ°ç›®æ ‡é¡¶ç‚¹çš„è¾¹
        adjList.get(source).removeIf(edge -> edge.destination == destination);
        if (!isDirected) {
            // æ— å‘å›¾è¿˜éœ€ç§»é™¤åå‘è¾¹
            adjList.get(destination).removeIf(edge -> edge.destination == source);
        }
    }

    // æ£€æŸ¥è¾¹æ˜¯å¦å­˜åœ¨
    public boolean hasEdge(int source, int destination) {
        if (source < 0 || source >= numVertices || destination < 0 || destination >= numVertices) {
            return false;
        }

        for (Edge edge : adjList.get(source)) {
            if (edge.destination == destination) {
                return true;
            }
        }
        return false;
    }

    // è·å–è¾¹çš„æƒé‡
    public int getEdgeWeight(int source, int destination) {
        if (source < 0 || source >= numVertices || destination < 0 || destination >= numVertices) {
            return 0;
        }

        for (Edge edge : adjList.get(source)) {
            if (edge.destination == destination) {
                return edge.weight;
            }
        }
        return 0;
    }

    // è·å–é¡¶ç‚¹çš„é‚»æ¥é¡¶ç‚¹
    public List<Integer> getNeighbors(int vertex) {
        List<Integer> neighbors = new ArrayList<>();
        if (vertex < 0 || vertex >= numVertices) {
            return neighbors;
        }

        for (Edge edge : adjList.get(vertex)) {
            neighbors.add(edge.destination);
        }
        return neighbors;
    }

    // è·å–é¡¶ç‚¹æ•°é‡
    public int getNumVertices() {
        return numVertices;
    }
}
```

### 2. å›¾çš„éå†ç®—æ³•

#### æ·±åº¦ä¼˜å…ˆæœç´¢(DFS)
```java
public class GraphTraversal {
    // é€’å½’å®ç°DFS
    public static void dfsRecursive(GraphList graph, int startVertex, boolean[] visited, List<Integer> result) {
        visited[startVertex] = true;
        result.add(startVertex);

        for (int neighbor : graph.getNeighbors(startVertex)) {
            if (!visited[neighbor]) {
                dfsRecursive(graph, neighbor, visited, result);
            }
        }
    }

    // éé€’å½’å®ç°DFS
    public static List<Integer> dfsIterative(GraphList graph, int startVertex) {
        List<Integer> result = new ArrayList<>();
        if (startVertex < 0 || startVertex >= graph.getNumVertices()) {
            return result;
        }

        boolean[] visited = new boolean[graph.getNumVertices()];
        Stack<Integer> stack = new Stack<>();

        stack.push(startVertex);
        visited[startVertex] = true;

        while (!stack.isEmpty()) {
            int vertex = stack.pop();
            result.add(vertex);

            // é€†åºæ·»åŠ é‚»æ¥é¡¶ç‚¹ï¼Œä¿è¯éå†é¡ºåºä¸é€’å½’ç‰ˆä¸€è‡´
            List<Integer> neighbors = graph.getNeighbors(vertex);
            Collections.reverse(neighbors);
            for (int neighbor : neighbors) {
                if (!visited[neighbor]) {
                    visited[neighbor] = true;
                    stack.push(neighbor);
                }
            }
        }
        return result;
    }

    // å¹¿åº¦ä¼˜å…ˆæœç´¢(BFS)
    public static List<Integer> bfs(GraphList graph, int startVertex) {
        List<Integer> result = new ArrayList<>();
        if (startVertex < 0 || startVertex >= graph.getNumVertices()) {
            return result;
        }

        boolean[] visited = new boolean[graph.getNumVertices()];
        Queue<Integer> queue = new LinkedList<>();

        queue.add(startVertex);
        visited[startVertex] = true;

        while (!queue.isEmpty()) {
            int vertex = queue.poll();
            result.add(vertex);

            for (int neighbor : graph.getNeighbors(vertex)) {
                if (!visited[neighbor]) {
                    visited[neighbor] = true;
                    queue.add(neighbor);
                }
            }
        }
        return result;
    }
}
```

### 3. æœ€çŸ­è·¯å¾„ç®—æ³•

#### Dijkstraç®—æ³•
```java
public class ShortestPath {
    // Dijkstraç®—æ³•ï¼šå•æºæœ€çŸ­è·¯å¾„ï¼ˆæ— æƒå›¾æˆ–éè´Ÿæƒå›¾ï¼‰
    public static int[] dijkstra(GraphList graph, int startVertex) {
        int numVertices = graph.getNumVertices();
        int[] distances = new int[numVertices]; // è·ç¦»æ•°ç»„
        boolean[] visited = new boolean[numVertices]; // è®¿é—®æ ‡è®°
        int[] predecessors = new int[numVertices]; // å‰é©±èŠ‚ç‚¹

        // åˆå§‹åŒ–
        Arrays.fill(distances, Integer.MAX_VALUE);
        Arrays.fill(predecessors, -1);
        distances[startVertex] = 0;

        for (int i = 0; i < numVertices - 1; i++) {
            // æ‰¾åˆ°è·ç¦»æœ€è¿‘çš„æœªè®¿é—®é¡¶ç‚¹
            int minVertex = findMinDistance(distances, visited);
            visited[minVertex] = true;

            // æ›´æ–°é‚»æ¥é¡¶ç‚¹çš„è·ç¦»
            for (int neighbor : graph.getNeighbors(minVertex)) {
                int weight = graph.getEdgeWeight(minVertex, neighbor);
                if (!visited[neighbor] && distances[minVertex] != Integer.MAX_VALUE &&
                    distances[minVertex] + weight < distances[neighbor]) {
                    distances[neighbor] = distances[minVertex] + weight;
                    predecessors[neighbor] = minVertex;
                }
            }
        }
        return distances;
    }

    // æ‰¾åˆ°è·ç¦»æœ€è¿‘çš„æœªè®¿é—®é¡¶ç‚¹
    private static int findMinDistance(int[] distances, boolean[] visited) {
        int minDistance = Integer.MAX_VALUE;
        int minVertex = -1;

        for (int v = 0; v < distances.length; v++) {
            if (!visited[v] && distances[v] <= minDistance) {
                minDistance = distances[v];
                minVertex = v;
            }
        }
        return minVertex;
    }

    // è·å–æœ€çŸ­è·¯å¾„
    public static List<Integer> getShortestPath(int[] predecessors, int target) {
        List<Integer> path = new ArrayList<>();
        for (int at = target; at != -1; at = predecessors[at]) {
            path.add(at);
        }
        Collections.reverse(path);
        return path;
    }
}
```

### 4. æ‹“æ‰‘æ’åº
```java
public class TopologicalSort {
    // Kahnç®—æ³•å®ç°æ‹“æ‰‘æ’åº
    public static List<Integer> kahnAlgorithm(GraphList graph) {
        int numVertices = graph.getNumVertices();
        List<Integer> result = new ArrayList<>();
        int[] inDegree = new int[numVertices];
        Queue<Integer> queue = new LinkedList<>();

        // è®¡ç®—å…¥åº¦
        for (int i = 0; i < numVertices; i++) {
            for (int neighbor : graph.getNeighbors(i)) {
                inDegree[neighbor]++;
            }
        }

        // å°†å…¥åº¦ä¸º0çš„é¡¶ç‚¹åŠ å…¥é˜Ÿåˆ—
        for (int i = 0; i < numVertices; i++) {
            if (inDegree[i] == 0) {
                queue.add(i);
            }
        }

        // å¤„ç†é˜Ÿåˆ—ä¸­çš„é¡¶ç‚¹
        while (!queue.isEmpty()) {
            int vertex = queue.poll();
            result.add(vertex);

            // å‡å°‘é‚»æ¥é¡¶ç‚¹çš„å…¥åº¦
            for (int neighbor : graph.getNeighbors(vertex)) {
                inDegree[neighbor]--;
                if (inDegree[neighbor] == 0) {
                    queue.add(neighbor);
                }
            }
        }

        // æ£€æŸ¥æ˜¯å¦æœ‰ç¯
        if (result.size() != numVertices) {
            throw new IllegalArgumentException("å›¾ä¸­å­˜åœ¨ç¯ï¼Œæ— æ³•è¿›è¡Œæ‹“æ‰‘æ’åº");
        }

        return result;
    }
}
```

## ğŸ“Š å¤æ‚åº¦åˆ†æ

### å›¾çš„è¡¨ç¤ºæ–¹æ³•æ¯”è¾ƒ
| æ“ä½œ | é‚»æ¥çŸ©é˜µ | é‚»æ¥è¡¨ | è¯´æ˜ |
|------|----------|--------|------|
| å­˜å‚¨ç©ºé—´ | O(VÂ²) | O(V+E) | Væ˜¯é¡¶ç‚¹æ•°ï¼ŒEæ˜¯è¾¹æ•° |
| æ·»åŠ è¾¹ | O(1) | O(1) | é‚»æ¥è¡¨åœ¨é“¾è¡¨å¤´éƒ¨æ·»åŠ  |
| åˆ é™¤è¾¹ | O(1) | O(degree(V)) | é‚»æ¥è¡¨éœ€éå†é¡¶ç‚¹çš„é‚»æ¥è¡¨ |
| æ£€æŸ¥è¾¹æ˜¯å¦å­˜åœ¨ | O(1) | O(degree(V)) | é‚»æ¥çŸ©é˜µç›´æ¥è®¿é—®ï¼Œé‚»æ¥è¡¨éœ€éå† |
| è·å–æ‰€æœ‰é‚»æ¥é¡¶ç‚¹ | O(V) | O(degree(V)) | é‚»æ¥çŸ©é˜µéœ€éå†æ•´è¡Œ |

### å›¾çš„ç®—æ³•å¤æ‚åº¦
| ç®—æ³• | æ—¶é—´å¤æ‚åº¦ | ç©ºé—´å¤æ‚åº¦ | è¯´æ˜ |
|------|------------|------------|------|
| DFS(é€’å½’) | O(V+E) | O(V) | é€’å½’æ ˆå’Œè®¿é—®æ ‡è®° |
| DFS(éé€’å½’) | O(V+E) | O(V) | æ ˆå’Œè®¿é—®æ ‡è®° |
| BFS | O(V+E) | O(V) | é˜Ÿåˆ—å’Œè®¿é—®æ ‡è®° |
| Dijkstra(æ•°ç»„) | O(VÂ²) | O(V) | é€‚ç”¨äºç¨ å¯†å›¾ |
| Dijkstra(å †) | O((V+E)logV) | O(V) | é€‚ç”¨äºç¨€ç–å›¾ |
| Floyd-Warshall | O(VÂ³) | O(VÂ²) | å¤šæºæœ€çŸ­è·¯å¾„ |
| Primç®—æ³• | O(ElogV) | O(V) | æœ€å°ç”Ÿæˆæ ‘ |
| Kruskalç®—æ³• | O(ElogE) | O(V) | æœ€å°ç”Ÿæˆæ ‘ï¼Œé€‚åˆç¨€ç–å›¾ |
| æ‹“æ‰‘æ’åº | O(V+E) | O(V) | Kahnç®—æ³• |

## ğŸ” åº”ç”¨åœºæ™¯

1. **ç¤¾äº¤ç½‘ç»œåˆ†æ**ï¼šç”¨æˆ·ä½œä¸ºé¡¶ç‚¹ï¼Œå…³ç³»ä½œä¸ºè¾¹ï¼Œåˆ†æç¤¾åŒºç»“æ„å’Œå½±å“åŠ›
2. **è·¯çº¿è§„åˆ’ç³»ç»Ÿ**ï¼šå¦‚Google Mapsä¸­çš„æœ€çŸ­è·¯å¾„è®¡ç®—
3. **ç½‘ç»œçˆ¬è™«**ï¼šä½¿ç”¨BFSéå†ç½‘é¡µé“¾æ¥ï¼Œæ„å»ºç½‘ç«™åœ°å›¾
4. **ç”µè·¯è®¾è®¡**ï¼šè¡¨ç¤ºç”µå­å…ƒä»¶å’Œè¿æ¥å…³ç³»ï¼ŒéªŒè¯ç”µè·¯å®Œæ•´æ€§
5. **é¡¹ç›®ç®¡ç†**ï¼šPERTå›¾ç”¨äºä»»åŠ¡è°ƒåº¦å’Œå…³é”®è·¯å¾„åˆ†æ
6. **æ¨èç³»ç»Ÿ**ï¼šåŸºäºç”¨æˆ·-ç‰©å“äºŒåˆ†å›¾è¿›è¡ŒååŒè¿‡æ»¤
7. **ç¼–è¯‘å™¨è®¾è®¡**ï¼šè¯­æ³•åˆ†æä¸­çš„ä¾èµ–å›¾å’Œæ‹“æ‰‘æ’åº
8. **ç‰©æµä¼˜åŒ–**ï¼šè¿è¾“ç½‘ç»œä¸­çš„æœ€ä¼˜è·¯å¾„å’Œèµ„æºåˆ†é…
9. **ç¥ç»ç½‘ç»œ**ï¼šç¥ç»å…ƒä½œä¸ºé¡¶ç‚¹ï¼Œçªè§¦ä½œä¸ºè¾¹çš„å¤æ‚å›¾ç»“æ„
10. **æ¸¸æˆå¼€å‘**ï¼šAIè·¯å¾„findingã€åœ°å›¾å¯¼èˆªå’Œåœºæ™¯æ„å»º

## âš ï¸ æ³¨æ„äº‹é¡¹

1. **è¡¨ç¤ºæ–¹æ³•é€‰æ‹©**ï¼š
   - ç¨ å¯†å›¾ï¼ˆè¾¹æ•°æ¥è¿‘VÂ²ï¼‰é€‚åˆé‚»æ¥çŸ©é˜µ
   - ç¨€ç–å›¾ï¼ˆè¾¹æ•°æ¥è¿‘Vï¼‰é€‚åˆé‚»æ¥è¡¨
   - è€ƒè™‘æ“ä½œé¢‘ç‡ï¼šé¢‘ç¹åˆ¤æ–­è¾¹æ˜¯å¦å­˜åœ¨é€‰é‚»æ¥çŸ©é˜µï¼Œé¢‘ç¹éå†é‚»æ¥é¡¶ç‚¹é€‰é‚»æ¥è¡¨

2. **ç¯çš„å¤„ç†**ï¼š
   - æ— ç¯å›¾å¯ä½¿ç”¨æ‹“æ‰‘æ’åº
   - æ£€æµ‹ç¯çš„å­˜åœ¨å¯¹è®¸å¤šç®—æ³•è‡³å…³é‡è¦
   - æœ‰ç¯å›¾ä¸­æŸäº›ç®—æ³•ï¼ˆå¦‚Dijkstraï¼‰å¯èƒ½å¤±æ•ˆ

3. **æœ‰å‘å›¾ä¸æ— å‘å›¾**ï¼š
   - å®ç°æ—¶éœ€æ˜ç¡®åŒºåˆ†ï¼Œæ— å‘å›¾éœ€å¯¹ç§°å¤„ç†è¾¹
   - æœ‰å‘å›¾çš„å…¥åº¦å’Œå‡ºåº¦æ˜¯ä¸åŒæ¦‚å¿µ

4. **å¤§å‹å›¾çš„æŒ‘æˆ˜**ï¼š
   - å†…å­˜é™åˆ¶ï¼šå¯èƒ½éœ€è¦å¤–éƒ¨å­˜å‚¨æˆ–åˆ†å¸ƒå¼å›¾å¤„ç†
   - è®¡ç®—å¤æ‚åº¦ï¼šæŸäº›ç®—æ³•åœ¨å¤§å‹å›¾ä¸Šä¸å¯è¡Œ
   - å¯è€ƒè™‘è¿‘ä¼¼ç®—æ³•æˆ–å¯å‘å¼æ–¹æ³•

5. **æƒé‡å¤„ç†**ï¼š
   - è´Ÿæƒé‡ä¼šå½±å“æŸäº›ç®—æ³•ï¼ˆå¦‚Dijkstraï¼‰çš„æ­£ç¡®æ€§
   - è´Ÿæƒç¯ä¼šä½¿æœ€çŸ­è·¯å¾„é—®é¢˜æ— è§£

6. **è¿é€šæ€§è€ƒè™‘**ï¼š
   - éè¿é€šå›¾éœ€å¤šæ¬¡éå†
   - å¤„ç†è¿é€šåˆ†é‡æ—¶éœ€ç‰¹åˆ«æ³¨æ„

## ğŸ“ æœ€ä½³å®è·µ

1. **é€‰æ‹©åˆé€‚çš„å›¾å®ç°**ï¼š
   ```java
   // ç¨€ç–å›¾é€‰æ‹©é‚»æ¥è¡¨
   Graph graph = new GraphList(1000, false);
   
   // ç¨ å¯†å›¾æˆ–éœ€è¦é¢‘ç¹åˆ¤æ–­è¾¹æ˜¯å¦å­˜åœ¨æ—¶é€‰æ‹©é‚»æ¥çŸ©é˜µ
   Graph denseGraph = new GraphMatrix(100, false);
   ```

2. **å›¾ç®—æ³•é€‰æ‹©æŒ‡å—**ï¼š
   - éå†æ‰€æœ‰é¡¶ç‚¹ï¼šDFSæˆ–BFSï¼ˆO(V+E)ï¼‰
   - å•æºæœ€çŸ­è·¯å¾„ï¼šDijkstra(éè´Ÿæƒ)æˆ–Bellman-Ford(è´Ÿæƒ)
   - å¤šæºæœ€çŸ­è·¯å¾„ï¼šFloyd-Warshallæˆ–å¤šæ¬¡Dijkstra
   - æœ€å°ç”Ÿæˆæ ‘ï¼šPrim(ç¨ å¯†å›¾)æˆ–Kruskal(ç¨€ç–å›¾)
   - æœ‰å‘æ— ç¯å›¾æ’åºï¼šæ‹“æ‰‘æ’åº

3. **æ€§èƒ½ä¼˜åŒ–æŠ€å·§**ï¼š
   - ä½¿ç”¨é‚»æ¥è¡¨æ—¶ï¼Œä¸ºé¢‘ç¹è®¿é—®çš„é¡¶ç‚¹é¢„åˆ†é…ç©ºé—´
   - Dijkstraç®—æ³•ä½¿ç”¨ä¼˜å…ˆé˜Ÿåˆ—ä¼˜åŒ–
   - å¤§å‹å›¾è€ƒè™‘å¹¶è¡Œå¤„ç†æˆ–åˆ†å¸ƒå¼è®¡ç®—
   - ä½¿ç”¨ä½è¿ç®—ä¼˜åŒ–è®¿é—®æ ‡è®°æ•°ç»„

4. **å†…å­˜ç®¡ç†**ï¼š
   - å¯¹äºè¶…å¤§å›¾ï¼Œè€ƒè™‘ä½¿ç”¨å‹ç¼©å­˜å‚¨æˆ–å¤–éƒ¨å­˜å‚¨
   - æŒ‰éœ€åŠ è½½å­å›¾è€Œéä¸€æ¬¡æ€§åŠ è½½æ•´ä¸ªå›¾
   - åŠæ—¶é‡Šæ”¾ä¸å†éœ€è¦çš„å›¾ç»“æ„

5. **é”™è¯¯å¤„ç†**ï¼š
   - æ·»åŠ é¡¶ç‚¹/è¾¹å‰éªŒè¯èŒƒå›´
   - æ‹“æ‰‘æ’åºå‰æ£€æµ‹ç¯
   - å¤„ç†è´Ÿæƒé‡å’Œè´Ÿæƒç¯
   - éè¿é€šå›¾çš„ç‰¹æ®Šå¤„ç†

---

> **å·²å®Œæˆ**ï¼šæœ¬æ–‡æ¡£å·²å®Œå–„ï¼ŒåŒ…å«å›¾æ•°æ®ç»“æ„çš„æ ¸å¿ƒæ¦‚å¿µã€ä¸¤ç§è¡¨ç¤ºæ–¹æ³•ï¼ˆé‚»æ¥çŸ©é˜µå’Œé‚»æ¥è¡¨ï¼‰ã€å¸¸ç”¨ç®—æ³•å®ç°ï¼ˆDFS/BFS/æœ€çŸ­è·¯å¾„/æ‹“æ‰‘æ’åºï¼‰ã€å¤æ‚åº¦åˆ†æã€åº”ç”¨åœºæ™¯å’Œæœ€ä½³å®è·µï¼Œå¯ä½œä¸ºå›¾æ•°æ®ç»“æ„å­¦ä¹ çš„å®Œæ•´å‚è€ƒèµ„æ–™
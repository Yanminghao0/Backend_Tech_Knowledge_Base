# 数独求解

> 数独求解是回溯算法的经典应用，要求在9×9的网格中填入数字1-9，使得每行、每列和每个3×3子网格内都包含1-9的所有数字，且不重复。数独游戏起源于18世纪末的瑞士，后在美国发展并在日本发扬光大。

---

## 📋 基本信息
- **类别**：回溯算法、约束满足问题、精确覆盖问题
- **难度**：困难
- **核心思想**：通过回溯尝试在空白格填入数字，并利用约束传播和剪枝减少无效搜索
- **时间复杂度**：O(9^(n))（n为空白格数量，最坏情况）
- **空间复杂度**：O(n)（递归栈和状态记录）
- **关键词**：回溯、约束传播、剪枝策略、精确覆盖、递归

## 🎯 问题分析
数独求解的本质是在一个9×9的网格中填充数字，满足以下约束条件：
1. 每行包含1-9的所有数字，不重复
2. 每列包含1-9的所有数字，不重复
3. 每个3×3的子网格（共9个）包含1-9的所有数字，不重复
4. 部分格子已预先填充数字，不可更改

解决数独问题的关键挑战：
- **搜索效率**：空白格数量多时，纯回溯会导致指数级时间复杂度
- **约束检查**：如何高效检查行、列和子网格的约束冲突
- **智能选择**：选择哪个空白格优先填充对搜索效率影响巨大

经典解题思路：
1. **回溯搜索**：尝试在空白格填入有效数字，递归探索直到完成或回溯
2. **约束传播**：利用数独规则减少每个格子的可能取值
3. **启发式选择**：优先选择候选数字最少的格子（最少剩余值启发式）
4. **剪枝优化**：提前排除无效路径，减少搜索空间

## 💻 代码实现
### Java实现（数独求解经典解法）
#### 1. 基础回溯实现
```java
import java.util.*;

public class SudokuSolver {
    public void solveSudoku(char[][] board) {
        if (board == null || board.length == 0) return;
        solve(board);
    }

    private boolean solve(char[][] board) {
        int n = board.length;
        // 遍历每个格子
        for (int row = 0; row < n; row++) {
            for (int col = 0; col < n; col++) {
                // 找到空白格
                if (board[row][col] == '.') {
                    // 尝试填入1-9
                    for (char num = '1'; num <= '9'; num++) {
                        // 检查是否有效
                        if (isValid(board, row, col, num)) {
                            // 填入数字
                            board[row][col] = num;
                            // 递归求解
                            if (solve(board)) {
                                return true;
                            } else {
                                // 回溯
                                board[row][col] = '.';
                            }
                        }
                    }
                    // 如果所有数字都尝试过仍无法解决，返回false
                    return false;
                }
            }
        }
        // 所有格子都已填满
        return true;
    }

    // 检查在(row, col)位置填入num是否有效
    private boolean isValid(char[][] board, int row, int col, char num) {
        int n = board.length;
        // 检查行
        for (int i = 0; i < n; i++) {
            if (board[row][i] == num) return false;
        }

        // 检查列
        for (int i = 0; i < n; i++) {
            if (board[i][col] == num) return false;
        }

        // 检查3×3子网格
        int subgridSize = (int) Math.sqrt(n);
        int startRow = row - row % subgridSize;
        int startCol = col - col % subgridSize;
        for (int i = 0; i < subgridSize; i++) {
            for (int j = 0; j < subgridSize; j++) {
                if (board[startRow + i][startCol + j] == num) return false;
            }
        }

        return true;
    }

    // 打印数独棋盘
    public static void printBoard(char[][] board) {
        for (int i = 0; i < board.length; i++) {
            if (i % 3 == 0 && i != 0) {
                System.out.println("-------------------------");
            }
            for (int j = 0; j < board[0].length; j++) {
                if (j % 3 == 0 && j != 0) {
                    System.out.print(" | ");
                }
                System.out.print(" " + board[i][j]);
            }
            System.out.println();
        }
    }

    public static void main(String[] args) {
        SudokuSolver solver = new SudokuSolver();
        char[][] board = {
            {'5','3','.','.','7','.','.','.','.'},
            {'6','.','.','1','9','5','.','.','.'},
            {'.','9','8','.','.','.','.','6','.'},
            {'8','.','.','.','6','.','.','.','3'},
            {'4','.','.','8','.','3','.','.','1'},
            {'7','.','.','.','2','.','.','.','6'},
            {'.','6','.','.','.','.','2','8','.'},
            {'.','.','.','4','1','9','.','.','5'},
            {'.','.','.','.','8','.','.','7','9'}
        };

        System.out.println("原始数独：");
        printBoard(board);

        if (solver.solveSudoku(board)) {
            System.out.println("\n求解结果：");
            printBoard(board);
        } else {
            System.out.println("\n该数独无解！");
        }
    }
}
```

#### 2. 优化回溯实现（带剪枝策略）
```java
import java.util.*;

public class SudokuSolverOptimized {
    // 使用位集记录每行、每列和每个子网格的数字占用情况
    private BitSet[] rows; // 每行已使用的数字
    private BitSet[] cols; // 每列已使用的数字
    private BitSet[] subgrids; // 每个子网格已使用的数字
    private List<int[]> emptyCells; // 空白格位置列表
    private boolean solved; // 是否已找到解

    public void solveSudoku(char[][] board) {
        int n = board.length;
        int subgridSize = (int) Math.sqrt(n);

        // 初始化位集
        rows = new BitSet[n];
        cols = new BitSet[n];
        subgrids = new BitSet[n];
        for (int i = 0; i < n; i++) {
            rows[i] = new BitSet(n + 1);
            cols[i] = new BitSet(n + 1);
            subgrids[i] = new BitSet(n + 1);
        }

        emptyCells = new ArrayList<>();

        // 初始化棋盘状态
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                if (board[i][j] == '.') {
                    emptyCells.add(new int[]{i, j});
                } else {
                    int num = board[i][j] - '0';
                    int subgrid = (i / subgridSize) * subgridSize + j / subgridSize;
                    rows[i].set(num);
                    cols[j].set(num);
                    subgrids[subgrid].set(num);
                }
            }
        }

        // 按空白格候选数字数量排序，优先处理候选少的格子（最少剩余值启发式）
        emptyCells.sort(Comparator.comparingInt(this::countCandidates));

        solved = false;
        backtrack(board, 0);
    }

    // 计算空白格的候选数字数量
    private int countCandidates(int[] cell) {
        int row = cell[0], col = cell[1];
        int subgrid = (row / 3) * 3 + col / 3;
        BitSet used = new BitSet();
        used.or(rows[row]);
        used.or(cols[col]);
        used.or(subgrids[subgrid]);
        return 9 - used.cardinality();
    }

    // 获取空白格的候选数字
    private List<Integer> getCandidates(int[] cell) {
        int row = cell[0], col = cell[1];
        int subgrid = (row / 3) * 3 + col / 3;
        List<Integer> candidates = new ArrayList<>();

        for (int num = 1; num <= 9; num++) {
            if (!rows[row].get(num) && !cols[col].get(num) && !subgrids[subgrid].get(num)) {
                candidates.add(num);
            }
        }
        return candidates;
    }

    private void backtrack(char[][] board, int index) {
        if (solved) return;
        if (index == emptyCells.size()) {
            solved = true;
            return;
        }

        int[] cell = emptyCells.get(index);
        int row = cell[0], col = cell[1];
        int subgrid = (row / 3) * 3 + col / 3;

        // 获取并尝试所有候选数字
        List<Integer> candidates = getCandidates(cell);
        for (int num : candidates) {
            // 放置数字
            board[row][col] = (char) ('0' + num);
            rows[row].set(num);
            cols[col].set(num);
            subgrids[subgrid].set(num);

            // 递归回溯
            backtrack(board, index + 1);

            if (solved) return;

            // 撤销放置
            board[row][col] = '.';
            rows[row].clear(num);
            cols[col].clear(num);
            subgrids[subgrid].clear(num);
        }
    }
}
```

## 📊 剪枝策略
数独求解的效率很大程度上依赖于剪枝策略，常用优化方法包括：

### 1. 最少剩余值启发式（MRV）
- **原理**：优先选择候选数字最少的空白格进行填充
- **实现**：计算每个空白格的可用数字数量，按升序排序
- **效果**：减少分支因子，更早地发现矛盾
- **代码示例**：
  ```java
  emptyCells.sort(Comparator.comparingInt(this::countCandidates));
  ```

### 2. 约束传播
- **原理**：填入一个数字后，立即更新相关行、列和子网格的约束
- **实现**：使用位集记录每行、每列和子网格的已用数字
- **优势**：将冲突检查从O(n)降为O(1)，大幅提高效率

### 3. 前向检查
- **原理**：在填入数字后，检查相关空白格是否还有可用数字
- **实现**：对受影响的空白格进行候选数字检查
- **效果**：提前发现无效路径，避免不必要的递归

### 4. 度启发式
- **原理**：优先选择影响最大的空白格（与最多空白格相关联）
- **实现**：计算每个空白格所在行、列和子网格的空白格数量
- **适用场景**：当多个空白格有相同数量的候选数字时使用

### 5. 价值排序
- **原理**：按某种顺序尝试候选数字，如升序或降序
- **实现**：对候选数字排序后尝试
- **效果**：在有多个解时，可控制解的顺序

## 🔍 经典题目
| 题目 | 难度 | 考点 | 链接 |
|------|------|------|------|
| 解数独 | 困难 | 基础回溯+剪枝 | [LeetCode 37](https://leetcode-cn.com/problems/sudoku-solver/) |
| 有效的数独 | 中等 | 数独验证 | [LeetCode 36](https://leetcode-cn.com/problems/valid-sudoku/) |
| 不同路径 III | 困难 | 带约束的路径搜索 | [LeetCode 980](https://leetcode-cn.com/problems/unique-paths-iii/) |
| 矩阵中的最长递增路径 | 困难 | 记忆化搜索 | [LeetCode 329](https://leetcode-cn.com/problems/longest-increasing-path-in-a-matrix/) |
| 黄金矿工 | 中等 | 深度优先搜索 | [LeetCode 1219](https://leetcode-cn.com/problems/path-with-maximum-gold/) |

## ⚠️ 注意事项
1. **数据结构选择**：使用位集(BitSet)比布尔数组更高效地记录数字占用状态
2. **空白格排序**：对空白格排序可显著提高剪枝效率，减少搜索树深度
3. **递归终止条件**：找到一个解后立即终止所有递归，提高效率
4. **数独变体**：注意处理不同大小的数独（如4×4、16×16）和特殊规则数独
5. **无解判断**：实现时需考虑数独无解的情况
6. **约束检查**：确保行、列和子网格的约束都被正确检查
7. **回溯状态恢复**：撤销选择时，确保所有状态变量都被正确恢复
8. **初始状态验证**：在求解前验证初始数独是否有效
9. **性能优化**：对于极难数独，可能需要更高级的算法如舞蹈链(DLX)
10. **多解问题**：标准数独只有唯一解，但算法可扩展为寻找所有解

## 🎓 最佳实践
- **状态表示优化**：使用位运算或位集代替数组记录状态，提高效率
- **搜索顺序优化**：结合MRV和度启发式，优化空白格选择顺序
- **约束传播**：尽可能在递归前进行约束传播，减少搜索空间
- **记忆化**：对于重复出现的子问题，考虑使用记忆化存储结果
- **非递归实现**：复杂数独可考虑使用迭代回溯，避免栈溢出
- **并行搜索**：在多核环境下，可尝试并行探索不同的候选数字
- **算法对比**：了解舞蹈链(DLX)算法，对比其与回溯法的适用场景
- **实际应用**：将数独求解思想应用于其他约束满足问题，如N皇后、地图着色

---
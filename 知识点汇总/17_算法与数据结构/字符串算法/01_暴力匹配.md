# 暴力匹配

> 暴力匹配算法（Brute Force）是最简单直观的字符串匹配算法，也称为朴素匹配算法，通过逐个字符比较来查找模式串在主串中的位置。

---

## 📋 基本信息

### 定义
暴力匹配算法是一种简单的字符串匹配方法，它将模式串与主串中的所有可能位置进行逐一比较，直到找到匹配或遍历完整个主串。

### 核心思想
从主串的第一个字符开始，将主串与模式串的字符逐个比较；如果匹配失败，则回溯到主串的下一个字符，重新开始比较模式串的第一个字符。

### 与其他算法对比
| 算法 | 时间复杂度(平均) | 时间复杂度(最坏) | 空间复杂度 | 特点 |
|------|------------------|------------------|------------|------|
| 暴力匹配 | O(m+n) | O(m*n) | O(1) | 简单直观，无需预处理 |
| KMP算法 | O(m+n) | O(m+n) | O(n) | 利用前缀函数避免回溯 |
| Boyer-Moore | O(m/n) | O(m*n) | O(k) | 实际应用中效率最高 |
| Rabin-Karp | O(m+n) | O(m*n) | O(1) | 基于哈希值比较 |

---

## 🎯 算法原理

### 基本步骤
1. 将模式串P与主串T的起始位置对齐
2. 逐个比较P和T中的对应字符
3. 如果所有字符匹配成功，则返回匹配起始位置
4. 如果出现不匹配字符，则将模式串向右移动一位，重复步骤2
5. 如果模式串到达主串末尾仍未匹配，则返回匹配失败

### 图解说明
```
主串: A B C A B D A B C A B C
模式串: A B C A B C

第1次比较:
A B C A B D A B C A B C
A B C A B C
      ↑ 不匹配(D vs C)

第2次比较(右移1位):
A B C A B D A B C A B C
  A B C A B C
   ↑ 不匹配(B vs A)
...

第6次比较:
A B C A B D A B C A B C
          A B C A B C
                    ↑ 完全匹配
返回起始位置: 6
```

---

## 💻 代码实现

### 基本实现
```python
def brute_force_search(text, pattern):
    """
    暴力匹配算法实现
    :param text: 主串
    :param pattern: 模式串
    :return: 匹配起始位置，未找到返回-1
    """
    n = len(text)
    m = len(pattern)
    
    # 主串长度小于模式串，直接返回-1
    if n < m:
        return -1
    
    # 遍历主串的每个可能起始位置
    for i in range(n - m + 1):
        # 检查从i开始的子串是否与模式串匹配
        match = True
        for j in range(m):
            if text[i + j] != pattern[j]:
                match = False
                break
        if match:
            return i
    
    return -1
```

### 优化实现（添加计数和早期退出）
```python
def optimized_brute_force(text, pattern):
    """
    优化的暴力匹配算法，添加比较计数和早期退出
    :param text: 主串
    :param pattern: 模式串
    :return: (匹配起始位置, 比较次数)，未找到返回(-1, 比较次数)
    """
    n = len(text)
    m = len(pattern)
    comparisons = 0
    
    if n < m:
        return -1, 0
    
    for i in range(n - m + 1):
        j = 0
        while j < m:
            comparisons += 1
            if text[i + j] != pattern[j]:
                break
            j += 1
        if j == m:
            return i, comparisons
    
    return -1, comparisons
```

### 带调试输出的实现
```python
def brute_force_with_debug(text, pattern):
    """
    带调试输出的暴力匹配算法
    :param text: 主串
    :param pattern: 模式串
    :return: 匹配起始位置，未找到返回-1
    """
    n = len(text)
    m = len(pattern)
    
    if n < m:
        print("主串长度小于模式串，无法匹配")
        return -1
    
    print(f"主串: {text}")
    print(f"模式串: {pattern}")
    
    for i in range(n - m + 1):
        print(f"\n尝试匹配位置 {i}:")
        print(f"主串子串: {text[i:i+m]}")
        print(f"模式串:    {pattern}")
        
        match = True
        for j in range(m):
            if text[i + j] != pattern[j]:
                print(f"不匹配位置: 主串[{i+j}]='{text[i+j]}', 模式串[{j}]='{pattern[j]}'")
                match = False
                break
        
        if match:
            print(f"匹配成功！起始位置: {i}")
            return i
    
    print("遍历完主串，未找到匹配")
    return -1
```

---

## 📊 复杂度分析

### 时间复杂度
- **最佳情况**: O(m)，其中m为模式串长度。当模式串的第一个字符就与主串不匹配时，只需比较m次。
- **平均情况**: O(m+n)，其中n为主串长度。
- **最坏情况**: O(m*n)，当主串和模式串只有最后一个字符不同时。

### 空间复杂度
- **空间复杂度**: O(1)，只需要常数级别的额外空间。

### 复杂度对比表
| 场景 | 时间复杂度 | 比较次数 | 说明 |
|------|------------|----------|------|
| 最好情况 | O(m) | m | 第一次比较就不匹配 |
| 平均情况 | O(m+n) | (n-m+1)*m/2 | 随机文本中的平均比较次数 |
| 最坏情况 | O(m*n) | (n-m+1)*m | 主串为AAAAA，模式串为AAAB |

---

## 🔍 应用场景

1. **简单文本编辑器**：小型文本编辑器中的查找功能
2. **教学演示**：算法入门教学中展示基本匹配思想
3. **小规模数据处理**：处理短文本或小文件时使用
4. **模式串较长的场景**：当模式串长度接近主串长度时，效率接近最优
5. **硬件实现**：在资源受限的嵌入式系统中实现简单匹配
6. **作为基准算法**：与其他高级算法进行性能对比
7. **调试辅助**：在开发高级匹配算法时作为参考实现

---

## ⚠️ 注意事项

1. **性能问题**：在处理长文本或大量数据时效率低下，不建议使用
2. **回溯开销**：每次匹配失败都要回溯到主串的下一个字符，造成大量重复比较
3. **边界条件**：需特别处理模式串为空、主串长度小于模式串等特殊情况
4. **字符编码**：对于多字节字符集（如UTF-8），需确保比较的是字符而非字节
5. **内存占用**：虽然空间复杂度低，但对于极长字符串，仍需注意内存使用
6. **特殊字符处理**：对于包含通配符或特殊正则符号的模式串需要额外处理

---

## 🎓 最佳实践

1. **小规模场景使用**：只在小数据量或教学场景中使用该算法
2. **添加早期退出**：在发现不匹配时立即退出内层循环，减少不必要比较
3. **预处理过滤**：先检查模式串长度是否大于主串，避免无效计算
4. **结合启发式**：对于实际应用，可先检查模式串首字符是否存在于主串中
5. **使用内置函数**：在实际编程中，优先使用语言内置的高效字符串匹配函数
6. **性能测试**：在决定使用前，对目标数据进行性能测试，确认是否满足需求

---

## 📚 扩展阅读
- [维基百科：字符串搜索算法](https://en.wikipedia.org/wiki/String-searching_algorithm)
- 《算法导论》第32章：字符串匹配
- 《编程珠玑》第13章：文本匹配算法
- [GeeksforGeeks: Brute Force algorithm for Pattern Searching](https://www.geeksforgeeks.org/naive-algorithm-for-pattern-searching/)
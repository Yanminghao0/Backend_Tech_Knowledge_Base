# ç½‘ç»œæµ

> ç½‘ç»œæµæ˜¯å›¾è®ºä¸­çš„ä¸€ä¸ªé‡è¦æ¦‚å¿µï¼Œç”¨äºæè¿°åœ¨æœ‰å‘å›¾ä¸­ä»æºç‚¹åˆ°æ±‡ç‚¹çš„æµé‡ä¼ è¾“é—®é¢˜ã€‚ç½‘ç»œæµç®—æ³•å¹¿æ³›åº”ç”¨äºèµ„æºåˆ†é…ã€è·¯å¾„ä¼˜åŒ–å’Œæµé‡æ§åˆ¶ç­‰é¢†åŸŸã€‚

---

## ğŸ“Š åŸºæœ¬ä¿¡æ¯

### å®šä¹‰
ç½‘ç»œæµï¼ˆNetwork Flowï¼‰æ˜¯æŒ‡åœ¨ä¸€ä¸ªæœ‰å‘å›¾ï¼ˆç§°ä¸ºæµç½‘ç»œï¼‰ä¸­ï¼Œä»æºç‚¹ï¼ˆSourceï¼‰åˆ°æ±‡ç‚¹ï¼ˆSinkï¼‰çš„æµé‡ä¼ è¾“è¿‡ç¨‹ã€‚æµç½‘ç»œé€šå¸¸åŒ…å«ä»¥ä¸‹è¦ç´ ï¼š
- **æºç‚¹ï¼ˆSï¼‰**ï¼šå”¯ä¸€çš„å…¥åº¦ä¸º0çš„é¡¶ç‚¹ï¼Œæ˜¯æµé‡çš„èµ·ç‚¹
- **æ±‡ç‚¹ï¼ˆTï¼‰**ï¼šå”¯ä¸€çš„å‡ºåº¦ä¸º0çš„é¡¶ç‚¹ï¼Œæ˜¯æµé‡çš„ç»ˆç‚¹
- **å®¹é‡ï¼ˆCapacityï¼‰**ï¼šæ¯æ¡è¾¹(u, v)éƒ½æœ‰ä¸€ä¸ªéè´Ÿæ•´æ•°å®¹é‡c(u, v)ï¼Œè¡¨ç¤ºè¯¥è¾¹å¯ä¼ è¾“çš„æœ€å¤§æµé‡
- **æµé‡ï¼ˆFlowï¼‰**ï¼šæ¯æ¡è¾¹(u, v)ä¸Šçš„å®é™…æµé‡f(u, v)ï¼Œæ»¡è¶³å®¹é‡é™åˆ¶å’Œæµé‡å®ˆæ’

### æ ¸å¿ƒæ€æƒ³
ç½‘ç»œæµçš„æ ¸å¿ƒæ€æƒ³åŸºäºä»¥ä¸‹åŸåˆ™ï¼š
1. **å®¹é‡é™åˆ¶**ï¼šå¯¹äºæ¯æ¡è¾¹(u, v)ï¼Œæµé‡f(u, v) â‰¤ å®¹é‡c(u, v)
2. **æµé‡å®ˆæ’**ï¼šå¯¹äºé™¤æºç‚¹å’Œæ±‡ç‚¹å¤–çš„æ‰€æœ‰é¡¶ç‚¹ï¼Œæµå…¥æµé‡ç­‰äºæµå‡ºæµé‡
3. **åå¯¹ç§°æ€§**ï¼šf(u, v) = -f(v, u)ï¼ˆåå‘è¾¹çš„æµé‡æ˜¯æ­£å‘è¾¹æµé‡çš„ç›¸åæ•°ï¼‰
4. **æœ€å¤§æµé—®é¢˜**ï¼šå¯»æ‰¾ä»æºç‚¹åˆ°æ±‡ç‚¹çš„æœ€å¤§å¯èƒ½æµé‡

### ä¸å…¶ä»–å›¾ç®—æ³•çš„å…³ç³»
| é—®é¢˜ç±»å‹ | æ ¸å¿ƒç®—æ³• | æ—¶é—´å¤æ‚åº¦ | åº”ç”¨åœºæ™¯ | ç‰¹ç‚¹ |
|----------|----------|------------|----------|------|
| æœ€å¤§æµ | Ford-Fulkerson | O(FÂ·E) | èµ„æºåˆ†é… | Fä¸ºæœ€å¤§æµé‡ |
| æœ€å¤§æµ | Edmonds-Karp | O(VÂ·EÂ²) | ç½‘ç»œè§„åˆ’ | åŸºäºBFSçš„å®ç° |
| æœ€å¤§æµ | Dinic | O(VÂ²Â·E) | å¤§è§„æ¨¡ç½‘ç»œ | é«˜æ•ˆçš„å±‚æ¬¡å›¾å®ç° |
| æœ€å°å‰² | Max-Flow Min-Cut | O(VÂ·EÂ²) | ç½‘ç»œåˆ†å‰² | ä¸æœ€å¤§æµç­‰ä»· |
| æœ€å°è´¹ç”¨æµ | Successive Shortest Path | O(FÂ·(V+E)logV) | æˆæœ¬ä¼˜åŒ– | ç»“åˆæœ€çŸ­è·¯å¾„ |

---

## ğŸ¯ ç®—æ³•åŸç†

### åŸºæœ¬æ¦‚å¿µ
- **å¯è¡Œæµ**ï¼šæ»¡è¶³å®¹é‡é™åˆ¶å’Œæµé‡å®ˆæ’çš„æµ
- **æ®‹ç•™ç½‘ç»œ**ï¼šè¡¨ç¤ºå‰©ä½™å®¹é‡çš„è¾…åŠ©ç½‘ç»œï¼ŒåŒ…å«æ­£å‘è¾¹å’Œåå‘è¾¹
- **å¢å¹¿è·¯å¾„**ï¼šæ®‹ç•™ç½‘ç»œä¸­ä»æºç‚¹åˆ°æ±‡ç‚¹çš„è·¯å¾„ï¼Œå¯ç”¨äºå¢åŠ æ€»æµé‡
- **å‰²**ï¼šå°†æµç½‘ç»œåˆ†ä¸ºSå’ŒTä¸¤ä¸ªå­é›†çš„è¾¹é›†åˆï¼Œå…¶ä¸­æºç‚¹åœ¨Sï¼Œæ±‡ç‚¹åœ¨T
- **æœ€å°å‰²**ï¼šå®¹é‡ä¹‹å’Œæœ€å°çš„å‰²ï¼Œæ ¹æ®æœ€å¤§æµæœ€å°å‰²å®šç†ï¼Œå…¶å®¹é‡ç­‰äºæœ€å¤§æµ

### ä¸»è¦ç®—æ³•
**Ford-Fulkersonæ–¹æ³•æ­¥éª¤ï¼š**
1. åˆå§‹åŒ–æ‰€æœ‰è¾¹çš„æµé‡ä¸º0
2. åœ¨æ®‹ç•™ç½‘ç»œä¸­å¯»æ‰¾å¢å¹¿è·¯å¾„
3. è®¡ç®—å¢å¹¿è·¯å¾„ä¸Šçš„æœ€å°æ®‹ç•™å®¹é‡ï¼ˆç“¶é¢ˆå®¹é‡ï¼‰
4. æ›´æ–°æ®‹ç•™ç½‘ç»œä¸­çš„æµé‡ï¼ˆå¢åŠ æ­£å‘æµé‡ï¼Œå‡å°‘åå‘æµé‡ï¼‰
5. é‡å¤æ­¥éª¤2-4ï¼Œç›´åˆ°ä¸å­˜åœ¨å¢å¹¿è·¯å¾„

**Edmonds-Karpç®—æ³•æ­¥éª¤ï¼š**
1. ä½œä¸ºFord-Fulkersonæ–¹æ³•çš„ç‰¹ä¾‹ï¼Œä½¿ç”¨BFSå¯»æ‰¾æœ€çŸ­å¢å¹¿è·¯å¾„
2. è®¡ç®—è·¯å¾„ç“¶é¢ˆå®¹é‡å¹¶æ›´æ–°æµé‡
3. é‡å¤ç›´è‡³æ— å¢å¹¿è·¯å¾„ï¼Œæ—¶é—´å¤æ‚åº¦ä¼˜åŒ–ä¸ºO(VÂ·EÂ²)

**Dinicç®—æ³•æ­¥éª¤ï¼š**
1. æ„å»ºå±‚æ¬¡å›¾ï¼ˆæŒ‰BFSè·ç¦»åˆ’åˆ†é¡¶ç‚¹å±‚æ¬¡ï¼‰
2. ä½¿ç”¨DFSåœ¨å±‚æ¬¡å›¾ä¸­å¯»æ‰¾é˜»å¡æµï¼ˆæ— æ³•å†å¢åŠ æµé‡çš„æµï¼‰
3. å°†é˜»å¡æµå åŠ åˆ°æ€»æµé‡ä¸Š
4. é‡å¤æ­¥éª¤1-3ï¼Œç›´è‡³æ— æ³•æ„å»ºå±‚æ¬¡å›¾ï¼Œæ—¶é—´å¤æ‚åº¦ä¸ºO(VÂ²Â·E)

### å›¾è§£è¯´æ˜
![ç½‘ç»œæµç¤ºä¾‹](https://upload.wikimedia.org/wikipedia/commons/thumb/b/b5/Max_flow.svg/800px-Max_flow.svg.png)
*å›¾ï¼šç½‘ç»œæµç¤ºä¾‹ï¼Œç®­å¤´æ—æ•°å­—è¡¨ç¤ºï¼ˆæµé‡/å®¹é‡ï¼‰*

---

## ğŸ’» ä»£ç å®ç°

### Edmonds-Karpç®—æ³•å®ç°
```python
from collections import deque

def edmonds_karp(graph, source, sink):
    n = len(graph)
    # åˆå§‹åŒ–æ®‹ç•™ç½‘ç»œï¼Œä½¿ç”¨é‚»æ¥çŸ©é˜µè¡¨ç¤º
    residual_graph = [[0]*n for _ in range(n)]
    for u in range(n):
        for v, capacity in graph[u]:
            residual_graph[u][v] = capacity
    
    max_flow = 0
    parent = [-1]*n  # ç”¨äºå­˜å‚¨å¢å¹¿è·¯å¾„
    
    while bfs(residual_graph, source, sink, parent):
        # æ‰¾åˆ°è·¯å¾„ä¸Šçš„æœ€å°æ®‹ç•™å®¹é‡ï¼ˆç“¶é¢ˆå®¹é‡ï¼‰
        path_flow = float('inf')
        s = sink
        while s != source:
            path_flow = min(path_flow, residual_graph[parent[s]][s])
            s = parent[s]
        
        # æ›´æ–°æœ€å¤§æµé‡
        max_flow += path_flow
        
        # æ›´æ–°æ®‹ç•™ç½‘ç»œ
        v = sink
        while v != source:
            u = parent[v]
            residual_graph[u][v] -= path_flow
            residual_graph[v][u] += path_flow
            v = parent[v]
    
    return max_flow

def bfs(residual_graph, source, sink, parent):
    n = len(residual_graph)
    visited = [False]*n
    queue = deque()
    queue.append(source)
    visited[source] = True
    
    while queue:
        u = queue.popleft()
        for v in range(n):
            if not visited[v] and residual_graph[u][v] > 0:
                queue.append(v)
                visited[v] = True
                parent[v] = u
                if v == sink:
                    return True
    return False

# ç¤ºä¾‹ä½¿ç”¨
if __name__ == "__main__":
    # å›¾çš„é‚»æ¥è¡¨è¡¨ç¤ºï¼šgraph[u] = [(v, capacity), ...]
    graph = [
        [(1, 3), (2, 2)],   # 0 (æºç‚¹)
        [(2, 5), (3, 2)],   # 1
        [(4, 3)],           # 2
        [(2, 1), (4, 1)],   # 3
        []                  # 4 (æ±‡ç‚¹)
    ]
    
    max_flow = edmonds_karp(graph, 0, 4)
    print(f"Edmonds-Karpç®—æ³•è®¡ç®—çš„æœ€å¤§æµ: {max_flow}")
```

### Dinicç®—æ³•å®ç°
```python
from collections import deque

def dinic_max_flow(graph, source, sink):
    n = len(graph)
    level = [0]*n  # é¡¶ç‚¹å±‚æ¬¡
    ptr = [0]*n    # å½“å‰å¼§æŒ‡é’ˆï¼Œä¼˜åŒ–DFS
    
    # æ„å»ºæ®‹ç•™ç½‘ç»œé‚»æ¥è¡¨
    residual_graph = [[] for _ in range(n)]
    for u in range(n):
        for v, capacity in graph[u]:
            residual_graph[u].append({'to': v, 'cap': capacity, 'rev': len(residual_graph[v])})
            residual_graph[v].append({'to': u, 'cap': 0, 'rev': len(residual_graph[u])-1})
    
    def bfs():
        # æ„å»ºå±‚æ¬¡å›¾
        q = deque()
        level[:] = [-1]*n
        level[source] = 0
        q.append(source)
        while q:
            u = q.popleft()
            for edge in residual_graph[u]:
                if edge['cap'] > 0 and level[edge['to']] == -1:
                    level[edge['to']] = level[u] + 1
                    q.append(edge['to'])
                    if edge['to'] == sink:
                        return True
        return False
    
    def dfs(u, flow):
        # å¯»æ‰¾é˜»å¡æµ
        if u == sink:
            return flow
        while ptr[u] < len(residual_graph[u]):
            edge = residual_graph[u][ptr[u]]
            if edge['cap'] > 0 and level[u] < level[edge['to']]:
                min_flow = min(flow, edge['cap'])
                result = dfs(edge['to'], min_flow)
                if result > 0:
                    edge['cap'] -= result
                    residual_graph[edge['to']][edge['rev']]['cap'] += result
                    return result
            ptr[u] += 1
        return 0
    
    max_flow = 0
    while bfs():
        ptr[:] = [0]*n
        while True:
            pushed = dfs(source, float('inf'))
            if pushed == 0:
                break
            max_flow += pushed
    return max_flow

# å¸¦é¡¶ç‚¹æ ‡ç­¾çš„ç½‘ç»œæµè®¡ç®—
def max_flow_with_labels(labels_graph, source_label, sink_label):
    # å°†æ ‡ç­¾æ˜ å°„åˆ°ID
    labels = list(labels_graph.keys())
    label_to_id = {label: i for i, label in enumerate(labels)}
    n = len(labels)
    
    # æ„å»ºIDå›¾
    id_graph = [[] for _ in range(n)]
    for u_label, edges in labels_graph.items():
        u = label_to_id[u_label]
        for v_label, capacity in edges:
            v = label_to_id[v_label]
            id_graph[u].append((v, capacity))
    
    # è®¡ç®—æœ€å¤§æµ
    source = label_to_id[source_label]
    sink = label_to_id[sink_label]
    return dinic_max_flow(id_graph, source, sink)

# ç¤ºä¾‹ä½¿ç”¨
if __name__ == "__main__":
    # å¸¦æ ‡ç­¾çš„ç½‘ç»œæµå›¾
    network = {
        'S': [('A', 3), ('B', 2)],
        'A': [('B', 5), ('C', 2)],
        'B': [('D', 3)],
        'C': [('B', 1), ('D', 1)],
        'D': []
    }
    
    max_flow = max_flow_with_labels(network, 'S', 'D')
    print(f"Dinicç®—æ³•è®¡ç®—çš„æœ€å¤§æµ: {max_flow}")
```

### æœ€å°å‰²å®ç°
```python
def min_cut(graph, source, sink):
    # å…ˆè®¡ç®—æœ€å¤§æµ
    max_flow_val = edmonds_karp(graph, source, sink)
    n = len(graph)
    
    # æ„å»ºæ®‹ç•™ç½‘ç»œ
    residual_graph = [[0]*n for _ in range(n)]
    for u in range(n):
        for v, capacity in graph[u]:
            residual_graph[u][v] = capacity
    
    # BFSå¯»æ‰¾å¯è¾¾é¡¶ç‚¹
    visited = [False]*n
    q = deque([source])
    visited[source] = True
    
    while q:
        u = q.popleft()
        for v in range(n):
            if residual_graph[u][v] > 0 and not visited[v]:
                visited[v] = True
                q.append(v)
    
    # æœ€å°å‰²æ˜¯ä»å¯è¾¾é¡¶ç‚¹åˆ°ä¸å¯è¾¾é¡¶ç‚¹çš„è¾¹
    min_cut_edges = []
    for u in range(n):
        if visited[u]:
            for v, capacity in graph[u]:
                if not visited[v]:
                    min_cut_edges.append((u, v, capacity))
    
    return max_flow_val, min_cut_edges

# ç¤ºä¾‹ä½¿ç”¨
if __name__ == "__main__":
    graph = [
        [(1, 3), (2, 2)],   # 0 (æºç‚¹)
        [(2, 5), (3, 2)],   # 1
        [(4, 3)],           # 2
        [(2, 1), (4, 1)],   # 3
        []                  # 4 (æ±‡ç‚¹)
    ]
    
    flow, cut = min_cut(graph, 0, 4)
    print(f"æœ€å°å‰²å®¹é‡: {flow}")
    print("æœ€å°å‰²è¾¹é›†:", cut)
```

---

## ğŸ“Š å¤æ‚åº¦åˆ†æ

| ç®—æ³• | æ—¶é—´å¤æ‚åº¦ | ç©ºé—´å¤æ‚åº¦ | ä¼˜åŠ¿ | åŠ£åŠ¿ |
|------|------------|------------|------|------|
| Ford-Fulkerson | O(FÂ·E) | O(V + E) | ç®€å•ç›´è§‚ | ä¾èµ–æœ€å¤§æµé‡Fï¼Œå¯èƒ½ä¸æ”¶æ•› |
| Edmonds-Karp | O(VÂ·EÂ²) | O(VÂ²) | ç¨³å®šæ”¶æ•›ï¼Œå®ç°ç®€å• | å¯¹ç¨ å¯†å›¾æ•ˆç‡ä½ |
| Dinic | O(VÂ²Â·E) | O(V + E) | é«˜æ•ˆå¤„ç†å¤§è§„æ¨¡ç½‘ç»œ | å®ç°è¾ƒå¤æ‚ |
| Shortest Augmenting Path | O(FÂ·E) | O(V + E) | é€‚åˆå°æµé‡ç½‘ç»œ | Fè¾ƒå¤§æ—¶æ•ˆç‡ä½ |
| Capacity Scaling | O(EÂ²Â·VÂ·logU) | O(V + E) | é€‚åˆå¤§å®¹é‡ç½‘ç»œ | å®ç°å¤æ‚ |

### å¤æ‚åº¦è¯´æ˜
- **æ—¶é—´å¤æ‚åº¦**ï¼š
  - Edmonds-Karpç®—æ³•ï¼šæ¯æ¬¡BFSè€—æ—¶O(E)ï¼Œæœ€å¤šæ‰§è¡ŒO(VÂ·E)æ¬¡ï¼Œæ€»å¤æ‚åº¦O(VÂ·EÂ²)
  - Dinicç®—æ³•ï¼šå±‚æ¬¡å›¾æ„å»ºO(E)ï¼Œé˜»å¡æµå¯»æ‰¾O(VÂ·E)ï¼Œæœ€å¤šæ„å»ºO(V)å±‚ï¼Œæ€»å¤æ‚åº¦O(VÂ²Â·E)
  - å®é™…åº”ç”¨ä¸­ï¼ŒDinicç®—æ³•é€šå¸¸æ¯”Edmonds-Karpå¿«ä¸€ä¸ªæ•°é‡çº§ä»¥ä¸Š
- **ç©ºé—´å¤æ‚åº¦**ï¼š
  - ä¸»è¦æ¥è‡ªå­˜å‚¨æ®‹ç•™ç½‘ç»œï¼Œé‚»æ¥è¡¨è¡¨ç¤ºä¸ºO(V + E)ï¼Œé‚»æ¥çŸ©é˜µä¸ºO(VÂ²)
- **æ€§èƒ½å½±å“å› ç´ **ï¼š
  - å›¾çš„å¯†åº¦ï¼šç¨€ç–å›¾æ›´é€‚åˆé‚»æ¥è¡¨å®ç°
  - ç½‘ç»œè§„æ¨¡ï¼šDinicç®—æ³•åœ¨å¤§å‹ç½‘ç»œä¸­ä¼˜åŠ¿æ˜æ˜¾
  - å®¹é‡åˆ†å¸ƒï¼šæ•´æ•°å®¹é‡æ¯”æµ®ç‚¹æ•°å®¹é‡è®¡ç®—æ›´å¿«

---

## ğŸ” åº”ç”¨åœºæ™¯

1. **èµ„æºåˆ†é…**ï¼š
   - ä¾›æ°´ç½‘ç»œè®¾è®¡
   - ç”µåŠ›åˆ†é…ç³»ç»Ÿ
   - é€šä¿¡å¸¦å®½åˆ†é…

2. **è¿è¾“é—®é¢˜**ï¼š
   - ç‰©æµç½‘ç»œä¼˜åŒ–
   - èˆªç­è°ƒåº¦ç³»ç»Ÿ
   - å…¬è·¯äº¤é€šæµé‡æ§åˆ¶

3. **ç½‘ç»œä¼˜åŒ–**ï¼š
   - è®¡ç®—æœºç½‘ç»œè·¯ç”±
   - æ•°æ®ä¸­å¿ƒå†·å´ç³»ç»Ÿ
   - ç¤¾äº¤ç½‘ç»œä¿¡æ¯ä¼ æ’­

4. **å·¥ä¸šå·¥ç¨‹**ï¼š
   - ç”Ÿäº§æµç¨‹ä¼˜åŒ–
   - ä¾›åº”é“¾ç®¡ç†
   - å·¥å‚å¸ƒå±€è®¾è®¡

5. **å…¶ä»–é¢†åŸŸ**ï¼š
   - å›¾åƒåˆ†å‰²ï¼ˆæœ€å°å‰²åº”ç”¨ï¼‰
   - é¡¹ç›®è°ƒåº¦ä¸­çš„èµ„æºå¹³è¡¡
   - åŒ¹é…é—®é¢˜ï¼ˆ bipartite matching å¯è½¬åŒ–ä¸ºç½‘ç»œæµï¼‰

---

## âš ï¸ æ³¨æ„äº‹é¡¹

1. **å›¾çš„è¡¨ç¤º**ï¼š
   - ç¨€ç–å›¾ä¼˜å…ˆä½¿ç”¨é‚»æ¥è¡¨ï¼Œç¨ å¯†å›¾å¯è€ƒè™‘é‚»æ¥çŸ©é˜µ
   - é¡¶ç‚¹ç¼–å·åº”è¿ç»­ä»¥æé«˜ç©ºé—´æ•ˆç‡
   - æ®‹ç•™ç½‘ç»œéœ€æ­£ç¡®å¤„ç†åå‘è¾¹

2. **ç®—æ³•é€‰æ‹©**ï¼š
   - å°è§„æ¨¡ç½‘ç»œæˆ–æ•™å­¦ç›®çš„ï¼šEdmonds-Karpç®—æ³•ï¼ˆå®ç°ç®€å•ï¼‰
   - å¤§è§„æ¨¡ç½‘ç»œæˆ–æ€§èƒ½è¦æ±‚é«˜ï¼šDinicç®—æ³•
   - æ•´æ•°å®¹é‡ç½‘ç»œï¼šå¯è€ƒè™‘Capacity Scalingç®—æ³•
   - å¸¦è´¹ç”¨çš„æµé—®é¢˜ï¼šéœ€ä½¿ç”¨æœ€å°è´¹ç”¨æµç®—æ³•

3. **å®ç°ç»†èŠ‚**ï¼š
   - æ®‹ç•™ç½‘ç»œæ›´æ–°æ—¶éœ€åŒæ—¶ä¿®æ”¹æ­£å‘å’Œåå‘è¾¹
   - BFS/DFSå®ç°éœ€é«˜æ•ˆä»¥å¤„ç†å¤§è§„æ¨¡ç½‘ç»œ
   - æ³¨æ„æ•´æ•°æº¢å‡ºé—®é¢˜ï¼ˆå¤§å®¹é‡ç½‘ç»œéœ€ä½¿ç”¨64ä½æ•´æ•°ï¼‰

4. **ç‰¹æ®Šæƒ…å†µå¤„ç†**ï¼š
   - å¤šæºå¤šæ±‡ç½‘ç»œï¼šå¯æ·»åŠ è¶…çº§æºç‚¹å’Œè¶…çº§æ±‡ç‚¹
   - æ— å‘å›¾ï¼šå°†æ¯æ¡è¾¹è§†ä¸ºåŒå‘è¾¹å¤„ç†
   - é¡¶ç‚¹å®¹é‡é™åˆ¶ï¼šæ‹†åˆ†ä¸ºä¸¤ä¸ªé¡¶ç‚¹å’Œä¸€æ¡è¾¹

---

## ğŸ“ æœ€ä½³å®è·µ

1. **ç®—æ³•å®ç°æŠ€å·§**ï¼š
   - Dinicç®—æ³•ä¸­ä½¿ç”¨å½“å‰å¼§ä¼˜åŒ–ï¼ˆptræ•°ç»„ï¼‰å‡å°‘é‡å¤éå†
   - BFSé˜Ÿåˆ—ä½¿ç”¨åŒç«¯é˜Ÿåˆ—æé«˜æ•ˆç‡
   - æ®‹ç•™ç½‘ç»œé‡‡ç”¨é‚»æ¥è¡¨+ç»“æ„ä½“å­˜å‚¨è¾¹ä¿¡æ¯

2. **æ€§èƒ½ä¼˜åŒ–**ï¼š
   - é¢„å¤„ç†ç½‘ç»œï¼Œç§»é™¤æ— æ•ˆè¾¹ï¼ˆå®¹é‡ä¸º0çš„è¾¹ï¼‰
   - ä½¿ç”¨ä½è¿ç®—å’Œç´§å‡‘æ•°æ®ç»“æ„å‡å°‘å†…å­˜å ç”¨
   - å¹¶è¡ŒåŒ–å¤„ç†å¤§å‹ç½‘ç»œçš„å¢å¹¿è·¯å¾„æœç´¢

3. **åº”ç”¨å»ºè®®**ï¼š
   - ç»“åˆé—®é¢˜ç‰¹ç‚¹é€‰æ‹©åˆé€‚çš„ç½‘ç»œæµæ¨¡å‹
   - æœ€å¤§æµé—®é¢˜ä¼˜å…ˆå°è¯•Dinicç®—æ³•
   - å¤æ‚é—®é¢˜è€ƒè™‘ä½¿ç”¨ä¸“ä¸šç½‘ç»œæµåº“ï¼ˆå¦‚LEMONï¼‰

4. **å¸¸è§é”™è¯¯é¿å…**ï¼š
   - å¿½ç•¥åå‘è¾¹çš„æ›´æ–°
   - é”™è¯¯è®¡ç®—ç“¶é¢ˆå®¹é‡
   - æœªæ­£ç¡®å¤„ç†å¤šæºå¤šæ±‡é—®é¢˜
   - æ®‹ç•™ç½‘ç»œåˆå§‹åŒ–é”™è¯¯

---

### ç›¸å…³é“¾æ¥
- [ç½‘ç»œæµ - Wikipedia](https://en.wikipedia.org/wiki/Flow_network)
- [æœ€å¤§æµæœ€å°å‰²å®šç† - Wikipedia](https://en.wikipedia.org/wiki/Max-flow_min-cut_theorem)
- [Edmonds-Karpç®—æ³• - Wikipedia](https://en.wikipedia.org/wiki/Edmonds%E2%80%93Karp_algorithm)
- [Dinicç®—æ³• - Wikipedia](https://en.wikipedia.org/wiki/Dinic%27s_algorithm)
- [ç½‘ç»œæµå¯è§†åŒ–å·¥å…·](https://visualgo.net/en/maxflow)

> **æ›´æ–°æ—¥æœŸ**: 2023-11-15
# 二分图匹配

> 二分图匹配是图论中的重要问题，用于在二分图中寻找最大匹配或完美匹配。它在任务分配、资源调度、网络流等领域有广泛应用，核心算法包括匈牙利算法和Hopcroft-Karp算法。

---

## 📊 基本信息

### 定义
二分图（Bipartite Graph）是指顶点可以分为两个不相交集合U和V，且所有边都连接U中的顶点和V中的顶点的图。二分图匹配是指在二分图中找到一组边，使得每个顶点最多只与一条边关联。

### 核心概念
- **匹配（Matching）**：一组没有公共顶点的边
- **最大匹配（Maximum Matching）**：包含边数最多的匹配
- **完美匹配（Perfect Matching）**：所有顶点都被匹配的匹配
- **增广路径（Augmenting Path）**：从非匹配顶点出发，交替经过非匹配边和匹配边，以非匹配顶点结束的路径
- **顶点覆盖（Vertex Cover）**：覆盖所有边的顶点集合，Konig定理表明二分图中最大匹配大小等于最小顶点覆盖大小

### 与其他图算法的关系
| 算法 | 时间复杂度 | 空间复杂度 | 特点 | 适用场景 |
|------|------------|------------|------|----------|
| 匈牙利算法 | O(VE) | O(V) | 经典算法，实现简单 | 稠密图，小规模匹配 |
| Hopcroft-Karp算法 | O(E√V) | O(V+E) | 基于BFS和DFS，更高效 | 大规模二分图，稀疏图 |
| Ford-Fulkerson方法 | O(F·E) | O(V+E) | 基于最大流 | 二分图匹配转化为最大流问题 |
| 带权二分匹配 | O(V³) | O(V²) | 处理权重匹配问题 | 任务分配问题 |

---

## 🎯 算法原理

### 基本流程
**匈牙利算法步骤**：
1. 初始化所有顶点为未匹配状态
2. 对每个未匹配顶点u∈U，执行DFS寻找增广路径
3. 若找到增广路径，更新匹配集（翻转路径上的边状态）
4. 重复步骤2-3，直到无法找到更多增广路径

**Hopcroft-Karp算法步骤**：
1. 使用BFS构建层次图，将未匹配顶点加入队列
2. 在层次图上执行多轮DFS，寻找多条不相交的增广路径
3. 同时更新所有找到的增广路径，扩大匹配集
4. 重复步骤1-3，直到BFS无法找到增广路径

### 关键概念图解
![二分图匹配示例](https://upload.wikimedia.org/wikipedia/commons/thumb/9/94/MaxBipartiteMatching.svg/800px-MaxBipartiteMatching.svg.png)
*图：二分图最大匹配示例，红线表示匹配边*

### 数据结构选择
- **邻接表**：适合稀疏二分图，存储效率高
- **邻接矩阵**：适合稠密二分图，随机访问快
- **配对数组**：记录每个顶点的匹配对象，如pair_U[u] = v表示U中顶点u匹配V中顶点v
- **距离数组**：Hopcroft-Karp算法中用于构建层次图

---

## 💻 代码实现

### 匈牙利算法实现（邻接表）
```python
def hungarian_algorithm(graph, U_size, V_size):
    """匈牙利算法求解二分图最大匹配
    Args:
        graph: 邻接表表示的二分图，graph[u]包含u的所有邻接顶点
        U_size: U集合顶点数
        V_size: V集合顶点数
    Returns:
        最大匹配数和匹配结果
    """
    # pair_U[u] = v表示U中顶点u匹配V中顶点v
    # pair_V[v] = u表示V中顶点v匹配U中顶点u
    # -1表示未匹配
    pair_U = [-1] * U_size
    pair_V = [-1] * V_size
    result = 0  # 匹配数
    
    def dfs(u, visited):
        """从u出发寻找增广路径"
        for v in graph[u]:
            if not visited[v]:
                visited[v] = True
                # 若v未匹配或v的匹配顶点可找到其他增广路径
                if pair_V[v] == -1 or dfs(pair_V[v], visited):
                    pair_U[u] = v
                    pair_V[v] = u
                    return True
        return False
    
    # 对每个U中的顶点尝试寻找增广路径
    for u in range(U_size):
        visited = [False] * V_size
        if dfs(u, visited):
            result += 1
    
    return result, pair_U, pair_V

# 示例使用
if __name__ == "__main__":
    # 二分图邻接表，U={0,1,2,3}, V={0,1,2,3}
    graph = [
        [1, 2],    # U0连接V1,V2
        [0, 3],    # U1连接V0,V3
        [2],       # U2连接V2
        [1, 3]     # U3连接V1,V3
    ]
    
    max_matching, pair_U, pair_V = hungarian_algorithm(graph, 4, 4)
    print(f"最大匹配数: {max_matching}")
    print(f"U匹配结果: {pair_U}")  # [-1, 0, 2, 3] 表示U0未匹配，U1匹配V0，U2匹配V2，U3匹配V3
```

### Hopcroft-Karp算法实现
```python
from collections import deque

def hopcroft_karp(graph, U_size, V_size):
    """Hopcroft-Karp算法求解二分图最大匹配
    Args:
        graph: 邻接表表示的二分图
        U_size: U集合顶点数
        V_size: V集合顶点数
    Returns:
        最大匹配数和匹配结果
    """
    pair_U = [-1] * U_size
    pair_V = [-1] * V_size
    dist = [0] * U_size  # BFS层次距离
    result = 0
    
    def bfs():
        """构建层次图，返回是否存在增广路径"
        queue = deque()
        # 将未匹配的U顶点加入队列
        for u in range(U_size):
            if pair_U[u] == -1:
                dist[u] = 0
                queue.append(u)
            else:
                dist[u] = float('inf')
        
        dist_null = float('inf')
        while queue:
            u = queue.popleft()
            if dist[u] < dist_null:
                for v in graph[u]:
                    # v未匹配，找到增广路径
                    if pair_V[v] == -1:
                        dist_null = dist[u] + 1
                    # 更新v的匹配顶点的距离
                    elif dist[pair_V[v]] == float('inf'):
                        dist[pair_V[v]] = dist[u] + 1
                        queue.append(pair_V[v])
        return dist_null != float('inf')
    
    def dfs(u):
        """寻找增广路径并更新匹配"
        for v in graph[u]:
            if pair_V[v] == -1 or (dist[pair_V[v]] == dist[u] + 1 and dfs(pair_V[v])):
                pair_U[u] = v
                pair_V[v] = u
                return True
        dist[u] = float('inf')
        return False
    
    # 多轮BFS+DFS寻找增广路径
    while bfs():
        for u in range(U_size):
            if pair_U[u] == -1:
                if dfs(u):
                    result += 1
    
    return result, pair_U, pair_V

# 带顶点标签的二分图匹配
def bipartite_matching_with_labels(labels_graph, u_labels, v_labels):
    """带顶点标签的二分图匹配
    Args:
        labels_graph: 带标签的二分图邻接表
        u_labels: U集合顶点标签列表
        v_labels: V集合顶点标签列表
    Returns:
        最大匹配数和带标签的匹配结果
    """
    # 构建标签到ID的映射
    u_id = {label: i for i, label in enumerate(u_labels)}
    v_id = {label: i for i, label in enumerate(v_labels)}
    U_size = len(u_labels)
    V_size = len(v_labels)
    
    # 构建ID图
    graph = [[] for _ in range(U_size)]
    for u_label, v_labels in labels_graph.items():
        u = u_id[u_label]
        for v_label in v_labels:
            v = v_id[v_label]
            graph[u].append(v)
    
    # 计算最大匹配
    max_matching, pair_U, pair_V = hopcroft_karp(graph, U_size, V_size)
    
    # 转换为标签匹配结果
    label_pair_U = {u_label: None for u_label in u_labels}
    for u, v in enumerate(pair_U):
        if v != -1:
            label_pair_U[u_labels[u]] = v_labels[v]
    
    return max_matching, label_pair_U

# 示例使用
if __name__ == "__main__":
    # 带标签的二分图
    labeled_graph = {
        '工人A': ['任务1', '任务2'],
        '工人B': ['任务0', '任务3'],
        '工人C': ['任务2'],
        '工人D': ['任务1', '任务3']
    }
    u_labels = ['工人A', '工人B', '工人C', '工人D']
    v_labels = ['任务0', '任务1', '任务2', '任务3']
    
    max_matching, label_matching = bipartite_matching_with_labels(labeled_graph, u_labels, v_labels)
    print(f"最大匹配数: {max_matching}")
    print("匹配结果:", {k: v for k, v in label_matching.items() if v is not None})
```

### 应用：任务分配问题
```python
def assignment_problem(cost_matrix):
    """解决指派问题（带权二分匹配）
    Args:
        cost_matrix: 成本矩阵，cost[i][j]表示工人i完成任务j的成本
    Returns:
        最小成本和分配方案
    """
    n = len(cost_matrix)
    m = len(cost_matrix[0]) if n > 0 else 0
    assert n == m, "成本矩阵必须为方阵"
    
    # 转换为最大匹配问题（取负值）
    max_weight = max(max(row) for row in cost_matrix) if n > 0 else 0
    profit_matrix = [[max_weight - cost for cost in row] for row in cost_matrix]
    
    # 构建邻接表
    graph = [[] for _ in range(n)]
    for i in range(n):
        for j in range(m):
            if profit_matrix[i][j] > 0:
                graph[i].append(j)
    
    # 计算最大匹配
    max_profit_matching, pair_U, _ = hungarian_algorithm(graph, n, m)
    
    # 计算最小成本
    total_cost = 0
    assignment = {}
    for i in range(n):
        if pair_U[i] != -1:
            j = pair_U[i]
            total_cost += cost_matrix[i][j]
            assignment[f"工人{i}"] = f"任务{j}"
    
    return total_cost, assignment

# 示例使用
if __name__ == "__main__":
    # 成本矩阵: 3个工人完成3个任务的成本
    cost_matrix = [
        [4, 1, 3],
        [2, 0, 5],
        [3, 2, 2]
    ]
    
    min_cost, assignment = assignment_problem(cost_matrix)
    print(f"最小总成本: {min_cost}")
    print("最优分配方案:", assignment)
```

---

## 📊 复杂度分析

| 算法 | 时间复杂度 | 空间复杂度 | 优势 | 劣势 |
|------|------------|------------|------|------|
| 匈牙利算法 | O(VE) | O(V) | 实现简单，适合稠密图 | 大规模图效率低 |
| Hopcroft-Karp | O(E√V) | O(V+E) | 高效处理大规模图，多增广路径 | 实现较复杂 |
| Ford-Fulkerson | O(F·E) | O(V+E) | 适用范围广，可处理带权图 | 依赖最大流F，效率不稳定 |
| 匈牙利算法（矩阵） | O(V³) | O(V²) | 稠密图性能好 | 空间复杂度高 |
| 带权二分匹配 | O(V³) | O(V²) | 处理权重匹配 | 计算复杂，耗时 |

### 复杂度说明
- **匈牙利算法**：每个顶点最多执行一次DFS，每次DFS遍历O(E)条边，总复杂度O(VE)
- **Hopcroft-Karp算法**：BFS复杂度O(E)，DFS复杂度O(E)，最多执行O(√V)轮，总复杂度O(E√V)
- **实际性能**：在稀疏图中，Hopcroft-Karp比匈牙利算法快3-10倍；在稠密图中两者性能接近
- **空间复杂度**：主要来自邻接表存储(O(E))和匹配数组(O(V))

---

## 🔍 应用场景

1. **任务分配**：
   - 员工-任务分配问题
   - 资源调度与分配
   - 项目团队人员分配

2. **网络与通信**：
   - 交换机端口分配
   - 信道分配与频率规划
   - P2P网络节点匹配

3. **推荐系统**：
   - 用户-物品推荐匹配
   - 内容推荐算法
   - 相亲/交友平台匹配

4. **生物信息学**：
   - DNA序列比对
   - 蛋白质相互作用预测
   - 基因-疾病关联分析

5. **其他领域**：
   - 二分图匹配在搜索引擎中的应用
   - 排课系统（教师-课程-教室匹配）
   - 二手车-买家匹配平台
   - 边缘着色问题

---

## ⚠️ 注意事项

1. **图的二分性验证**：
   - 应用算法前需确保图是二分图，可使用染色法验证
   - 非二分图使用二分匹配算法会导致错误结果

2. **数据结构选择**：
   - 稀疏图优先使用邻接表，节省空间
   - 稠密图可使用邻接矩阵，随机访问更快
   - 大规模图推荐使用Hopcroft-Karp算法

3. **算法选择依据**：
   - 小规模图（V<1000）：匈牙利算法实现简单
   - 大规模图（V>10000）：Hopcroft-Karp算法效率更高
   - 带权匹配问题：使用KM算法或最小费用最大流

4. **特殊情况处理**：
   - 非完美匹配：允许部分顶点不匹配
   - 多对一匹配：需转换为标准二分图模型
   - 顶点权重：可通过边权重转化处理

---

## 🎓 最佳实践

1. **实现技巧**：
   - Hopcroft-Karp算法中使用BFS层次图优化DFS搜索范围
   - 匈牙利算法中使用递归或非递归DFS实现
   - 对稀疏图使用邻接表+集合存储，提高查找效率

2. **性能优化**：
   - 预先移除孤立顶点，减少计算量
   - 使用双向链表存储邻接表，加速边遍历
   - 对顶点进行排序，优先处理度数小的顶点

3. **问题转化**：
   - 将多对多匹配转化为二分图匹配
   - 带权匹配问题可使用Kuhn-Munkres算法
   - 限制条件匹配可通过添加虚拟顶点和边实现

4. **常见错误避免**：
   - 混淆U集合和V集合顶点
   - 未正确初始化匹配数组
   - BFS层次图构建错误
   - 忽略增广路径的多轮查找

---

### 相关链接
- [二分图 - Wikipedia](https://en.wikipedia.org/wiki/Bipartite_graph)
- [匈牙利算法 - Wikipedia](https://en.wikipedia.org/wiki/Hungarian_algorithm)
- [Hopcroft-Karp算法 - Wikipedia](https://en.wikipedia.org/wiki/Hopcroft%E2%80%93Karp_algorithm)
- [Konig定理 - Wikipedia](https://en.wikipedia.org/wiki/K%C3%B6nig%27s_theorem_(graph_theory))
- [二分图匹配可视化工具](https://visualgo.net/en/matching)

> **更新日期**: 2023-11-15
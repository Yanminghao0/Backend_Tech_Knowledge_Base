# Dijkstraç®—æ³•

> Dijkstraç®—æ³•æ˜¯ä¸€ç§ç”¨äºå¯»æ‰¾å›¾ä¸­ä»å•ä¸€æºç‚¹åˆ°å…¶ä»–æ‰€æœ‰é¡¶ç‚¹çš„æœ€çŸ­è·¯å¾„çš„è´ªå¿ƒç®—æ³•ï¼Œç”±è·å…°è®¡ç®—æœºç§‘å­¦å®¶Edsger W. Dijkstraäº1956å¹´æå‡ºã€‚è¯¥ç®—æ³•åªé€‚ç”¨äºè¾¹æƒä¸ºéè´Ÿå€¼çš„å›¾ã€‚

---

## ğŸ“‹ åŸºæœ¬ä¿¡æ¯

### å®šä¹‰
Dijkstraç®—æ³•æ˜¯ä¸€ç§æœ€çŸ­è·¯å¾„ç®—æ³•ï¼Œå®ƒé€šè¿‡è´ªå¿ƒç­–ç•¥é€æ­¥æ‰¾åˆ°ä»èµ·ç‚¹åˆ°å›¾ä¸­æ‰€æœ‰å…¶ä»–é¡¶ç‚¹çš„æœ€çŸ­è·¯å¾„ã€‚ç®—æ³•ç»´æŠ¤ä¸€ä¸ªä¼˜å…ˆé˜Ÿåˆ—æ¥é€‰æ‹©å½“å‰è·ç¦»èµ·ç‚¹æœ€è¿‘çš„é¡¶ç‚¹ï¼Œå¹¶é€šè¿‡æ¾å¼›æ“ä½œæ›´æ–°å…¶é‚»æ¥é¡¶ç‚¹çš„è·ç¦»ã€‚

### æ ¸å¿ƒæ€æƒ³
- ä»èµ·ç‚¹å¼€å§‹ï¼Œä¸ºæ¯ä¸ªé¡¶ç‚¹ç»´æŠ¤ä¸€ä¸ªè·ç¦»å€¼ï¼ˆåˆå§‹åŒ–ä¸ºæ— ç©·å¤§ï¼Œèµ·ç‚¹è·ç¦»ä¸º0ï¼‰
- ä½¿ç”¨ä¼˜å…ˆé˜Ÿåˆ—ï¼ˆæœ€å°å †ï¼‰é€‰æ‹©å½“å‰è·ç¦»æœ€å°çš„é¡¶ç‚¹
- å¯¹é€‰ä¸­é¡¶ç‚¹çš„æ‰€æœ‰é‚»æ¥é¡¶ç‚¹æ‰§è¡Œæ¾å¼›æ“ä½œï¼Œæ›´æ–°å…¶è·ç¦»å€¼
- é‡å¤ä¸Šè¿°è¿‡ç¨‹ï¼Œç›´åˆ°æ‰€æœ‰é¡¶ç‚¹éƒ½è¢«å¤„ç†

### é€‚ç”¨èŒƒå›´
- æœ‰æƒå›¾ï¼ˆè¾¹æƒå¿…é¡»ä¸ºéè´Ÿå€¼ï¼‰
- æœ‰å‘å›¾å’Œæ— å‘å›¾å‡å¯
- å•æºæœ€çŸ­è·¯å¾„é—®é¢˜

## ğŸ¯ ç®—æ³•åŸç†

### åŸºæœ¬æ­¥éª¤
1. åˆå§‹åŒ–ï¼šå°†èµ·ç‚¹è·ç¦»è®¾ä¸º0ï¼Œå…¶ä»–æ‰€æœ‰é¡¶ç‚¹è·ç¦»è®¾ä¸ºæ— ç©·å¤§ï¼›åˆ›å»ºä¸€ä¸ªä¼˜å…ˆé˜Ÿåˆ—ï¼Œå¹¶å°†èµ·ç‚¹åŠ å…¥é˜Ÿåˆ—
2. å½“é˜Ÿåˆ—ä¸ä¸ºç©ºæ—¶ï¼š
   - å–å‡ºè·ç¦»æœ€å°çš„é¡¶ç‚¹u
   - å¯¹uçš„æ¯ä¸ªé‚»æ¥é¡¶ç‚¹vï¼š
     - å¦‚æœé€šè¿‡uåˆ°è¾¾vçš„è·¯å¾„æ¯”å½“å‰vçš„è·ç¦»æ›´çŸ­ï¼Œåˆ™æ›´æ–°vçš„è·ç¦»
     - å¦‚æœvçš„è·ç¦»è¢«æ›´æ–°ï¼Œå°†våŠ å…¥ä¼˜å…ˆé˜Ÿåˆ—
3. å½“æ‰€æœ‰é¡¶ç‚¹éƒ½è¢«å¤„ç†åï¼Œå¾—åˆ°èµ·ç‚¹åˆ°æ‰€æœ‰å…¶ä»–é¡¶ç‚¹çš„æœ€çŸ­è·¯å¾„

### æ¾å¼›æ“ä½œ
å¯¹äºè¾¹(u, v)ï¼Œå¦‚æœ`distance[v] > distance[u] + weight(u, v)`ï¼Œåˆ™æ›´æ–°`distance[v] = distance[u] + weight(u, v)`

### æ•°æ®ç»“æ„
- **ä¼˜å…ˆé˜Ÿåˆ—(æœ€å°å †)**ï¼šç”¨äºé«˜æ•ˆè·å–è·ç¦»æœ€å°çš„é¡¶ç‚¹
- **è·ç¦»æ•°ç»„**ï¼šå­˜å‚¨ä»èµ·ç‚¹åˆ°å„é¡¶ç‚¹çš„å½“å‰æœ€çŸ­è·ç¦»
- **å‰é©±æ•°ç»„**ï¼šå¯é€‰ï¼Œç”¨äºé‡å»ºæœ€çŸ­è·¯å¾„

## ğŸ’» ä»£ç å®ç°

### åŸºæœ¬å®ç°ï¼ˆé‚»æ¥è¡¨+ä¼˜å…ˆé˜Ÿåˆ—ï¼‰
```python
import heapq

def dijkstra(graph, start):
    """Dijkstraç®—æ³•åŸºæœ¬å®ç°
    Args:
        graph: é‚»æ¥è¡¨è¡¨ç¤ºçš„å›¾ï¼Œæ ¼å¼ä¸º{èŠ‚ç‚¹: [(é‚»å±…, æƒé‡), ...]}
        start: èµ·å§‹èŠ‚ç‚¹
    Returns:
        distance: ä»èµ·ç‚¹åˆ°å„èŠ‚ç‚¹çš„æœ€çŸ­è·ç¦»å­—å…¸
        predecessor: å‰é©±èŠ‚ç‚¹å­—å…¸ï¼Œç”¨äºé‡å»ºè·¯å¾„
    ""
    # åˆå§‹åŒ–è·ç¦»å­—å…¸ï¼Œèµ·ç‚¹è·ç¦»ä¸º0ï¼Œå…¶ä»–ä¸ºæ— ç©·å¤§
    distance = {node: float('inf') for node in graph}
    distance[start] = 0
    
    # å‰é©±èŠ‚ç‚¹å­—å…¸ï¼Œç”¨äºé‡å»ºè·¯å¾„
    predecessor = {node: None for node in graph}
    
    # ä¼˜å…ˆé˜Ÿåˆ—ï¼Œå­˜å‚¨(è·ç¦», èŠ‚ç‚¹)ï¼Œåˆå§‹åŠ å…¥èµ·ç‚¹
    priority_queue = [(0, start)]
    
    # å·²è®¿é—®èŠ‚ç‚¹é›†åˆ
    visited = set()
    
    while priority_queue:
        # å–å‡ºè·ç¦»æœ€å°çš„èŠ‚ç‚¹
        current_distance, current_node = heapq.heappop(priority_queue)
        
        # å¦‚æœèŠ‚ç‚¹å·²è®¿é—®ï¼Œè·³è¿‡
        if current_node in visited:
            continue
        
        # æ ‡è®°èŠ‚ç‚¹ä¸ºå·²è®¿é—®
        visited.add(current_node)
        
        # éå†å½“å‰èŠ‚ç‚¹çš„æ‰€æœ‰é‚»æ¥èŠ‚ç‚¹
        for neighbor, weight in graph[current_node]:
            # æ¾å¼›æ“ä½œ
            if distance[neighbor] > current_distance + weight:
                # æ›´æ–°è·ç¦»
                distance[neighbor] = current_distance + weight
                # æ›´æ–°å‰é©±èŠ‚ç‚¹
                predecessor[neighbor] = current_node
                # å°†æ›´æ–°åçš„èŠ‚ç‚¹åŠ å…¥ä¼˜å…ˆé˜Ÿåˆ—
                heapq.heappush(priority_queue, (distance[neighbor], neighbor))
    
    return distance, predecessor

# ç¤ºä¾‹å›¾
 graph = {
    'A': [('B', 4), ('C', 2)],
    'B': [('A', 4), ('C', 5), ('D', 10)],
    'C': [('A', 2), ('B', 5), ('D', 3)],
    'D': [('B', 10), ('C', 3)]
}

# æ‰§è¡ŒDijkstraç®—æ³•
 distance, predecessor = dijkstra(graph, 'A')
print("æœ€çŸ­è·ç¦»:", distance)  # è¾“å‡º: {'A': 0, 'B': 4, 'C': 2, 'D': 5}
print("å‰é©±èŠ‚ç‚¹:", predecessor)  # è¾“å‡º: {'A': None, 'B': 'A', 'C': 'A', 'D': 'C'}
```

### è·¯å¾„é‡å»ºå‡½æ•°
```python
def reconstruct_path(predecessor, start, end):
    """æ ¹æ®å‰é©±èŠ‚ç‚¹å­—å…¸é‡å»ºä»èµ·ç‚¹åˆ°ç»ˆç‚¹çš„æœ€çŸ­è·¯å¾„
    Args:
        predecessor: å‰é©±èŠ‚ç‚¹å­—å…¸
        start: èµ·å§‹èŠ‚ç‚¹
        end: ç›®æ ‡èŠ‚ç‚¹
    Returns:
        æœ€çŸ­è·¯å¾„åˆ—è¡¨ï¼Œè‹¥ä¸å­˜åœ¨è·¯å¾„åˆ™è¿”å›None
    ""
    path = []
    current = end
    
    while current is not None:
        path.append(current)
        current = predecessor[current]
        
    # åè½¬è·¯å¾„ï¼Œä»èµ·ç‚¹åˆ°ç»ˆç‚¹
    path.reverse()
    
    # æ£€æŸ¥è·¯å¾„æ˜¯å¦æœ‰æ•ˆ
    if path[0] != start:
        return None
    
    return path

# ç¤ºä¾‹ä½¿ç”¨
print("æœ€çŸ­è·¯å¾„(Aåˆ°D):", reconstruct_path(predecessor, 'A', 'D'))  # è¾“å‡º: ['A', 'C', 'D']
```

### é‚»æ¥çŸ©é˜µå®ç°
```python
def dijkstra_matrix(matrix, start):
    """åŸºäºé‚»æ¥çŸ©é˜µçš„Dijkstraç®—æ³•å®ç°
    Args:
        matrix: é‚»æ¥çŸ©é˜µï¼Œmatrix[i][j]è¡¨ç¤ºèŠ‚ç‚¹iåˆ°jçš„æƒé‡ï¼Œ0è¡¨ç¤ºæ— ç›´æ¥è¿æ¥
        start: èµ·å§‹èŠ‚ç‚¹ç´¢å¼•
    Returns:
        distance: è·ç¦»æ•°ç»„
        predecessor: å‰é©±èŠ‚ç‚¹æ•°ç»„
    ""
    n = len(matrix)
    INF = float('inf')
    distance = [INF] * n
    distance[start] = 0
    predecessor = [-1] * n
    visited = [False] * n
    
    for _ in range(n):
        # æ‰¾åˆ°æœªè®¿é—®èŠ‚ç‚¹ä¸­è·ç¦»æœ€å°çš„èŠ‚ç‚¹
        min_dist = INF
        u = -1
        for i in range(n):
            if not visited[i] and distance[i] < min_dist:
                min_dist = distance[i]
                u = i
        
        if u == -1:  # æ‰€æœ‰å¯è¾¾èŠ‚ç‚¹å·²å¤„ç†
            break
        
        visited[u] = True
        
        # æ¾å¼›æ“ä½œ
        for v in range(n):
            if matrix[u][v] > 0 and not visited[v] and distance[v] > distance[u] + matrix[u][v]:
                distance[v] = distance[u] + matrix[u][v]
                predecessor[v] = u
    
    return distance, predecessor
```

### ä¼˜å…ˆé˜Ÿåˆ—ä¼˜åŒ–ç‰ˆï¼ˆä½¿ç”¨heapqï¼‰
```python
def dijkstra_heap_optimized(graph, start):
    """ä½¿ç”¨å †ä¼˜åŒ–çš„Dijkstraç®—æ³•ï¼Œå¤„ç†å¤§å‹ç¨€ç–å›¾æ›´é«˜æ•ˆ
    Args:
        graph: é‚»æ¥è¡¨è¡¨ç¤ºçš„å›¾
        start: èµ·å§‹èŠ‚ç‚¹
    Returns:
        distance: æœ€çŸ­è·ç¦»å­—å…¸
    ""
    import heapq
    
    distance = {node: float('inf') for node in graph}
    distance[start] = 0
    priority_queue = [(0, start)]
    
    while priority_queue:
        current_dist, u = heapq.heappop(priority_queue)
        
        # å¦‚æœå½“å‰è·ç¦»å¤§äºå·²çŸ¥æœ€çŸ­è·ç¦»ï¼Œè·³è¿‡
        if current_dist > distance[u]:
            continue
        
        for v, weight in graph[u]:
            if distance[v] > distance[u] + weight:
                distance[v] = distance[u] + weight
                heapq.heappush(priority_queue, (distance[v], v))
    
    return distance
```

## ğŸ“Š å¤æ‚åº¦åˆ†æ

| å®ç°æ–¹å¼       | æ—¶é—´å¤æ‚åº¦       | ç©ºé—´å¤æ‚åº¦ | è¯´æ˜                     |
|----------------|------------------|------------|--------------------------|
| é‚»æ¥çŸ©é˜µ+çº¿æ€§æŸ¥æ‰¾ | O(VÂ²)            | O(V)       | Væ˜¯é¡¶ç‚¹æ•°ï¼Œé€‚åˆç¨ å¯†å›¾   |
| é‚»æ¥è¡¨+ä¼˜å…ˆé˜Ÿåˆ— | O((V+E)logV)     | O(V)       | Eæ˜¯è¾¹æ•°ï¼Œé€‚åˆç¨€ç–å›¾     |
| Fibonacciå †ä¼˜åŒ– | O(E + VlogV)     | O(V)       | ç†è®ºæœ€ä¼˜ï¼Œä½†å®ç°å¤æ‚     |

> **æ³¨æ„**: ä¼˜å…ˆé˜Ÿåˆ—å®ç°ä¸­ï¼Œæ¯ä¸ªè¾¹å¯èƒ½è¢«åŠ å…¥é˜Ÿåˆ—å¤šæ¬¡ï¼Œå¯¼è‡´å®é™…å¤æ‚åº¦å¯èƒ½é«˜äºç†è®ºå€¼

## ğŸ” åº”ç”¨åœºæ™¯

1. **å¯¼èˆªç³»ç»Ÿ**: å¯»æ‰¾ä¸¤åœ°ä¹‹é—´çš„æœ€çŸ­è·¯å¾„
2. **ç½‘ç»œè·¯ç”±**: è·¯ç”±å™¨ä½¿ç”¨ç±»ä¼¼Dijkstraçš„ç®—æ³•ç¡®å®šæ•°æ®åŒ…ä¼ è¾“è·¯å¾„
3. **äº¤é€šæµé‡åˆ†æ**: ä¼˜åŒ–äº¤é€šè·¯çº¿ï¼Œå‡å°‘æ‹¥å µ
4. **æ¸¸æˆå¼€å‘**: AIè§’è‰²å¯»è·¯
5. **æœºå™¨äººè·¯å¾„è§„åˆ’**: ç§»åŠ¨æœºå™¨äººçš„è‡ªä¸»å¯¼èˆª
6. **åœ°å›¾æœåŠ¡**: å¦‚Google Mapsã€ç™¾åº¦åœ°å›¾ç­‰æä¾›çš„è·¯çº¿è§„åˆ’
7. **ç‰©æµé…é€**: ä¼˜åŒ–é…é€è·¯çº¿ï¼Œå‡å°‘è¿è¾“æˆæœ¬

## âš ï¸ æ³¨æ„äº‹é¡¹

1. **è´Ÿæƒè¾¹é—®é¢˜**: Dijkstraç®—æ³•**ä¸èƒ½å¤„ç†åŒ…å«è´Ÿæƒè¾¹**çš„å›¾ï¼Œæ­¤æ—¶åº”ä½¿ç”¨Bellman-Fordç®—æ³•
2. **ä¼˜å…ˆé˜Ÿåˆ—é€‰æ‹©**: ä½¿ç”¨äºŒå‰å †æ—¶ï¼Œæ—¶é—´å¤æ‚åº¦ä¸ºO((V+E)logV)ï¼›ä½¿ç”¨Fibonacciå †å¯ä¼˜åŒ–è‡³O(E + VlogV)ï¼Œä½†å®ç°å¤æ‚
3. **å›¾çš„è¡¨ç¤º**: ç¨€ç–å›¾é€‚åˆç”¨é‚»æ¥è¡¨ï¼Œç¨ å¯†å›¾é€‚åˆç”¨é‚»æ¥çŸ©é˜µ
4. **å¤šæºæœ€çŸ­è·¯å¾„**: Dijkstraç®—æ³•æ˜¯å•æºæœ€çŸ­è·¯å¾„ç®—æ³•ï¼Œå¦‚éœ€å¤šæºæœ€çŸ­è·¯å¾„ï¼Œéœ€å¤šæ¬¡è¿è¡Œæˆ–ä½¿ç”¨Floydç®—æ³•
5. **ä¸å¯è¾¾èŠ‚ç‚¹**: ç®—æ³•ç»“æŸåï¼Œè·ç¦»ä»ä¸ºæ— ç©·å¤§çš„èŠ‚ç‚¹è¡¨ç¤ºä»èµ·ç‚¹ä¸å¯è¾¾
6. **æœ‰å‘å›¾å¤„ç†**: ç®—æ³•å¯ç›´æ¥å¤„ç†æœ‰å‘å›¾ï¼Œåªéœ€éå†æœ‰å‘è¾¹å³å¯

## ğŸ“ æœ€ä½³å®è·µ

1. **é€‰æ‹©åˆé€‚çš„æ•°æ®ç»“æ„**: æ ¹æ®å›¾çš„ç¨€ç–ç¨‹åº¦é€‰æ‹©é‚»æ¥è¡¨æˆ–é‚»æ¥çŸ©é˜µ
2. **ä½¿ç”¨å †ä¼˜åŒ–**: å¯¹äºå¤§å‹å›¾ï¼Œä¼˜å…ˆä½¿ç”¨å †ä¼˜åŒ–ç‰ˆæœ¬ä»¥æé«˜æ•ˆç‡
3. **å¤„ç†å¤§é‡æ•°æ®**: å½“èŠ‚ç‚¹æ•°é‡å·¨å¤§æ—¶ï¼Œå¯è€ƒè™‘ä½¿ç”¨è¿‘ä¼¼ç®—æ³•æˆ–åˆ†æ²»ç­–ç•¥
4. **è·¯å¾„é‡å»º**: å¦‚éœ€é¢‘ç¹é‡å»ºè·¯å¾„ï¼Œå¯åœ¨ç®—æ³•ä¸­ç»´æŠ¤å‰é©±èŠ‚ç‚¹ä¿¡æ¯
5. **æå‰é€€å‡º**: å¦‚æœåªéœ€è¦åˆ°ç‰¹å®šç›®æ ‡èŠ‚ç‚¹çš„æœ€çŸ­è·¯å¾„ï¼Œå¯åœ¨ç›®æ ‡èŠ‚ç‚¹è¢«è®¿é—®åæå‰é€€å‡º
6. **å¤„ç†è´Ÿæƒè¾¹**: è‹¥å›¾ä¸­å¯èƒ½å­˜åœ¨è´Ÿæƒè¾¹ï¼Œåº”ä½¿ç”¨Bellman-Fordç®—æ³•æˆ–SPFAç®—æ³•
7. **ä½¿ç”¨å†…ç½®æ•°æ®ç»“æ„**: Pythonä¸­æ¨èä½¿ç”¨heapqæ¨¡å—å®ç°ä¼˜å…ˆé˜Ÿåˆ—

## ğŸ“š æ‰©å±•é˜…è¯»
- [Wikipedia: Dijkstra's algorithm](https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm)
- ã€Šç®—æ³•å¯¼è®ºã€‹ç¬¬3ç‰ˆï¼Œç¬¬24ç« ï¼šå•æºæœ€çŸ­è·¯å¾„
- ã€Šå›¾è®ºç®—æ³•ç†è®ºã€å®ç°åŠåº”ç”¨ã€‹ç¬¬7ç« 

---

> **æ›´æ–°è®°å½•**: 2023-10-27 å®ŒæˆåŸºæœ¬å†…å®¹ç¼–å†™
# 顺序查找

> 顺序查找是最简单的查找算法，通过逐个比较元素来确定目标是否存在，适用于任何数据结构

---

## 📋 基本信息

- **类型**: 线性查找算法
- **时间复杂度**: O(n)
- **空间复杂度**: O(1)
- **适用条件**: 
  - ✅ 无序数据集合
  - ✅ 有序数据集合
  - ✅ 链表等非随机访问数据结构
- **核心思想**: 从数据集合的一端开始，依次比较每个元素直到找到目标或遍历完成

---

## 🎯 算法原理

### 1. 基本思路
1. 从数据集合的第一个元素开始
2. 将当前元素与目标元素进行比较
3. 如果相等，则查找成功，返回当前位置
4. 如果不相等，则继续比较下一个元素
5. 重复步骤2-4，直到找到目标元素或到达数据集合的末尾
6. 如果遍历完所有元素仍未找到，则查找失败

### 2. 核心流程图
```mermaid
graph TD
    A[开始] --> B[初始化指针 i=0]
    B --> C{i < 数据长度?}
    C -- 是 --> D[比较数据[i]与目标值]
    D -- 相等 --> E[返回索引 i，查找成功]
    D -- 不相等 --> F[i = i + 1]
    F --> C
    C -- 否 --> G[返回 -1，查找失败]
    E --> H[结束]
    G --> H
```

### 3. 优化策略
- **哨兵优化**: 在数组末尾放置目标元素作为哨兵，避免每次循环都检查数组边界
- **双向顺序查找**: 从数组两端同时开始查找，理论上可减少一半比较次数
- **跳转顺序查找**: 对于有序数据，当发现当前元素小于目标时，可以跳过一定数量的元素

---

## 💻 代码实现

### 1. 基础实现
```java
/**
 * 顺序查找基础实现
 * @param arr 待查找的数组
 * @param target 目标值
 * @return 目标值索引，未找到返回-1
 */
public int sequentialSearch(int[] arr, int target) {
    // 遍历数组元素
    for (int i = 0; i < arr.length; i++) {
        // 找到目标值，返回索引
        if (arr[i] == target) {
            return i;
        }
    }
    // 未找到目标值
    return -1;
}
```

### 2. 哨兵优化实现
```java
/**
 * 顺序查找哨兵优化版本
 * @param arr 待查找的数组
 * @param target 目标值
 * @return 目标值索引，未找到返回-1
 */
public int sequentialSearchWithSentinel(int[] arr, int target) {
    if (arr == null || arr.length == 0) {
        return -1;
    }
    
    // 保存最后一个元素
    int last = arr[arr.length - 1];
    // 设置哨兵
    arr[arr.length - 1] = target;
    
    int i = 0;
    // 不需要检查i是否越界，因为哨兵的存在
    while (arr[i] != target) {
        i++;
    }
    
    // 恢复最后一个元素
    arr[arr.length - 1] = last;
    
    // 判断是否找到
    if (i < arr.length - 1 || last == target) {
        return i;
    }
    
    return -1;
}
```

### 3. 双向顺序查找
```java
/**
 * 双向顺序查找
 * @param arr 待查找的数组
 * @param target 目标值
 * @return 目标值索引，未找到返回-1
 */
public int twoWaySequentialSearch(int[] arr, int target) {
    int left = 0;
    int right = arr.length - 1;
    
    while (left <= right) {
        // 从左侧查找
        if (arr[left] == target) {
            return left;
        }
        // 从右侧查找
        if (arr[right] == target) {
            return right;
        }
        
        left++;
        right--;
    }
    
    return -1;
}
```

---

## 📊 复杂度分析

| 情况 | 时间复杂度 | 空间复杂度 | 说明 |
|------|------------|------------|------|
| 最好情况 | O(1) | O(1) | 目标元素在第一个位置 |
| 平均情况 | O(n) | O(1) | 目标元素在中间位置 |
| 最坏情况 | O(n) | O(1) | 目标元素在最后一个位置或不存在 |

### 复杂度分析要点
- 时间复杂度主要由比较次数决定，与数据规模n成正比
- 空间复杂度为常数级，只需要几个额外变量
- 平均比较次数为(n+1)/2，当n较大时接近n/2
- 哨兵优化版本减少了循环中的边界检查，但时间复杂度仍为O(n)

---

## 🔍 应用场景

### 典型应用
- 小规模数据集合的查找
- 无序数据集合的查找
- 链表等非随机访问数据结构
- 数据元素频繁变动的场景

### 实际案例
- 通讯录联系人查找
- 简单的数组元素查找
- 文本编辑器中的查找功能
- 某些编程语言中的indexOf/lastIndexOf方法实现

---

## ⚠️ 注意事项

### 1. 适用边界
- 数据规模较小时，顺序查找效率可接受
- 数据规模较大时（n>1000），应考虑更高效的查找算法
- 对于有序数据，二分查找通常比顺序查找效率更高

### 2. 性能影响因素
- 数据规模：规模越大，顺序查找效率越低
- 目标元素位置：位置越靠前，查找速度越快
- 数据结构：数组实现比链表实现效率略高

### 3. 优化建议
- 对于频繁查找的场景，考虑先对数据排序，再使用二分查找
- 对于静态数据，可建立索引提高查找效率
- 对于特定领域，可结合业务特点设计启发式顺序查找

---

## 🎓 最佳实践

### 使用建议
1. **简单场景优先选择**：实现简单，不易出错
2. **小规模数据适用**：数据量较小时性能可接受
3. **无序数据首选**：无需排序预处理
4. **链表结构必选**：无法进行随机访问的场景

### 代码优化技巧
- 使用哨兵技术减少边界检查
- 结合数据特点调整遍历方向（如从高频出现位置开始）
- 对于频繁查找失败的场景，可添加快速失败机制

### 与其他算法对比
- **顺序查找 vs 二分查找**：顺序查找实现简单但效率低，二分查找效率高但要求数据有序
- **顺序查找 vs 哈希查找**：哈希查找效率更高但需要额外空间和哈希函数设计

---

> **总结**：顺序查找是最基础的查找算法，虽然时间复杂度较高，但实现简单、适用范围广，是理解更复杂查找算法的基础。在实际开发中，应根据数据规模、有序性和访问模式综合选择查找算法。
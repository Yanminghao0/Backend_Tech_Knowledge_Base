# å“ˆå¸ŒæŸ¥æ‰¾

> å“ˆå¸ŒæŸ¥æ‰¾æ˜¯ä¸€ç§åŸºäºå“ˆå¸Œè¡¨çš„å¸¸æ•°æ—¶é—´å¤æ‚åº¦æŸ¥æ‰¾ç®—æ³•ï¼Œé€šè¿‡å“ˆå¸Œå‡½æ•°å°†å…³é”®å­—æ˜ å°„åˆ°å­˜å‚¨ä½ç½®ï¼Œå®ç°å¿«é€Ÿè®¿é—®

---

## ğŸ“‹ åŸºæœ¬ä¿¡æ¯

- **ç±»å‹**: å¿«é€ŸæŸ¥æ‰¾ç®—æ³•
- **æ—¶é—´å¤æ‚åº¦**: O(1) - å¹³å‡æƒ…å†µï¼ŒO(n) - æœ€åæƒ…å†µ
- **ç©ºé—´å¤æ‚åº¦**: O(n)
- **é€‚ç”¨æ¡ä»¶**: 
  - âœ… é™æ€æˆ–åŠ¨æ€æ•°æ®é›†åˆ
  - âœ… éœ€è¦é¢‘ç¹æŸ¥æ‰¾çš„åœºæ™¯
  - âœ… å…³é”®å­—å¯æ˜ å°„ä¸ºå“ˆå¸Œå€¼
- **æ ¸å¿ƒæ€æƒ³**: å»ºç«‹å…³é”®å­—ä¸å­˜å‚¨ä½ç½®ä¹‹é—´çš„ç›´æ¥æ˜ å°„å…³ç³»ï¼Œé€šè¿‡å“ˆå¸Œå‡½æ•°å¿«é€Ÿå®šä½

---

## ğŸ¯ ç®—æ³•åŸç†

### 1. åŸºæœ¬æ€è·¯
1. **å“ˆå¸Œå‡½æ•°**: å°†å…³é”®å­—é€šè¿‡å“ˆå¸Œå‡½æ•°è½¬æ¢ä¸ºå“ˆå¸Œåœ°å€
2. **å“ˆå¸Œè¡¨**: åŸºäºå“ˆå¸Œåœ°å€æ„å»ºçš„æ•°ç»„ç»“æ„
3. **æ’å…¥**: å°†å…³é”®å­—é€šè¿‡å“ˆå¸Œå‡½æ•°è®¡ç®—åœ°å€å¹¶å­˜å‚¨åˆ°å“ˆå¸Œè¡¨
4. **æŸ¥æ‰¾**: é€šè¿‡ç›¸åŒå“ˆå¸Œå‡½æ•°è®¡ç®—åœ°å€å¹¶ç›´æ¥è®¿é—®å“ˆå¸Œè¡¨å¯¹åº”ä½ç½®
5. **å†²çªå¤„ç†**: å½“å¤šä¸ªå…³é”®å­—æ˜ å°„åˆ°åŒä¸€åœ°å€æ—¶çš„è§£å†³ç­–ç•¥

### 2. æ ¸å¿ƒæµç¨‹å›¾
```mermaid
graph TD
    A[å¼€å§‹] --> B[è®¾è®¡å“ˆå¸Œå‡½æ•°H(key)]
    B --> C[åˆå§‹åŒ–å“ˆå¸Œè¡¨]
    C --> D{æ“ä½œç±»å‹?}
    D -- æ’å…¥ --> E[è®¡ç®—åœ°å€: addr = H(key)]
    D -- æŸ¥æ‰¾ --> E
    E --> F{åœ°å€æ˜¯å¦å†²çª?}
    F -- å¦ --> G[ç›´æ¥è®¿é—®/å­˜å‚¨å…³é”®å­—]
    F -- æ˜¯ --> H[ä½¿ç”¨å†²çªè§£å†³ç­–ç•¥è®¡ç®—æ–°åœ°å€]
    H --> I{æ–°åœ°å€æ˜¯å¦å¯ç”¨?}
    I -- æ˜¯ --> G
    I -- å¦ --> J[å“ˆå¸Œè¡¨å·²æ»¡?]
    J -- æ˜¯ --> K[æ‰©å®¹å“ˆå¸Œè¡¨]
    J -- å¦ --> H
    K --> E
    G --> L{æŸ¥æ‰¾æˆåŠŸ?}
    L -- æ˜¯ --> M[è¿”å›å…³é”®å­—ä½ç½®/å€¼]
    L -- å¦ --> N[è¿”å›æŸ¥æ‰¾å¤±è´¥]
    M --> O[ç»“æŸ]
    N --> O
```

### 3. å“ˆå¸Œå‡½æ•°è®¾è®¡
å¸¸ç”¨å“ˆå¸Œå‡½æ•°ç±»å‹ï¼š
- **ç›´æ¥å®šå€æ³•**: H(key) = a*key + b
- **é™¤ç•™ä½™æ•°æ³•**: H(key) = key % p (pä¸ºç´ æ•°)
- **æ•°å­—åˆ†ææ³•**: å–å…³é”®å­—æŸäº›æ•°å­—ä½ç»„æˆå“ˆå¸Œåœ°å€
- **å¹³æ–¹å–ä¸­æ³•**: å–å…³é”®å­—å¹³æ–¹çš„ä¸­é—´å‡ ä½ä½œä¸ºå“ˆå¸Œåœ°å€
- **æŠ˜å æ³•**: å°†å…³é”®å­—åˆ†å‰²æˆå‡ éƒ¨åˆ†ååˆå¹¶
- **éšæœºæ•°æ³•**: H(key) = random(key)

### 4. å†²çªè§£å†³ç­–ç•¥
| æ–¹æ³• | åŸç† | ä¼˜ç‚¹ | ç¼ºç‚¹ |
|------|------|------|------|
| å¼€æ”¾å®šå€æ³• | å†²çªæ—¶æ¢æŸ¥ä¸‹ä¸€ä¸ªç©ºä½ç½® | ç®€å• | èšé›†ç°è±¡ï¼Œåˆ é™¤å›°éš¾ |
| é“¾åœ°å€æ³• | å°†å†²çªå…ƒç´ é“¾æ¥æˆé“¾è¡¨ | å¤„ç†ç®€å•ï¼Œæ— èšé›† | éœ€è¦é¢å¤–æŒ‡é’ˆç©ºé—´ |
| å†å“ˆå¸Œæ³• | ä½¿ç”¨å¤šä¸ªå“ˆå¸Œå‡½æ•° | ä¸æ˜“äº§ç”Ÿèšé›† | å¢åŠ è®¡ç®—æ—¶é—´ |
| å»ºç«‹å…¬å…±æº¢å‡ºåŒº | å†²çªå…ƒç´ æ”¾å…¥æº¢å‡ºè¡¨ | ä¸»è¡¨æŸ¥æ‰¾æ•ˆç‡é«˜ | éœ€è¦ç»´æŠ¤æº¢å‡ºè¡¨ |

---

## ğŸ’» ä»£ç å®ç°

### 1. åŸºç¡€å“ˆå¸Œè¡¨å®ç°ï¼ˆé“¾åœ°å€æ³•ï¼‰
```java
import java.util.LinkedList;
import java.util.List;

/**
 * å“ˆå¸Œè¡¨å®ç°ï¼ˆé“¾åœ°å€æ³•è§£å†³å†²çªï¼‰
 */
public class HashTableChaining {
    private int capacity; // å“ˆå¸Œè¡¨å®¹é‡
    private float loadFactor; // è´Ÿè½½å› å­
    private int size; // å½“å‰å…ƒç´ æ•°é‡
    private List[] table; // å“ˆå¸Œè¡¨æ•°ç»„

    /**
     * æ„é€ å‡½æ•°
     * @param initialCapacity åˆå§‹å®¹é‡
     * @param loadFactor è´Ÿè½½å› å­
     */
    public HashTableChaining(int initialCapacity, float loadFactor) {
        this.capacity = initialCapacity;
        this.loadFactor = loadFactor;
        this.size = 0;
        this.table = new LinkedList[initialCapacity];
        // åˆå§‹åŒ–æ¯ä¸ªæ¡¶
        for (int i = 0; i < initialCapacity; i++) {
            table[i] = new LinkedList();
        }
    }

    /**
     * é»˜è®¤æ„é€ å‡½æ•°
     */
    public HashTableChaining() {
        this(16, 0.75f);
    }

    /**
     * å“ˆå¸Œå‡½æ•° - é™¤ç•™ä½™æ•°æ³•
     */
    private int hash(int key) {
        return key % capacity;
    }

    /**
     * å“ˆå¸Œå‡½æ•° - æ”¹è¿›çš„é™¤ç•™ä½™æ•°æ³•
     */
    private int betterHash(int key) {
        key ^= (key >>> 16);
        return key % capacity;
    }

    /**
     * æ·»åŠ å…ƒç´ 
     */
    public void put(int key, Object value) {
        // æ£€æŸ¥æ˜¯å¦éœ€è¦æ‰©å®¹
        if ((float) size / capacity >= loadFactor) {
            resize();
        }

        int index = betterHash(key);
        // éå†æ¡¶ä¸­çš„é“¾è¡¨ï¼Œæ›´æ–°å·²æœ‰key
        for (Object entry : table[index]) {
            HashEntry e = (HashEntry) entry;
            if (e.key == key) {
                e.value = value;
                return;
            }
        }
        // æ·»åŠ æ–°å…ƒç´ 
        table[index].add(new HashEntry(key, value));
        size++;
    }

    /**
     * è·å–å…ƒç´ 
     */
    public Object get(int key) {
        int index = betterHash(key);
        // éå†æ¡¶ä¸­çš„é“¾è¡¨
        for (Object entry : table[index]) {
            HashEntry e = (HashEntry) entry;
            if (e.key == key) {
                return e.value;
            }
        }
        return null; // æœªæ‰¾åˆ°
    }

    /**
     * åˆ é™¤å…ƒç´ 
     */
    public boolean remove(int key) {
        int index = betterHash(key);
        for (Object entry : table[index]) {
            HashEntry e = (HashEntry) entry;
            if (e.key == key) {
                table[index].remove(entry);
                size--;
                return true;
            }
        }
        return false; // æœªæ‰¾åˆ°
    }

    /**
     * å“ˆå¸Œè¡¨æ‰©å®¹
     */
    private void resize() {
        int newCapacity = capacity * 2;
        List[] newTable = new LinkedList[newCapacity];
        for (int i = 0; i < newCapacity; i++) {
            newTable[i] = new LinkedList();
        }

        // é‡æ–°å“ˆå¸Œæ‰€æœ‰å…ƒç´ 
        capacity = newCapacity;
        for (List bucket : table) {
            for (Object entry : bucket) {
                HashEntry e = (HashEntry) entry;
                int index = betterHash(e.key);
                newTable[index].add(e);
            }
        }
        table = newTable;
    }

    /**
     * å“ˆå¸Œè¡¨æ¡ç›®ç±»
     */
    private static class HashEntry {
        int key;
        Object value;

        HashEntry(int key, Object value) {
            this.key = key;
            this.value = value;
        }
    }
}
```

### 2. å¼€æ”¾å®šå€æ³•å®ç°ï¼ˆçº¿æ€§æ¢æµ‹ï¼‰
```java
/**
 * å“ˆå¸Œè¡¨å®ç°ï¼ˆçº¿æ€§æ¢æµ‹æ³•è§£å†³å†²çªï¼‰
 */
public class HashTableLinearProbing {
    private static final int DEFAULT_CAPACITY = 16;
    private static final float DEFAULT_LOAD_FACTOR = 0.75f;
    private static final Object DELETED = new Object(); // æ ‡è®°åˆ é™¤çš„å ä½ç¬¦

    private Object[] keys;
    private Object[] values;
    private int size;
    private int capacity;
    private float loadFactor;

    public HashTableLinearProbing() {
        this(DEFAULT_CAPACITY, DEFAULT_LOAD_FACTOR);
    }

    public HashTableLinearProbing(int capacity, float loadFactor) {
        this.capacity = capacity;
        this.loadFactor = loadFactor;
        this.keys = new Object[capacity];
        this.values = new Object[capacity];
        this.size = 0;
    }

    /**
     * å“ˆå¸Œå‡½æ•°
     */
    private int hash(Object key) {
        if (key == null) return 0;
        int h = key.hashCode();
        return (h ^ (h >>> 16)) % capacity;
    }

    /**
     * çº¿æ€§æ¢æµ‹è·å–ä¸‹ä¸€ä¸ªä½ç½®
     */
    private int probeNext(int index) {
        return (index + 1) % capacity;
    }

    /**
     * æ·»åŠ å…ƒç´ 
     */
    public void put(Object key, Object value) {
        if (key == null) throw new IllegalArgumentException("Key cannot be null");

        // æ£€æŸ¥æ˜¯å¦éœ€è¦æ‰©å®¹
        if ((float) size / capacity >= loadFactor) {
            resize();
        }

        int index = hash(key);
        // çº¿æ€§æ¢æµ‹æ‰¾åˆ°ç©ºä½ç½®æˆ–ç›¸åŒkey
        while (keys[index] != null && !keys[index].equals(key) && keys[index] != DELETED) {
            index = probeNext(index);
        }

        // å¦‚æœæ˜¯æ–°ä½ç½®ï¼Œå¢åŠ size
        if (keys[index] == null || keys[index] == DELETED) {
            size++;
        }
        keys[index] = key;
        values[index] = value;
    }

    /**
     * è·å–å…ƒç´ 
     */
    public Object get(Object key) {
        if (key == null) return null;

        int index = hash(key);
        // çº¿æ€§æ¢æµ‹æŸ¥æ‰¾
        while (keys[index] != null) {
            if (keys[index].equals(key)) {
                return values[index];
            }
            index = probeNext(index);
        }
        return null; // æœªæ‰¾åˆ°
    }

    /**
     * åˆ é™¤å…ƒç´ 
     */
    public Object remove(Object key) {
        if (key == null) return null;

        int index = hash(key);
        // çº¿æ€§æ¢æµ‹æŸ¥æ‰¾
        while (keys[index] != null) {
            if (keys[index].equals(key)) {
                Object oldValue = values[index];
                keys[index] = DELETED; // æ ‡è®°ä¸ºå·²åˆ é™¤
                values[index] = null;
                size--;
                return oldValue;
            }
            index = probeNext(index);
        }
        return null; // æœªæ‰¾åˆ°
    }

    /**
     * æ‰©å®¹å“ˆå¸Œè¡¨
     */
    private void resize() {
        int newCapacity = capacity * 2;
        Object[] newKeys = new Object[newCapacity];
        Object[] newValues = new Object[newCapacity];

        // é‡æ–°å“ˆå¸Œæ‰€æœ‰å…ƒç´ 
        for (int i = 0; i < capacity; i++) {
            if (keys[i] != null && keys[i] != DELETED) {
                int index = hash(keys[i]);
                // çº¿æ€§æ¢æµ‹æ‰¾åˆ°ç©ºä½ç½®
                while (newKeys[index] != null) {
                    index = (index + 1) % newCapacity;
                }
                newKeys[index] = keys[i];
                newValues[index] = values[i];
            }
        }

        this.capacity = newCapacity;
        this.keys = newKeys;
        this.values = newValues;
    }
}
```

### 3. å†å“ˆå¸Œæ³•å®ç°
```java
/**
 * å†å“ˆå¸Œæ³•å®ç°ï¼ˆåŒé‡å“ˆå¸Œè§£å†³å†²çªï¼‰
 */
public class RehashingHashTable {
    private Object[] keys;
    private Object[] values;
    private int size;
    private int capacity;
    private static final int[] PRIMES = {11, 23, 47, 97, 193, 389, 769, 1543};

    public RehashingHashTable() {
        this.capacity = PRIMES[0];
        this.keys = new Object[capacity];
        this.values = new Object[capacity];
        this.size = 0;
    }

    /**
     * ä¸»å“ˆå¸Œå‡½æ•°
     */
    private int hash1(Object key) {
        return Math.abs(key.hashCode()) % capacity;
    }

    /**
     * äºŒæ¬¡å“ˆå¸Œå‡½æ•°
     */
    private int hash2(Object key) {
        int prime = getPreviousPrime(capacity);
        return prime - (Math.abs(key.hashCode()) % prime);
    }

    /**
     * è·å–å°äºcapacityçš„æœ€å¤§ç´ æ•°
     */
    private int getPreviousPrime(int capacity) {
        for (int i = PRIMES.length - 1; i >= 0; i--) {
            if (PRIMES[i] < capacity) {
                return PRIMES[i];
            }
        }
        return 1;
    }

    /**
     * æ·»åŠ å…ƒç´ 
     */
    public void put(Object key, Object value) {
        if (size >= capacity / 2) {
            resize();
        }

        int index = hash1(key);
        int step = hash2(key);

        // åŒé‡å“ˆå¸Œæ¢æµ‹
        while (keys[index] != null && !keys[index].equals(key)) {
            index = (index + step) % capacity;
        }

        if (keys[index] == null) {
            size++;
        }
        keys[index] = key;
        values[index] = value;
    }

    /**
     * è·å–å…ƒç´ 
     */
    public Object get(Object key) {
        int index = hash1(key);
        int step = hash2(key);

        while (keys[index] != null) {
            if (keys[index].equals(key)) {
                return values[index];
            }
            index = (index + step) % capacity;
        }
        return null;
    }

    /**
     * æ‰©å®¹å“ˆå¸Œè¡¨
     */
    private void resize() {
        int newCapacity = getNextPrime(capacity);
        if (newCapacity == capacity) {
            throw new RuntimeException("Hash table is full");
        }

        Object[] oldKeys = keys;
        Object[] oldValues = values;

        keys = new Object[newCapacity];
        values = new Object[newCapacity];
        size = 0;
        capacity = newCapacity;

        // é‡æ–°å“ˆå¸Œæ‰€æœ‰å…ƒç´ 
        for (int i = 0; i < oldKeys.length; i++) {
            if (oldKeys[i] != null) {
                put(oldKeys[i], oldValues[i]);
            }
        }
    }

    /**
     * è·å–ä¸‹ä¸€ä¸ªç´ æ•°
     */
    private int getNextPrime(int capacity) {
        for (int prime : PRIMES) {
            if (prime > capacity) {
                return prime;
            }
        }
        return capacity * 2;
    }
}
```

---

## ğŸ“Š å¤æ‚åº¦åˆ†æ

| æƒ…å†µ | æ—¶é—´å¤æ‚åº¦ | ç©ºé—´å¤æ‚åº¦ | è¯´æ˜ |
|------|------------|------------|------|
| æœ€å¥½æƒ…å†µ | O(1) | O(n) | å“ˆå¸Œå‡½æ•°å‡åŒ€åˆ†å¸ƒï¼Œæ— å†²çª |
| å¹³å‡æƒ…å†µ | O(1) | O(n) | è€ƒè™‘å†²çªçš„å¹³å‡æ¢æµ‹æ¬¡æ•° |
| æœ€åæƒ…å†µ | O(n) | O(n) | æ‰€æœ‰å…³é”®å­—å“ˆå¸Œåˆ°åŒä¸€ä½ç½® |

### å¤æ‚åº¦åˆ†æè¦ç‚¹
- å“ˆå¸Œè¡¨æ€§èƒ½å–å†³äº**å“ˆå¸Œå‡½æ•°**å’Œ**å†²çªè§£å†³ç­–ç•¥**
- è´Ÿè½½å› å­(Î± = n/m)æ˜¯å½±å“æ€§èƒ½çš„å…³é”®æŒ‡æ ‡ï¼Œé€šå¸¸å–0.5-0.75
- é“¾åœ°å€æ³•çš„å¹³å‡æŸ¥æ‰¾é•¿åº¦ä¸ºO(1+Î±)ï¼Œå¼€æ”¾å®šå€æ³•ä¸ºO(1/(1-Î±))
- å“ˆå¸Œå‡½æ•°è®¾è®¡ç›´æ¥å½±å“å†²çªæ¦‚ç‡ï¼Œå¥½çš„å“ˆå¸Œå‡½æ•°åº”ä½¿å…³é”®å­—å‡åŒ€åˆ†å¸ƒ
- æ‰©å®¹æ“ä½œä¼šå¯¼è‡´O(n)æ—¶é—´å¤æ‚åº¦ï¼Œä½†å¹³å‡åˆ†æ‘Šåä»ä¸ºO(1)

### ä¸åŒå†²çªè§£å†³æ–¹æ³•æ€§èƒ½å¯¹æ¯”
| è§£å†³æ–¹æ³• | å¹³å‡æŸ¥æ‰¾é•¿åº¦(æˆåŠŸ) | å¹³å‡æŸ¥æ‰¾é•¿åº¦(å¤±è´¥) | å®ç°å¤æ‚åº¦ | ç©ºé—´åˆ©ç”¨ç‡ |
|----------|-------------------|-------------------|------------|------------|
| é“¾åœ°å€æ³• | 1+Î±/2 | Î±+eâ»Î± | ç®€å• | é«˜ |
| çº¿æ€§æ¢æµ‹ | (1+1/(1-Î±))/2 | (1+1/(1-Î±)Â²)/2 | ç®€å• | ä¸­ |
| äºŒæ¬¡æ¢æµ‹ | (1/(1-Î±))/2 | -ln(1-Î±)/Î± | ä¸­ç­‰ | ä¸­ |
| å†å“ˆå¸Œæ³• | 1+Î±/2 | 1/(1-Î±) | å¤æ‚ | ä¸­ |

---

## ğŸ” åº”ç”¨åœºæ™¯

### å…¸å‹åº”ç”¨
- æ•°æ®åº“ç´¢å¼•
- ç¼“å­˜ç³»ç»Ÿå®ç°
- ç¼–è¯‘å™¨ç¬¦å·è¡¨
- å“ˆå¸Œé›†åˆ/æ˜ å°„æ•°æ®ç»“æ„
- å¯†ç å­¦ä¸­çš„æ¶ˆæ¯æ‘˜è¦
- åˆ†å¸ƒå¼ç³»ç»Ÿä¸­çš„ä¸€è‡´æ€§å“ˆå¸Œ

### å®é™…æ¡ˆä¾‹
- **Javaé›†åˆæ¡†æ¶**: HashMap, HashSeté‡‡ç”¨é“¾åœ°å€æ³•
- **Pythonå­—å…¸**: é‡‡ç”¨å¼€æ”¾å®šå€æ³•å®ç°
- **Redisæ•°æ®åº“**: ä½¿ç”¨å“ˆå¸Œè¡¨ä½œä¸ºåº•å±‚æ•°æ®ç»“æ„
- **åˆ†å¸ƒå¼ç¼“å­˜**: Memcachedä½¿ç”¨ä¸€è‡´æ€§å“ˆå¸Œ
- **æœç´¢å¼•æ“**: å…³é”®è¯ç´¢å¼•ç³»ç»Ÿ
- **è·¯ç”±è¡¨**: ç½‘ç»œè®¾å¤‡ä¸­çš„è·¯ç”±æŸ¥æ‰¾

---

## âš ï¸ æ³¨æ„äº‹é¡¹

### 1. å“ˆå¸Œå‡½æ•°è®¾è®¡åŸåˆ™
- **ç¡®å®šæ€§**: åŒä¸€å…³é”®å­—å¿…é¡»äº§ç”ŸåŒä¸€å“ˆå¸Œåœ°å€
- **å‡åŒ€æ€§**: å…³é”®å­—åˆ†å¸ƒå‡åŒ€ï¼Œå‡å°‘å†²çª
- **é«˜æ•ˆæ€§**: è®¡ç®—å¿«é€Ÿï¼Œæ—¶é—´å¤æ‚åº¦O(1)
- **æŠ—ç¢°æ’æ€§**: éš¾ä»¥æ‰¾åˆ°ä¸åŒå…³é”®å­—äº§ç”ŸåŒä¸€å“ˆå¸Œåœ°å€
- **å®šä¹‰åŸŸ**: å“ˆå¸Œå‡½æ•°çš„å€¼åŸŸåº”åœ¨å“ˆå¸Œè¡¨å¤§å°èŒƒå›´å†…

### 2. å†²çªå¤„ç†æ³¨æ„äº‹é¡¹
- **é“¾åœ°å€æ³•**: 
  - éœ€è¦é¢å¤–ç©ºé—´å­˜å‚¨æŒ‡é’ˆ/å¼•ç”¨
  - é“¾è¡¨è¿‡é•¿ä¼šå¯¼è‡´æ€§èƒ½é€€åŒ–
  - åˆ é™¤æ“ä½œç®€å•ï¼Œæ— éœ€ç§»åŠ¨å…¶ä»–å…ƒç´ 

- **å¼€æ”¾å®šå€æ³•**: 
  - å­˜åœ¨èšé›†ç°è±¡ï¼Œå½±å“æ€§èƒ½
  - åˆ é™¤éœ€ä½¿ç”¨"å¢“ç¢‘"æ ‡è®°ï¼Œä¸èƒ½ç›´æ¥ç½®ç©º
  - å“ˆå¸Œè¡¨åˆ©ç”¨ç‡ä¸èƒ½è¾¾åˆ°100%

### 3. å®ç°æ³¨æ„äº‹é¡¹
- **ç©ºå€¼å¤„ç†**: æ˜ç¡®æ˜¯å¦å…è®¸keyæˆ–valueä¸ºç©º
- **æ‰©å®¹ç­–ç•¥**: åˆç†è®¾ç½®è´Ÿè½½å› å­å’Œæ‰©å®¹é˜ˆå€¼
- **å“ˆå¸Œå‡½æ•°é€‰æ‹©**: æ ¹æ®å…³é”®å­—ç‰¹æ€§é€‰æ‹©åˆé€‚çš„å“ˆå¸Œå‡½æ•°
- **çº¿ç¨‹å®‰å…¨**: å“ˆå¸Œè¡¨é€šå¸¸ä¸æ˜¯çº¿ç¨‹å®‰å…¨çš„ï¼Œå¤šçº¿ç¨‹ç¯å¢ƒéœ€åŒæ­¥
- **å†…å­˜ç®¡ç†**: é“¾åœ°å€æ³•éœ€ç®¡ç†é“¾è¡¨èŠ‚ç‚¹å†…å­˜
- **å“ˆå¸Œæ”»å‡»é˜²æŠ¤**: é¿å…æ¶æ„æ„é€ å“ˆå¸Œå†²çªå¯¼è‡´DoSæ”»å‡»

---

## ğŸ“ æœ€ä½³å®è·µ

### ä½¿ç”¨å»ºè®®
1. **é€‰æ‹©åˆé€‚çš„å“ˆå¸Œå‡½æ•°**: 
   - æ•´æ•°å…³é”®å­—: é™¤ç•™ä½™æ•°æ³•
   - å­—ç¬¦ä¸²å…³é”®å­—: å¤šé¡¹å¼å“ˆå¸Œæˆ–FNVå“ˆå¸Œ
   - è‡ªå®šä¹‰å¯¹è±¡: ç»“åˆå¤šä¸ªå­—æ®µè®¡ç®—å“ˆå¸Œå€¼

2. **å†²çªè§£å†³ç­–ç•¥é€‰æ‹©**: 
   - å†…å­˜å—é™: å¼€æ”¾å®šå€æ³•
   - é¢‘ç¹åˆ é™¤: é“¾åœ°å€æ³•
   - é«˜æ€§èƒ½è¦æ±‚: é“¾åœ°å€æ³•+çº¢é»‘æ ‘(JDK 8 HashMap)

3. **è´Ÿè½½å› å­è®¾ç½®**: 
   - é™æ€æ•°æ®: 0.7-0.8
   - åŠ¨æ€æ•°æ®: 0.5-0.7
   - å®æ—¶ç³»ç»Ÿ: 0.5ä»¥ä¸‹

### ä¼˜åŒ–æŠ€å·§
- **é¢„è®¡ç®—å“ˆå¸Œå€¼**: å¯¹é¢‘ç¹æŸ¥æ‰¾çš„å¯¹è±¡ç¼“å­˜å“ˆå¸Œå€¼
- **åˆç†åˆå§‹å®¹é‡**: æ ¹æ®é¢„æœŸæ•°æ®é‡è®¾ç½®åˆå§‹å¤§å°
- **å¤šçº§å“ˆå¸Œè¡¨**: å¤§å‹ç³»ç»Ÿå¯é‡‡ç”¨å¤šçº§å“ˆå¸Œç»“æ„
- **ç¡¬ä»¶åŠ é€Ÿ**: ä½¿ç”¨CPUæŒ‡ä»¤ä¼˜åŒ–å“ˆå¸Œè®¡ç®—
- **å¹¶è¡Œå“ˆå¸Œè¡¨**: å¤šçº¿ç¨‹ç¯å¢ƒä½¿ç”¨åˆ†æ®µé”æˆ–æ— é”è®¾è®¡
- **å¸ƒéš†è¿‡æ»¤å™¨**: å¯¹ä¸å­˜åœ¨çš„keyè¿›è¡Œå¿«é€Ÿè¿‡æ»¤

### å¸¸è§é—®é¢˜è§£å†³æ–¹æ¡ˆ
| é—®é¢˜ | è§£å†³æ–¹æ¡ˆ |
|------|----------|
| å“ˆå¸Œå†²çªä¸¥é‡ | æ”¹è¿›å“ˆå¸Œå‡½æ•°ï¼Œè°ƒæ•´è´Ÿè½½å› å­ï¼Œæ›´æ¢å†²çªè§£å†³æ–¹æ³• |
| å†…å­˜å ç”¨è¿‡å¤§ | å¼€æ”¾å®šå€æ³•ï¼Œå‹ç¼©å“ˆå¸Œå‡½æ•°å€¼åŸŸï¼Œä½¿ç”¨ç¨€ç–å“ˆå¸Œè¡¨ |
| åˆ é™¤æ•ˆç‡ä½ | é“¾åœ°å€æ³•ï¼Œå»¶è¿Ÿåˆ é™¤ï¼Œæ ‡è®°æ¸…é™¤ |
| å¹¶å‘æ€§èƒ½å·® | åˆ†æ®µé”ï¼Œæ— é”è®¾è®¡ï¼ŒConcurrentHashMap |
| å“ˆå¸Œæ”»å‡»é£é™© | ä½¿ç”¨éšæœºå“ˆå¸Œç§å­ï¼ŒåŠ å¯†å“ˆå¸Œå‡½æ•°ï¼Œé™åˆ¶æ¡¶å¤§å° |

---

> **æ€»ç»“**: å“ˆå¸ŒæŸ¥æ‰¾é€šè¿‡å»ºç«‹å…³é”®å­—ä¸å­˜å‚¨ä½ç½®çš„ç›´æ¥æ˜ å°„ï¼Œå®ç°äº†å¹³å‡O(1)æ—¶é—´å¤æ‚åº¦çš„æŸ¥æ‰¾æ“ä½œï¼Œæ˜¯é«˜æ€§èƒ½æŸ¥æ‰¾çš„é¦–é€‰ç®—æ³•ã€‚å®é™…åº”ç”¨ä¸­éœ€æƒè¡¡å“ˆå¸Œå‡½æ•°è®¾è®¡ã€å†²çªè§£å†³ç­–ç•¥å’Œè´Ÿè½½å› å­ï¼Œæ ¹æ®å…·ä½“åœºæ™¯é€‰æ‹©åˆé€‚çš„å®ç°æ–¹æ¡ˆã€‚åˆç†ä½¿ç”¨å“ˆå¸ŒæŸ¥æ‰¾å¯ä»¥æ˜¾è‘—æå‡ç³»ç»Ÿæ€§èƒ½ï¼Œå°¤å…¶åœ¨å¤§è§„æ¨¡æ•°æ®å’Œé¢‘ç¹æŸ¥æ‰¾çš„åœºæ™¯ä¸­è¡¨ç°çªå‡ºã€‚
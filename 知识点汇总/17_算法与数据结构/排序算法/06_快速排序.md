# 快速排序

> 快速排序（Quick Sort）是一种高效的分治排序算法，由计算机科学家Tony Hoare于1960年提出。它通过选择一个基准元素将数组分区，递归地对分区后的子数组进行排序，以平均O(n log n)的时间复杂度成为实际应用中最常用的排序算法之一。快速排序的核心优势在于原地排序特性和良好的缓存性能。

---

## 📋 基本信息

### 算法类别
- **排序类型**：快速排序（分治排序）
- **核心思想**：分治法（Divide, Conquer, Partition）
- **稳定性**：不稳定排序
- **时间复杂度**：O(n log n)（平均），O(n²)（最坏）
- **空间复杂度**：O(log n) ~ O(n)（递归栈空间）
- **难度级别**：中等
- **适用场景**：大规模数据排序、内存受限环境、平均性能要求高的场景

### 历史背景
快速排序由英国计算机科学家Tony Hoare在1960年为解决COBOL语言中的排序问题而发明。其设计灵感来源于归并排序的分治思想，但通过原地分区操作大幅减少了内存消耗。Hoare的原始实现使用双向扫描分区法，后来出现了多种优化变体，如三数取中法、随机化选择基准、三路快排等。快速排序因其卓越的实际性能，成为许多编程语言标准库的默认排序算法。

---

## 🎯 算法原理

### 基本思想
快速排序基于分治策略，通过以下步骤实现排序：
1. **选择基准（Pivot）**：从数组中选择一个元素作为基准
2. **分区（Partition）**：将数组重新排列，所有比基准值小的元素移到基准前面，所有比基准值大的元素移到基准后面
3. **递归排序**：递归地将小于基准值的子数组和大于基准值的子数组进行排序

### 分区策略
常用的分区方法包括：
- ** Lomuto分区法**：单指针扫描，将小于基准的元素依次交换到左侧
- **Hoare分区法**：双指针从两端向中间扫描，交换不满足条件的元素
- **三路快排**：将数组分为小于、等于和大于基准的三部分

### 工作流程
以Hoare分区法为例：
1. 选择最左侧元素作为基准
2. 初始化左右指针（i从左向右，j从右向左）
3. i向右移动直到找到大于基准的元素
4. j向左移动直到找到小于基准的元素
5. 交换i和j指向的元素
6. 重复步骤3-5，直到i >= j
7. 交换基准元素与j指向的元素（此时基准元素已就位）
8. 递归处理左右子数组

### 动图演示
> 示意图：快速排序的分区与递归过程
> [图示：快速排序使用Hoare分区法将数组分区并递归排序的动态过程]

---

## 💻 代码实现

### 基础实现（Lomuto分区法）
```java
public class QuickSortLomuto {
    public static void quickSort(int[] arr) {
        if (arr == null || arr.length <= 1) {
            return;
        }
        quickSort(arr, 0, arr.length - 1);
    }
    
    private static void quickSort(int[] arr, int low, int high) {
        if (low < high) {
            int pivotIndex = partition(arr, low, high);
            quickSort(arr, low, pivotIndex - 1);  // 排序左子数组
            quickSort(arr, pivotIndex + 1, high); // 排序右子数组
        }
    }
    
    private static int partition(int[] arr, int low, int high) {
        int pivot = arr[high]; // 选择最右侧元素作为基准
        int i = low - 1;       // 小于基准区域的边界
        
        for (int j = low; j < high; j++) {
            if (arr[j] <= pivot) {
                i++;
                // 交换元素到小于基准区域
                int temp = arr[i];
                arr[i] = arr[j];
                arr[j] = temp;
            }
        }
        
        // 将基准元素放到最终位置
        int temp = arr[i + 1];
        arr[i + 1] = arr[high];
        arr[high] = temp;
        
        return i + 1; // 返回基准元素索引
    }
}
```

### 经典实现（Hoare分区法）
```java
public class QuickSortHoare {
    public static void quickSort(int[] arr) {
        if (arr == null || arr.length <= 1) {
            return;
        }
        quickSort(arr, 0, arr.length - 1);
    }
    
    private static void quickSort(int[] arr, int low, int high) {
        if (low < high) {
            int pivotIndex = partition(arr, low, high);
            quickSort(arr, low, pivotIndex);    // 注意Hoare分区法的边界
            quickSort(arr, pivotIndex + 1, high);
        }
    }
    
    private static int partition(int[] arr, int low, int high) {
        int pivot = arr[low]; // 选择最左侧元素作为基准
        int i = low - 1;      // 左指针
        int j = high + 1;     // 右指针
        
        while (true) {
            // 向右移动左指针，直到找到大于等于基准的元素
            do {
                i++;
            } while (arr[i] < pivot);
            
            // 向左移动右指针，直到找到小于等于基准的元素
            do {
                j--;
            } while (arr[j] > pivot);
            
            // 如果指针相遇，返回右指针作为分区点
            if (i >= j) {
                return j;
            }
            
            // 交换元素
            int temp = arr[i];
            arr[i] = arr[j];
            arr[j] = temp;
        }
    }
}
```

### 优化实现（三数取中法+三路快排）
```java
public class QuickSortOptimized {
    public static void quickSort(int[] arr) {
        if (arr == null || arr.length <= 1) {
            return;
        }
        quickSort(arr, 0, arr.length - 1);
    }
    
    private static void quickSort(int[] arr, int low, int high) {
        if (low < high) {
            // 小规模数组使用插入排序
            if (high - low + 1 < 10) {
                insertionSort(arr, low, high);
                return;
            }
            
            // 三数取中法选择基准
            int pivotIndex = medianOfThree(arr, low, high);
            swap(arr, pivotIndex, low); // 将基准元素移到左端
            
            // 三路快排分区
            int[] p = partitionThreeWay(arr, low, high);
            int left = p[0];  // 等于基准区域的左边界
            int right = p[1]; // 等于基准区域的右边界
            
            quickSort(arr, low, left - 1);  // 排序小于基准区域
            quickSort(arr, right + 1, high); // 排序大于基准区域
        }
    }
    
    // 三数取中法选择基准
    private static int medianOfThree(int[] arr, int low, int high) {
        int mid = low + (high - low) / 2;
        
        // 排序三个位置的元素
        if (arr[low] > arr[mid]) swap(arr, low, mid);
        if (arr[low] > arr[high]) swap(arr, low, high);
        if (arr[mid] > arr[high]) swap(arr, mid, high);
        
        return mid; // 返回中间值的索引
    }
    
    // 三路快排分区
    private static int[] partitionThreeWay(int[] arr, int low, int high) {
        int pivot = arr[low];
        int lt = low;  // 小于基准区域的边界
        int gt = high; // 大于基准区域的边界
        int i = low + 1; // 当前扫描指针
        
        while (i <= gt) {
            if (arr[i] < pivot) {
                swap(arr, lt++, i++);
            } else if (arr[i] > pivot) {
                swap(arr, i, gt--);
            } else {
                i++;
            }
        }
        
        return new int[]{lt, gt}; // 返回等于基准区域的左右边界
    }
    
    // 插入排序（小规模数组）
    private static void insertionSort(int[] arr, int low, int high) {
        for (int i = low + 1; i <= high; i++) {
            int temp = arr[i];
            int j;
            for (j = i; j > low && arr[j - 1] > temp; j--) {
                arr[j] = arr[j - 1];
            }
            arr[j] = temp;
        }
    }
    
    private static void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
}
```

---

## 📊 复杂度分析

### 时间复杂度
- **最好情况**：O(n log n) - 每次分区都将数组均匀分成两部分
- **最坏情况**：O(n²) - 数组已排序或所有元素相等，且选择最左/右元素为基准
- **平均情况**：O(n log n) - 随机数据下的期望时间复杂度

### 空间复杂度
- **空间复杂度**：O(log n) ~ O(n)
  - 最佳情况：O(log n) - 均匀分区时的递归栈深度
  - 最坏情况：O(n) - 极端不平衡分区时的递归栈深度
  - 迭代实现可优化至O(log n)的辅助空间

### 复杂度分析图表
| 实现方式 | 时间复杂度(最好) | 时间复杂度(最坏) | 时间复杂度(平均) | 空间复杂度 | 稳定性 |
|----------|------------------|------------------|------------------|------------|--------|
| 基础递归 | O(n log n) | O(n²) | O(n log n) | O(log n) ~ O(n) | 不稳定 |
| Hoare分区 | O(n log n) | O(n²) | O(log n) | O(log n) ~ O(n) | 不稳定 |
| 三数取中 | O(n log n) | O(n log n) | O(n log n) | O(log n) | 不稳定 |
| 三路快排 | O(n log n) | O(n log n) | O(n log n) | O(log n) | 不稳定 |

---

## 🔍 应用场景

### 适用场景
- **大规模数据排序**：平均性能优异，实际应用中通常快于归并排序
- **内存受限环境**：原地排序特性，空间效率高
- **随机访问存储结构**：数组排序效率高
- **实时系统**：对平均响应时间有要求的应用
- **数据库系统**：内部排序操作
- **编程语言标准库**：如Java的Arrays.sort()对基本类型使用双轴快排

### 不适用场景
- **稳定性要求高的场景**：快速排序是不稳定排序
- **已排序或接近排序的数据**：可能导致最坏情况性能
- **链表结构**：随机访问效率低，不适合快排
- **对最坏情况敏感的系统**：需要保证O(n log n)最坏时间复杂度的场景

### 实际应用案例
- C++标准库的std::sort()实现
- Java的Arrays.sort()对原始类型的实现
- Python的list.sort()和sorted()在早期版本的实现
- 数据库系统中的索引构建
- 大数据处理中的局部排序阶段
- 搜索引擎的结果排序

---

## ✂️ 优化策略

### 1. 基准元素选择优化
- **随机化基准**：随机选择基准元素，避免最坏情况
- **三数取中法**：选择左端、中间、右端三个元素的中值作为基准
- **九数取中法**：从数组中随机选择9个元素，取中值作为基准
- **效果**：将最坏情况概率降至极低，实际性能提升显著

### 2. 分区策略优化
- **三路快排**：将数组分为小于、等于、大于基准三部分
- **优势**：处理重复元素效率高，避免重复元素导致的不平衡分区
- **应用场景**：含大量重复元素的数据排序

### 3. 小规模数组优化
- **切换到插入排序**：当子数组规模小于阈值（通常5-20）时使用插入排序
- **原理**：插入排序在小规模数组上常数因子小，效率更高
- **效果**：减少约10-15%的运行时间

### 4. 递归优化
- **尾递归消除**：对较大子数组使用循环，较小子数组使用递归
- **栈模拟**：使用显式栈代替递归，控制栈深度
- **效果**：避免栈溢出，空间复杂度稳定为O(log n)

### 5. 并行化实现
- **多线程快排**：将子数组分配给不同线程处理
- **优势**：利用多核处理器，加速排序过程
- **实现**：对超过一定规模的子数组才进行并行处理

---

## ⚠️ 注意事项

### 常见错误
- **基准选择不当**：导致分区不平衡，性能下降
- **边界条件错误**：分区和递归时的索引处理不当
- **重复元素处理**：未优化的快排对重复元素效率低
- **栈溢出风险**：递归深度过大导致栈溢出
- **稳定性误解**：错误地假设快排是稳定排序

### 实现要点
- **避免栈溢出**：使用迭代实现或限制递归深度
- **处理重复元素**：采用三路快排或其他优化策略
- **防止最坏情况**：使用随机化或中值选择基准
- **边界条件**：特别注意Hoare分区法的递归边界
- **小规模优化**：设置合适阈值切换到插入排序

### 稳定性分析
快速排序是不稳定的排序算法，原因如下：
- 分区过程中，相等元素的相对位置可能被交换
- 例如：[(2, A), (2, B)]以第一个2为基准时可能导致顺序改变
- 改进方法：通过复杂实现可以使快排稳定，但会丧失空间和时间优势

---

## 🎓 最佳实践

### 实现建议
1. **选择合适的基准策略**：对大多数应用，三数取中法足以避免最坏情况
2. **处理重复元素**：优先使用三路快排处理含重复元素的数据
3. **小规模优化**：设置10-15的阈值切换到插入排序
4. **迭代实现**：对大规模数据考虑使用显式栈的迭代实现
5. **并行处理**：多核环境下可对大子数组进行并行排序

### 代码规范
- 提取基准选择、分区、交换等操作作为独立函数
- 使用有意义的变量名（pivot, low, high, lt, gt等）
- 添加详细注释解释分区策略和优化措施
- 编写单元测试覆盖各种数据分布（随机、有序、逆序、重复元素）
- 处理特殊情况（空数组、单元素数组、所有元素相等）

### 与其他排序算法对比
| 特性 | 快速排序 | 归并排序 | 堆排序 |
|------|----------|----------|--------|
| 平均时间复杂度 | O(n log n) | O(n log n) | O(n log n) |
| 最坏时间复杂度 | O(n²) | O(n log n) | O(n log n) |
| 空间复杂度 | O(log n) | O(n) | O(1) |
| 稳定性 | 不稳定 | 稳定 | 不稳定 |
| 缓存效率 | 高 | 中 | 低 |
| 原地排序 | 是 | 否 | 是 |
| 并行性 | 中等 | 良好 | 较差 |

---

## 📝 经典题目

### LeetCode题目
1. **[LeetCode 912. 排序数组](https://leetcode.cn/problems/sort-array/)**
   - 难度：中等
   - 描述：使用快速排序实现数组排序
   - 提示：实现随机化基准或三数取中法避免超时

2. **[LeetCode 215. 数组中的第K个最大元素](https://leetcode.cn/problems/kth-largest-element-in-an-array/)**
   - 难度：中等
   - 描述：找到数组中第k个最大元素
   - 提示：利用快排的分区思想，无需完整排序

3. **[LeetCode 75. 颜色分类](https://leetcode.cn/problems/sort-colors/)**
   - 难度：中等
   - 描述：对包含0、1、2的数组进行排序
   - 提示：应用三路快排思想

4. **[LeetCode 922. 按奇偶排序数组 II](https://leetcode.cn/problems/sort-array-by-parity-ii/)**
   - 难度：简单
   - 描述：将数组按奇偶位置排序
   - 提示：双指针分区思想

### 面试常见问题
- 快速排序的工作原理是什么？如何实现？
- 如何优化快速排序的性能？
- 快速排序的最坏情况是什么？如何避免？
- 三路快排的原理是什么？适用于什么场景？
- 快速排序和归并排序的优缺点比较？
- 如何用快速排序思想找到第k大元素？

---

## 📚 扩展阅读

### 相关算法
- **双轴快速排序**：使用两个基准元素，将数组分为三部分
- **内省排序**：结合快排、堆排序和插入排序的混合算法
- **基数快速排序**：结合基数排序和快排的思想
- **外部快速排序**：处理大规模外部数据的快排变体
- **并行快速排序**：多线程实现的快排

### 推荐资源
- 《算法导论》第3版，第7章：快速排序
- 《算法》第4版，第2章：排序
- [快速排序可视化](https://visualgo.net/en/sorting)
- [Java双轴快排源码分析](https://hg.openjdk.java.net/jdk8/jdk8/jdk/file/tip/src/share/classes/java/util/DualPivotQuicksort.java)
- [Quicksort on Wikipedia](https://en.wikipedia.org/wiki/Quicksort)
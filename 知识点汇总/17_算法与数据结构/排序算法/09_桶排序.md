# 桶排序

> 桶排序（Bucket Sort）是一种分布式排序算法，它将待排序数据分到多个有序的桶中，每个桶内部再分别进行排序，最后将所有桶中的数据按顺序合并。桶排序的性能很大程度上取决于桶的设计和数据的分布特性。

---

## 📋 基本信息

| 项目                | 说明                                                                 |
|---------------------|----------------------------------------------------------------------|
| **算法类别**        | 分布式排序、非比较排序                                               |
| **时间复杂度**      | 最佳: O(n + k), 平均: O(n + k), 最坏: O(n²) (n为元素个数，k为桶数)    |
| **空间复杂度**      | O(n + k)                                                              |
| **稳定性**          | 取决于桶内排序算法                                                   |
| **原地排序**        | 否                                                                   |
| **并行性**          | 高度可并行化                                                         |
| **适用数据类型**    | 浮点数、整数、字符串（需自定义桶映射规则）                           |

## 🎯 算法原理

### 核心思想
桶排序的核心思想是将一个大数组分解为多个有序的小数组（桶），然后对每个小数组分别进行排序，最后将所有排序后的小数组合并成一个完整的有序数组。它利用了函数的映射关系，减少了直接比较的次数。

### 工作流程
1. **确定桶的数量和范围**：根据数据特性确定桶的数量k和每个桶的取值范围
2. **初始化桶结构**：创建k个空桶，通常使用链表或数组实现
3. **分配元素到桶中**：遍历原始数组，将每个元素根据映射函数分配到对应的桶中
4. **桶内排序**：对每个非空桶使用合适的排序算法进行排序（通常是插入排序或快速排序）
5. **合并桶数据**：按顺序将所有桶中的元素依次取出，合并成最终的有序数组

### 映射函数设计
常见的映射函数包括：
- **线性映射**：`bucketIndex = (int)(num * k / (maxValue - minValue + 1))`
- **哈希映射**：使用哈希函数将元素均匀分布到桶中
- **自定义映射**：根据数据分布特性设计专用映射函数

### 图解流程
```
原始数组: [3.6, 1.2, 4.8, 2.3, 5.7, 0.9, 3.1]

桶数量: 5个桶
桶范围: [0-1), [1-2), [2-3), [3-4), [4-5), [5-6)

分配结果:
桶0: [0.9]
桶1: [1.2]
桶2: [2.3]
桶3: [3.6, 3.1]
桶4: [4.8]
桶5: [5.7]

桶内排序后:
桶0: [0.9]
桶1: [1.2]
桶2: [2.3]
桶3: [3.1, 3.6]
桶4: [4.8]
桶5: [5.7]

合并结果: [0.9, 1.2, 2.3, 3.1, 3.6, 4.8, 5.7]
```

## 💻 代码实现

### 基础实现（针对浮点数）
```java
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

public class BucketSort {
    public static void bucketSort(double[] arr) {
        if (arr == null || arr.length <= 1) return;

        // 1. 找出最大值和最小值
        double max = arr[0];
        double min = arr[0];
        for (double num : arr) {
            if (num > max) max = num;
            if (num < min) min = num;
        }

        // 2. 初始化桶
        int bucketCount = arr.length; // 桶数量通常设为数组长度
        List<Double>[] buckets = new ArrayList[bucketCount];
        for (int i = 0; i < bucketCount; i++) {
            buckets[i] = new ArrayList<>();
        }

        // 3. 将元素分配到桶中
        double range = (max - min) / bucketCount;
        for (double num : arr) {
            int bucketIndex = (int) ((num - min) / range);
            // 处理最大值边界情况
            if (bucketIndex == bucketCount) {
                bucketIndex--;
            }
            buckets[bucketIndex].add(num);
        }

        // 4. 桶内排序并合并结果
        int index = 0;
        for (List<Double> bucket : buckets) {
            Collections.sort(bucket); // 使用内置排序
            for (double num : bucket) {
                arr[index++] = num;
            }
        }
    }
}
```

### 优化实现（针对整数，自定义桶内排序）
```java
import java.util.ArrayList;
import java.util.List;

public class OptimizedBucketSort {
    public static void bucketSort(int[] arr) {
        if (arr == null || arr.length <= 1) return;

        // 1. 确定桶数量和范围
        int max = arr[0], min = arr[0];
        for (int num : arr) {
            max = Math.max(max, num);
            min = Math.min(min, num);
        }
        int bucketCount = (int) Math.sqrt(arr.length) + 1;
        List<Integer>[] buckets = new ArrayList[bucketCount];
        for (int i = 0; i < bucketCount; i++) {
            buckets[i] = new ArrayList<>();
        }

        // 2. 分配元素到桶
        for (int num : arr) {
            int bucketIndex = (num - min) * (bucketCount - 1) / (max - min);
            buckets[bucketIndex].add(num);
        }

        // 3. 桶内使用插入排序优化
        int index = 0;
        for (List<Integer> bucket : buckets) {
            if (!bucket.isEmpty()) {
                // 桶内插入排序
                insertionSort(bucket);
                // 合并到原数组
                for (int num : bucket) {
                    arr[index++] = num;
                }
            }
        }
    }

    // 桶内插入排序实现
    private static void insertionSort(List<Integer> list) {
        for (int i = 1; i < list.size(); i++) {
            int temp = list.get(i);
            int j = i - 1;
            while (j >= 0 && list.get(j) > temp) {
                list.set(j + 1, list.get(j));
                j--;
            }
            list.set(j + 1, temp);
        }
    }
}
```

## 📊 复杂度分析

### 时间复杂度
- **最佳情况**：O(n + k) - 当数据均匀分布在每个桶中，且桶内排序接近O(1)时
- **平均情况**：O(n + k) - 数据分布较为均匀，每个桶内排序复杂度为O(m log m)，m为桶内元素数
- **最坏情况**：O(n²) - 所有元素都分配到同一个桶中，且使用了O(n²)的排序算法

其中：
- n是待排序数组的长度
- k是桶的数量
- m是单个桶中的平均元素数量

### 空间复杂度
- **空间复杂度**：O(n + k) - 需要存储n个元素和k个桶结构
- **稳定性**：取决于桶内排序算法，如果使用稳定的排序算法（如插入排序），则整体稳定

### 复杂度对比表
| 算法 | 时间复杂度(平均) | 空间复杂度 | 稳定性 | 适用场景 |
|------|------------------|------------|--------|----------|
| 桶排序 | O(n + k) | O(n + k) | 取决于桶内排序 | 分布均匀的浮点数/整数 |
| 计数排序 | O(n + k) | O(n + k) | 稳定 | 整数排序，k较小时 |
| 基数排序 | O(d(n + k)) | O(n + k) | 稳定 | 整数、字符串排序 |
| 快速排序 | O(n log n) | O(log n) | 不稳定 | 通用排序 |

## 🔍 应用场景

### 适用场景
1. **分布均匀的数据**：当数据在一定范围内均匀分布时效率最高
2. **大规模数据排序**：如处理海量数据的外部排序
3. **浮点数排序**：特别适合对小数进行排序
4. **Top K问题**：可用于快速找到数组中的最大/最小K个元素
5. **数据库索引**：某些数据库系统使用桶排序优化索引
6. **直方图统计**：数据分布分析和统计
7. **负载均衡**：分布式系统中的任务分配

### 不适用场景
1. **分布不均的数据**：当数据集中在少数几个桶时性能下降
2. **小数组**：对于小规模数据，简单排序算法更高效
3. **未知范围数据**：难以确定合适的桶数量和范围
4. **高维数据**：不适合多维数据排序

## ⚠️ 注意事项

1. **桶数量选择**：桶数量通常设为数据规模的平方根或与数据规模相当
2. **映射函数设计**：直接影响排序效率，应使数据均匀分布到各个桶
3. **桶内排序算法**：小规模桶适合插入排序，大规模桶适合快速排序
4. **边界处理**：需特别处理最大值可能超出计算范围的情况
5. **内存考量**：桶数量过多会浪费内存，过少则影响排序效率
6. **数据类型适应**：对非数字类型需要自定义比较规则

## 🎓 最佳实践

### 使用建议
1. **数据预处理**：排序前分析数据分布特征，选择合适的桶数量
2. **动态桶大小**：根据数据分布动态调整桶的范围和数量
3. **混合排序策略**：不同桶可采用不同排序算法，优化整体性能
4. **并行化实现**：利用桶的独立性进行并行处理，提高效率
5. **外部排序优化**：处理大数据时，可将桶存储在磁盘上实现外部排序

### 实现技巧
1. **桶数据结构**：
   - 小数组：使用数组实现桶
   - 大数据：使用链表或动态数组实现桶
2. **映射函数优化**：
   - 均匀分布：线性映射 `bucketIndex = (num - min) * k / (max - min)`
   - 正态分布：可使用平方根或对数映射
3. **桶内排序选择**：
   - 小桶（<5个元素）：插入排序
   - 中桶（5-20个元素）：快速排序
   - 大桶（>20个元素）：可进一步分桶

## 📚 经典题目

### LeetCode 347. 前 K 个高频元素
**题目描述**：给你一个整数数组 nums 和一个整数 k ，请你返回其中出现频率前 k 高的元素。

**解题思路**：使用桶排序思想，将频率作为桶的索引，将元素放入对应频率的桶中，然后从后向前取k个元素。

```java
public int[] topKFrequent(int[] nums, int k) {
    // 统计频率
    Map<Integer, Integer> frequencyMap = new HashMap<>();
    for (int num : nums) {
        frequencyMap.put(num, frequencyMap.getOrDefault(num, 0) + 1);
    }

    // 创建频率桶
    List<Integer>[] buckets = new List[nums.length + 1];
    for (int i = 0; i < buckets.length; i++) {
        buckets[i] = new ArrayList<>();
    }

    // 按频率放入桶中
    for (Map.Entry<Integer, Integer> entry : frequencyMap.entrySet()) {
        buckets[entry.getValue()].add(entry.getKey());
    }

    // 从高频到低频收集结果
    List<Integer> result = new ArrayList<>();
    for (int i = buckets.length - 1; i >= 0 && result.size() < k; i--) {
        if (!buckets[i].isEmpty()) {
            result.addAll(buckets[i]);
        }
    }

    // 转换为数组
    return result.stream().mapToInt(Integer::intValue).toArray();
}
```

### LeetCode 692. 前K个高频单词
**题目描述**：给一非空的单词列表，返回前 k 个出现次数最多的单词。

**解题思路**：结合哈希表和桶排序，先统计频率，再按频率分桶，最后排序每个桶中的单词。

### LeetCode 164. 最大间距
**题目描述**：给定一个无序的数组，找出数组在排序之后，相邻元素之间最大的差值。

**解题思路**：使用桶排序思想，通过设置适当的桶大小，确保最大间距一定出现在不同桶之间。

## 📖 扩展阅读

1. **《算法导论》**：第8章介绍了桶排序和基数排序的关系
2. **《数据结构与算法分析》**：详细讨论了桶排序的各种优化策略
3. **维基百科**：桶排序词条（https://en.wikipedia.org/wiki/Bucket_sort）
4. **论文**："Bucket sorting for external memory" - 讨论外部存储环境下的桶排序实现
5. **GeeksforGeeks**：桶排序算法详解（https://www.geeksforgeeks.org/bucket-sort-2/）

---

> **完成状态**: 本文档已完善所有核心内容，包括算法原理、多种实现方式、复杂度分析、应用场景和经典题目。
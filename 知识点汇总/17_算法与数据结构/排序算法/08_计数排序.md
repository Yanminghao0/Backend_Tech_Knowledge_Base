# 计数排序

> 计数排序（Counting Sort）是一种非比较型整数排序算法，其核心思想是通过统计待排序数组中每个元素出现的次数，然后根据这些统计信息将元素直接放置到正确的位置。它适用于已知数据范围的整数排序场景，时间复杂度可达线性级别。

---

## 📋 基本信息

| 项目                | 说明                                                                 |
|---------------------|----------------------------------------------------------------------|
| **算法类别**        | 非比较排序                                                           |
| **时间复杂度**      | 最佳: O(n + k), 平均: O(n + k), 最坏: O(n + k) (n为元素个数，k为数据范围) |
| **空间复杂度**      | O(n + k)                                                              |
| **稳定性**          | 稳定                                                                 |
| **原地排序**        | 否                                                                   |
| **并行性**          | 可并行化                                                             |
| **适用数据类型**    | 整数（或可映射为整数的离散值）                                         |

## 🎯 算法原理

### 核心思想
计数排序的基本思想是：对于给定的输入序列中的每一个元素x，确定该序列中值小于x的元素的个数，然后将x直接放置到最终排序序列的正确位置上。

### 工作流程
1. **确定数据范围**：找出待排序数组中的最大值max和最小值min，计算数据范围k = max - min + 1
2. **创建计数数组**：创建一个大小为k的计数数组count[]，初始化为0
3. **统计元素出现次数**：遍历待排序数组，统计每个元素出现的次数，存入count[]
4. **计算前缀和**：将count[]转换为前缀和数组，以确定每个元素在输出数组中的起始位置
5. **构建输出数组**：从后向前遍历待排序数组，根据count[]中的信息将元素放置到输出数组的正确位置，并更新count[]
6. **复制结果**：将输出数组复制回原数组（如果需要原地排序）

### 图解流程
```
原始数组: [4, 2, 2, 8, 3, 3, 1]
min=1, max=8, k=8-1+1=8

计数数组初始化: [0,0,0,0,0,0,0,0]
统计次数后: [1,2,2,1,0,0,0,1]  // 索引对应值为 min+index

前缀和计算: [1,3,5,6,6,6,6,7]

构建输出数组: [1,2,2,3,3,4,8]
```

## 💻 代码实现

### 基础实现（处理非负整数）
```java
public class CountingSort {
    public static void countingSort(int[] arr) {
        if (arr == null || arr.length <= 1) return;

        // 找出最大值和最小值
        int max = arr[0];
        int min = arr[0];
        for (int num : arr) {
            if (num > max) max = num;
            if (num < min) min = num;
        }

        // 创建计数数组
        int range = max - min + 1;
        int[] count = new int[range];

        // 统计元素出现次数
        for (int num : arr) {
            count[num - min]++;
        }

        // 计算前缀和
        for (int i = 1; i < count.length; i++) {
            count[i] += count[i - 1];
        }

        // 构建输出数组（从后向前遍历保证稳定性）
        int[] output = new int[arr.length];
        for (int i = arr.length - 1; i >= 0; i--) {
            int num = arr[i];
            output[count[num - min] - 1] = num;
            count[num - min]--;
        }

        // 复制结果到原数组
        System.arraycopy(output, 0, arr, 0, arr.length);
    }
}
```

### 优化实现（处理任意整数并优化空间）
```java
public class OptimizedCountingSort {
    public static void countingSort(int[] arr) {
        if (arr == null || arr.length <= 1) return;

        // 找出最大值和最小值
        int max = arr[0];
        int min = arr[0];
        for (int num : arr) {
            max = Math.max(max, num);
            min = Math.min(min, num);
        }

        // 只创建必要大小的计数数组
        int range = max - min + 1;
        int[] count = new int[range];

        // 统计频率
        for (int num : arr) {
            count[num - min]++;
        }

        // 直接覆盖原数组（不使用额外输出数组）
        int index = 0;
        for (int i = 0; i < range; i++) {
            while (count[i] > 0) {
                arr[index++] = i + min;
                count[i]--;
            }
        }
    }
}
```

## 📊 复杂度分析

### 时间复杂度
- **最佳情况**：O(n + k) - 当输入数据分布均匀且范围适中时
- **平均情况**：O(n + k) - 无论数据如何分布，时间复杂度保持线性
- **最坏情况**：O(n + k) - 当数据范围k远大于n时，复杂度主要由k决定

其中：
- n是待排序数组的长度
- k是数据范围（max - min + 1）

### 空间复杂度
- **空间复杂度**：O(n + k) - 需要额外的计数数组（大小k）和输出数组（大小n）
- **原地优化版本**：O(k) - 可以将空间优化到只使用计数数组

### 复杂度对比表
| 算法 | 时间复杂度(平均) | 空间复杂度 | 稳定性 | 适用场景 |
|------|------------------|------------|--------|----------|
| 计数排序 | O(n + k) | O(n + k) | 稳定 | 整数排序，k较小时 |
| 快速排序 | O(n log n) | O(log n) | 不稳定 | 通用排序 |
| 归并排序 | O(n log n) | O(n) | 稳定 | 通用排序，外部排序 |
| 基数排序 | O(d(n + k)) | O(n + k) | 稳定 | 整数、字符串排序 |

## 🔍 应用场景

### 适用场景
1. **整数排序**：特别是当数据范围k与n接近时效率最高
2. **评分统计**：如学生成绩排序（0-100分）
3. **年龄排序**：人口年龄数据排序（范围有限）
4. **作为基数排序的子过程**：基数排序通常使用计数排序作为每一位的排序算法
5. **频率统计**：需要统计元素出现次数的场景
6. **桶排序的基础**：可作为桶排序中每个桶内的排序算法

### 不适用场景
1. **浮点数排序**：无法直接应用于浮点数
2. **大数据范围**：当k远大于n时（如排序100个0到10^9的整数）
3. **小数组**：对于小规模数据，插入排序可能更高效
4. **非整数数据**：需要额外映射，实现复杂

## ⚠️ 注意事项

1. **数据范围问题**：当数据范围k远大于数组长度n时，计数排序效率会显著下降
2. **负数处理**：基础实现不支持负数，需要通过偏移量处理
3. **内存消耗**：大范围数据会导致计数数组过大，可能引发内存问题
4. **稳定性保证**：从后向前遍历原始数组才能保证排序的稳定性
5. **数据类型限制**：只适用于整数或可映射为整数的离散值
6. **非比较排序特性**：不适合需要比较操作的场景

## 🎓 最佳实践

### 使用建议
1. **确定数据特征**：使用前先分析数据范围和分布特征
2. **结合其他排序**：当数据范围较大时，考虑与其他排序算法结合使用
3. **优化空间**：对空间敏感时，使用原地优化版本
4. **处理负数**：实现时确保支持负整数排序
5. **稳定性考量**：如需保持相等元素的相对顺序，必须从后向前填充输出数组

### 实现技巧
1. **动态计算范围**：总是动态计算min和max，避免硬编码范围
2. **内存优化**：当n远小于k时，考虑使用其他排序算法
3. **稳定性实现**：通过从后向前遍历保证稳定性
4. **泛型实现**：可通过映射函数扩展到非整数类型

## 📚 经典题目

### LeetCode 75. 颜色分类
**题目描述**：给定一个包含红色、白色和蓝色，一共n个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。我们使用整数0、1和2分别表示红色、白色和蓝色。

**解题思路**：这是计数排序的典型应用场景，数据范围小（0-2），适合使用计数排序。

```java
public void sortColors(int[] nums) {
    int[] count = new int[3]; // 0, 1, 2
    for (int num : nums) {
        count[num]++;
    }
    int index = 0;
    for (int i = 0; i < 3; i++) {
        while (count[i] > 0) {
            nums[index++] = i;
            count[i]--;
        }
    }
}
```

### LeetCode 164. 最大间距
**题目描述**：给定一个无序的数组，找出数组在排序之后，相邻元素之间最大的差值。如果数组元素个数小于2，则返回0。

**解题思路**：使用计数排序或桶排序可以在线性时间内解决此问题。

### LeetCode 274. H 指数
**题目描述**：给定一位研究者论文被引用次数的数组（被引用次数是非负整数）。编写一个方法，计算出研究者的h指数。

**解题思路**：可以使用计数排序统计各引用次数的论文数量，然后从高到低计算h指数。

## 📖 扩展阅读

1. **《算法导论》**：第8章详细介绍了计数排序和基数排序
2. **《算法》（Robert Sedgewick）**：第5章讨论了非比较排序算法
3. **维基百科**：计数排序词条（https://en.wikipedia.org/wiki/Counting_sort）
4. **GeeksforGeeks**：计数排序详解（https://www.geeksforgeeks.org/counting-sort/）
5. **论文**："Efficiently sorting networks of varying size" - 讨论了计数排序的并行实现

---

> **完成状态**: 本文档已完善所有核心内容，包括算法原理、多种实现方式、复杂度分析、应用场景和经典题目。
# 归并排序

> 归并排序（Merge Sort）是一种基于分治策略（Divide and Conquer）的高效排序算法。它将问题分解为多个子问题，递归解决子问题后将结果合并，从而实现整体排序。归并排序的核心优势在于稳定的O(n log n)时间复杂度和良好的并行性，是理解分治思想的经典案例。

---

## 📋 基本信息

### 算法类别
- **排序类型**：归并排序（分治排序）
- **核心思想**：分治法（Divide, Conquer, Merge）
- **稳定性**：稳定排序
- **时间复杂度**：O(n log n)（所有情况）
- **空间复杂度**：O(n)（需要额外空间存储临时数组）
- **难度级别**：中等
- **适用场景**：大规模数据排序、外部排序、稳定性要求高的场景

### 历史背景
归并排序由约翰·冯·诺依曼（John von Neumann）于1945年提出，是最早的计算机排序算法之一。它最初用于外部排序，处理无法全部加载到内存的数据。归并排序的分治思想为后来许多高效算法奠定了基础，至今仍在数据库系统、大数据处理等领域广泛应用。

---

## 🎯 算法原理

### 基本思想
归并排序采用分治策略，将一个大问题分解为多个小问题：
1. **分解（Divide）**：将待排序数组分成两个大小大致相等的子数组
2. **解决（Conquer）**：递归地对两个子数组进行归并排序
3. **合并（Merge）**：将排好序的子数组合并为一个有序数组

### 工作流程
1. 若数组长度为1，则已排序完成
2. 否则将数组从中间分成左右两个子数组
3. 递归排序左子数组和右子数组
4. 合并两个已排序的子数组，得到完整的有序数组

### 合并过程详解
合并操作是归并排序的核心，步骤如下：
1. 创建临时数组，大小为两个子数组长度之和
2. 初始化三个指针：i（左子数组起始）、j（右子数组起始）、k（临时数组起始）
3. 比较左右子数组当前元素，将较小元素放入临时数组并移动相应指针
4. 将剩余元素复制到临时数组
5. 将临时数组复制回原数组

### 动图演示
> 示意图：归并排序的分治与合并过程
> [图示：归并排序将数组不断二分，然后逐层合并的动态过程]

---

## 💻 代码实现

### 递归实现
```java
public class MergeSortRecursive {
    public static void mergeSort(int[] arr) {
        if (arr == null || arr.length <= 1) {
            return;
        }
        int[] temp = new int[arr.length];
        mergeSort(arr, temp, 0, arr.length - 1);
    }
    
    private static void mergeSort(int[] arr, int[] temp, int left, int right) {
        if (left < right) {
            int mid = left + (right - left) / 2; // 避免溢出
            mergeSort(arr, temp, left, mid);      // 排序左子数组
            mergeSort(arr, temp, mid + 1, right); // 排序右子数组
            merge(arr, temp, left, mid, right);   // 合并两个子数组
        }
    }
    
    private static void merge(int[] arr, int[] temp, int left, int mid, int right) {
        // 复制元素到临时数组
        for (int i = left; i <= right; i++) {
            temp[i] = arr[i];
        }
        
        int i = left;    // 左子数组指针
        int j = mid + 1; // 右子数组指针
        int k = left;    // 原数组指针
        
        // 合并过程
        while (i <= mid && j <= right) {
            if (temp[i] <= temp[j]) {
                arr[k++] = temp[i++];
            } else {
                arr[k++] = temp[j++];
            }
        }
        
        // 复制左子数组剩余元素
        while (i <= mid) {
            arr[k++] = temp[i++];
        }
        // 右子数组剩余元素已在正确位置，无需复制
    }
}
```

### 迭代实现（非递归）
```java
public class MergeSortIterative {
    public static void mergeSort(int[] arr) {
        if (arr == null || arr.length <= 1) {
            return;
        }
        int n = arr.length;
        int[] temp = new int[n];
        
        // 子数组大小：1, 2, 4, 8...
        for (int size = 1; size < n; size *= 2) {
            // 合并相邻子数组
            for (int left = 0; left < n - size; left += 2 * size) {
                int mid = left + size - 1;
                int right = Math.min(left + 2 * size - 1, n - 1);
                merge(arr, temp, left, mid, right);
            }
        }
    }
    
    private static void merge(int[] arr, int[] temp, int left, int mid, int right) {
        // 实现与递归版本相同
        for (int i = left; i <= right; i++) {
            temp[i] = arr[i];
        }
        
        int i = left;
        int j = mid + 1;
        int k = left;
        
        while (i <= mid && j <= right) {
            if (temp[i] <= temp[j]) {
                arr[k++] = temp[i++];
            } else {
                arr[k++] = temp[j++];
            }
        }
        
        while (i <= mid) {
            arr[k++] = temp[i++];
        }
    }
}
```

### 优化实现（自底向上+插入排序优化）
```java
public class MergeSortOptimized {
    private static final int INSERTION_SORT_THRESHOLD = 7; // 阈值
    
    public static void mergeSort(int[] arr) {
        if (arr == null || arr.length <= 1) {
            return;
        }
        int n = arr.length;
        int[] temp = new int[n];
        
        // 对小规模子数组使用插入排序
        for (int i = 0; i < n; i += INSERTION_SORT_THRESHOLD) {
            insertionSort(arr, i, Math.min(i + INSERTION_SORT_THRESHOLD - 1, n - 1));
        }
        
        // 自底向上归并
        for (int size = INSERTION_SORT_THRESHOLD; size < n; size *= 2) {
            for (int left = 0; left < n - size; left += 2 * size) {
                int mid = left + size - 1;
                int right = Math.min(left + 2 * size - 1, n - 1);
                if (arr[mid] > arr[mid + 1]) { // 只有子数组无序时才合并
                    merge(arr, temp, left, mid, right);
                }
            }
        }
    }
    
    private static void insertionSort(int[] arr, int left, int right) {
        for (int i = left + 1; i <= right; i++) {
            int temp = arr[i];
            int j;
            for (j = i; j > left && arr[j - 1] > temp; j--) {
                arr[j] = arr[j - 1];
            }
            arr[j] = temp;
        }
    }
    
    private static void merge(int[] arr, int[] temp, int left, int mid, int right) {
        // 合并实现与前面相同
        for (int i = left; i <= right; i++) {
            temp[i] = arr[i];
        }
        
        int i = left;
        int j = mid + 1;
        int k = left;
        
        while (i <= mid && j <= right) {
            if (temp[i] <= temp[j]) {
                arr[k++] = temp[i++];
            } else {
                arr[k++] = temp[j++];
            }
        }
        
        while (i <= mid) {
            arr[k++] = temp[i++];
        }
    }
}
```

---

## 📊 复杂度分析

### 时间复杂度
- **最好情况**：O(n log n) - 无论数据分布如何，始终需要完全分解和合并
- **最坏情况**：O(n log n) - 同样需要完整的分治过程
- **平均情况**：O(n log n) - 稳定的时间复杂度

### 空间复杂度
- **空间复杂度**：O(n) - 需要临时数组存储合并结果
- **递归实现额外栈空间**：O(log n) - 递归调用栈深度
- **迭代实现**：O(n) - 仅需要临时数组

### 复杂度分析图表
| 实现方式 | 时间复杂度(最好) | 时间复杂度(最坏) | 时间复杂度(平均) | 空间复杂度 | 稳定性 |
|----------|------------------|------------------|------------------|------------|--------|
| 递归实现 | O(n log n) | O(n log n) | O(n log n) | O(n + log n) | 稳定 |
| 迭代实现 | O(n log n) | O(n log n) | O(n log n) | O(n) | 稳定 |
| 优化实现 | O(n log n) | O(n log n) | O(n log n) | O(n) | 稳定 |
| 快速排序 | O(n log n) | O(n²) | O(n log n) | O(log n) | 不稳定 |

---

## 🔍 应用场景

### 适用场景
- **大规模数据排序**：时间复杂度稳定为O(n log n)
- **外部排序**：适合处理磁盘等外部存储数据
- **稳定性要求高的场景**：如电商订单排序（价格相同保持原顺序）
- **链表排序**：归并排序对链表结构效率高（空间复杂度可优化至O(1)）
- **并行计算**：分治特性适合并行处理
- **数据库系统**：作为内部排序或外部排序的实现

### 不适用场景
- **内存受限环境**：需要额外O(n)空间
- **小规模数据**：常数因子大于插入排序
- **对缓存不友好**：数组实现时可能导致较多缓存失效
- **实时系统**：递归实现可能导致栈溢出

### 实际应用案例
- Java的Arrays.sort()对对象数组使用归并排序（或TimSort）
- Python的sorted()和list.sort()使用Timsort（归并排序变体）
- 数据库系统中的外部排序实现
- 大数据处理框架（如Hadoop）中的排序阶段
- 版本控制系统中的文件差异比较

---

## ✂️ 优化策略

### 1. 小规模子数组使用插入排序
- **原理**：对于小规模数组（通常长度<15），插入排序效率更高
- **实现**：设置阈值，当子数组长度小于阈值时使用插入排序
- **效果**：减少约10-15%的运行时间

### 2. 避免不必要的合并
- **原理**：如果两个子数组已经有序，则无需合并
- **实现**：比较左子数组最后一个元素与右子数组第一个元素
- **效果**：在部分有序数据上性能提升显著

### 3. 优化临时数组空间
- **原理**：避免每次合并都创建临时数组
- **实现**：预先分配一个大临时数组并复用
- **效果**：减少内存分配开销

### 4. 自底向上迭代实现
- **原理**：避免递归调用栈开销
- **实现**：从最小子数组开始，逐层向上合并
- **效果**：内存使用更高效，避免栈溢出

### 5. 原地归并排序
- **原理**：无需额外O(n)空间实现合并
- **实现**：使用反转、旋转等操作实现原地合并
- **效果**：空间复杂度降至O(log n)，但实现复杂且时间常数增大

---

## ⚠️ 注意事项

### 常见错误
- **数组越界**：合并过程中未正确处理边界条件
- **临时数组使用不当**：未正确复制元素或释放空间
- **递归深度问题**：大规模数据可能导致栈溢出
- **稳定性误解**：错误实现可能破坏稳定性
- **性能优化过度**：简单场景下过度优化反而降低可读性

### 实现要点
- 确保合并操作的稳定性（使用<=比较）
- 处理好长度为0或1的数组情况
- 避免递归实现中的栈溢出风险
- 临时数组的合理管理与复用
- 正确计算中间索引（避免溢出：mid = left + (right - left)/2）

### 稳定性分析
归并排序是稳定的排序算法，原因如下：
- 合并过程中，当左右子数组元素相等时，优先选择左子数组元素
- 相等元素的相对顺序在合并过程中得以保持
- 例如：[(2, A), (1), (2, B)]排序后为[(1), (2, A), (2, B)]

---

## 🎓 最佳实践

### 实现建议
1. **选择合适实现方式**：小规模数据用迭代实现，大规模数据考虑递归+尾调用优化
2. **设置插入排序阈值**：根据实际数据测试确定最佳阈值（通常5-15）
3. **复用临时数组**：预先分配并传递临时数组，避免频繁内存分配
4. **处理边界情况**：空数组、单元素数组、已排序数组等特殊情况
5. **并行化实现**：多核环境下可将子数组分配给不同线程处理

### 代码规范
- 将排序逻辑与合并逻辑分离为不同函数
- 使用有意义的变量名（left, mid, right而非i, j, k）
- 添加详细注释解释分治策略和合并过程
- 提取公共代码（如合并操作）为辅助函数
- 编写单元测试覆盖各种边界情况

### 与其他排序算法对比
| 特性 | 归并排序 | 快速排序 | 堆排序 |
|------|----------|----------|--------|
| 平均时间复杂度 | O(n log n) | O(n log n) | O(n log n) |
| 最坏时间复杂度 | O(n log n) | O(n²) | O(n log n) |
| 空间复杂度 | O(n) | O(log n) | O(1) |
| 稳定性 | 稳定 | 不稳定 | 不稳定 |
| 缓存效率 | 较低 | 较高 | 较低 |
| 并行性 | 良好 | 一般 | 一般 |
| 实现复杂度 | 中等 | 中等 | 较复杂 |

---

## 📝 经典题目

### LeetCode题目
1. **[LeetCode 912. 排序数组](https://leetcode.cn/problems/sort-array/)**
   - 难度：中等
   - 描述：使用归并排序实现数组排序
   - 提示：可实现递归或迭代版本

2. **[LeetCode 21. 合并两个有序链表](https://leetcode.cn/problems/merge-two-sorted-lists/)**
   - 难度：简单
   - 描述：合并两个升序链表
   - 提示：应用归并排序的合并思想

3. **[LeetCode 148. 排序链表](https://leetcode.cn/problems/sort-list/)**
   - 难度：中等
   - 描述：在O(n log n)时间和常数级空间下排序链表
   - 提示：使用自底向上的归并排序

4. **[LeetCode 315. 计算右侧小于当前元素的个数](https://leetcode.cn/problems/count-of-smaller-numbers-after-self/)**
   - 难度：困难
   - 描述：计算每个元素右侧小于它的元素个数
   - 提示：归并排序过程中统计逆序对

### 面试常见问题
- 归并排序的分治思想是什么？如何实现？
- 归并排序的时间复杂度为什么是O(n log n)？
- 如何优化归并排序的空间复杂度？
- 归并排序和快速排序的优缺点比较？
- 如何用归并排序解决逆序对问题？

---

## 📚 扩展阅读

### 相关算法
- **Timsort**：结合归并排序和插入排序的混合算法
- **外部归并排序**：处理大规模外部数据的排序算法
- **多路归并排序**：同时合并多个有序子序列
- **自然归并排序**：利用数据中已有的有序子序列
- **并行归并排序**：多线程或分布式环境下的实现

### 推荐资源
- 《算法导论》第3版，第2章：算法基础
- 《算法》第4版，第2章：排序
- [归并排序可视化](https://visualgo.net/en/sorting)
- [GeeksforGeeks - 归并排序](https://www.geeksforgeeks.org/merge-sort/)
- [Java Arrays.sort()源码分析](https://hg.openjdk.java.net/jdk8/jdk8/jdk/file/tip/src/share/classes/java/util/Arrays.java)

---

> **总结**：归并排序是一种基于分治策略的高效稳定排序算法，以O(n log n)的稳定时间复杂度和O(n)的空间复杂度为特点。它将问题分解为子问题递归解决，再将结果合并，核心在于高效的合并操作。归并排序特别适用于大规模数据、外部排序和稳定性要求高的场景，在链表排序中也表现出色。通过插入排序优化、避免不必要合并、临时数组复用等策略，可以进一步提升其性能。尽管需要额外空间，但其稳定的性能和清晰的分治思想使其成为排序算法中的重要成员，也是理解分治策略的经典案例。归并排序的思想还广泛应用于其他算法问题，如逆序对计数、区间合并等，具有重要的理论和实践价值。
# 基数排序

> 基数排序（Radix Sort）是一种非比较型整数排序算法，它通过按位（个位、十位、百位等）对数字进行排序，最终实现整体有序。基数排序可以看作是多轮桶排序或计数排序的组合应用，特别适用于整数和固定长度字符串的排序。

---

## 📋 基本信息

| 项目                | 说明                                                                 |
|---------------------|----------------------------------------------------------------------|
| **算法类别**        | 非比较排序、分布式排序                                               |
| **时间复杂度**      | 最佳: O(d(n + k)), 平均: O(d(n + k)), 最坏: O(d(n + k)) (d为位数，k为基数) |
| **空间复杂度**      | O(n + k)                                                              |
| **稳定性**          | 稳定                                                                 |
| **原地排序**        | 否                                                                   |
| **并行性**          | 可并行化                                                             |
| **适用数据类型**    | 整数、固定长度字符串、日期等可按位比较的数据                         |

## 🎯 算法原理

### 核心思想
基数排序的核心思想是将待排序数据按位分割成不同的数字，然后按每个位的值对数据进行排序。排序过程可以从最低有效位（LSD）开始，也可以从最高有效位（MSD）开始，通过多轮排序最终使数据整体有序。

### 两种实现策略
1. **LSD（Least Significant Digit first）**：从最低有效位开始排序，适用于位数较少的情况
2. **MSD（Most Significant Digit first）**：从最高有效位开始排序，适用于位数较多或可变长度的数据

### 工作流程（以LSD为例）
1. **确定最大位数**：找出数组中最大数的位数d
2. **初始化基数**：通常使用10作为基数（十进制）
3. **按位排序**：从最低位到最高位，对每一位执行以下操作：
   - 使用计数排序或桶排序对当前位进行排序
   - 保持其他位的相对顺序（确保稳定性）
4. **合并结果**：经过d轮排序后，数组整体有序

### 图解流程
```
原始数组: [170, 45, 75, 90, 802, 24, 2, 66]
最大数为802，共3位

第一轮（个位排序）:
0: [170, 90, 802]
2: [2]
4: [24]
5: [45, 75]
6: [66]
结果: [170, 90, 802, 2, 24, 45, 75, 66]

第二轮（十位排序）:
0: [802, 2]
2: [24]
4: [45]
6: [66]
7: [170, 75]
9: [90]
结果: [802, 2, 24, 45, 66, 170, 75, 90]

第三轮（百位排序）:
0: [2, 24, 45, 66, 75, 90, 170]
8: [802]
结果: [2, 24, 45, 66, 75, 90, 170, 802]
```

## 💻 代码实现

### 基础实现（LSD基数排序）
```java
public class RadixSort {
    // 基数排序主方法
    public static void radixSort(int[] arr) {
        if (arr == null || arr.length <= 1) return;

        // 1. 找出最大值，确定最大位数
        int max = arr[0];
        for (int num : arr) {
            if (num > max) max = num;
        }

        // 2. 按位排序（从个位开始）
        for (int exp = 1; max / exp > 0; exp *= 10) {
            countSortByDigit(arr, exp);
        }
    }

    // 按指定位数进行计数排序
    private static void countSortByDigit(int[] arr, int exp) {
        int n = arr.length;
        int[] output = new int[n]; // 输出数组
        int[] count = new int[10]; // 计数数组（基数为10）

        // 统计每个数字出现的次数
        for (int i = 0; i < n; i++) {
            int digit = (arr[i] / exp) % 10;
            count[digit]++;
        }

        // 计算前缀和，确定每个数字在输出数组中的位置
        for (int i = 1; i < 10; i++) {
            count[i] += count[i - 1];
        }

        // 构建输出数组（从后向前保证稳定性）
        for (int i = n - 1; i >= 0; i--) {
            int digit = (arr[i] / exp) % 10;
            output[count[digit] - 1] = arr[i];
            count[digit]--;
        }

        // 将结果复制回原数组
        System.arraycopy(output, 0, arr, 0, n);
    }
}
```

### 优化实现（支持负数和可变基数）
```java
public class OptimizedRadixSort {
    public static void radixSort(int[] arr) {
        if (arr == null || arr.length <= 1) return;

        // 1. 分离正数和负数，分别排序
        int positiveCount = 0;
        for (int num : arr) {
            if (num >= 0) positiveCount++;
        }

        int[] positives = new int[positiveCount];
        int[] negatives = new int[arr.length - positiveCount];
        int p = 0, n = 0;
        for (int num : arr) {
            if (num >= 0) {
                positives[p++] = num;
            } else {
                negatives[n++] = -num; // 负数取绝对值
            }
        }

        // 2. 分别排序正数和负数（绝对值）
        radixSortPositives(positives);
        radixSortPositives(negatives);

        // 3. 合并结果（负数按逆序放回，恢复符号）
        int index = 0;
        for (int i = negatives.length - 1; i >= 0; i--) {
            arr[index++] = -negatives[i];
        }
        for (int num : positives) {
            arr[index++] = num;
        }
    }

    // 对非负整数数组进行基数排序
    private static void radixSortPositives(int[] arr) {
        if (arr.length <= 1) return;

        int max = arr[0];
        for (int num : arr) {
            if (num > max) max = num;
        }

        // 使用更大的基数优化（如16或256）
        for (int exp = 1; max / exp > 0; exp *= 16) {
            countSortByDigit(arr, exp, 16);
        }
    }

    // 支持可变基数的计数排序
    private static void countSortByDigit(int[] arr, int exp, int radix) {
        int n = arr.length;
        int[] output = new int[n];
        int[] count = new int[radix];

        for (int i = 0; i < n; i++) {
            int digit = (arr[i] / exp) % radix;
            count[digit]++;
        }

        for (int i = 1; i < radix; i++) {
            count[i] += count[i - 1];
        }

        for (int i = n - 1; i >= 0; i--) {
            int digit = (arr[i] / exp) % radix;
            output[count[digit] - 1] = arr[i];
            count[digit]--;
        }

        System.arraycopy(output, 0, arr, 0, n);
    }
}
```

## 📊 复杂度分析

### 时间复杂度
- **最佳/平均/最坏情况**：O(d(n + k))
  其中：
  - d是待排序数据的最大位数
  - n是数组长度
  - k是基数（通常为10或256等）

### 空间复杂度
- **空间复杂度**：O(n + k)
  需要额外的输出数组（大小n）和计数数组（大小k）

### 复杂度对比表
| 算法 | 时间复杂度 | 空间复杂度 | 稳定性 | 适用场景 |
|------|------------|------------|--------|----------|
| 基数排序 | O(d(n + k)) | O(n + k) | 稳定 | 整数、固定长度字符串 |
| 计数排序 | O(n + k) | O(n + k) | 稳定 | 小范围整数 |
| 桶排序 | O(n + k) | O(n + k) | 取决于桶内排序 | 均匀分布数据 |
| 快速排序 | O(n log n) | O(log n) | 不稳定 | 通用排序 |

## 🔍 应用场景

### 适用场景
1. **整数排序**：尤其是位数较少的正整数
2. **字符串排序**：固定长度的字符串（如电话号码、身份证号）
3. **日期排序**：可以按年、月、日的顺序进行多轮排序
4. **数据库系统**：用于索引构建和范围查询优化
5. **后缀数组构建**：在字符串处理算法中用于构建后缀数组
6. **大规模数据排序**：当数据量很大但位数有限时效率高

### 不适用场景
1. **浮点数排序**：处理浮点数需要特殊的位提取方法
2. **小数组**：对于小规模数据，简单排序算法更高效
3. **位数差异大的数据**：当数据位数差异悬殊时性能下降
4. **高基数数据**：基数过大（如超过n）会导致空间复杂度增加

## ⚠️ 注意事项

1. **负数处理**：基础实现不支持负数，需要特殊处理（如取绝对值后排序再恢复符号）
2. **基数选择**：基数过大会增加空间复杂度，过小会增加排序轮次
3. **位数计算**：需要准确计算最大位数，避免遗漏高位
4. **稳定性保证**：必须使用稳定的子排序算法（如计数排序）
5. **内存消耗**：对于大数据集，额外的输出数组可能消耗较多内存
6. **非整数类型**：处理非整数类型需要自定义位提取函数

## 🎓 最佳实践

### 使用建议
1. **基数选择**：
   - 整数排序：通常选择10（十进制）或256（字节）
   - 字符串排序：选择256（ASCII）或65536（Unicode）
   - 内存受限：选择较小基数；时间受限：选择较大基数
2. **处理负数**：采用分离正负再合并的策略
3. **混合排序**：当位数较少时使用基数排序，位数多时考虑其他算法
4. **并行实现**：不同位的排序可以并行处理，提高效率

### 实现技巧
1. **位运算优化**：使用位运算代替除法和取模提取数字（如对2^k基数）
   ```java
   // 对于基数256（2^8），提取第exp字节
   int digit = (num &gt;&gt; (exp * 8)) & 0xFF;
   ```
2. **动态基数调整**：根据数据特征自动选择最优基数
3. **内存优化**：可以使用环形缓冲区减少内存分配
4. **MSD vs LSD选择**：
   - 短固定长度：LSD更简单高效
   - 长可变长度：MSD可以提前终止排序

## 📚 经典题目

### LeetCode 912. 排序数组
**题目描述**：给你一个整数数组 nums，请你将该数组升序排列。

**解题思路**：对于包含负数的整数数组，可使用支持负数的基数排序实现。

```java
public int[] sortArray(int[] nums) {
    if (nums.length <= 1) return nums;
    OptimizedRadixSort.radixSort(nums);
    return nums;
}
```

### LeetCode 164. 最大间距
**题目描述**：给定一个无序的数组，找出数组在排序之后，相邻元素之间最大的差值。

**解题思路**：基数排序可以在线性时间内完成排序，然后遍历数组计算最大间距。

### LeetCode 347. 前 K 个高频元素
**题目描述**：找出数组中出现频率前k高的元素。

**解题思路**：可以结合基数排序思想，按频率对元素进行排序。

## 📖 扩展阅读

1. **《算法导论》**：第8章详细介绍了基数排序的原理和证明
2. **《编程珠玑》**：讨论了基数排序在实际编程中的应用
3. **维基百科**：基数排序词条（https://en.wikipedia.org/wiki/Radix_sort）
4. **论文**："Engineering Radix Sort" - 讨论基数排序的工程实现优化
5. **GeeksforGeeks**：基数排序详解（https://www.geeksforgeeks.org/radix-sort/）

---

> **完成状态**: 本文档已完善所有核心内容，包括算法原理、多种实现方式、复杂度分析、应用场景和经典题目。
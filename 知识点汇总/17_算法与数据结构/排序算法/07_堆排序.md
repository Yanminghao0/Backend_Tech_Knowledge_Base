# 堆排序

> 堆排序（Heap Sort）是一种基于堆数据结构的高效排序算法，由计算机科学家J. W. J. Williams于1964年提出。它利用堆的特性将数组转换为最大堆（或最小堆），然后通过反复提取堆顶元素并调整堆结构来实现排序。堆排序以其O(n log n)的稳定时间复杂度和原地排序特性，在许多场景中得到广泛应用。

---

## 📋 基本信息

### 算法类别
- **排序类型**：堆排序（选择排序的改进版）
- **核心思想**：利用堆数据结构进行选择排序
- **稳定性**：不稳定排序
- **时间复杂度**：O(n log n)（所有情况）
- **空间复杂度**：O(1)（原地排序）
- **难度级别**：中等
- **适用场景**：大规模数据排序、内存受限环境、需要稳定时间复杂度的场景

### 历史背景
堆排序由J. W. J. Williams在1964年发表的论文"Algorithm 232 - Heapsort"中首次提出。该算法最初用于将二叉堆应用于排序问题，后来由Robert W. Floyd在1964年对其进行了改进，提出了非递归的堆构建方法，进一步提高了效率。堆排序的重要意义在于它是少数几个能够在最坏情况下仍保持O(n log n)时间复杂度的原地排序算法之一，这使得它在实时系统和嵌入式设备中具有重要应用价值。

---

## 🎯 算法原理

### 基本思想
堆排序基于堆这种特殊的完全二叉树结构，主要包括两个阶段：
1. **建堆阶段**：将待排序数组转换为最大堆（或最小堆）
2. **排序阶段**：反复提取堆顶元素（最大值或最小值），将其放到数组末尾，并调整剩余元素为新的堆

### 堆的概念
- **最大堆**：每个父节点的值大于或等于其子节点的值
- **最小堆**：每个父节点的值小于或等于其子节点的值
- **堆的存储**：通常用数组实现，对于索引i的节点：
  - 左子节点索引：2i + 1
  - 右子节点索引：2i + 2
  - 父节点索引：(i - 1) / 2（向下取整）

### 工作流程
1. **构建最大堆**：从最后一个非叶子节点开始，自底向上调整堆结构
2. **交换堆顶元素**：将堆顶元素（最大值）与数组末尾元素交换
3. **调整堆结构**：将剩余元素重新调整为最大堆
4. **重复步骤2-3**：直到所有元素排序完成

### 动图演示
> 示意图：堆排序的建堆与排序过程
> [图示：堆排序从建堆到逐步提取最大值并调整堆的动态过程]

---

## 💻 代码实现

### 基础实现（最大堆）
```java
public class HeapSort {
    public static void heapSort(int[] arr) {
        if (arr == null || arr.length <= 1) {
            return;
        }
        int n = arr.length;
        
        // 构建最大堆
        for (int i = n / 2 - 1; i >= 0; i--) {
            heapify(arr, n, i);
        }
        
        // 提取堆顶元素并调整堆
        for (int i = n - 1; i > 0; i--) {
            // 交换堆顶元素和当前末尾元素
            int temp = arr[0];
            arr[0] = arr[i];
            arr[i] = temp;
            
            // 调整剩余元素为最大堆
            heapify(arr, i, 0);
        }
    }
    
    // 堆化操作：将以i为根的子树调整为最大堆
    private static void heapify(int[] arr, int n, int i) {
        int largest = i;       // 初始化根节点为最大值
        int left = 2 * i + 1;  // 左子节点
        int right = 2 * i + 2; // 右子节点
        
        // 如果左子节点大于根节点
        if (left < n && arr[left] > arr[largest]) {
            largest = left;
        }
        
        // 如果右子节点大于当前最大值
        if (right < n && arr[right] > arr[largest]) {
            largest = right;
        }
        
        // 如果最大值不是根节点
        if (largest != i) {
            // 交换根节点和最大值节点
            int temp = arr[i];
            arr[i] = arr[largest];
            arr[largest] = temp;
            
            // 递归调整受影响的子树
            heapify(arr, n, largest);
        }
    }
}
```

### 优化实现（非递归堆化+最小堆）
```java
public class HeapSortOptimized {
    // 使用最小堆实现升序排序
    public static void heapSortAscending(int[] arr) {
        if (arr == null || arr.length <= 1) {
            return;
        }
        int n = arr.length;
        
        // 构建最小堆
        for (int i = n / 2 - 1; i >= 0; i--) {
            heapifyMin(arr, n, i);
        }
        
        // 创建结果数组
        int[] result = new int[n];
        
        // 提取堆顶元素（最小值）
        for (int i = 0; i < n; i++) {
            result[i] = arr[0];
            
            // 将最后一个元素移到堆顶
            arr[0] = arr[n - 1 - i];
            
            // 调整剩余元素为最小堆
            heapifyMin(arr, n - 1 - i, 0);
        }
        
        // 将结果复制回原数组
        System.arraycopy(result, 0, arr, 0, n);
    }
    
    // 非递归实现的最小堆化
    private static void heapifyMin(int[] arr, int n, int i) {
        while (true) {
            int smallest = i;
            int left = 2 * i + 1;
            int right = 2 * i + 2;
            
            if (left < n && arr[left] < arr[smallest]) {
                smallest = left;
            }
            
            if (right < n && arr[right] < arr[smallest]) {
                smallest = right;
            }
            
            if (smallest == i) {
                break; // 堆结构已正确
            }
            
            // 交换元素
            int temp = arr[i];
            arr[i] = arr[smallest];
            arr[smallest] = temp;
            
            i = smallest; // 继续向下调整
        }
    }
    
    // 优化的最大堆实现（非递归）
    public static void heapSortDescending(int[] arr) {
        if (arr == null || arr.length <= 1) {
            return;
        }
        int n = arr.length;
        
        // 构建最大堆
        for (int i = n / 2 - 1; i >= 0; i--) {
            heapifyMaxNonRecursive(arr, n, i);
        }
        
        // 提取堆顶元素
        for (int i = n - 1; i > 0; i--) {
            int temp = arr[0];
            arr[0] = arr[i];
            arr[i] = temp;
            
            heapifyMaxNonRecursive(arr, i, 0);
        }
    }
    
    // 非递归实现的最大堆化
    private static void heapifyMaxNonRecursive(int[] arr, int n, int i) {
        while (true) {
            int largest = i;
            int left = 2 * i + 1;
            int right = 2 * i + 2;
            
            if (left < n && arr[left] > arr[largest]) {
                largest = left;
            }
            
            if (right < n && arr[right] > arr[largest]) {
                largest = right;
            }
            
            if (largest == i) {
                break;
            }
            
            int temp = arr[i];
            arr[i] = arr[largest];
            arr[largest] = temp;
            
            i = largest;
        }
    }
}
```

---

## 📊 复杂度分析

### 时间复杂度
- **建堆阶段**：O(n) - 看似O(n log n)，实际分析可得线性时间复杂度
- **排序阶段**：O(n log n) - 共n-1次调整，每次调整为O(log n)
- **总体复杂度**：O(n log n) - 最好、最坏和平均情况均为此复杂度

### 空间复杂度
- **空间复杂度**：O(1) - 原地排序，仅需常数级额外空间
- **递归实现**：O(log n) - 递归调用栈深度
- **非递归实现**：O(1) - 无额外空间消耗

### 复杂度分析图表
| 操作 | 时间复杂度 | 空间复杂度 | 稳定性 |
|------|------------|------------|--------|
| 建堆 | O(n) | O(1) | 不稳定 |
| 排序 | O(n log n) | O(1) | 不稳定 |
| 总体 | O(n log n) | O(1) | 不稳定 |
| 递归实现 | O(n log n) | O(log n) | 不稳定 |
| 非递归实现 | O(n log n) | O(1) | 不稳定 |

---

## 🔍 应用场景

### 适用场景
- **内存受限环境**：原地排序特性，空间效率高
- **最坏情况保证**：需要O(n log n)最坏时间复杂度的场景
- **实时系统**：对时间复杂度稳定性要求高的应用
- **优先级队列实现**：堆排序是优先级队列的基础
- **Top K问题**：高效找出数组中前K个最大/小元素
- **操作系统调度**：进程调度算法常基于堆实现

### 不适用场景
- **稳定性要求高的场景**：堆排序是不稳定排序
- **近乎有序的数据**：性能不如优化的快速排序
- **小规模数据**：常数因子较大，不如插入排序
- **对缓存不友好**：数据访问模式跳跃，缓存命中率低

### 实际应用案例
- Java的PriorityQueue实现
- C++的std::priority_queue实现
- 操作系统的进程调度算法
- 大数据处理中的Top K问题
- 内存受限设备中的排序应用
- 实时系统中的任务调度

---

## ✂️ 优化策略

### 1. 非递归实现
- **优势**：避免递归调用栈开销，提高效率
- **实现**：使用循环代替递归进行堆化操作
- **效果**：减少内存消耗，提高缓存效率

### 2. 堆大小阈值优化
- **小规模优化**：当堆大小小于一定阈值（通常20-30）时，使用插入排序
- **原理**：小规模数据下插入排序常数因子更小
- **实现**：在堆化过程中添加大小判断

### 3. 并行堆排序
- **分治策略**：将数组分成多个子数组，并行构建子堆
- **合并阶段**：合并多个子堆得到最终排序结果
- **适用场景**：多核处理器环境

### 4. 原地堆排序优化
- **减少交换操作**：通过记录最大值位置，最后一次交换
- **缓存优化**：调整数据访问模式，提高缓存命中率
- **循环展开**：手动展开循环，减少分支预测错误

---

## ⚠️ 注意事项

### 常见错误
- **堆化方向错误**：建堆应从下往上，排序时从上往下
- **索引计算错误**：左子节点和右子节点索引计算错误
- **边界条件处理**：忽略堆大小变化，导致数组越界
- **稳定性误解**：错误地认为堆排序是稳定排序
- **递归深度问题**：递归实现可能导致栈溢出

### 实现要点
- **选择合适的堆类型**：最大堆用于升序排序，最小堆用于降序排序
- **非递归实现优先**：避免栈溢出风险，提高性能
- **边界检查**：确保所有数组访问都在有效范围内
- **理解堆结构**：正确把握完全二叉树的性质
- **测试极端情况**：空数组、单元素数组、已排序数组

### 稳定性分析
堆排序是不稳定的排序算法，原因如下：
- 交换操作可能改变相等元素的相对顺序
- 例如：[(2, A), (2, B)]在堆化过程中可能导致顺序改变
- 改进方法：可以通过添加索引信息实现稳定堆排序，但会增加复杂度

---

## 🎓 最佳实践

### 实现建议
1. **优先使用非递归实现**：避免栈溢出，提高性能
2. **选择合适的堆类型**：根据排序方向选择最大堆或最小堆
3. **小规模数据优化**：设置阈值切换到插入排序
4. **缓存优化**：调整循环顺序，提高数据局部性
5. **测试多种数据分布**：验证算法在各种情况下的表现

### 代码规范
- 清晰区分建堆和排序两个阶段
- 提取堆化操作作为独立函数
- 使用有意义的变量名（heapify, parent, left, right等）
- 添加详细注释解释堆操作过程
- 实现非递归版本以提高性能

### 与其他排序算法对比
| 特性 | 堆排序 | 快速排序 | 归并排序 |
|------|--------|----------|----------|
| 平均时间复杂度 | O(n log n) | O(n log n) | O(n log n) |
| 最坏时间复杂度 | O(n log n) | O(n²) | O(n log n) |
| 空间复杂度 | O(1) | O(log n) | O(n) |
| 稳定性 | 不稳定 | 不稳定 | 稳定 |
| 缓存效率 | 低 | 高 | 中 |
| 原地排序 | 是 | 是 | 否 |
| 并行性 | 中等 | 良好 | 良好 |

---

## 📝 经典题目

### LeetCode题目
1. **[LeetCode 215. 数组中的第K个最大元素](https://leetcode.cn/problems/kth-largest-element-in-an-array/)**
   - 难度：中等
   - 描述：找到数组中第k个最大元素
   - 提示：使用小顶堆实现，时间复杂度O(n log k)

2. **[LeetCode 347. 前 K 个高频元素](https://leetcode.cn/problems/top-k-frequent-elements/)**
   - 难度：中等
   - 描述：找出数组中出现频率前k高的元素
   - 提示：结合哈希表和堆实现

3. **[LeetCode 973. 最接近原点的 K 个点](https://leetcode.cn/problems/k-closest-points-to-origin/)**
   - 难度：中等
   - 描述：找到平面上距离原点最近的k个点
   - 提示：使用最大堆维护k个最近点

4. **[LeetCode 295. 数据流的中位数](https://leetcode.cn/problems/find-median-from-data-stream/)**
   - 难度：困难
   - 描述：设计一个支持添加元素和查找中位数的数据结构
   - 提示：使用两个堆（最大堆+最小堆）实现

### 面试常见问题
- 堆排序的工作原理是什么？如何实现？
- 堆排序的时间复杂度为什么是O(n log n)？
- 如何用堆解决Top K问题？
- 堆排序和快速排序的优缺点比较？
- 如何实现一个稳定的堆排序？
- 堆和栈有什么区别？

---

## 📚 扩展阅读

### 相关算法
- **索引堆**：带有索引的堆结构，优化元素查找
- **二项堆**：支持合并操作的高级堆结构
- **斐波那契堆**：理论上具有更优的摊还时间复杂度

### 推荐资源
- 《算法导论》第3版，第6章：堆排序
- 《算法》第4版，第2章：排序
- [堆排序可视化](https://visualgo.net/en/sorting)
- [Java PriorityQueue源码分析](https://hg.openjdk.java.net/jdk8/jdk8/jdk/file/tip/src/share/classes/java/util/PriorityQueue.java)
- [Heap Sort on Wikipedia](https://en.wikipedia.org/wiki/Heapsort)
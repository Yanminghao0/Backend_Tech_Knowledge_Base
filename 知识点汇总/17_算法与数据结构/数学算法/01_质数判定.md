# 质数判定

质数是指在大于1的自然数中，除了1和它本身以外不再有其他因数的自然数。质数判定是数论中的基础问题，在密码学、哈希函数、随机数生成等领域有重要应用。

---

## 📋 基本信息
- **定义**：只能被1和自身整除的大于1的整数
- **别名**：素数
- **相关概念**：合数（非质数的大于1的整数）、孪生素数、梅森素数
- **历史背景**：欧几里得在《几何原本》中首次证明了无穷多个质数的存在

## 🎯 算法原理

### 1. 试除法
- **基本思想**：检查n是否能被2到√n之间的任何整数整除
- **步骤**：
  1. 如果n ≤ 1，不是质数
  2. 如果n ≤ 3，是质数
  3. 如果n是偶数或能被3整除，不是质数
  4. 检查从5到√n的所有数，步长为6（因为大于3的质数都形如6k±1）

### 2. 埃拉托斯特尼筛法（Sieve of Eratosthenes）
- **基本思想**：创建一个布尔数组，标记从2开始的所有倍数为非质数
- **步骤**：
  1. 创建长度为n+1的数组is_prime，初始化为True
  2. 将is_prime[0]和is_prime[1]设为False
  3. 对于每个i从2到√n，如果is_prime[i]为True，则将i的所有倍数标记为False
  4. 剩余为True的索引即为质数

### 3. 米勒-拉宾素性测试（Miller-Rabin Primality Test）
- **基本思想**：基于费马小定理的概率测试，可用于大整数的素性判定
- **步骤**：
  1. 写出n-1 = d×2^s
  2. 选择随机整数a（1 < a < n）
  3. 计算x = a^d mod n
  4. 如果x == 1或x == n-1，可能是质数
  5. 否则重复平方x s-1次，如果始终不等于n-1，则不是质数
  6. 多次测试提高准确性

## 💻 代码实现

### 试除法实现
```python
import math

def is_prime_trial_division(n):
    if n <= 1:
        return False
    if n <= 3:
        return True
    if n % 2 == 0 or n % 3 == 0:
        return False
    i = 5
    w = 2
    while i * i <= n:
        if n % i == 0:
            return False
        i += w
        w = 6 - w  # 切换步长 2 和 4
    return True
```

### 埃拉托斯特尼筛法实现
```python
def sieve_of_eratosthenes(n):
    if n < 2:
        return []
    is_prime = [True] * (n + 1)
    is_prime[0] = is_prime[1] = False
    for i in range(2, int(math.sqrt(n)) + 1):
        if is_prime[i]:
            # 标记i的倍数为非质数
            for j in range(i*i, n+1, i):
                is_prime[j] = False
    return [i for i, prime in enumerate(is_prime) if prime]
```

### 米勒-拉宾素性测试实现
```python
import random

def is_prime_miller_rabin(n, k=5):
    if n <= 1:
        return False
    elif n <= 3:
        return True
    elif n % 2 == 0:
        return False
    
    # 写成n-1 = d * 2^s
    d = n - 1
    s = 0
    while d % 2 == 0:
        d //= 2
        s += 1
    
    # 进行k次测试
    for _ in range(k):
        a = random.randint(2, min(n - 2, 1 << 20))
        x = pow(a, d, n)
        if x == 1 or x == n - 1:
            continue
        for __ in range(s - 1):
            x = pow(x, 2, n)
            if x == n - 1:
                break
        else:
            # 如果没有通过测试
            return False
    return True
```

## 📊 复杂度分析

| 算法 | 时间复杂度 | 空间复杂度 | 特点 |
|------|------------|------------|------|
| 试除法 | O(√n) | O(1) | 简单直观，适合小整数 |
| 埃拉托斯特尼筛法 | O(n log log n) | O(n) | 适合一次性生成多个小质数 |
| 米勒-拉宾测试 | O(k log³ n) | O(1) | 概率算法，适合大整数，k为测试次数 |

## 🔍 应用场景
- **密码学**：RSA加密算法中的密钥生成需要大质数
- **哈希函数**：质数用于减少哈希冲突
- **随机数生成**：质数模数确保更好的分布特性
- **算法竞赛**：数论问题的基础组件
- **计算机安全**：数字签名和认证系统

## ⚠️ 注意事项
- 试除法在n很大时效率低下
- 埃拉托斯特尼筛法空间复杂度较高，不适合超大n
- 米勒-拉宾测试是概率算法，存在误判可能，需选择合适的测试次数k
- 对于确定性需求，可使用特定底数集合进行米勒-拉宾测试
- 处理大整数时需注意溢出问题，使用语言内置的大整数支持

## 🎓 最佳实践
- 小整数判定：优先使用试除法
- 生成一定范围内所有质数：使用埃拉托斯特尼筛法
- 大整数判定（>10^18）：使用米勒-拉宾测试，建议k=5以上
- 安全关键应用：使用经过验证的质数库，如GMP
- 算法优化：结合6k±1优化、记忆化等技巧提高性能

---

> **相关链接**：
> - [素数定理](https://zh.wikipedia.org/wiki/素数定理)
> - [米勒-拉宾素性测试](https://zh.wikipedia.org/wiki/米勒-拉宾素性测试)
> - [RSA加密算法](https://zh.wikipedia.org/wiki/RSA加密算法)
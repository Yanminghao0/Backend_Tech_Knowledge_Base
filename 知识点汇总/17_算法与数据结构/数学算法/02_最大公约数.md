# 最大公约数

最大公约数（GCD）是指两个或多个整数共有约数中最大的一个，是数论中的基础概念，在分数化简、模运算、密码学等领域有广泛应用。

---

## 📋 基本信息
- **定义**：两个或多个整数共有约数中最大的一个
- **英文缩写**：GCD (Greatest Common Divisor)
- **相关概念**：最小公倍数(LCM)、互质数(最大公约数为1的两个数)
- **数学性质**：GCD(a,b) = GCD(b,a mod b)，GCD(a,b) × LCM(a,b) = |a×b|

## 🎯 算法原理

### 1. 欧几里得算法（辗转相除法）
- **基本思想**：基于定理GCD(a,b) = GCD(b,a mod b)，通过反复取余将问题规模缩小
- **步骤**：
  1. 若b为0，则GCD为a
  2. 否则计算a除以b的余数r
  3. 将问题转化为求GCD(b,r)
  4. 重复步骤1-3直到余数为0

### 2. 扩展欧几里得算法
- **基本思想**：在求GCD(a,b)的同时，找到整数x和y使得ax + by = GCD(a,b)
- **步骤**：
  1. 当b=0时，x=1,y=0，返回GCD=a
  2. 否则递归计算GCD(b,a mod b)
  3. 回代求解x和y：x=y', y=x'-(a//b)y'
  4. 其中(x',y')是上一步递归得到的解

### 3. 更相减损术（中国传统算法）
- **基本思想**：基于定理GCD(a,b) = GCD(a-b,b) (a > b)
- **步骤**：
  1. 若a=b，则GCD为a
  2. 若a > b，则a = a - b
  3. 若b > a，则b = b - a
  4. 重复步骤1-3直到a=b

## 💻 代码实现

### 欧几里得算法（迭代版）
```python
def gcd_euclidean(a, b):
    while b != 0:
        a, b = b, a % b
    return a
```

### 扩展欧几里得算法
```python
def extended_gcd(a, b):
    if b == 0:
        return (a, 1, 0)
    else:
        g, x1, y1 = extended_gcd(b, a % b)
        x = y1
        y = x1 - (a // b) * y1
        return (g, x, y)
```

### 更相减损术
```python
def gcd_subtraction(a, b):
    while a != b:
        if a > b:
            a -= b
        else:
            b -= a
    return a
```

### 内置函数实现（Python）
```python
import math

def gcd_builtin(a, b):
    return math.gcd(a, b)  # Python 3.5+

# 最小公倍数计算
def lcm(a, b):
    return a * b // gcd_euclidean(a, b)
```

## 📊 复杂度分析

| 算法 | 时间复杂度 | 空间复杂度 | 特点 |
|------|------------|------------|------|
| 欧几里得算法 | O(log min(a,b)) | O(1) | 效率最高，迭代实现优于递归 |
| 扩展欧几里得算法 | O(log min(a,b)) | O(log min(a,b)) | 递归实现有额外空间开销 |
| 更相减损术 | O(max(a,b)) | O(1) | 适合a,b相差较小的情况 |

## 🔍 应用场景
- **分数运算**：化简分数（分子分母同除以GCD）
- **模运算**：求解线性同余方程ax ≡ b (mod m)
- **密码学**：RSA加密算法中的密钥生成
- **工程测量**：等比例缩放、最大公约数长度单位
- **数据压缩**：JPEG压缩中的离散余弦变换
- **历法计算**：计算回归年和朔望月的最小公倍数

## ⚠️ 注意事项
- 欧几里得算法中，若a < b，第一次迭代会自动交换a和b
- 处理负数时，通常取绝对值后计算GCD
- 扩展欧几里得算法解不唯一，通解为x=x0+k*(b/d), y=y0-k*(a/d)（d为GCD）
- Python的math.gcd函数返回非负整数，且不接受负数输入
- 对于多个数的GCD，可迭代计算：GCD(a,b,c) = GCD(GCD(a,b),c)

## 🎓 最佳实践
- **性能优先**：选择欧几里得算法（迭代实现）
- **求解方程**：使用扩展欧几里得算法
- **Python环境**：优先使用math.gcd（经过优化的C实现）
- **大数计算**：考虑使用内置函数或专门的数学库（如gmpy2）
- **多个数GCD**：使用reduce函数结合gcd函数

```python
from functools import reduce
import math

def gcd_multiple(numbers):
    return reduce(math.gcd, numbers)
```

---

> **相关链接**：
> - [欧几里得算法](https://zh.wikipedia.org/wiki/欧几里得算法)
> - [扩展欧几里得算法](https://zh.wikipedia.org/wiki/扩展欧几里得算法)
> - [最小公倍数](https://zh.wikipedia.org/wiki/最小公倍数)
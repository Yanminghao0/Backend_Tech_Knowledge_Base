# 素数筛法

素数筛法是一种高效查找一定范围内所有素数的算法，广泛应用于数论、密码学、算法优化等领域。常见的素数筛法包括埃拉托斯特尼筛法（Sieve of Eratosthenes）、欧拉筛法（线性筛）、区间筛法等，它们各有特点和适用场景。

---

## 📋 基本信息
- **定义**：通过特定规则标记或排除非素数，从而快速找出一定范围内所有素数的算法
- **核心思想**：利用素数的倍数一定不是素数的特性，通过标记倍数来排除非素数
- **常见类型**：埃拉托斯特尼筛法、欧拉筛法（线性筛）、区间筛法、分段筛法
- **应用领域**：密码学（如RSA算法）、数值计算、哈希表设计、随机数生成

## 🎯 算法原理

### 1. 埃拉托斯特尼筛法（Sieve of Eratosthenes）
- **基本思想**：从2开始，将每个素数的倍数标记为非素数
- **步骤**：
  1. 创建一个布尔数组is_prime[0..n]，初始化所有 entries 为True，除了索引0和1
  2. 从第一个素数p=2开始，将p的所有倍数标记为False
  3. 找到大于p的最小索引，该索引仍为True，即为下一个素数
  4. 重复步骤2-3，直到p² > n
  5. 所有仍为True的索引即为素数

### 2. 欧拉筛法（线性筛）
- **基本思想**：每个合数只被其最小质因数标记一次，时间复杂度达到O(n)
- **核心优化**：对于每个数i，与已知素数相乘时，当i能被素数整除时停止，确保每个合数只被标记一次
- **步骤**：
  1. 创建素数列表primes和布尔数组is_prime
  2. 遍历从2到n的每个数i
  3. 如果i是素数，加入素数列表
  4. 对于每个素数p，标记i*p为非素数
  5. 当i能被p整除或i*p > n时停止

### 3. 区间筛法
- **基本思想**：在大范围内筛选素数时，将区间分段处理，降低内存占用
- **适用场景**：需要找出[L, R]区间内的素数，且R很大（如10^12）
- **核心步骤**：
  1. 先用埃拉托斯特尼筛法找出√R范围内的所有素数
  2. 创建区间[L, R]的布尔数组
  3. 对于每个素数p，标记区间内p的倍数为非素数

## 💻 代码实现

### 埃拉托斯特尼筛法
```python
def sieve_of_eratosthenes(n):
    if n < 2:
        return []
    is_prime = [True] * (n + 1)
    is_prime[0] = is_prime[1] = False
    for p in range(2, int(n ** 0.5) + 1):
        if is_prime[p]:
            # 从p*p开始标记倍数，优化小素数的倍数已被标记
            for multiple in range(p * p, n + 1, p):
                is_prime[multiple] = False
    primes = [i for i, val in enumerate(is_prime) if val]
    return primes
```

### 欧拉筛法（线性筛）
```python
def euler_sieve(n):
    if n < 2:
        return []
    is_prime = [True] * (n + 1)
    primes = []
    for i in range(2, n + 1):
        if is_prime[i]:
            primes.append(i)
        # 遍历已知素数，标记i的倍数
        for p in primes:
            if i * p > n:
                break
            is_prime[i * p] = False
            # 关键优化：确保每个合数只被其最小质因数标记
            if i % p == 0:
                break
    return primes
```

### 区间筛法
```python
def segment_sieve(l, r):
    if r < 2:
        return []
    # 先筛选出sqrt(r)以内的素数
    sqrt_r = int(r ** 0.5) + 1
    base_primes = sieve_of_eratosthenes(sqrt_r)
    
    # 初始化区间[l, r]的筛子
    is_prime = [True] * (r - l + 1)
    if l == 0:
        if r >= 0: is_prime[0] = False
        if r >= 1: is_prime[1] = False
    elif l == 1:
        is_prime[0] = False
    
    # 用每个素数p标记区间内的倍数
    for p in base_primes:
        # 计算区间内第一个p的倍数
        start = max(p * p, ((l + p - 1) // p) * p)
        # 标记所有p的倍数
        for multiple in range(start, r + 1, p):
            is_prime[multiple - l] = False
    
    primes = [l + i for i, val in enumerate(is_prime) if val]
    return primes
```

## 📊 复杂度分析

| 算法 | 时间复杂度 | 空间复杂度 | 特点 |
|------|------------|------------|------|
| 埃拉托斯特尼筛法 | O(n log log n) | O(n) | 实现简单，适用于中小范围 |
| 欧拉筛法 | O(n) | O(n) | 线性时间，适用于大范围筛选 |
| 区间筛法 | O((r-l+1) log log √r + √r log log √r) | O(√r + (r-l)) | 适用于超大范围筛选 |

## 🔍 应用场景
- **密码学**：RSA加密算法中的大素数生成
- **哈希表**：素数大小的散列表可以减少哈希冲突
- **数学问题**：解决素数相关的数论问题
- **算法竞赛**：快速解决范围素数查询问题
- **随机数生成**：基于素数的随机数生成算法
- **计算机安全**：素数测试和加密系统

## ⚠️ 注意事项
- **内存限制**：对于非常大的n（如10^8以上），标准筛法可能导致内存溢出
- **初始值处理**：0和1不是素数，需要特殊处理
- **边界条件**：处理小范围（n<2）时应返回空列表
- **区间筛法**：处理l=0或l=1的情况时需正确标记非素数
- **时间优化**：埃拉托斯特尼筛法可从p²开始标记倍数，减少重复操作

## 🎓 最佳实践
- **中小范围筛选**：优先选择埃拉托斯特尼筛法，实现简单高效
- **大范围筛选**：使用欧拉筛法，获得线性时间复杂度
- **超大范围筛选**：采用区间筛法，降低内存占用
- **内存优化**：对于极端大n，考虑使用位运算压缩存储（如BitArray）
- **并行计算**：大规模素数筛选可采用并行化实现
- **素数判断**：对于单个素数判断，可使用Miller-Rabin素性测试

```python
# 素数判断（Miller-Rabin测试）
def is_prime(n, k=5):
    if n <= 1:
        return False
    elif n <= 3:
        return True
    elif n % 2 == 0:
        return False
    
    # 将n-1表示为d*2^s
    d = n - 1
    s = 0
    while d % 2 == 0:
        d //= 2
        s += 1
    
    # 进行k次测试
    for _ in range(k):
        a = random.randint(2, min(n-2, 1 << 20))
        x = pow(a, d, n)
        if x == 1 or x == n - 1:
            continue
        for __ in range(s - 1):
            x = pow(x, 2, n)
            if x == n - 1:
                break
        else:
            return False
    return True
```

---

> **相关链接**：
> - [埃拉托斯特尼筛法](https://zh.wikipedia.org/wiki/埃拉托斯特尼筛法)
> - [素数](https://zh.wikipedia.org/wiki/素数)
> - [RSA加密算法](https://zh.wikipedia.org/wiki/RSA加密算法)
# 组合数学

组合数学（Combinatorics）是研究离散对象的计数、排列、组合和优化等问题的数学分支，在算法设计、密码学、概率论、计算机科学等领域有广泛应用。组合数学主要关注“计数”和“选择”问题，提供了高效解决离散结构问题的方法和技巧。

---

## 📋 基本信息
- **定义**：研究离散对象的排列、组合、计数和优化等问题的数学分支
- **核心问题**：存在性问题、计数问题、构造问题、优化问题
- **基本概念**：排列、组合、二项式系数、容斥原理、生成函数、递归关系
- **研究对象**：离散结构、有限集合、离散概率空间
- **应用领域**：算法设计、密码学、编码理论、人工智能、运筹学

## 🎯 算法原理

### 1. 排列与组合
- **排列（Permutation）**：从n个不同元素中取出k个元素，按照一定顺序排成一列，记为P(n,k)或A(n,k)
  - 公式：P(n,k) = n! / (n-k)!
  - 全排列：P(n,n) = n!

- **组合（Combination）**：从n个不同元素中取出k个元素，不考虑顺序组成一组，记为C(n,k)或$inom{n}{k}$
  - 公式：C(n,k) = n! / (k!(n-k)!)
  - 性质：C(n,k) = C(n,n-k)，C(n,k) = C(n-1,k) + C(n-1,k-1)

### 2. 二项式系数
- **定义**：二项式定理中各项的系数，即$(a+b)^n = \sum_{k=0}^{n} \binom{n}{k}a^{n-k}b^k$
- **递推关系**：杨辉三角（Pascal's Triangle），$inom{n}{k} = inom{n-1}{k-1} + inom{n-1}{k}$
- **计算方法**：动态规划、阶乘公式、乘法逆元（模运算下）

### 3. 容斥原理
- **基本思想**：计算多个集合的并集大小时，先累加单个集合大小，再减去所有两两交集，加上所有三三交集，以此类推
- **公式**：$|A_1 ∪ A_2 ∪ ... ∪ A_n| = \sum|A_i| - \sum|A_i ∩ A_j| + \sum|A_i ∩ A_j ∩ A_k| - ... + (-1)^{n+1}|A_1 ∩ ... ∩ A_n|$
- **应用**：计数问题、概率计算、 inclusion-exclusion principle 在算法中的实现

### 4. 卡特兰数（Catalan Number）
- **定义**：一类重要的组合计数数列，记为C_n
- **公式**：$C_n = \frac{1}{n+1}\binom{2n}{n}$
- **递推关系**：$C_0 = 1, C_{n+1} = \sum_{i=0}^{n} C_iC_{n-i}$
- **应用场景**：括号匹配、凸多边形三角剖分、二叉树计数、路径规划

### 5. 生成函数
- **定义**：将数列用多项式或幂级数表示，通过函数运算解决组合问题
- **普通生成函数**：$G(x) = \sum_{n=0}^{∞} a_nx^n$
- **指数生成函数**：$G(x) = \sum_{n=0}^{∞} a_n\frac{x^n}{n!}$
- **应用**：求解递推关系、组合计数、整数拆分

## 💻 代码实现

### 1. 组合数计算（动态规划）
```python
def combination_dp(n, k):
    """使用动态规划计算组合数C(n,k)"
    if k < 0 or k > n:
        return 0
    if k == 0 or k == n:
        return 1
    # 优化空间，只保留上一行
    dp = [0] * (k + 1)
    dp[0] = 1
    for i in range(1, n + 1):
        # 从后往前更新，避免覆盖
        for j in range(min(i, k), 0, -1):
            dp[j] = dp[j] + dp[j - 1]
    return dp[k]
```

### 2. 排列数计算
```python
def permutation(n, k):
    """计算排列数P(n,k)"
    if k < 0 or k > n:
        return 0
    result = 1
    for i in range(n, n - k, -1):
        result *= i
    return result
```

### 3. 卡特兰数计算
```python
def catalan_number(n):
    """计算第n个卡特兰数"
    if n < 0:
        return 0
    # 使用动态规划
    catalan = [0] * (n + 1)
    catalan[0] = 1
    for i in range(1, n + 1):
        for j in range(i):
            catalan[i] += catalan[j] * catalan[i - j - 1]
    return catalan[n]

# 使用组合公式计算卡特兰数（需处理大数）
def catalan_number_comb(n):
    from math import comb
    return comb(2 * n, n) // (n + 1)
```

### 4. 容斥原理应用：计算1~n中与m互质的数的个数
```python
def count_coprime(n, m):
    """计算1~n中与m互质的数的个数"
    # 分解m的质因数
    factors = []
    temp = m
    i = 2
    while i * i <= temp:
        if temp % i == 0:
            factors.append(i)
            while temp % i == 0:
                temp //= i
        i += 1
    if temp > 1:
        factors.append(temp)

    # 容斥原理计算
    k = len(factors)
    total = 0
    # 枚举所有非空子集
    for mask in range(1, 1 << k):
        bits = bin(mask).count('1')
        product = 1
        for i in range(k):
            if mask & (1 << i):
                product *= factors[i]
        # 奇加偶减
        if bits % 2 == 1:
            total += n // product
        else:
            total -= n // product
    return n - total
```

### 5. 生成函数应用：整数拆分
```python
def integer_partition(n):
    """计算正整数n的拆分数"
    dp = [0] * (n + 1)
    dp[0] = 1
    # 每个数作为一个部分
    for i in range(1, n + 1):
        for j in range(i, n + 1):
            dp[j] += dp[j - i]
    return dp[n]
```

## 📊 复杂度分析

| 算法 | 时间复杂度 | 空间复杂度 | 说明 |
|------|------------|------------|------|
| 组合数（动态规划） | O(nk) | O(k) | 空间优化版本 |
| 排列数 | O(k) | O(1) | 直接计算 |
| 卡特兰数（DP） | O(n²) | O(n) | 动态规划实现 |
| 卡特兰数（组合公式） | O(n) | O(1) | 需计算组合数 |
| 容斥原理 | O(2^k) | O(k) | k为质因数个数 |
| 整数拆分 | O(n²) | O(n) | 完全背包思想 |

## 🔍 应用场景
- **算法设计**：组合优化、动态规划状态设计
- **密码学**：基于组合数学的加密算法设计
- **编码理论**：纠错码、数据压缩
- **人工智能**：概率图模型、贝叶斯网络
- **运筹学**：资源分配、调度问题
- **计算机科学**：排列组合在算法复杂度分析中的应用
- **数学竞赛**：组合计数问题、构造性问题
- **统计学**：组合概率、抽样方法

## ⚠️ 注意事项
- **大数问题**：组合数和卡特兰数随n增长极快，易导致整数溢出
- **精度问题**：浮点数计算组合数时可能产生精度损失
- **时间复杂度**：容斥原理在质因数较多时复杂度指数增长
- **边界条件**：组合数C(n,k)中k=0或k=n时结果为1
- **重复计算**：未优化的递归实现会导致大量重复计算
- **模运算**：在算法竞赛中常需对结果取模，避免溢出

## 🎓 最佳实践
- **空间优化**：组合数计算使用一维动态规划数组
- **模运算应用**：对大数值结果采用模运算（如1e9+7）
- **预处理**：提前计算阶乘和逆元，加速组合数查询
- **递归转迭代**：将递归实现的组合算法转为迭代，避免栈溢出
- **数学公式优化**：使用组合恒等式简化计算
- **位运算**：容斥原理中使用位运算枚举子集
- **库函数利用**：Python中可使用math.comb（Python 3.10+）高效计算组合数

```python
# 优化示例：预处理阶乘和逆元计算组合数（模运算）
MOD = 10**9 + 7
def precompute_factorials(max_n):
    factorial = [1] * (max_n + 1)
    inverse = [1] * (max_n + 1)
    for i in range(1, max_n + 1):
        factorial[i] = factorial[i-1] * i % MOD
    # 使用费马小定理计算逆元
    inverse[max_n] = pow(factorial[max_n], MOD-2, MOD)
    for i in range(max_n-1, -1, -1):
        inverse[i] = inverse[i+1] * (i+1) % MOD
    return factorial, inverse

# 使用预处理的阶乘和逆元计算组合数
def comb_mod(n, k, factorial, inverse):
    if k < 0 or k > n:
        return 0
    return factorial[n] * inverse[k] % MOD * inverse[n - k] % MOD
```

---

> **相关链接**：
> - [组合数学](https://zh.wikipedia.org/wiki/组合数学)
> - [排列](https://zh.wikipedia.org/wiki/排列)
> - [组合](https://zh.wikipedia.org/wiki/组合)
> - [卡特兰数](https://zh.wikipedia.org/wiki/卡塔兰数)
> - [容斥原理](https://zh.wikipedia.org/wiki/容斥原理)
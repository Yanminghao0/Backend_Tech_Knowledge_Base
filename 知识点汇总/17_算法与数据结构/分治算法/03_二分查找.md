# 二分查找

> 二分查找（Binary Search）是一种高效的查找算法，也称为折半查找，通过分治策略在有序集合中快速定位目标元素。

---

## 📋 基本信息
- **类别**：分治算法、查找算法
- **难度**：简单
- **核心思想**：分而治之，逐步缩小查找范围
- **时间复杂度**：O(log n)
- **空间复杂度**：O(1)（迭代实现）/ O(log n)（递归实现）
- **关键词**：有序数组、分治、折半、边界条件

## 🎯 分治策略
二分查找的分治思想体现在三个步骤：
1. **分解**：将有序数组分为两部分，比较中间元素与目标值
2. **解决**：
   - 若中间元素等于目标值，查找成功
   - 若中间元素大于目标值，在左半部分继续查找
   - 若中间元素小于目标值，在右半部分继续查找
3. **合并**：无需合并，查找结果直接返回

## 💻 代码实现
### Java实现（基本迭代版）
```java
public class BinarySearch {
    public int binarySearch(int[] arr, int target) {
        if (arr == null || arr.length == 0) return -1;
        
        int left = 0;
        int right = arr.length - 1;
        
        while (left <= right) {
            // 防止溢出，等价于 (left + right) / 2
            int mid = left + (right - left) / 2;
            
            if (arr[mid] == target) {
                return mid; // 找到目标，返回索引
            } else if (arr[mid] < target) {
                left = mid + 1; // 目标在右半部分
            } else {
                right = mid - 1; // 目标在左半部分
            }
        }
        return -1; // 未找到目标
    }
}
```

### Java实现（递归版）
```java
public int binarySearchRecursive(int[] arr, int target) {
    if (arr == null || arr.length == 0) return -1;
    return search(arr, target, 0, arr.length - 1);
}

private int search(int[] arr, int target, int left, int right) {
    if (left > right) return -1;
    
    int mid = left + (right - left) / 2;
    
    if (arr[mid] == target) {
        return mid;
    } else if (arr[mid] < target) {
        return search(arr, target, mid + 1, right);
    } else {
        return search(arr, target, left, mid - 1);
    }
}
```

### 常见变体：查找第一个出现的目标值
```java
public int findFirstOccurrence(int[] arr, int target) {
    int left = 0;
    int right = arr.length - 1;
    int result = -1;
    
    while (left <= right) {
        int mid = left + (right - left) / 2;
        
        if (arr[mid] == target) {
            result = mid; // 记录找到的位置
            right = mid - 1; // 继续向左查找
        } else if (arr[mid] < target) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    return result;
}
```

## 📊 复杂度分析
- **时间复杂度**：O(log n)
  - 每次比较将查找范围缩小一半
  - 最多需要 log₂(n) + 1 次比较
- **空间复杂度**：
  - 迭代实现：O(1)（常量空间）
  - 递归实现：O(log n)（递归栈深度）

## 🔍 应用场景
- 有序数组中的元素查找
- 数据库索引查询（B+树索引本质）
- 二分答案（在解空间中查找最优解）
- 数值计算中的方程求解
- 编译器中的符号表查找
- 海量数据处理中的快速定位

## ⚠️ 注意事项
1. **边界条件**：注意循环条件是 left ≤ right 还是 left < right
2. **整数溢出**：计算 mid 时使用 left + (right - left)/2 而非 (left + right)/2
3. **数组有序性**：确保输入数组是有序的，否则结果不可靠
4. **重复元素**：基本实现可能返回任意匹配元素，需特殊处理
5. **空数组处理**：需先判断数组是否为空，避免索引异常

## 💡 最佳实践
- 优先使用迭代实现（避免栈溢出风险）
- 明确处理边界条件和特殊情况
- 对于重复元素，根据需求实现特定变体
- 结合二分查找思想解决非查找类问题（如二分答案）
- 大型数组可考虑并行二分查找优化

## 📚 经典题目
- [LeetCode 704. 二分查找](https://leetcode-cn.com/problems/binary-search/)
- [LeetCode 33. 搜索旋转排序数组](https://leetcode-cn.com/problems/search-in-rotated-sorted-array/)
- [LeetCode 34. 在排序数组中查找元素的第一个和最后一个位置](https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/)

---
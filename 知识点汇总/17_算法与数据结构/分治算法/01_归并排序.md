# 归并排序

> 归并排序（Merge Sort）是一种稳定高效的排序算法，采用分治策略实现，由John von Neumann于1945年提出。

---

## 📋 基本信息
- **类别**：分治算法
- **难度**：中等
- **稳定性**：稳定
- **时间复杂度**：O(n log n)（所有情况）
- **空间复杂度**：O(n)
- **关键词**：分治、合并、递归、稳定排序、外部排序

## 🎯 分治策略
归并排序的分治思想体现在三个步骤：
1. **分解**：将数组递归拆分为两个 halves，直到每个子数组只包含一个元素
2. **解决**：递归地对两个子数组进行归并排序
3. **合并**：将已排序的子数组合并为一个有序数组

## 💻 代码实现
### Java实现（递归版）
```java
public class MergeSort {
    public void mergeSort(int[] arr) {
        if (arr == null || arr.length <= 1) return;
        int[] temp = new int[arr.length];
        sort(arr, 0, arr.length - 1, temp);
    }

    private void sort(int[] arr, int left, int right, int[] temp) {
        if (left < right) {
            int mid = left + (right - left) / 2;
            // 递归排序左半部分
            sort(arr, left, mid, temp);
            // 递归排序右半部分
            sort(arr, mid + 1, right, temp);
            // 合并两个有序子数组
            merge(arr, left, mid, right, temp);
        }
    }

    private void merge(int[] arr, int left, int mid, int right, int[] temp) {
        int i = left;    // 左子数组起始索引
        int j = mid + 1; // 右子数组起始索引
        int t = 0;       // 临时数组指针

        // 合并两个子数组
        while (i <= mid && j <= right) {
            if (arr[i] <= arr[j]) {
                temp[t++] = arr[i++];
            } else {
                temp[t++] = arr[j++];
            }
        }

        // 将左子数组剩余元素复制到临时数组
        while (i <= mid) {
            temp[t++] = arr[i++];
        }

        // 将右子数组剩余元素复制到临时数组
        while (j <= right) {
            temp[t++] = arr[j++];
        }

        // 将临时数组元素复制回原数组
        t = 0;
        while (left <= right) {
            arr[left++] = temp[t++];
        }
    }
}
```

### Java实现（迭代版）
```java
public void mergeSortIterative(int[] arr) {
    if (arr == null || arr.length <= 1) return;
    int n = arr.length;
    int[] temp = new int[n];
    
    // 子数组大小从1开始，每次翻倍
    for (int size = 1; size < n; size *= 2) {
        // 合并相邻子数组
        for (int left = 0; left < n - size; left += 2 * size) {
            int mid = left + size - 1;
            int right = Math.min(left + 2 * size - 1, n - 1);
            merge(arr, left, mid, right, temp);
        }
    }
}
```

## 📊 复杂度分析
- **时间复杂度**：O(n log n)（所有情况）
  - 分解：O(log n)层递归
  - 合并：每层O(n)操作
  - 总复杂度：O(n log n)
- **空间复杂度**：O(n)
  - 需要额外数组存储合并结果
  - 递归实现额外需要O(log n)的栈空间

## 🔍 应用场景
- 外部排序（磁盘文件排序）
- 大型数据库系统中的排序操作
- 需要稳定排序的场景
- 链表排序（只需O(1)额外空间）
- 求逆序对数量

## ⚠️ 注意事项
1. **额外空间**：需要O(n)的辅助空间，不适合内存受限场景
2. **小规模数据**：对小规模数据效率不如插入排序
3. **递归深度**：递归实现可能导致栈溢出，大规模数据建议用迭代实现
4. **缓存效率**：数组实现的缓存局部性不如快速排序

## 💡 最佳实践
- 对小规模子数组（长度<15）使用插入排序优化
- 采用自底向上的迭代实现避免栈溢出
- 合并操作中减少元素复制次数
- 对于链表实现，可实现O(1)空间复杂度
- 与快速排序结合使用（如Timsort算法）

---

## 📚 经典题目
- [LeetCode 148. 排序链表](https://leetcode-cn.com/problems/sort-list/)
- [LeetCode 23. 合并K个升序链表](https://leetcode-cn.com/problems/merge-k-sorted-lists/)
- [LeetCode 315. 计算右侧小于当前元素的个数](https://leetcode-cn.com/problems/count-of-smaller-numbers-after-self/)

---
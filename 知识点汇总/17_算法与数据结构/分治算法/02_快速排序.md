# 快速排序

> 快速排序（Quick Sort）是一种高效的排序算法，采用分治策略实现，由Tony Hoare于1960年提出。

---

## 📋 基本信息
- **类别**：分治算法
- **难度**：中等
- **稳定性**：不稳定
- **时间复杂度**：平均O(n log n)，最坏O(n²)
- **空间复杂度**：O(log n)（递归栈）
- **关键词**：分治、基准元素、递归、原地排序

## 🎯 分治策略
快速排序的分治思想体现在三个步骤：
1. **分解**：选择一个基准元素(pivot)，将数组分为两部分，左侧元素小于等于基准，右侧元素大于基准
2. **解决**：递归地对左右两部分数组进行快速排序
3. **合并**：由于是原地排序，无需额外合并操作

## 💻 代码实现
### Java实现（基本版）
```java
public class QuickSort {
    public void quickSort(int[] arr, int low, int high) {
        if (low < high) {
            // 获取基准元素位置
            int pivotIndex = partition(arr, low, high);
            // 递归排序左子数组
            quickSort(arr, low, pivotIndex - 1);
            // 递归排序右子数组
            quickSort(arr, pivotIndex + 1, high);
        }
    }

    private int partition(int[] arr, int low, int high) {
        // 选择最右侧元素作为基准
        int pivot = arr[high];
        // i是小于基准区域的边界
        int i = low - 1;
        
        for (int j = low; j < high; j++) {
            // 当前元素小于等于基准，扩展小于区域
            if (arr[j] <= pivot) {
                i++;
                // 交换元素到小于区域
                int temp = arr[i];
                arr[i] = arr[j];
                arr[j] = temp;
            }
        }
        
        // 将基准元素放到最终位置
        int temp = arr[i + 1];
        arr[i + 1] = arr[high];
        arr[high] = temp;
        
        return i + 1;
    }
}
```

### 优化策略：三数取中法（解决有序数组退化问题）
```java
private int medianOfThree(int[] arr, int low, int high) {
    int mid = low + (high - low) / 2;
    // 排序三个位置的元素
    if (arr[low] > arr[mid]) swap(arr, low, mid);
    if (arr[low] > arr[high]) swap(arr, low, high);
    if (arr[mid] > arr[high]) swap(arr, mid, high);
    // 将中间值放到high-1位置
    swap(arr, mid, high - 1);
    return arr[high - 1];
}
```

## 📊 复杂度分析
- **时间复杂度**：
  - 最佳情况：O(n log n)（每次划分均衡）
  - 平均情况：O(n log n)
  - 最坏情况：O(n²)（数组已排序或所有元素相等时）
- **空间复杂度**：
  - O(log n)：递归调用栈（平衡划分）
  - O(n)：最坏情况下的递归栈

## 🔍 应用场景
- 大规模数据排序（平均性能优异）
- 内存有限的系统（原地排序特性）
- 商业级排序库实现（如Java Arrays.sort()对原始类型使用双轴快速排序）
- 数据库索引构建中的排序环节

## ⚠️ 注意事项
1. **基准选择**：随机选择基准或三数取中法可避免最坏情况
2. **重复元素**：可采用三向切分（小于、等于、大于基准）处理大量重复元素
3. **小规模数组**：对长度小于一定阈值（如10-20）的子数组改用插入排序
4. **递归深度**：过深的递归可能导致栈溢出，可转换为非递归实现

## 💡 最佳实践
- 结合插入排序处理小规模子数组
- 使用三数取中法或随机基准选择
- 实现尾递归优化减少栈空间使用
- 对重复元素采用三向切分策略
- 对于几乎有序的数据，考虑使用其他排序算法

## 📚 经典题目
- [LeetCode 912. 排序数组](https://leetcode-cn.com/problems/sort-an-array/)
- [LeetCode 215. 数组中的第K个最大元素](https://leetcode-cn.com/problems/kth-largest-element-in-an-array/)
- [LeetCode 75. 颜色分类](https://leetcode-cn.com/problems/sort-colors/)

---
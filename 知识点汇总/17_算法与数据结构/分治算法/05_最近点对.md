# æœ€è¿‘ç‚¹å¯¹

> æœ€è¿‘ç‚¹å¯¹é—®é¢˜ï¼ˆClosest Pair Problemï¼‰æ˜¯è®¡ç®—å‡ ä½•ä¸­çš„ç»å…¸é—®é¢˜ï¼Œå¯»æ‰¾å¹³é¢ä¸Šè·ç¦»æœ€è¿‘çš„ä¸€å¯¹ç‚¹ï¼Œåˆ†æ²»ç­–ç•¥å¯é«˜æ•ˆè§£å†³æ­¤é—®é¢˜ã€‚

---

## ğŸ“‹ åŸºæœ¬ä¿¡æ¯
- **ç±»åˆ«**ï¼šåˆ†æ²»ç®—æ³•ã€è®¡ç®—å‡ ä½•
- **éš¾åº¦**ï¼šå›°éš¾
- **æ ¸å¿ƒæ€æƒ³**ï¼šå°†å¹³é¢ç‚¹é›†é€’å½’åˆ’åˆ†ï¼Œé«˜æ•ˆåˆå¹¶ç»“æœ
- **æ—¶é—´å¤æ‚åº¦**ï¼šO(n log n)
- **ç©ºé—´å¤æ‚åº¦**ï¼šO(n)
- **å…³é”®è¯**ï¼šåˆ†æ²»ã€è®¡ç®—å‡ ä½•ã€è·ç¦»è®¡ç®—ã€é€’å½’åˆ’åˆ†

## ğŸ¯ åˆ†æ²»ç­–ç•¥
æœ€è¿‘ç‚¹å¯¹ç®—æ³•çš„åˆ†æ²»æ€æƒ³ä½“ç°åœ¨å››ä¸ªæ­¥éª¤ï¼š
1. **åˆ†è§£**ï¼š
   - å°†ç‚¹é›†æŒ‰xåæ ‡æ’åº
   - é€’å½’åˆ’åˆ†ä¸ºå·¦å³ä¸¤ä¸ªå­é›†
2. **è§£å†³**ï¼š
   - é€’å½’æ±‚è§£å·¦å³å­é›†çš„æœ€è¿‘ç‚¹å¯¹
3. **åˆå¹¶**ï¼š
   - è®¡ç®—å·¦å³å­é›†æœ€è¿‘è·ç¦»Î´
   - åœ¨åˆ†å‰²çº¿é™„è¿‘Î´èŒƒå›´å†…å¯»æ‰¾è·¨å­é›†æœ€è¿‘ç‚¹å¯¹
   - æ¯”è¾ƒå¾—å‡ºå…¨å±€æœ€è¿‘ç‚¹å¯¹
4. **ä¼˜åŒ–**ï¼š
   - ä»…éœ€è€ƒè™‘æ¯ä¸ªç‚¹å‰åæœ€å¤š6ä¸ªç‚¹
   - é€šè¿‡yåæ ‡æ’åºå‡å°‘æ¯”è¾ƒæ¬¡æ•°

## ğŸ’» ä»£ç å®ç°
### Javaå®ç°ï¼ˆåˆ†æ²»ç®—æ³•ï¼‰
```java
import java.util.*;

public class ClosestPair {
    // ç‚¹ç±»å®šä¹‰
    static class Point implements Comparable<Point> {
        double x, y;
        int index;

        Point(double x, double y, int index) {
            this.x = x;
            this.y = y;
            this.index = index;
        }

        // æŒ‰xåæ ‡æ’åº
        @Override
        public int compareTo(Point other) {
            if (this.x != other.x) {
                return Double.compare(this.x, other.x);
            }
            return Double.compare(this.y, other.y);
        }
    }

    // æŒ‰yåæ ‡æ¯”è¾ƒçš„æ¯”è¾ƒå™¨
    static class YComparator implements Comparator<Point> {
        @Override
        public int compare(Point a, Point b) {
            return Double.compare(a.y, b.y);
        }
    }

    // è®¡ç®—ä¸¤ç‚¹é—´è·ç¦»çš„å¹³æ–¹ï¼ˆé¿å…å¼€æ–¹è¿ç®—ï¼‰
    private static double distanceSquared(Point a, Point b) {
        double dx = a.x - b.x;
        double dy = a.y - b.y;
        return dx * dx + dy * dy;
    }

    // è®¡ç®—ä¸¤ç‚¹é—´è·ç¦»
    private static double distance(Point a, Point b) {
        return Math.sqrt(distanceSquared(a, b));
    }

    // æš´åŠ›æŸ¥æ‰¾æœ€è¿‘ç‚¹å¯¹ï¼ˆç”¨äºå°è§„æ¨¡ç‚¹é›†ï¼‰
    private static double bruteForce(Point[] points, int left, int right, Point[] result) {
        double minDist = Double.POSITIVE_INFINITY;
        for (int i = left; i <= right; i++) {
            for (int j = i + 1; j <= right; j++) {
                double dist = distanceSquared(points[i], points[j]);
                if (dist < minDist) {
                    minDist = dist;
                    result[0] = points[i];
                    result[1] = points[j];
                }
            }
        }
        return Math.sqrt(minDist);
    }

    // ä¸»ç®—æ³•ï¼šå¯»æ‰¾æœ€è¿‘ç‚¹å¯¹
    public static double findClosestPair(Point[] points, Point[] result) {
        // æŒ‰xåæ ‡æ’åº
        Arrays.sort(points);
        Point[] temp = new Point[points.length];
        return closestPairRecursive(points, 0, points.length - 1, temp, result);
    }

    // é€’å½’å¯»æ‰¾æœ€è¿‘ç‚¹å¯¹
    private static double closestPairRecursive(Point[] points, int left, int right, Point[] temp, Point[] result) {
        // å°è§„æ¨¡ç‚¹é›†ç›´æ¥æš´åŠ›æ±‚è§£
        if (right - left + 1 <= 3) {
            return bruteForce(points, left, right, result);
        }

        // æ‰¾åˆ°ä¸­é—´ç‚¹
        int mid = (left + right) / 2;
        Point midPoint = points[mid];

        // é€’å½’æ±‚è§£å·¦å³å­é›†
        Point[] leftResult = new Point[2];
        Point[] rightResult = new Point[2];
        double leftDist = closestPairRecursive(points, left, mid, temp, leftResult);
        double rightDist = closestPairRecursive(points, mid + 1, right, temp, rightResult);

        // ç¡®å®šå½“å‰æœ€å°è·ç¦»å’Œå¯¹åº”ç‚¹å¯¹
        double minDist;
        if (leftDist < rightDist) {
            minDist = leftDist;
            result[0] = leftResult[0];
            result[1] = leftResult[1];
        } else {
            minDist = rightDist;
            result[0] = rightResult[0];
            result[1] = rightResult[1];
        }

        // å¯»æ‰¾è·¨å­é›†çš„æœ€è¿‘ç‚¹å¯¹
        double stripDist = findStripClosest(points, left, right, midPoint, minDist, temp, result);
        if (stripDist < minDist) {
            minDist = stripDist;
        }

        return minDist;
    }

    // å¯»æ‰¾å¸¦çŠ¶åŒºåŸŸå†…çš„æœ€è¿‘ç‚¹å¯¹
    private static double findStripClosest(Point[] points, int left, int right, Point midPoint,
                                          double minDist, Point[] temp, Point[] result) {
        int stripSize = 0;
        double delta = minDist;

        // æ”¶é›†è·ç¦»ä¸­é—´çº¿å°äºdeltaçš„ç‚¹
        for (int i = left; i <= right; i++) {
            if (Math.abs(points[i].x - midPoint.x) < delta) {
                temp[stripSize++] = points[i];
            }
        }

        // æŒ‰yåæ ‡æ’åº
        Arrays.sort(temp, 0, stripSize, new YComparator());

        // æ£€æŸ¥æ¯ä¸ªç‚¹å‰åæœ€å¤š6ä¸ªç‚¹
        double minStripDist = minDist;
        for (int i = 0; i < stripSize; i++) {
            for (int j = i + 1; j < stripSize && (temp[j].y - temp[i].y) < minStripDist; j++) {
                double dist = distance(temp[i], temp[j]);
                if (dist < minStripDist) {
                    minStripDist = dist;
                    result[0] = temp[i];
                    result[1] = temp[j];
                }
            }
        }

        return minStripDist;
    }

    // ä¸»å‡½æ•°ç¤ºä¾‹
    public static void main(String[] args) {
        Point[] points = {
            new Point(2, 3, 0),
            new Point(12, 30, 1),
            new Point(40, 50, 2),
            new Point(5, 1, 3),
            new Point(12, 10, 4),
            new Point(3, 4, 5)
        };

        Point[] result = new Point[2];
        double minDistance = findClosestPair(points, result);

        System.out.println("æœ€è¿‘ç‚¹å¯¹: ç‚¹" + result[0].index + " å’Œ ç‚¹" + result[1].index);
        System.out.println("æœ€å°è·ç¦»: " + minDistance);
    }
}
```

## ğŸ“Š å¤æ‚åº¦åˆ†æ
- **æ—¶é—´å¤æ‚åº¦**ï¼šO(n log n)
  - æ’åºç‚¹é›†ï¼šO(n log n)
  - åˆ†æ²»é€’å½’ï¼šæ¯å±‚O(n)æ“ä½œï¼Œå…±O(log n)å±‚
  - åˆå¹¶æ­¥éª¤ï¼šæ¯å±‚O(n)æ“ä½œï¼ˆæ¯ä¸ªç‚¹æœ€å¤šæ¯”è¾ƒ6ä¸ªç‚¹ï¼‰
- **ç©ºé—´å¤æ‚åº¦**ï¼šO(n)
  - å­˜å‚¨ç‚¹é›†ï¼šO(n)
  - é€’å½’è°ƒç”¨æ ˆï¼šO(log n)
  - ä¸´æ—¶æ•°ç»„ï¼šO(n)

## ğŸ” åº”ç”¨åœºæ™¯
- åœ°ç†ä¿¡æ¯ç³»ç»Ÿï¼ˆGISï¼‰ä¸­çš„ç©ºé—´åˆ†æ
- è®¡ç®—æœºå›¾å½¢å­¦ä¸­çš„ç¢°æ’æ£€æµ‹
- æ— çº¿ä¼ æ„Ÿå™¨ç½‘ç»œä¸­çš„èŠ‚ç‚¹é€šä¿¡ä¼˜åŒ–
- æœºå™¨å­¦ä¹ ä¸­çš„èšç±»ç®—æ³•ï¼ˆDBSCANç­‰ï¼‰
- èˆªç©ºç®¡åˆ¶ç³»ç»Ÿä¸­çš„å†²çªæ£€æµ‹
- åˆ†å­å»ºæ¨¡ä¸­çš„åŸå­è·ç¦»è®¡ç®—
- æœºå™¨äººè·¯å¾„è§„åˆ’

## âš ï¸ æ³¨æ„äº‹é¡¹
1. **æ•°å€¼ç²¾åº¦**ï¼šæµ®ç‚¹æ•°è®¡ç®—å¯èƒ½å¼•å…¥è¯¯å·®ï¼Œå¯ä½¿ç”¨è·ç¦»å¹³æ–¹æ¯”è¾ƒé¿å…å¼€æ–¹
2. **é€€åŒ–æƒ…å†µ**ï¼šå¤„ç†æ‰€æœ‰ç‚¹å…±çº¿æˆ–å­˜åœ¨é‡å¤ç‚¹çš„æƒ…å†µ
3. **æ’åºç¨³å®šæ€§**ï¼šç¡®ä¿æ’åºç®—æ³•çš„ç¨³å®šæ€§ä»¥ä¿è¯ç»“æœä¸€è‡´æ€§
4. **è¾¹ç•Œå¤„ç†**ï¼šæ­£ç¡®å¤„ç†é€’å½’ç»ˆæ­¢æ¡ä»¶å’Œå¸¦çŠ¶åŒºåŸŸå®½åº¦
5. **é«˜ç»´æ‰©å±•**ï¼šæœ¬ç®—æ³•ä¸»è¦é€‚ç”¨äºäºŒç»´ç©ºé—´ï¼Œé«˜ç»´ç©ºé—´éœ€ä½¿ç”¨å…¶ä»–æ–¹æ³•

## ğŸ’¡ æœ€ä½³å®è·µ
- ä½¿ç”¨è·ç¦»å¹³æ–¹æ¯”è¾ƒä»£æ›¿å®é™…è·ç¦»ï¼Œæé«˜æ€§èƒ½
- é¢„æ’åºç‚¹é›†ä»¥é¿å…é‡å¤æ’åº
- å®ç°å¹¶è¡Œåˆ†æ²»ä»¥å¤„ç†å¤§è§„æ¨¡ç‚¹é›†
- ç»“åˆç©ºé—´ç´¢å¼•ç»“æ„ï¼ˆå¦‚KDæ ‘ï¼‰ä¼˜åŒ–æŸ¥è¯¢æ•ˆç‡
- ä½¿ç”¨è¿‘ä¼¼ç®—æ³•å¤„ç†è¶…é«˜ç»´æ•°æ®
- å¯¹è¾“å…¥ç‚¹è¿›è¡Œé¢„å¤„ç†ï¼Œå»é™¤é‡å¤ç‚¹
- é‡‡ç”¨å¢é‡ç®—æ³•å¤„ç†åŠ¨æ€ç‚¹é›†

## ğŸ“š ç»å…¸é¢˜ç›®
- [LeetCode 973. æœ€æ¥è¿‘åŸç‚¹çš„ K ä¸ªç‚¹](https://leetcode-cn.com/problems/k-closest-points-to-origin/)
- [LeetCode 463. å²›å±¿çš„å‘¨é•¿](https://leetcode-cn.com/problems/island-perimeter/)
- [LeetCode 149. ç›´çº¿ä¸Šæœ€å¤šçš„ç‚¹æ•°](https://leetcode-cn.com/problems/max-points-on-a-line/)

---
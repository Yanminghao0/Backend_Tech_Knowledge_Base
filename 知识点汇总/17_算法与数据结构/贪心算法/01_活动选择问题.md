# 活动选择问题

> 活动选择问题是贪心算法的经典应用，用于在多个互相竞争的活动中选择最大数量的互不重叠活动。该问题展示了贪心算法的核心思想：通过局部最优选择达到全局最优解。

---

## 📋 基本信息

| 项目                | 说明                                                                 |
|---------------------|----------------------------------------------------------------------|
| **问题类型**        | 组合优化问题                                                         |
| **核心思想**        | 每次选择结束时间最早的活动，以最大化剩余时间可安排的活动数量         |
| **贪心策略**        | 选择最早结束的活动，递归选择后续兼容活动                             |
| **时间复杂度**      | O(n log n)（排序阶段），O(n)（选择阶段）                            |
| **空间复杂度**      | O(1)（原地选择）或 O(n)（存储结果）                                 |
| **适用场景**        | 调度安排、资源分配、任务规划等需要最大化非冲突项目数量的场景         |
| **关键特点**        | 具有最优子结构和贪心选择性质，可证明贪心策略能得到全局最优解         |

## 🎯 问题分析

### 问题描述
假设有n个活动，每个活动都有一个开始时间s[i]和结束时间f[i]，且s[i] < f[i]。如果两个活动的时间区间不重叠，则称它们是兼容的。活动选择问题就是要找出最大的兼容活动子集。

### 问题示例
考虑以下活动集合：

| 活动 | 开始时间 | 结束时间 |
|------|----------|----------|
| A1   | 1        | 4        |
| A2   | 3        | 5        |
| A3   | 0        | 6        |
| A4   | 5        | 7        |
| A5   | 3        | 9        |
| A6   | 5        | 9        |
| A7   | 6        | 10       |
| A8   | 8        | 11       |
| A9   | 8        | 12       |
| A10  | 2        | 14       |
| A11  | 12       | 16       |

最优解为{A1, A4, A8, A11}，共4个活动。

### 贪心选择性质证明
活动选择问题具有贪心选择性质：
1. 设S是活动集合，a是S中结束时间最早的活动
2. 则存在S的某个最优解包含活动a
3. 选择a后，剩余问题简化为选择与a兼容的活动

## 💻 代码实现

### 1. 排序+迭代实现
```python
def activity_selection(start, end):
    # 将活动按结束时间排序
    activities = sorted(zip(start, end), key=lambda x: x[1])
    selected = []
    last_end = -float('inf')
    
    for s, e in activities:
        if s >= last_end:
            selected.append((s, e))
            last_end = e
    
    return selected

# 示例使用
start_times = [1, 3, 0, 5, 3, 5, 6, 8, 8, 2, 12]
end_times = [4, 5, 6, 7, 9, 9, 10, 11, 12, 14, 16]
selected_activities = activity_selection(start_times, end_times)
print(f"选择的活动数量: {len(selected_activities)}")
print(f"选择的活动: {selected_activities}")
```

### 2. 递归实现
```python
def recursive_activity_selector(start, end, index, n, selected):
    # 找到第一个与前一个活动兼容的活动
    m = index + 1
    while m < n and start[m] < end[index]:
        m += 1
    
    if m < n:
        selected.append(m)
        return recursive_activity_selector(start, end, m, n, selected)
    else:
        return selected

# 示例使用
start_times = [1, 3, 0, 5, 3, 5, 6, 8, 8, 2, 12]
end_times = [4, 5, 6, 7, 9, 9, 10, 11, 12, 14, 16]
# 按结束时间排序
activities = sorted(zip(start_times, end_times), key=lambda x: x[1])
start_sorted = [x[0] for x in activities]
end_sorted = [x[1] for x in activities]
selected_indices = []
# 从-1开始（表示前一个活动结束时间为负无穷）
recursive_activity_selector(start_sorted, end_sorted, -1, len(activities), selected_indices)
selected_activities = [(start_sorted[i], end_sorted[i]) for i in selected_indices]
print(f"选择的活动数量: {len(selected_activities)}")
print(f"选择的活动: {selected_activities}")
```

### 3. 带权重的活动选择
```python
def weighted_activity_selection(start, end, weight):
    n = len(start)
    # 创建活动元组并排序
    activities = sorted(zip(start, end, weight), key=lambda x: x[1])
    start = [x[0] for x in activities]
    end = [x[1] for x in activities]
    weight = [x[2] for x in activities]
    
    # dp[i]表示前i个活动的最大权重和
    dp = [0] * n
    dp[0] = weight[0]
    
    for i in range(1, n):
        # 找到最后一个与当前活动兼容的活动
        low, high = 0, i - 1
        last_compatible = -1
        while low <= high:
            mid = (low + high) // 2
            if end[mid] <= start[i]:
                last_compatible = mid
                low = mid + 1
            else:
                high = mid - 1
        
        # 选择当前活动或不选择
        if last_compatible != -1:
            dp[i] = max(dp[i-1], weight[i] + dp[last_compatible])
        else:
            dp[i] = max(dp[i-1], weight[i])
    
    return dp[-1]

# 示例使用
start = [1, 3, 0, 5, 3, 5, 6, 8, 8, 2, 12]
end = [4, 5, 6, 7, 9, 9, 10, 11, 12, 14, 16]
weight = [3, 2, 4, 1, 5, 6, 2, 7, 3, 4, 2]
max_weight = weighted_activity_selection(start, end, weight)
print(f"最大权重和: {max_weight}")
```

## 📊 贪心策略分析

### 为什么贪心选择有效？
活动选择问题满足两个关键性质：
1. **贪心选择性质**：局部最优选择导致全局最优解
2. **最优子结构**：问题的最优解包含子问题的最优解

证明：假设A是活动集合S的最优解，a是S中结束时间最早的活动。如果A包含a，则A={a}∪A'，其中A'是S中与a兼容的活动的最优解。如果A不包含a，设a'是A中第一个结束的活动，由于a的结束时间早于a'，用a替换a'得到的解A''={a}∪(A'-{a'})也是最优解，且包含a。因此，总存在包含最早结束活动的最优解。

### 不同贪心策略对比

| 贪心策略                | 描述                                 | 是否能得到最优解 | 适用场景                     |
|-------------------------|--------------------------------------|------------------|------------------------------|
| 最早结束时间优先        | 选择最早结束的活动                   | 是               | 标准活动选择问题             |
| 最早开始时间优先        | 选择最早开始的活动                   | 否               | 特殊场景                     |
| 最短持续时间优先        | 选择持续时间最短的活动               | 否               | 时间资源受限场景             |
| 最多兼容活动优先        | 选择能兼容最多其他活动的活动         | 否               | 复杂调度问题                 |

## 🔍 应用场景

### 资源调度
- **会议室安排**：最大化会议室利用率
- **课程表设计**：安排最多课程而不冲突
- **任务调度**：单处理器执行最多任务

### 时间管理
- **日程规划**：个人日程安排，最大化完成事项数量
- **项目排期**：在有限时间内安排最多项目阶段

### 网络通信
- **数据传输调度**：最大化信道利用率
- **无线频谱分配**：避免信号干扰的前提下最大化使用效率

### 交通管理
- **航班调度**：机场跑道使用安排
- **列车时刻表**：单轨道多列车调度

## ⚠️ 注意事项

1. **输入数据要求**：
   - 活动时间必须是数值型，且开始时间小于结束时间
   - 实际应用中需考虑时间表示方式（绝对时间/相对时间）
   - 需注意时区和时间格式转换问题

2. **边界情况处理**：
   - 无活动可选择时返回空集
   - 所有活动都冲突时选择持续时间最短的活动
   - 活动开始和结束时间相同的特殊情况

3. **算法局限性**：
   - 标准算法仅适用于单资源调度
   - 无法直接处理带权重的活动选择（需动态规划）
   - 当活动具有依赖关系时不适用

4. **实现注意点**：
   - 必须先对活动按结束时间排序
   - 递归实现可能在大规模数据时导致栈溢出
   - 注意区分0-based和1-based索引

## 🎓 最佳实践

### 实现技巧
```python
# 高效实现：一次排序+线性扫描
def optimal_activity_selection(activities):
    # 按结束时间排序
    activities.sort(key=lambda x: x[1])
    selected = [activities[0]]
    
    for act in activities[1:]:
        # 如果当前活动开始时间 >= 最后选择活动的结束时间
        if act[0] >= selected[-1][1]:
            selected.append(act)
    
    return selected

# 使用示例
activities = [(1,4), (3,5), (0,6), (5,7), (3,9), (5,9), (6,10), (8,11), (8,12), (2,14), (12,16)]
print(optimal_activity_selection(activities))
```

### 扩展应用
1. **多资源活动选择**：
   当有k个资源可用时，可维护k个最后结束时间，每次选择最早结束的资源分配新活动

2. **区间图着色**：
   将活动选择问题扩展为区间着色问题，最少颜色数等于最大重叠活动数

3. **在线活动选择**：
   对于动态到达的活动，可使用贪心策略进行实时调度

### 性能优化
- **预排序优化**：如果活动需频繁查询，可预先排序并缓存结果
- **二分查找加速**：在递归实现中使用二分查找寻找兼容活动
- **空间优化**：无需存储所有活动，只需保留最后选择的活动结束时间

---

> **相关资源**：
> - [Wikipedia: Activity selection problem](https://en.wikipedia.org/wiki/Activity_selection_problem)
> - Cormen, T. H., Leiserson, C. E., Rivest, R. L., & Stein, C. (2009). Introduction to Algorithms (3rd ed.). MIT Press.
# æœ€çŸ­è·¯å¾„

> æœ€çŸ­è·¯å¾„é—®é¢˜æ˜¯å›¾è®ºä¸­çš„æ ¸å¿ƒé—®é¢˜ï¼Œæ—¨åœ¨å¯»æ‰¾å›¾ä¸­ä¸¤ä¸ªé¡¶ç‚¹ä¹‹é—´æƒå€¼ä¹‹å’Œæœ€å°çš„è·¯å¾„ã€‚Dijkstraç®—æ³•ä½œä¸ºè§£å†³å•æºæœ€çŸ­è·¯å¾„çš„ç»å…¸è´ªå¿ƒç®—æ³•ï¼Œé€šè¿‡é€æ­¥é€‰æ‹©å½“å‰æœ€çŸ­è·¯å¾„é¡¶ç‚¹æ¥æ„å»ºå…¨å±€æœ€ä¼˜è§£ï¼Œå±•ç°äº†è´ªå¿ƒç­–ç•¥åœ¨ä¼˜åŒ–é—®é¢˜ä¸­çš„é«˜æ•ˆåº”ç”¨ã€‚

---

## ğŸ“‹ åŸºæœ¬ä¿¡æ¯

| é¡¹ç›®                | è¯´æ˜                                                                 |
|---------------------|----------------------------------------------------------------------|
| **é—®é¢˜ç±»å‹**        | å›¾è®ºä¼˜åŒ–é—®é¢˜                                                         |
| **æ ¸å¿ƒæ€æƒ³**        | ä»èµ·ç‚¹å¼€å§‹ï¼Œæ¯æ¬¡é€‰æ‹©è·ç¦»æœ€è¿‘çš„æœªè®¿é—®é¡¶ç‚¹ï¼Œæ¾å¼›å…¶é‚»æ¥é¡¶ç‚¹çš„è·ç¦»       |
| **ä¸»è¦ç®—æ³•**        | Dijkstraç®—æ³•ï¼ˆè´ªå¿ƒï¼‰ã€Bellman-Fordç®—æ³•ï¼ˆåŠ¨æ€è§„åˆ’ï¼‰ã€Floyd-Warshallç®—æ³•ï¼ˆåŠ¨æ€è§„åˆ’ï¼‰ |
| **æ—¶é—´å¤æ‚åº¦**      | Dijkstra: O(E log V)ï¼ŒBellman-Ford: O(VE)ï¼ŒFloyd-Warshall: O(VÂ³)     |
| **ç©ºé—´å¤æ‚åº¦**      | O(VÂ²)ï¼ˆé‚»æ¥çŸ©é˜µï¼‰æˆ–O(V+E)ï¼ˆé‚»æ¥è¡¨ï¼‰                                 |
| **é€‚ç”¨åœºæ™¯**        | å¯¼èˆªç³»ç»Ÿã€ç½‘ç»œè·¯ç”±ã€ç‰©æµè§„åˆ’ã€æ¸¸æˆè·¯å¾„å¯»è·¯ç­‰                         |
| **å…³é”®ç‰¹ç‚¹**        | Dijkstraç®—æ³•è¦æ±‚è¾¹æƒéè´Ÿï¼›å¯å¤„ç†å•æºæˆ–å¤šæºæœ€çŸ­è·¯å¾„é—®é¢˜               |

## ğŸ¯ é—®é¢˜åˆ†æ

### é—®é¢˜å®šä¹‰
æœ€çŸ­è·¯å¾„é—®é¢˜æ—¨åœ¨æ‰¾åˆ°å›¾ä¸­ä¸¤ä¸ªé¡¶ç‚¹ä¹‹é—´æ€»æƒå€¼æœ€å°çš„è·¯å¾„ã€‚æ ¹æ®é—®é¢˜èŒƒå›´å¯åˆ†ä¸ºï¼š
- **å•æºæœ€çŸ­è·¯å¾„**ï¼šä»ä¸€ä¸ªå›ºå®šèµ·ç‚¹åˆ°æ‰€æœ‰å…¶ä»–é¡¶ç‚¹çš„æœ€çŸ­è·¯å¾„ï¼ˆDijkstraã€Bellman-Fordç®—æ³•ï¼‰
- **å¤šæºæœ€çŸ­è·¯å¾„**ï¼šæ‰¾åˆ°æ‰€æœ‰é¡¶ç‚¹å¯¹ä¹‹é—´çš„æœ€çŸ­è·¯å¾„ï¼ˆFloyd-Warshallç®—æ³•ï¼‰
- **å•ç›®æ ‡æœ€çŸ­è·¯å¾„**ï¼šä»æ‰€æœ‰é¡¶ç‚¹åˆ°ä¸€ä¸ªå›ºå®šç»ˆç‚¹çš„æœ€çŸ­è·¯å¾„
- **æ‰€æœ‰é¡¶ç‚¹å¯¹æœ€çŸ­è·¯å¾„**ï¼šè®¡ç®—å›¾ä¸­æ¯å¯¹é¡¶ç‚¹ä¹‹é—´çš„æœ€çŸ­è·¯å¾„

### åŸºæœ¬æ¦‚å¿µ
- **è·¯å¾„æƒå€¼**ï¼šè·¯å¾„ä¸­æ‰€æœ‰è¾¹çš„æƒå€¼ä¹‹å’Œ
- **æ¾å¼›æ“ä½œ**ï¼šå¯¹äºé¡¶ç‚¹uå’Œvï¼Œå¦‚æœé€šè¿‡uåˆ°è¾¾vçš„è·¯å¾„æ¯”å½“å‰å·²çŸ¥è·¯å¾„æ›´çŸ­ï¼Œåˆ™æ›´æ–°vçš„æœ€çŸ­è·ç¦»
- **å‰é©±èŠ‚ç‚¹**ï¼šè®°å½•æœ€çŸ­è·¯å¾„ä¸­æ¯ä¸ªé¡¶ç‚¹çš„å‰ä¸€ä¸ªé¡¶ç‚¹ï¼Œç”¨äºé‡æ„è·¯å¾„
- **è´Ÿæƒè¾¹**ï¼šæƒå€¼ä¸ºè´Ÿçš„è¾¹ï¼Œå¯èƒ½å¯¼è‡´æŸäº›ç®—æ³•å¤±æ•ˆæˆ–éœ€è¦ç‰¹æ®Šå¤„ç†
- **è´Ÿæƒç¯**ï¼šæƒå€¼ä¹‹å’Œä¸ºè´Ÿçš„ç¯ï¼Œä¼šä½¿æœ€çŸ­è·¯å¾„æ— å®šä¹‰ï¼ˆå¯æ— é™ç¼©çŸ­ï¼‰

### é—®é¢˜ç¤ºä¾‹
è€ƒè™‘ä»¥ä¸‹å¸¦æƒæœ‰å‘å›¾ï¼š
```
    1    4
A ----> B ----> C
|        ^
|        |
|  2     | 1
v        |
D ----> E
    5
```
ä»Aåˆ°Cçš„æœ€çŸ­è·¯å¾„æ˜¯Aâ†’Dâ†’Eâ†’Bâ†’Cï¼Œæ€»æƒå€¼ä¸º1+5+1+4=11ã€‚

### è´ªå¿ƒç­–ç•¥è¯æ˜
Dijkstraç®—æ³•åŸºäºä»¥ä¸‹æ€§è´¨ï¼šè‹¥uæ˜¯å½“å‰é€‰æ‹©çš„æœ€çŸ­è·¯å¾„é¡¶ç‚¹ï¼Œåˆ™ä»èµ·ç‚¹åˆ°uçš„æœ€çŸ­è·¯å¾„å·²ç»ç¡®å®šã€‚è¯æ˜å¦‚ä¸‹ï¼š
å‡è®¾å­˜åœ¨ä¸€æ¡ä»èµ·ç‚¹såˆ°uçš„æ›´çŸ­è·¯å¾„sâ†’...â†’vâ†’uï¼Œå…¶ä¸­væ˜¯æœªè®¿é—®é¡¶ç‚¹ã€‚ç”±äºvæœªè¢«è®¿é—®ä¸”è·¯å¾„sâ†’...â†’vçš„æƒå€¼å°äºsâ†’...â†’uï¼Œç®—æ³•åº”å…ˆé€‰æ‹©vè€Œéuï¼Œä¸å‡è®¾çŸ›ç›¾ã€‚å› æ­¤ï¼ŒDijkstraç®—æ³•çš„è´ªå¿ƒé€‰æ‹©æ˜¯æ­£ç¡®çš„ã€‚

## ğŸ’» ä»£ç å®ç°

### 1. Dijkstraç®—æ³•ï¼ˆåŸºäºä¼˜å…ˆé˜Ÿåˆ—ï¼‰
```python
import heapq

def dijkstra(graph, start):
    """
    Dijkstraç®—æ³•å®ç°å•æºæœ€çŸ­è·¯å¾„
    graph: å›¾çš„é‚»æ¥è¡¨è¡¨ç¤º {é¡¶ç‚¹: [(é‚»æ¥é¡¶ç‚¹, æƒå€¼), ...]}
    start: èµ·å§‹é¡¶ç‚¹
    è¿”å›: (æœ€çŸ­è·ç¦»å­—å…¸, å‰é©±èŠ‚ç‚¹å­—å…¸)
    """
    # åˆå§‹åŒ–è·ç¦»å’Œå‰é©±
    distances = {vertex: float('infinity') for vertex in graph}
    distances[start] = 0
    predecessors = {vertex: None for vertex in graph}
    
    # ä¼˜å…ˆé˜Ÿåˆ— (è·ç¦», é¡¶ç‚¹)
    priority_queue = [(0, start)]
    visited = set()
    
    while priority_queue:
        current_distance, current_vertex = heapq.heappop(priority_queue)
        
        # å¦‚æœå·²å¤„ç†ï¼Œè·³è¿‡
        if current_vertex in visited:
            continue
        visited.add(current_vertex)
        
        # å¦‚æœå½“å‰è·ç¦»å¤§äºå·²çŸ¥æœ€çŸ­è·ç¦»ï¼Œè·³è¿‡
        if current_distance > distances[current_vertex]:
            continue
        
        # æ¾å¼›æ“ä½œ
        for neighbor, weight in graph[current_vertex]:
            distance = current_distance + weight
            
            # å¦‚æœæ‰¾åˆ°æ›´çŸ­è·¯å¾„
            if distance < distances[neighbor]:
                distances[neighbor] = distance
                predecessors[neighbor] = current_vertex
                heapq.heappush(priority_queue, (distance, neighbor))
    
    return distances, predecessors

# é‡æ„è·¯å¾„
def reconstruct_path(predecessors, start, end):
    path = []
    current = end
    while current is not None:
        path.append(current)
        current = predecessors[current]
    path.reverse()
    return path if path[0] == start else []

# ç¤ºä¾‹ä½¿ç”¨
if __name__ == "__main__":
    # å›¾çš„é‚»æ¥è¡¨è¡¨ç¤º
    graph = {
        'A': [('B', 1), ('D', 2)],
        'B': [('C', 4)],
        'C': [],
        'D': [('E', 5)],
        'E': [('B', 1)]
    }
    distances, predecessors = dijkstra(graph, 'A')
    print(f"æœ€çŸ­è·ç¦»: {distances}")
    print(f"ä»Aåˆ°Cçš„è·¯å¾„: {reconstruct_path(predecessors, 'A', 'C')}")
```

### 2. Dijkstraç®—æ³•ï¼ˆåŸºäºé‚»æ¥çŸ©é˜µï¼‰
```python
def dijkstra_matrix(matrix, start):
    """
    åŸºäºé‚»æ¥çŸ©é˜µçš„Dijkstraç®—æ³•å®ç°
    matrix: é‚»æ¥çŸ©é˜µï¼Œmatrix[i][j]è¡¨ç¤ºé¡¶ç‚¹iåˆ°jçš„æƒå€¼ï¼Œ0è¡¨ç¤ºæ— ç›´æ¥è¿æ¥
    start: èµ·å§‹é¡¶ç‚¹ç´¢å¼•
    è¿”å›: (æœ€çŸ­è·ç¦»æ•°ç»„, å‰é©±èŠ‚ç‚¹æ•°ç»„)
    """
    n = len(matrix)
    INF = float('infinity')
    distances = [INF] * n
    distances[start] = 0
    predecessors = [-1] * n
    visited = [False] * n
    
    for _ in range(n):
        # æ‰¾åˆ°æœªè®¿é—®çš„æœ€å°è·ç¦»é¡¶ç‚¹
        min_dist = INF
        u = -1
        for i in range(n):
            if not visited[i] and distances[i] < min_dist:
                min_dist = distances[i]
                u = i
        
        if u == -1:  # å›¾ä¸è¿é€š
            break
        
        visited[u] = True
        
        # æ¾å¼›æ“ä½œ
        for v in range(n):
            # å­˜åœ¨è¾¹u->vä¸”væœªè®¿é—®
            if matrix[u][v] > 0 and not visited[v] and distances[v] > distances[u] + matrix[u][v]:
                distances[v] = distances[u] + matrix[u][v]
                predecessors[v] = u
    
    return distances, predecessors

# ç¤ºä¾‹ä½¿ç”¨
if __name__ == "__main__":
    # é‚»æ¥çŸ©é˜µè¡¨ç¤º (0è¡¨ç¤ºæ— è¿æ¥)
    matrix = [
        [0, 1, 0, 2, 0],  # A(0)åˆ°å„é¡¶ç‚¹çš„æƒå€¼
        [0, 0, 4, 0, 0],  # B(1)åˆ°å„é¡¶ç‚¹çš„æƒå€¼
        [0, 0, 0, 0, 0],  # C(2)åˆ°å„é¡¶ç‚¹çš„æƒå€¼
        [0, 0, 0, 0, 5],  # D(3)åˆ°å„é¡¶ç‚¹çš„æƒå€¼
        [0, 1, 0, 0, 0]   # E(4)åˆ°å„é¡¶ç‚¹çš„æƒå€¼
    ]
    distances, predecessors = dijkstra_matrix(matrix, 0)  # ä»A(0)å¼€å§‹
    print(f"æœ€çŸ­è·ç¦»æ•°ç»„: {distances}")
```

### 3. å…¶ä»–æœ€çŸ­è·¯å¾„ç®—æ³•å®ç°

#### Bellman-Fordç®—æ³•ï¼ˆå¤„ç†è´Ÿæƒè¾¹ï¼‰
```python
def bellman_ford(graph, start):
    """
    Bellman-Fordç®—æ³•å®ç°å•æºæœ€çŸ­è·¯å¾„ï¼Œå¯å¤„ç†è´Ÿæƒè¾¹
    graph: å›¾çš„è¾¹åˆ—è¡¨è¡¨ç¤º [(u, v, weight), ...]
    start: èµ·å§‹é¡¶ç‚¹
    è¿”å›: (æœ€çŸ­è·ç¦»å­—å…¸, å‰é©±èŠ‚ç‚¹å­—å…¸, æ˜¯å¦å­˜åœ¨è´Ÿæƒç¯)
    """
    vertices = set()
    for u, v, _ in graph:
        vertices.add(u)
        vertices.add(v)
    vertices = list(vertices)
    
    distances = {v: float('infinity') for v in vertices}
    distances[start] = 0
    predecessors = {v: None for v in vertices}
    
    # æ¾å¼›æ‰€æœ‰è¾¹n-1æ¬¡
    for _ in range(len(vertices) - 1):
        updated = False
        for u, v, weight in graph:
            if distances[u] != float('infinity') and distances[v] > distances[u] + weight:
                distances[v] = distances[u] + weight
                predecessors[v] = u
                updated = True
        if not updated:
            break
    
    # æ£€æµ‹è´Ÿæƒç¯
    has_negative_cycle = False
    for u, v, weight in graph:
        if distances[u] != float('infinity') and distances[v] > distances[u] + weight:
            has_negative_cycle = True
            break
    
    return distances, predecessors, has_negative_cycle
```

#### Floyd-Warshallç®—æ³•ï¼ˆå¤šæºæœ€çŸ­è·¯å¾„ï¼‰
```python
def floyd_warshall(matrix):
    """
    Floyd-Warshallç®—æ³•å®ç°å¤šæºæœ€çŸ­è·¯å¾„
    matrix: é‚»æ¥çŸ©é˜µï¼Œmatrix[i][j]è¡¨ç¤ºé¡¶ç‚¹iåˆ°jçš„æƒå€¼
    è¿”å›: æœ€çŸ­è·ç¦»çŸ©é˜µ
    """
    n = len(matrix)
    # åˆå§‹åŒ–è·ç¦»çŸ©é˜µ
    dist = [row[:] for row in matrix]
    
    # é€šè¿‡ä¸­é—´é¡¶ç‚¹kæ›´æ–°è·ç¦»
    for k in range(n):
        for i in range(n):
            for j in range(n):
                if dist[i][j] > dist[i][k] + dist[k][j]:
                    dist[i][j] = dist[i][k] + dist[k][j]
    
    return dist
```

## ğŸ“Š è´ªå¿ƒç­–ç•¥åˆ†æ

### Dijkstraç®—æ³•çš„è´ªå¿ƒé€‰æ‹©
Dijkstraç®—æ³•é€šè¿‡ä»¥ä¸‹æ­¥éª¤å®ç°è´ªå¿ƒé€‰æ‹©ï¼š
1. ç»´æŠ¤ä¸€ä¸ªä¼˜å…ˆé˜Ÿåˆ—ï¼Œå­˜å‚¨å¾…å¤„ç†çš„é¡¶ç‚¹åŠå…¶å½“å‰æœ€çŸ­è·ç¦»
2. æ¯æ¬¡é€‰æ‹©é˜Ÿåˆ—ä¸­è·ç¦»æœ€å°çš„é¡¶ç‚¹u
3. å¯¹uçš„æ‰€æœ‰é‚»æ¥é¡¶ç‚¹væ‰§è¡Œæ¾å¼›æ“ä½œï¼šè‹¥é€šè¿‡uåˆ°è¾¾vçš„è·¯å¾„æ›´çŸ­ï¼Œåˆ™æ›´æ–°vçš„è·ç¦»
4. å°†æ›´æ–°åçš„våŠ å…¥ä¼˜å…ˆé˜Ÿåˆ—
5. é‡å¤ç›´åˆ°æ‰€æœ‰é¡¶ç‚¹éƒ½è¢«å¤„ç†

è¿™ç§ç­–ç•¥èƒ½æ‰¾åˆ°æœ€çŸ­è·¯å¾„çš„åŸå› æ˜¯ï¼šä¸€æ—¦é¡¶ç‚¹uè¢«ä»ä¼˜å…ˆé˜Ÿåˆ—ä¸­å–å‡ºå¹¶æ ‡è®°ä¸ºå·²è®¿é—®ï¼Œå…¶æœ€çŸ­è·ç¦»å°±å·²ç¡®å®šï¼Œä¸ä¼šå†è¢«æ›´æ–°ã€‚

### ä¸åŒç®—æ³•å¯¹æ¯”

| ç®—æ³•           | è´ªå¿ƒç­–ç•¥                          | é€‚ç”¨åœºæ™¯                     | å¤„ç†è´Ÿæƒè¾¹ | æ—¶é—´å¤æ‚åº¦   | ç©ºé—´å¤æ‚åº¦ |
|----------------|-----------------------------------|------------------------------|------------|--------------|------------|
| Dijkstra       | é€‰æ‹©å½“å‰æœ€çŸ­è·ç¦»é¡¶ç‚¹             | éè´Ÿæƒå›¾ï¼Œå•æºæœ€çŸ­è·¯å¾„       | å¦         | O(E log V)   | O(V + E)   |
| Bellman-Ford   | å¤šæ¬¡æ¾å¼›æ‰€æœ‰è¾¹                   | è´Ÿæƒè¾¹å›¾ï¼Œå•æºæœ€çŸ­è·¯å¾„       | æ˜¯         | O(VE)        | O(V + E)   |
| Floyd-Warshall | åŠ¨æ€è§„åˆ’ï¼Œè€ƒè™‘ä¸­é—´é¡¶ç‚¹           | å¤šæºæœ€çŸ­è·¯å¾„                 | æ˜¯         | O(VÂ³)        | O(VÂ²)      |
| A*             | å¯å‘å¼æœç´¢ï¼Œç»“åˆç›®æ ‡ä¼°è®¡è·ç¦»     | è·¯å¾„è§„åˆ’ï¼Œæ¸¸æˆAI             | å¦         | å–å†³äºå¯å‘å‡½æ•° | O(V)       |

### å¤æ‚åº¦ä¼˜åŒ–
- **æ–æ³¢é‚£å¥‘å †ä¼˜åŒ–**ï¼šDijkstraç®—æ³•æ—¶é—´å¤æ‚åº¦å¯é™è‡³O(E + V log V)ï¼Œä½†å®ç°å¤æ‚
- **ç¨€ç–å›¾ä¼˜åŒ–**ï¼šä½¿ç”¨é‚»æ¥è¡¨è€Œéé‚»æ¥çŸ©é˜µï¼Œå‡å°‘ç©ºé—´å ç”¨
- **åŒå‘Dijkstra**ï¼šåŒæ—¶ä»èµ·ç‚¹å’Œç»ˆç‚¹æœç´¢ï¼Œåœ¨å¤§å‹å›¾ä¸­æ•ˆç‡æ›´é«˜
- **å¯å‘å¼ä¼˜åŒ–**ï¼šA*ç®—æ³•é€šè¿‡å¯å‘å‡½æ•°å¼•å¯¼æœç´¢æ–¹å‘ï¼Œé€‚åˆåœ°å›¾å¯¼èˆªç­‰åœºæ™¯

## ğŸ” åº”ç”¨åœºæ™¯

### å¯¼èˆªä¸è·¯å¾„è§„åˆ’
- **åœ°å›¾åº”ç”¨**ï¼šå¦‚Google Mapsã€é«˜å¾·åœ°å›¾çš„è·¯çº¿è§„åˆ’
- **æ¸¸æˆAI**ï¼šè§’è‰²ç§»åŠ¨è·¯å¾„è®¡ç®—ï¼Œå¦‚RTSæ¸¸æˆä¸­çš„å•ä½å¯»è·¯
- **æœºå™¨äººå¯¼èˆª**ï¼šè‡ªä¸»ç§»åŠ¨æœºå™¨äººçš„é¿éšœè·¯å¾„è§„åˆ’

### ç½‘ç»œé€šä¿¡
- **è·¯ç”±ç®—æ³•**ï¼šOSPF(Open Shortest Path First)ä½¿ç”¨Dijkstraç®—æ³•
- **æ‹¥å¡æ§åˆ¶**ï¼šç½‘ç»œæµé‡åˆ†é…ï¼Œé¿å…è·¯å¾„è¿‡è½½
- **æ•°æ®ä¼ è¾“**ï¼šå¯»æ‰¾å»¶è¿Ÿæœ€å°çš„æ•°æ®ä¼ è¾“è·¯å¾„

### èµ„æºè°ƒåº¦
- **ç‰©æµé…é€**ï¼šä¼˜åŒ–é…é€è·¯çº¿ï¼Œå‡å°‘è¿è¾“æˆæœ¬
- **ç”µç½‘è§„åˆ’**ï¼šç”µåŠ›ä¼ è¾“è·¯å¾„ä¼˜åŒ–ï¼Œå‡å°‘æŸè€—
- **ä¾›åº”é“¾ç®¡ç†**ï¼šä¼˜åŒ–ç‰©æ–™è¿è¾“è·¯å¾„ï¼Œç¼©çŸ­äº¤è´§æ—¶é—´

### å…¶ä»–é¢†åŸŸ
- **æ¸¸æˆå¼€å‘**ï¼šNPCç§»åŠ¨ã€åœ°å›¾ç”Ÿæˆ
- **äº¤é€šç®¡ç†**ï¼šäº¤é€šæµé‡ä¼˜åŒ–ï¼Œå‡å°‘æ‹¥å µ
- **é‡‘èäº¤æ˜“**ï¼šå¯»æ‰¾æœ€ä¼˜äº¤æ˜“è·¯å¾„ï¼Œé™ä½æ‰‹ç»­è´¹

## âš ï¸ æ³¨æ„äº‹é¡¹

1. **è´Ÿæƒè¾¹å¤„ç†**ï¼š
   - Dijkstraç®—æ³•**ä¸èƒ½å¤„ç†**åŒ…å«è´Ÿæƒè¾¹çš„å›¾
   - è´Ÿæƒè¾¹å¯èƒ½å¯¼è‡´å·²ç¡®å®šæœ€çŸ­è·ç¦»çš„é¡¶ç‚¹éœ€è¦é‡æ–°æ›´æ–°
   - å­˜åœ¨è´Ÿæƒè¾¹æ—¶åº”ä½¿ç”¨Bellman-Fordæˆ–Floyd-Warshallç®—æ³•
   - æ£€æµ‹è´Ÿæƒç¯ï¼šBellman-Fordå¯é€šè¿‡ç¬¬næ¬¡æ¾å¼›æ£€æµ‹æ˜¯å¦å­˜åœ¨è´Ÿæƒç¯

2. **å›¾çš„è¡¨ç¤ºæ–¹å¼**ï¼š
   - ç¨ å¯†å›¾é€‚åˆç”¨é‚»æ¥çŸ©é˜µï¼ˆO(VÂ²)ç©ºé—´ï¼‰
   - ç¨€ç–å›¾é€‚åˆç”¨é‚»æ¥è¡¨ï¼ˆO(V + E)ç©ºé—´ï¼‰
   - å¤§å‹å›¾éœ€è€ƒè™‘å†…å­˜é™åˆ¶ï¼Œå¯èƒ½éœ€è¦å¤–å­˜å­˜å‚¨

3. **è¾¹ç•Œæƒ…å†µå¤„ç†**ï¼š
   - èµ·ç‚¹ä¸å¯è¾¾çš„é¡¶ç‚¹ï¼šè·ç¦»ä¿æŒä¸ºæ— ç©·å¤§
   - å­¤ç«‹é¡¶ç‚¹ï¼šè·ç¦»ä¸º0ï¼ˆåˆ°è‡ªèº«ï¼‰ï¼Œå…¶ä»–é¡¶ç‚¹ä¸å¯è¾¾
   - æœ‰å‘å›¾ä¸æ— å‘å›¾ï¼šæ— å‘å›¾æ¯æ¡è¾¹éœ€åœ¨é‚»æ¥è¡¨ä¸­æ·»åŠ ä¸¤æ¬¡

4. **æ•°å€¼ç²¾åº¦é—®é¢˜**ï¼š
   - ä½¿ç”¨æµ®ç‚¹æ•°æƒå€¼æ—¶å¯èƒ½äº§ç”Ÿç²¾åº¦è¯¯å·®
   - å»ºè®®åœ¨æ¯”è¾ƒè·ç¦»æ—¶ä½¿ç”¨é€‚å½“çš„epsilonå€¼
   - æ•´æ•°æƒå€¼ä¼˜å…ˆä½¿ç”¨æ•´æ•°è¿ç®—

## ğŸ“ æœ€ä½³å®è·µ

### ç®—æ³•é€‰æ‹©æŒ‡å—
```python
# æ ¹æ®å›¾çš„ç‰¹æ€§é€‰æ‹©åˆé€‚ç®—æ³•
def choose_shortest_path_algorithm(graph, has_negative_weights, multi_source=False):
    if multi_source:
        return "Floyd-Warshall"
    elif has_negative_weights:
        return "Bellman-Ford"
    else:
        # åˆ¤æ–­å›¾çš„ç¨ å¯†ç¨‹åº¦
        num_vertices = len(graph)
        num_edges = sum(len(neighbors) for neighbors in graph.values())
        if num_edges > num_vertices * (num_vertices - 1) / 4:
            return "Dijkstra (matrix)"
        else:
            return "Dijkstra (priority queue)"
```

### å®ç°ä¼˜åŒ–æŠ€å·§
1. **ä¼˜å…ˆé˜Ÿåˆ—ä¼˜åŒ–**ï¼š
   ```python
   # ä½¿ç”¨heapqçš„é«˜æ•ˆå®ç°
   def optimized_dijkstra(graph, start):
       distances = {v: float('inf') for v in graph}
       distances[start] = 0
       heap = [(0, start)]
       
       while heap:
           d, u = heapq.heappop(heap)
           if d > distances[u]:
               continue
           for v, w in graph[u]:
               if distances[v] > d + w:
                   distances[v] = d + w
                   heapq.heappush(heap, (distances[v], v))
       return distances
   ```

2. **è·¯å¾„é‡æ„ä¼˜åŒ–**ï¼š
   ```python
   # å­˜å‚¨å®Œæ•´è·¯å¾„è€Œéä»…å‰é©±èŠ‚ç‚¹
   def dijkstra_with_path(graph, start):
       # å®ç°ç•¥ï¼Œåœ¨æ¾å¼›æ—¶åŒæ—¶è®°å½•è·¯å¾„
       pass
   ```

3. **å¤§å‹å›¾å¤„ç†**ï¼š
   ```python
   # åˆ†å—å¤„ç†æˆ–ä½¿ç”¨è¿‘ä¼¼ç®—æ³•
   def approximate_shortest_path(graph, start, end, epsilon=0.1):
       # å®ç°å¯å‘å¼è¿‘ä¼¼ç®—æ³•
       pass
   ```

### å¸¸è§é—®é¢˜è§£å†³æ–¹æ¡ˆ
1. **å¤„ç†è´Ÿæƒè¾¹**ï¼š
   ```python
   def handle_negative_weights(graph, start):
       # ä½¿ç”¨Bellman-Fordç®—æ³•
       distances, predecessors, has_cycle = bellman_ford(graph, start)
       if has_cycle:
           raise ValueError("å›¾ä¸­å­˜åœ¨è´Ÿæƒç¯ï¼Œæ— æ³•è®¡ç®—æœ€çŸ­è·¯å¾„")
       return distances, predecessors
   ```

2. **é™åˆ¶è·¯å¾„é•¿åº¦**ï¼š
   ```python
   def shortest_path_with_constraint(graph, start, end, max_length):
       # å¸¦è·¯å¾„é•¿åº¦çº¦æŸçš„æœ€çŸ­è·¯å¾„
       pass
   ```

3. **å¤šç›®æ ‡ä¼˜åŒ–**ï¼š
   ```python
   def multi_criteria_shortest_path(graph, start, end):
       # åŒæ—¶è€ƒè™‘è·ç¦»ã€æ—¶é—´ã€æˆæœ¬ç­‰å¤šä¸ªç›®æ ‡
       pass
   ```

---

> **ç›¸å…³èµ„æº**ï¼š
> - [Wikipedia: Dijkstra's algorithm](https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm)
> - Cormen, T. H., Leiserson, C. E., Rivest, R. L., & Stein, C. (2009). Introduction to Algorithms (3rd ed.). MIT Press.
> - Dijkstra, E. W. (1959). A note on two problems in connexion with graphs. Numerische Mathematik, 1(1), 269-271.
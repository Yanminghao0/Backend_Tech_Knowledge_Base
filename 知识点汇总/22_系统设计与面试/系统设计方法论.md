# 系统设计方法论

> 系统设计面试的通用方法和思维框架

## 📋 目录
- [系统设计四步法](#系统设计四步法)
- [需求澄清](#一需求澄清5-10分钟)
- [概要设计](#二概要设计10-15分钟)
- [详细设计](#三详细设计15-20分钟)
- [优化与扩展](#四优化与扩展5-10分钟)
- [通用设计模式](#通用设计模式)
- [常见问题与解决方案](#常见问题与解决方案)

---

## 系统设计四步法

### 时间分配（45分钟面试）
```
第一步：需求澄清      5-10分钟  ⭐⭐⭐⭐⭐
第二步：概要设计     10-15分钟  ⭐⭐⭐⭐⭐
第三步：详细设计     15-20分钟  ⭐⭐⭐⭐
第四步：优化与扩展    5-10分钟  ⭐⭐⭐
```

### 核心原则
1. **先问后答**：不要急于设计，先澄清需求
2. **由简到繁**：先实现基本功能，再逐步优化
3. **边画边说**：用图表辅助表达，保持沟通
4. **权衡取舍**：说明设计选择的理由和代价
5. **预判追问**：提前思考可能的追问点

---

## 一、需求澄清（5-10分钟）

### 1.1 功能需求

**必问清单**：
```
✅ 核心功能是什么？
✅ 需要支持哪些操作？
✅ 用户角色有哪些？
✅ 有哪些边界条件？
✅ 需要哪些辅助功能？
```

**示例对话**：
```
面试官：设计一个短链接系统
候选人：
  - 核心功能是生成短链接和跳转吗？
  - 需要支持自定义短链接吗？
  - 需要统计点击数据吗？
  - 短链接是否有过期时间？
  - 需要支持修改和删除吗？
```

### 1.2 非功能需求

**性能要求**：
```
✅ QPS（每秒请求数）：多少？读写比例？
✅ 延迟要求：P99延迟多少毫秒？
✅ 并发量：峰值并发多少？
✅ 数据规模：存储多少数据？增长速度？
```

**可靠性要求**：
```
✅ 可用性：需要几个9？（99.9% = 3个9）
✅ 一致性：强一致还是最终一致？
✅ 容错性：单点故障如何处理？
✅ 数据持久性：数据丢失容忍度？
```

**可扩展性要求**：
```
✅ 用户增长预期：未来1-2年增长多少倍？
✅ 功能扩展：未来可能新增哪些功能？
✅ 地域扩展：是否需要跨地域部署？
```

### 1.3 规模估算

**用户规模估算**：
```
DAU（日活）→ QPS 计算
  假设：1亿DAU，每人每天平均10次请求
  总请求 = 1亿 × 10 = 10亿次/天
  
  QPS = 10亿 / (24 × 3600) ≈ 11,574
  峰值QPS（按3倍算）≈ 35,000
```

**存储估算**：
```
单条数据大小估算
  短链接：原始URL(200B) + 短链(10B) + 元数据(50B) = 260B
  
存储总量 = 每天新增 × 单条大小 × 保存天数
  = 100万/天 × 260B × 365天 × 5年
  ≈ 475GB × 5 = 2.4TB
```

**带宽估算**：
```
写入带宽 = 100万/天 × 260B / 86400秒 ≈ 3KB/s
读取带宽（读写比100:1）= 3KB/s × 100 = 300KB/s
峰值带宽（×3）= 900KB/s ≈ 1MB/s
```

---

## 二、概要设计（10-15分钟）

### 2.1 核心流程梳理

**用例图示例**：
```
短链接系统核心流程：

1. 用户输入长URL
2. 系统生成短链接
3. 用户访问短链接
4. 系统重定向到原始URL
5. 记录访问统计
```

### 2.2 关键组件识别

**典型系统组件**：
```
┌─────────┐
│ 客户端  │
└────┬────┘
     │
┌────▼────────────────┐
│   负载均衡器(LB)    │
└────┬────────────────┘
     │
┌────▼────────────────┐
│   API网关/反向代理  │  ← 鉴权、限流、路由
└────┬────────────────┘
     │
┌────▼────────────────┐
│   应用服务集群      │  ← 无状态、可水平扩展
└────┬────────────────┘
     │
┌────▼────────────────┐
│   缓存层(Redis)     │  ← 热点数据
└────┬────────────────┘
     │
┌────▼────────────────┐
│   数据库(MySQL)     │  ← 持久化数据
└─────────────────────┘
```

**组件职责**：
| 组件 | 职责 | 技术选型 |
|------|------|----------|
| 负载均衡 | 流量分发、健康检查 | Nginx、LVS、云LB |
| API网关 | 鉴权、限流、路由 | Kong、Spring Cloud Gateway |
| 应用层 | 业务逻辑处理 | Spring Boot微服务 |
| 缓存层 | 热点数据缓存 | Redis Cluster |
| 数据库 | 持久化存储 | MySQL主从、分库分表 |
| 消息队列 | 异步处理、削峰 | Kafka、RocketMQ |
| 对象存储 | 文件/图片存储 | OSS、S3 |

### 2.3 技术选型

**数据库选型**：
```
关系型数据库（MySQL、PostgreSQL）
  ✅ 适用：结构化数据、事务要求高、复杂查询
  ❌ 限制：水平扩展困难、写入性能瓶颈

NoSQL数据库（MongoDB、Cassandra）
  ✅ 适用：非结构化数据、高吞吐、易扩展
  ❌ 限制：事务支持弱、一致性保证弱

KV存储（Redis、Memcached）
  ✅ 适用：缓存、会话、计数器
  ❌ 限制：内存限制、持久化有限
```

**缓存选型**：
```
本地缓存（Caffeine、Guava Cache）
  ✅ 优点：速度快、无网络开销
  ❌ 缺点：数据不共享、内存受限

分布式缓存（Redis、Memcached）
  ✅ 优点：集中管理、容量大、数据共享
  ❌ 缺点：网络延迟、单点问题
```

**消息队列选型**：
```
Kafka
  ✅ 适用：高吞吐、日志收集、流处理
  ❌ 限制：延迟较高、不支持优先级

RocketMQ
  ✅ 适用：事务消息、延迟消息、顺序消息
  ❌ 限制：社区相对较小

RabbitMQ
  ✅ 适用：复杂路由、优先级队列、低延迟
  ❌ 限制：吞吐量相对较低
```

### 2.4 架构图绘制

**简化架构图（V1版本）**：
```
┌──────────┐
│  客户端  │
└─────┬────┘
      │
┌─────▼─────┐
│  服务器   │
└─────┬─────┘
      │
┌─────▼─────┐
│  数据库   │
└───────────┘
```

**优化架构图（V2版本）**：
```
          ┌──────────┐
          │  客户端  │
          └────┬─────┘
               │
      ┌────────▼────────┐
      │   负载均衡器    │
      └────────┬────────┘
               │
    ┌──────────┼──────────┐
    │          │          │
┌───▼───┐  ┌──▼───┐  ┌──▼───┐
│服务器1│  │服务器2│  │服务器3│
└───┬───┘  └──┬───┘  └──┬───┘
    │         │         │
    └─────────┼─────────┘
              │
      ┌───────▼────────┐
      │  Redis缓存     │
      └───────┬────────┘
              │
      ┌───────▼────────┐
      │  MySQL主从     │
      └────────────────┘
```

**完整架构图（V3版本）**：
```
                    ┌──────────┐
                    │   CDN    │
                    └────┬─────┘
                         │
              ┌──────────▼──────────┐
              │   负载均衡器(LB)    │
              └──────────┬──────────┘
                         │
              ┌──────────▼──────────┐
              │    API网关          │  ← 鉴权、限流
              └──────────┬──────────┘
                         │
        ┌────────────────┼────────────────┐
        │                │                │
    ┌───▼───┐        ┌──▼───┐        ┌──▼───┐
    │服务A  │        │服务B │        │服务C │
    └───┬───┘        └──┬───┘        └──┬───┘
        │               │               │
        └───────────────┼───────────────┘
                        │
         ┌──────────────┼──────────────┐
         │              │              │
    ┌────▼────┐    ┌───▼───┐    ┌────▼────┐
    │ Redis   │    │ MySQL │    │  Kafka  │
    │ Cluster │    │ 主从  │    │ 集群    │
    └─────────┘    └───────┘    └─────────┘
```

---

## 三、详细设计（15-20分钟）

### 3.1 数据模型设计

**数据库表设计原则**：
```
1. 满足业务需求
2. 适当冗余（空间换时间）
3. 考虑查询效率（添加索引）
4. 预留扩展字段
5. 考虑分库分表
```

**示例：短链接表设计**：
```sql
CREATE TABLE short_url (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    short_key VARCHAR(10) UNIQUE NOT NULL,      -- 短链接key
    original_url VARCHAR(2048) NOT NULL,        -- 原始URL
    user_id BIGINT,                             -- 创建用户
    expire_at TIMESTAMP,                        -- 过期时间
    click_count INT DEFAULT 0,                  -- 点击次数
    status TINYINT DEFAULT 1,                   -- 状态：1有效 0失效
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    
    INDEX idx_user_id (user_id),
    INDEX idx_expire_at (expire_at),
    INDEX idx_created_at (created_at)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
```

**NoSQL数据模型**：
```json
{
  "_id": "abc123",
  "short_key": "abc123",
  "original_url": "https://example.com/very/long/url",
  "user_id": 10001,
  "expire_at": 1735660800,
  "click_count": 1024,
  "status": 1,
  "created_at": 1703923200,
  "metadata": {
    "title": "Example Page",
    "description": "Description",
    "tags": ["tech", "blog"]
  }
}
```

### 3.2 接口设计

**RESTful API设计**：
```
POST   /api/v1/short-urls              # 创建短链接
GET    /api/v1/short-urls/{shortKey}   # 获取短链接详情
PUT    /api/v1/short-urls/{shortKey}   # 更新短链接
DELETE /api/v1/short-urls/{shortKey}   # 删除短链接
GET    /api/v1/short-urls              # 查询用户的短链接列表
GET    /{shortKey}                     # 短链接重定向
```

**请求响应示例**：
```json
// POST /api/v1/short-urls
// Request
{
  "original_url": "https://example.com/very/long/url",
  "expire_days": 30,
  "custom_key": "mylink"  // 可选
}

// Response
{
  "code": 0,
  "message": "success",
  "data": {
    "short_key": "abc123",
    "short_url": "https://short.ly/abc123",
    "original_url": "https://example.com/very/long/url",
    "expire_at": "2025-11-28T00:00:00Z",
    "created_at": "2025-10-29T10:00:00Z"
  }
}
```

### 3.3 核心算法

**短链接生成算法**：

**方案1：自增ID + Base62编码**
```java
// 优点：简单、唯一、递增
// 缺点：可预测、容易爬取

public String generateShortKey(long id) {
    String chars = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
    StringBuilder sb = new StringBuilder();
    while (id > 0) {
        sb.append(chars.charAt((int)(id % 62)));
        id /= 62;
    }
    return sb.reverse().toString();
}

// 示例：id=12345 → Base62 → "3d7"
```

**方案2：Hash + 冲突检测**
```java
// 优点：不可预测、分布均匀
// 缺点：可能冲突、需要检测

public String generateShortKey(String url) {
    String hash = md5(url).substring(0, 8);  // 取前8位
    String shortKey = base62Encode(hash);
    
    // 冲突检测
    while (exists(shortKey)) {
        hash = md5(hash).substring(0, 8);  // 再hash
        shortKey = base62Encode(hash);
    }
    return shortKey;
}
```

**方案3：分布式ID生成（雪花算法）**
```
推荐用于大规模分布式系统
详见：05_设计分布式ID.md
```

### 3.4 容错处理

**幂等性设计**：
```java
// 创建短链接接口幂等性
POST /api/v1/short-urls
{
  "original_url": "xxx",
  "idempotency_key": "uuid-xxx"  // 幂等键
}

// 服务端逻辑
if (cache.exists(idempotencyKey)) {
    return cache.get(idempotencyKey);  // 返回之前的结果
}
// 执行业务逻辑
result = createShortUrl(url);
cache.set(idempotencyKey, result, 24h);
return result;
```

**降级策略**：
```
级别1：关闭非核心功能（统计、推荐）
级别2：限制部分用户（新用户、普通用户）
级别3：只保留核心功能（短链接跳转）
级别4：返回静态页面（服务维护中）
```

**熔断机制**：
```java
// Hystrix/Sentinel熔断配置
@HystrixCommand(
    fallbackMethod = "getFallback",
    commandProperties = {
        @HystrixProperty(name="circuitBreaker.requestVolumeThreshold", value="10"),
        @HystrixProperty(name="circuitBreaker.errorThresholdPercentage", value="50"),
        @HystrixProperty(name="circuitBreaker.sleepWindowInMilliseconds", value="5000")
    }
)
public String getShortUrl(String key) {
    // 正常逻辑
}

public String getFallback(String key) {
    return "服务暂时不可用，请稍后重试";
}
```

**重试策略**：
```
立即重试：适用于瞬时故障（网络抖动）
延迟重试：指数退避（1s, 2s, 4s, 8s...）
限制次数：最多重试3次
重试条件：只对可重试错误重试（500、超时）
```

---

## 四、优化与扩展（5-10分钟）

### 4.1 性能优化

**缓存优化**：
```
多级缓存：
  L1: 本地缓存（Caffeine）- 10ms
  L2: Redis缓存 - 1-5ms
  L3: 数据库 - 50-100ms
  
缓存策略：
  Cache Aside：先查缓存，未命中查DB，更新缓存
  Read Through：缓存层自动加载数据
  Write Through：写缓存同时写DB
  Write Behind：异步写DB
```

**数据库优化**：
```
索引优化：
  - 为高频查询字段添加索引
  - 避免过多索引影响写入性能
  - 定期分析慢查询

读写分离：
  - 主库：写操作
  - 从库：读操作
  - 解决读多写少场景

分库分表：
  - 垂直分库：按业务拆分
  - 水平分库：按数据拆分
  - 路由策略：hash、range
```

**异步化处理**：
```
同步改异步：
  ❌ 同步：创建 → 统计 → 发通知 → 返回（耗时200ms）
  ✅ 异步：创建 → 返回（耗时50ms），统计和通知异步处理
  
技术实现：
  - 消息队列（Kafka、RocketMQ）
  - 线程池
  - CompletableFuture
```

### 4.2 可扩展性设计

**水平扩展**：
```
应用层无状态：
  ✅ Session存Redis，不存本地
  ✅ 任务幂等，可重复执行
  ✅ 配置中心统一管理

数据层可分片：
  ✅ 分库分表策略
  ✅ 数据迁移方案
  ✅ 跨分片查询方案
```

**微服务拆分**：
```
单体应用 → 微服务

拆分原则：
  - 按业务域拆分（DDD）
  - 按技术特性拆分（读写分离）
  - 按团队拆分

示例：
  - 用户服务
  - 短链接服务
  - 统计服务
  - 通知服务
```

### 4.3 监控告警

**监控指标**：
```
业务指标：
  - QPS、RT（响应时间）
  - 成功率、错误率
  - 转化率

系统指标：
  - CPU、内存、磁盘、网络
  - 连接数、线程数
  - GC频率和时间

中间件指标：
  - Redis命中率、慢查询
  - MySQL慢SQL、连接数
  - Kafka积压、消费延迟
```

**告警策略**：
```
分级告警：
  P0：核心服务不可用 → 电话 + 短信
  P1：重要功能异常 → 短信 + 企业微信
  P2：性能下降 → 企业微信
  P3：预警 → 邮件

告警收敛：
  - 5分钟内同类告警只发一次
  - 告警恢复通知
  - 告警升级机制
```

### 4.4 成本优化

**存储成本**：
```
热数据 vs 冷数据：
  - 热数据（1个月内）：Redis + MySQL
  - 温数据（1年内）：MySQL
  - 冷数据（1年外）：对象存储（OSS）

数据压缩：
  - URL压缩
  - 日志压缩
  - 定期归档
```

**计算成本**：
```
弹性伸缩：
  - 高峰期自动扩容
  - 低峰期自动缩容
  - 使用云厂商竞价实例

资源优化：
  - 代码性能优化
  - 减少不必要的计算
  - 批量处理代替实时处理
```

---

## 通用设计模式

### 1. 缓存模式

**Cache Aside（旁路缓存）**：
```java
// 读取
public Data getData(String key) {
    Data data = cache.get(key);
    if (data == null) {
        data = db.query(key);
        if (data != null) {
            cache.set(key, data, 3600);  // 1小时过期
        }
    }
    return data;
}

// 更新
public void updateData(String key, Data data) {
    db.update(key, data);
    cache.delete(key);  // 删除缓存
}
```

**缓存穿透解决**：
```java
// 布隆过滤器 + 缓存空值
public Data getData(String key) {
    // 1. 布隆过滤器快速判断
    if (!bloomFilter.exists(key)) {
        return null;
    }
    
    // 2. 查缓存
    Data data = cache.get(key);
    if (data != null) {
        return data;
    }
    
    // 3. 查数据库
    data = db.query(key);
    if (data != null) {
        cache.set(key, data, 3600);
    } else {
        cache.set(key, NULL_VALUE, 300);  // 缓存空值5分钟
    }
    return data;
}
```

### 2. 限流模式

**令牌桶算法**：
```java
public class TokenBucket {
    private long capacity;      // 桶容量
    private long rate;          // 生成速率
    private long tokens;        // 当前令牌数
    private long lastTime;      // 上次更新时间
    
    public synchronized boolean tryAcquire() {
        long now = System.currentTimeMillis();
        // 补充令牌
        tokens = Math.min(capacity, 
                         tokens + (now - lastTime) / 1000 * rate);
        lastTime = now;
        
        if (tokens > 0) {
            tokens--;
            return true;
        }
        return false;
    }
}
```

### 3. 分库分表模式

**分片策略**：
```java
// Hash分片
public int getShardId(String key) {
    return Math.abs(key.hashCode()) % SHARD_COUNT;
}

// Range分片（按时间）
public int getShardId(Date date) {
    String yyyyMM = format(date, "yyyyMM");
    return getShardNumber(yyyyMM);
}

// 一致性Hash（节点动态伸缩）
public String getNode(String key) {
    return consistentHash.getNode(key);
}
```

### 4. 异步处理模式

**消息队列解耦**：
```
同步调用：
  A → B → C → D  (串行，总耗时300ms)

异步调用：
  A → MQ ← B
      MQ ← C
      MQ ← D
  A只需50ms返回，BCD异步处理
```

---

## 常见问题与解决方案

### Q1: 如何保证高可用？

**多层容错**：
```
1. 应用层：
   - 多实例部署
   - 负载均衡
   - 健康检查

2. 数据层：
   - 主从复制
   - 读写分离
   - 自动故障转移

3. 缓存层：
   - Redis Cluster
   - 客户端容错
   - 降级策略

4. 跨地域：
   - 多机房部署
   - 异地容灾
   - 就近访问
```

### Q2: 如何应对流量突增？

**弹性伸缩 + 降级**：
```
1. 水平扩展：
   - 自动扩容（K8s HPA）
   - 预热缓存
   - CDN加速

2. 限流保护：
   - 接口限流
   - 用户限流
   - IP限流

3. 降级策略：
   - 关闭非核心功能
   - 返回默认值
   - 静态化页面

4. 消息队列削峰：
   - 异步处理
   - 流量整形
```

### Q3: 如何保证数据一致性？

**分布式事务方案**：
```
1. 2PC（两阶段提交）：
   ✅ 强一致性
   ❌ 性能差、阻塞

2. TCC（Try-Confirm-Cancel）：
   ✅ 性能好、灵活
   ❌ 业务侵入大

3. Saga（长事务）：
   ✅ 适合复杂流程
   ❌ 补偿逻辑复杂

4. 最终一致性（推荐）：
   ✅ 性能好、可用性高
   ❌ 短暂不一致
   实现：消息队列 + 重试 + 幂等
```

### Q4: 如何设计秒杀系统？

**核心要点**：
```
1. 前端：
   - 按钮倒计时
   - 请求拦截
   - 答题验证码

2. 后端：
   - 多级限流
   - Redis预减库存
   - 消息队列异步下单
   - 数据库乐观锁

3. 缓存：
   - 页面静态化
   - CDN加速
   - 热点数据缓存
```

详见：[02_设计秒杀系统.md](./经典系统设计案例/02_设计秒杀系统.md)

### Q5: 如何防止缓存穿透/击穿/雪崩？

**三大问题解决**：
```
缓存穿透（查询不存在的数据）：
  - 布隆过滤器
  - 缓存空值（短期）
  - 参数校验

缓存击穿（热点key过期）：
  - 热点key永不过期
  - 互斥锁更新缓存
  - 逻辑过期（异步更新）

缓存雪崩（大量key同时过期）：
  - 过期时间加随机值
  - 多级缓存
  - 限流降级
```

---

## 📚 总结

### 系统设计的本质

```
不是找"最优解"，而是找"最合适的解"

需要权衡：
  ✅ 功能 vs 性能
  ✅ 一致性 vs 可用性
  ✅ 成本 vs 收益
  ✅ 复杂度 vs 可维护性
```

### 面试成功要素

1. **结构化思维**：按四步法系统设计
2. **主动沟通**：边画边说，确认需求
3. **权衡分析**：说明方案选择理由
4. **深度与广度**：既要全面，也要深入
5. **实战经验**：结合项目经验

### 持续学习建议

```
1. 学习经典案例（本目录10个案例）
2. 分析大厂架构（技术博客、开源项目）
3. 实战项目练习（动手实现）
4. 模拟面试训练（时间限制、口头表达）
5. 总结归纳（形成自己的方法论）
```

---

## 📖 相关文档

- [高并发系统设计](./高并发系统设计.md)
- [经典系统设计案例](./经典系统设计案例/)
- [面试真题解析](./面试真题解析/)

---

**最后更新**: 2025-10-29  
**文档状态**: ✅ 核心内容已完成

💡 **记住**: 系统设计没有标准答案，展示你的思维过程和权衡能力最重要！

# 数据库面试题

> MySQL高频面试题及详细解答

## 📋 目录
- [索引原理](#索引原理)
- [事务机制](#事务机制)
- [锁机制](#锁机制)
- [SQL优化](#sql优化)
- [主从复制](#主从复制)
- [分库分表](#分库分表)

---

## 索引原理

### Q1: B+树 vs B树？（⭐⭐⭐⭐⭐）

**B树特点**：
```
B树（Balance Tree）：

结构：
  - 所有节点都存储数据
  - 叶子节点不相连
  - 每个节点包含：关键字、数据、子节点指针

示例（3阶B树）：
          [10, 20]
         /    |    \
    [5,8]  [15,18]  [25,30]
    
特点：
  - 每个节点存储数据
  - 查找可能在非叶子节点结束
  - 范围查询效率较低（需要中序遍历）
```

**B+树特点**：
```
B+树（B+ Tree）：

结构：
  - 非叶子节点只存储索引（关键字）
  - 叶子节点存储所有数据
  - 叶子节点通过指针相连
  - 所有数据都在叶子节点

示例（3阶B+树）：
          [10, 20]
         /    |    \
    [5,8]  [10,15,18]  [20,25,30]
      ↓       ↓            ↓
    5→8→  10→15→18→  20→25→30→ (链表)
    
特点：
  - 非叶子节点不存储数据
  - 所有查找都到叶子节点
  - 叶子节点形成有序链表
  - 范围查询效率高
```

**对比总结**：

| 对比项 | B树 | B+树 |
|--------|-----|------|
| 数据存储 | 所有节点 | 仅叶子节点 |
| 叶子节点连接 | ❌ 不连接 | ✅ 有序链表 |
| 范围查询 | 慢（中序遍历） | 快（链表遍历） |
| 单点查询 | 可能更快（非叶子节点） | 稳定（都到叶子） |
| 磁盘IO | 较多 | 较少 |
| 空间利用率 | 较低 | 较高 |

**为什么MySQL使用B+树？**
```
1. 磁盘IO次数少：
   - 非叶子节点不存数据，可以存更多索引
   - 树的高度更低
   - 例：3层B+树可存储百万级数据
   
2. 范围查询效率高：
   - 叶子节点有序链表
   - SELECT * FROM user WHERE age > 20 AND age < 30
   - 只需遍历叶子节点链表
   
3. 查询性能稳定：
   - 所有查询都到叶子节点
   - 深度一致，性能可预测
   
4. 便于顺序遍历：
   - 全表扫描效率高
   - 适合范围查询、排序、分组

实际案例：
  假设每个节点16KB（MySQL页大小）
  每个索引8B，指针6B
  每个节点存储：16KB / 14B ≈ 1170个索引
  
  三层B+树：
    第1层：1个节点
    第2层：1170个节点
    第3层：1170² = 1,368,900个节点（叶子）
    
  可存储：130万+ 数据
  最多3次磁盘IO！
```

---

### Q2: 聚簇索引 vs 非聚簇索引？（⭐⭐⭐⭐⭐）

**聚簇索引（Clustered Index）**：
```
定义：
  - 索引的叶子节点存储完整行数据
  - 表数据按索引顺序物理存储
  - 一个表只能有一个聚簇索引

InnoDB聚簇索引：
  - 主键索引是聚簇索引
  - 如果没有主键，使用第一个唯一非空索引
  - 如果都没有，InnoDB创建隐藏的row_id作为聚簇索引

结构：
          [10, 20, 30]
         /      |      \
    [5,8]   [15,18]   [25,28]
      ↓        ↓         ↓
   完整行   完整行     完整行
   数据     数据       数据
   
示例：
CREATE TABLE user (
    id INT PRIMARY KEY,  -- 聚簇索引
    name VARCHAR(50),
    age INT
);

主键索引（聚簇）：
  id=10 → {id:10, name:'张三', age:20}  -- 存储完整行
  id=20 → {id:20, name:'李四', age:25}
  id=30 → {id:30, name:'王五', age:30}
```

**非聚簇索引（Secondary Index）**：
```
定义：
  - 索引的叶子节点存储主键值
  - 需要回表查询完整数据
  - 一个表可以有多个非聚簇索引

结构：
          [张三, 李四, 王五]
         /        |        \
    [刘一,...]  [张三,...]  [王五,...]
       ↓          ↓           ↓
     id=5       id=10       id=30  -- 存储主键
     
示例：
CREATE INDEX idx_name ON user(name);

二级索引（非聚簇）：
  name='张三' → id=10  -- 存储主键值
  name='李四' → id=20
  name='王五' → id=30

查询过程：
SELECT * FROM user WHERE name = '张三';

1. 在idx_name索引找到 name='张三' → id=10
2. 拿id=10去主键索引查找完整数据（回表）
3. 返回 {id:10, name:'张三', age:20}
```

**对比总结**：

| 对比项 | 聚簇索引 | 非聚簇索引 |
|--------|----------|------------|
| 叶子节点 | 完整行数据 | 主键值 |
| 数量 | 1个 | 多个 |
| 查询 | 一次索引查找 | 两次索引查找（回表）|
| 插入速度 | 慢（维护顺序）| 快 |
| 范围查询 | 快 | 慢（回表）|
| 存储空间 | 无额外空间 | 额外空间 |

**回表问题**：
```java
// 情况1：需要回表
SELECT * FROM user WHERE name = '张三';
  ① idx_name: name='张三' → id=10
  ② PRIMARY: id=10 → 完整数据

// 情况2：无需回表（覆盖索引）
SELECT id FROM user WHERE name = '张三';
  ① idx_name: name='张三' → id=10
  ② 直接返回id=10，无需回表 ✅

// 情况3：联合索引避免回表
CREATE INDEX idx_name_age ON user(name, age);

SELECT name, age FROM user WHERE name = '张三';
  ① idx_name_age已包含name和age
  ② 无需回表 ✅
```

---

### Q3: 索引失效场景？（⭐⭐⭐⭐⭐）

**常见失效场景**：

**1. 违反最左前缀原则**：
```sql
-- 联合索引
CREATE INDEX idx_name_age_city ON user(name, age, city);

-- ✅ 索引生效
SELECT * FROM user WHERE name = '张三';
SELECT * FROM user WHERE name = '张三' AND age = 20;
SELECT * FROM user WHERE name = '张三' AND age = 20 AND city = '北京';
SELECT * FROM user WHERE name = '张三' AND city = '北京';  -- name生效

-- ❌ 索引失效
SELECT * FROM user WHERE age = 20;  -- 跳过name
SELECT * FROM user WHERE city = '北京';  -- 跳过name
SELECT * FROM user WHERE age = 20 AND city = '北京';  -- 跳过name
```

**2. 使用函数或表达式**：
```sql
-- ❌ 索引失效
SELECT * FROM user WHERE YEAR(create_time) = 2024;
SELECT * FROM user WHERE UPPER(name) = 'ZHANGSAN';
SELECT * FROM user WHERE age + 1 = 21;

-- ✅ 索引生效
SELECT * FROM user WHERE create_time >= '2024-01-01' 
                     AND create_time < '2025-01-01';
SELECT * FROM user WHERE name = 'zhangsan';
SELECT * FROM user WHERE age = 20;
```

**3. 类型转换**：
```sql
-- 假设 phone 是 VARCHAR 类型
CREATE INDEX idx_phone ON user(phone);

-- ❌ 索引失效（字符串和数字比较）
SELECT * FROM user WHERE phone = 13800138000;

-- ✅ 索引生效
SELECT * FROM user WHERE phone = '13800138000';

-- 假设 age 是 INT 类型
-- ✅ 索引生效（数字可以和字符串比较）
SELECT * FROM user WHERE age = '20';
```

**4. 模糊查询前导通配符**：
```sql
-- ❌ 索引失效
SELECT * FROM user WHERE name LIKE '%张%';
SELECT * FROM user WHERE name LIKE '%张三';

-- ✅ 索引生效
SELECT * FROM user WHERE name LIKE '张%';
SELECT * FROM user WHERE name LIKE '张三%';

-- 前导通配符解决方案：使用全文索引
ALTER TABLE user ADD FULLTEXT INDEX idx_name_fulltext(name);
SELECT * FROM user WHERE MATCH(name) AGAINST('张三');
```

**5. OR条件**：
```sql
-- 假设有索引：idx_name, idx_age

-- ❌ 索引失效（city没有索引）
SELECT * FROM user WHERE name = '张三' OR city = '北京';

-- ✅ 索引生效（都有索引）
SELECT * FROM user WHERE name = '张三' OR age = 20;

-- 优化方案：UNION
SELECT * FROM user WHERE name = '张三'
UNION
SELECT * FROM user WHERE city = '北京';
```

**6. NOT、!=、<>**：
```sql
-- ❌ 索引失效
SELECT * FROM user WHERE age != 20;
SELECT * FROM user WHERE age <> 20;
SELECT * FROM user WHERE name NOT IN ('张三', '李四');

-- ✅ 可能使用索引（优化器决定）
SELECT * FROM user WHERE age > 20 OR age < 20;
```

**7. IS NULL / IS NOT NULL**：
```sql
-- 可能失效（数据量大时）
SELECT * FROM user WHERE name IS NULL;
SELECT * FROM user WHERE name IS NOT NULL;

-- 优化：允许NULL的列不建议建索引
-- 或添加默认值NOT NULL DEFAULT ''
```

**8. 范围查询后的列失效**：
```sql
CREATE INDEX idx_name_age_city ON user(name, age, city);

-- name、age索引生效，city失效
SELECT * FROM user 
WHERE name = '张三' 
  AND age > 20      -- 范围查询
  AND city = '北京'; -- 失效

-- 优化：调整索引顺序
CREATE INDEX idx_name_city_age ON user(name, city, age);
```

**9. 数据量太小**：
```sql
-- 表只有100条数据
-- MySQL可能选择全表扫描（成本更低）
SELECT * FROM user WHERE age = 20;
```

**10. 选择性太低**：
```sql
-- 性别字段（只有男/女）
SELECT * FROM user WHERE gender = '男';

-- 优化器可能选择全表扫描
-- 因为返回数据量太大（约50%）
```

---

### Q4: 覆盖索引？（⭐⭐⭐⭐）

**定义**：
```
覆盖索引（Covering Index）：
  - 查询的列都在索引中
  - 无需回表查询
  - 直接从索引获取数据
```

**示例**：
```sql
-- 表结构
CREATE TABLE user (
    id INT PRIMARY KEY,
    name VARCHAR(50),
    age INT,
    city VARCHAR(50)
);

-- 索引
CREATE INDEX idx_name_age ON user(name, age);

-- ❌ 需要回表（查询city）
SELECT id, name, age, city FROM user WHERE name = '张三';

-- ✅ 覆盖索引（查询列都在索引中）
SELECT id, name, age FROM user WHERE name = '张三';

-- ✅ 覆盖索引（只查id）
SELECT id FROM user WHERE name = '张三';

-- ✅ 覆盖索引（COUNT）
SELECT COUNT(*) FROM user WHERE name = '张三';
```

**EXPLAIN验证**：
```sql
EXPLAIN SELECT id, name, age FROM user WHERE name = '张三';

Extra: Using index  -- 覆盖索引标识
```

**优化案例**：
```sql
-- 慢查询
SELECT id, name, age, city FROM user WHERE name = '张三';

-- 分析：
-- ① idx_name_age找到数据
-- ② 回表查询city（慢）

-- 优化方案1：扩展索引（空间换时间）
CREATE INDEX idx_name_age_city ON user(name, age, city);
SELECT id, name, age, city FROM user WHERE name = '张三';
-- 覆盖索引，无需回表 ✅

-- 优化方案2：拆分查询（先查主键，再批量查）
-- 1. 覆盖索引获取id
SELECT id FROM user WHERE name = '张三';  -- 很快
-- 2. 根据id批量查询
SELECT * FROM user WHERE id IN (1, 2, 3);  -- 主键查询
```

---

## 事务机制

### Q5: ACID特性？（⭐⭐⭐⭐⭐）

**ACID详解**：

**1. 原子性（Atomicity）**：
```
定义：
  - 事务是最小执行单位
  - 要么全部成功，要么全部失败
  - 不存在部分成功

示例：
BEGIN;
  UPDATE account SET balance = balance - 100 WHERE id = 1;  -- A转账
  UPDATE account SET balance = balance + 100 WHERE id = 2;  -- B收款
COMMIT;

结果：
  - 两条SQL都成功 → 提交 ✅
  - 任意一条失败 → 全部回滚 ✅

实现：
  - undo log（回滚日志）
  - 记录修改前的数据
  - 回滚时恢复
```

**2. 一致性（Consistency）**：
```
定义：
  - 事务前后数据完整性不被破坏
  - 符合业务规则和约束

示例：
  转账前：A=1000, B=1000, 总额=2000
  转账中：A=900,  B=1000, 总额=1900  ❌ 不一致
  转账后：A=900,  B=1100, 总额=2000  ✅ 一致

约束：
  - 主键约束
  - 外键约束
  - 唯一约束
  - 非空约束
  - 自定义约束（触发器）

实现：
  - 由应用程序保证
  - 数据库约束辅助
```

**3. 隔离性（Isolation）**：
```
定义：
  - 并发事务互不干扰
  - 一个事务的中间状态对其他事务不可见

问题：
  - 脏读：读到未提交的数据
  - 不可重复读：两次读取结果不同
  - 幻读：两次读取记录数不同

隔离级别：
  - READ UNCOMMITTED（读未提交）
  - READ COMMITTED（读已提交）
  - REPEATABLE READ（可重复读）-- MySQL默认
  - SERIALIZABLE（串行化）

实现：
  - 锁机制
  - MVCC（多版本并发控制）
```

**4. 持久性（Durability）**：
```
定义：
  - 事务提交后，数据永久保存
  - 系统崩溃也不丢失

实现：
  - redo log（重做日志）
  - binlog（归档日志）
  - 双写缓冲（doublewrite buffer）

流程：
  1. 事务修改数据
  2. 写入redo log（磁盘）
  3. 写入binlog（磁盘）
  4. 提交事务
  5. 后台线程刷新数据页到磁盘

崩溃恢复：
  - 读取redo log
  - 重放已提交事务
  - 回滚未提交事务
```

---

### Q6: 事务隔离级别？（⭐⭐⭐⭐⭐）

**四种隔离级别**：

**1. READ UNCOMMITTED（读未提交）**：
```sql
-- 事务A
BEGIN;
UPDATE account SET balance = 900 WHERE id = 1;
-- 未提交

-- 事务B
BEGIN;
SELECT balance FROM account WHERE id = 1;  -- 读到900（脏读）❌
COMMIT;

-- 事务A
ROLLBACK;  -- 回滚

-- 结果：事务B读到了未提交的数据（脏读）

问题：
  ✅ 无幻读
  ❌ 脏读
  ❌ 不可重复读
```

**2. READ COMMITTED（读已提交）**：
```sql
-- 事务A
BEGIN;
SELECT balance FROM account WHERE id = 1;  -- 1000

-- 事务B
BEGIN;
UPDATE account SET balance = 900 WHERE id = 1;
COMMIT;

-- 事务A
SELECT balance FROM account WHERE id = 1;  -- 900（不可重复读）❌
COMMIT;

-- 结果：同一事务中两次读取结果不同

问题：
  ✅ 无脏读
  ❌ 不可重复读
  ❌ 幻读
  
Oracle、SQL Server默认级别
```

**3. REPEATABLE READ（可重复读）**：
```sql
-- 事务A
BEGIN;
SELECT balance FROM account WHERE id = 1;  -- 1000

-- 事务B
BEGIN;
UPDATE account SET balance = 900 WHERE id = 1;
COMMIT;

-- 事务A
SELECT balance FROM account WHERE id = 1;  -- 还是1000 ✅
COMMIT;

-- 结果：事务A读取的数据不受事务B影响

MySQL默认级别

问题：
  ✅ 无脏读
  ✅ 无不可重复读
  ✅ 无幻读（MySQL通过MVCC + 间隙锁解决）
```

**4. SERIALIZABLE（串行化）**：
```sql
-- 事务A
BEGIN;
SELECT * FROM account WHERE id = 1;

-- 事务B
BEGIN;
UPDATE account SET balance = 900 WHERE id = 1;  -- 阻塞，等待A提交
-- ...

-- 事务A
COMMIT;

-- 事务B
-- 此时才能执行UPDATE
COMMIT;

-- 结果：事务串行执行，完全隔离

问题：
  ✅ 无脏读
  ✅ 无不可重复读
  ✅ 无幻读
  ❌ 性能最差
```

**隔离级别对比**：

| 隔离级别 | 脏读 | 不可重复读 | 幻读 | 性能 |
|----------|------|------------|------|------|
| READ UNCOMMITTED | ❌ 有 | ❌ 有 | ❌ 有 | ⭐⭐⭐⭐⭐ |
| READ COMMITTED | ✅ 无 | ❌ 有 | ❌ 有 | ⭐⭐⭐⭐ |
| REPEATABLE READ | ✅ 无 | ✅ 无 | ✅ 无(MySQL) | ⭐⭐⭐ |
| SERIALIZABLE | ✅ 无 | ✅ 无 | ✅ 无 | ⭐ |

**查看和设置**：
```sql
-- 查看当前隔离级别
SELECT @@transaction_isolation;

-- 设置会话级别
SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;

-- 设置全局级别
SET GLOBAL TRANSACTION ISOLATION LEVEL REPEATABLE READ;
```

---

### Q7: MVCC原理？（⭐⭐⭐⭐⭐）

**MVCC（Multi-Version Concurrency Control）**：
```
定义：
  - 多版本并发控制
  - 读不加锁，读写不冲突
  - 提高并发性能

适用场景：
  - READ COMMITTED
  - REPEATABLE READ
  - 仅对SELECT生效（快照读）
```

**核心概念**：

**1. 版本链**：
```
每行数据有多个版本，通过隐藏列连接：

隐藏列：
  - DB_TRX_ID：最后修改该行的事务ID
  - DB_ROLL_PTR：回滚指针，指向undo log
  - DB_ROW_ID：隐藏主键（无主键时）

示例：
原始数据：
  id=1, name='张三', DB_TRX_ID=100

事务200修改：
  id=1, name='李四', DB_TRX_ID=200
          ↓ DB_ROLL_PTR
  id=1, name='张三', DB_TRX_ID=100

事务300修改：
  id=1, name='王五', DB_TRX_ID=300
          ↓ DB_ROLL_PTR
  id=1, name='李四', DB_TRX_ID=200
          ↓ DB_ROLL_PTR
  id=1, name='张三', DB_TRX_ID=100

版本链：王五 → 李四 → 张三
```

**2. ReadView（读视图）**：
```
ReadView包含：
  - m_ids：活跃事务ID列表
  - min_trx_id：最小活跃事务ID
  - max_trx_id：下一个分配的事务ID
  - creator_trx_id：创建ReadView的事务ID

可见性判断：
  对于版本链中的某个版本，判断是否可见：
  
  1. DB_TRX_ID < min_trx_id
     → 可见（已提交）
     
  2. DB_TRX_ID >= max_trx_id
     → 不可见（未开始）
     
  3. DB_TRX_ID in m_ids
     → 不可见（未提交）
     
  4. DB_TRX_ID == creator_trx_id
     → 可见（自己修改的）
     
  5. 否则
     → 可见（已提交）
```

**ReadView生成时机**：
```
READ COMMITTED：
  - 每次SELECT都生成新的ReadView
  - 可以读到其他事务已提交的修改
  
REPEATABLE READ：
  - 第一次SELECT生成ReadView
  - 后续SELECT复用同一个ReadView
  - 读不到其他事务的修改（可重复读）
```

**示例**：
```sql
-- 初始数据
id=1, name='张三', DB_TRX_ID=100

-- 事务A（TRX_ID=200）
BEGIN;
SELECT * FROM user WHERE id = 1;  -- 张三
-- 生成ReadView：m_ids=[200], min=200, max=201

-- 事务B（TRX_ID=201）
BEGIN;
UPDATE user SET name='李四' WHERE id = 1;
COMMIT;
-- 版本链：李四(201) → 张三(100)

-- 事务A（REPEATABLE READ）
SELECT * FROM user WHERE id = 1;  -- 还是'张三'
-- 复用ReadView：m_ids=[200]
-- 判断：201 >= max(201) ? NO
--       201 in [200] ? NO
--       201 >= min(200) ? YES
-- 不可见，继续找下一个版本：张三(100)
-- 100 < min(200) ? YES → 可见 ✅

-- 事务A（READ COMMITTED）
SELECT * FROM user WHERE id = 1;  -- '李四'
-- 生成新ReadView：m_ids=[], min=202, max=202
-- 判断：201 < min(202) ? YES → 可见 ✅
```

---

### Q8: 幻读问题？（⭐⭐⭐⭐）

**幻读定义**：
```
幻读（Phantom Read）：
  - 同一事务中两次查询
  - 结果集的记录数不同
  - 其他事务插入或删除了记录
```

**示例**：
```sql
-- 事务A
BEGIN;
SELECT * FROM user WHERE age > 20;  -- 5条记录

-- 事务B
BEGIN;
INSERT INTO user (name, age) VALUES ('赵六', 25);
COMMIT;

-- 事务A
SELECT * FROM user WHERE age > 20;  -- 6条记录（幻读）❌
COMMIT;
```

**MySQL如何解决幻读？**

**1. MVCC（快照读）**：
```sql
-- REPEATABLE READ级别

-- 事务A
BEGIN;
SELECT * FROM user WHERE age > 20;  -- 快照读，5条
-- 生成ReadView

-- 事务B
BEGIN;
INSERT INTO user (name, age) VALUES ('赵六', 25);
COMMIT;

-- 事务A
SELECT * FROM user WHERE age > 20;  -- 还是5条 ✅
-- MVCC保证读取的是快照版本
COMMIT;
```

**2. 间隙锁（当前读）**：
```sql
-- 当前读：SELECT ... FOR UPDATE, UPDATE, DELETE

-- 事务A
BEGIN;
SELECT * FROM user WHERE age > 20 FOR UPDATE;  -- 当前读
-- 加间隙锁：(20, +∞)

-- 事务B
BEGIN;
INSERT INTO user (name, age) VALUES ('赵六', 25);  -- 阻塞 ⏳
-- age=25在间隙(20, +∞)中，等待事务A释放锁

-- 事务A
COMMIT;  -- 释放间隙锁

-- 事务B
-- 此时才能插入
COMMIT;
```

**间隙锁详解**：
```
假设索引值：10, 20, 30

间隙：
  - (-∞, 10)
  - (10, 20)
  - (20, 30)
  - (30, +∞)

SELECT * FROM user WHERE age > 20 FOR UPDATE;

加锁范围：
  - 记录锁：age=30
  - 间隙锁：(20, 30), (30, +∞)
  
阻塞的操作：
  - INSERT age=25  ❌ 阻塞（间隙锁）
  - INSERT age=35  ❌ 阻塞（间隙锁）
  - UPDATE age=30  ❌ 阻塞（记录锁）
  - UPDATE age=10  ✅ 不阻塞
```

**临键锁（Next-Key Lock）**：
```
临键锁 = 记录锁 + 间隙锁

SELECT * FROM user WHERE age >= 20 FOR UPDATE;

加锁范围：
  - (10, 20]  -- 临键锁
  - (20, 30]  -- 临键锁
  - (30, +∞)  -- 间隙锁
```

---

## 锁机制

### Q9: 表锁 vs 行锁？（⭐⭐⭐⭐）

**表锁（Table Lock）**：
```
特点：
  - 锁整张表
  - 开销小，加锁快
  - 无死锁
  - 并发度低

MyISAM：只支持表锁

示例：
LOCK TABLE user READ;   -- 读锁（共享锁）
LOCK TABLE user WRITE;  -- 写锁（排它锁）
UNLOCK TABLES;

读锁：
  - 当前会话：可读，不可写
  - 其他会话：可读，写阻塞
  
写锁：
  - 当前会话：可读，可写
  - 其他会话：读写都阻塞
```

**行锁（Row Lock）**：
```
特点：
  - 锁单行或多行
  - 开销大，加锁慢
  - 可能死锁
  - 并发度高

InnoDB：支持行锁

示例：
SELECT * FROM user WHERE id = 1 FOR UPDATE;  -- 行锁

类型：
  - 记录锁（Record Lock）：锁定单行
  - 间隙锁（Gap Lock）：锁定范围
  - 临键锁（Next-Key Lock）：记录锁+间隙锁
```

**对比总结**：

| 对比项 | 表锁 | 行锁 |
|--------|------|------|
| 锁粒度 | 整表 | 单行/多行 |
| 开销 | 小 | 大 |
| 加锁速度 | 快 | 慢 |
| 并发性 | 低 | 高 |
| 死锁 | 不会 | 可能 |
| 引擎 | MyISAM | InnoDB |

---

### Q10: 乐观锁 vs 悲观锁？（⭐⭐⭐⭐）

**悲观锁（Pessimistic Lock）**：
```
思想：
  - 假设冲突一定会发生
  - 读取数据时就加锁
  - 其他事务无法修改

实现：
  - 数据库锁（行锁、表锁）
  - SELECT ... FOR UPDATE

示例：
-- 事务A
BEGIN;
SELECT stock FROM product WHERE id = 1 FOR UPDATE;  -- 加锁
-- stock = 100

UPDATE product SET stock = stock - 1 WHERE id = 1;
-- stock = 99

COMMIT;  -- 释放锁

-- 事务B
SELECT stock FROM product WHERE id = 1 FOR UPDATE;  -- 阻塞，等待A释放

适用场景：
  ✅ 冲突频繁
  ✅ 写多读少
  ✅ 严格的数据一致性

劣势：
  ❌ 性能较差（阻塞）
  ❌ 可能死锁
```

**乐观锁（Optimistic Lock）**：
```
思想：
  - 假设冲突很少发生
  - 读取数据时不加锁
  - 更新时检查版本号

实现方式1：版本号
CREATE TABLE product (
    id INT PRIMARY KEY,
    stock INT,
    version INT  -- 版本号
);

-- 事务A
SELECT stock, version FROM product WHERE id = 1;
-- stock=100, version=10

UPDATE product 
SET stock = 99, version = 11 
WHERE id = 1 AND version = 10;  -- 检查版本号
-- 影响行数=1，更新成功 ✅

-- 事务B（同时进行）
SELECT stock, version FROM product WHERE id = 1;
-- stock=100, version=10

UPDATE product 
SET stock = 99, version = 11 
WHERE id = 1 AND version = 10;
-- 影响行数=0，更新失败 ❌（版本号已变）
-- 需要重试

实现方式2：时间戳
CREATE TABLE product (
    id INT PRIMARY KEY,
    stock INT,
    update_time TIMESTAMP
);

UPDATE product 
SET stock = 99, update_time = NOW() 
WHERE id = 1 AND update_time = '2024-01-01 10:00:00';

适用场景：
  ✅ 冲突较少
  ✅ 读多写少
  ✅ 高并发

劣势：
  ❌ 可能需要多次重试
  ❌ ABA问题
```

**对比总结**：

| 对比项 | 悲观锁 | 乐观锁 |
|--------|--------|--------|
| 加锁时机 | 读取时 | 更新时 |
| 冲突处理 | 阻塞等待 | 失败重试 |
| 性能 | 较差 | 较好 |
| 适用场景 | 写多 | 读多 |
| 实现 | 数据库锁 | 版本号 |

---

## SQL优化

### Q11: 慢SQL排查？（⭐⭐⭐⭐⭐）

**排查步骤**：

**1. 开启慢查询日志**：
```sql
-- 查看慢查询配置
SHOW VARIABLES LIKE 'slow_query%';
SHOW VARIABLES LIKE 'long_query_time';

-- 开启慢查询日志
SET GLOBAL slow_query_log = ON;
SET GLOBAL slow_query_log_file = '/var/log/mysql/slow.log';
SET GLOBAL long_query_time = 2;  -- 超过2秒的查询记录

-- 查看慢查询日志
# Time: 2024-01-01T10:00:00.000000Z
# User@Host: root[root] @ localhost []
# Query_time: 5.123456  Lock_time: 0.000123  Rows_sent: 1000  Rows_examined: 1000000
SELECT * FROM user WHERE name LIKE '%张%';
```

**2. 使用EXPLAIN分析**：
```sql
EXPLAIN SELECT * FROM user WHERE name = '张三';

重点字段：
  - type：访问类型（system > const > eq_ref > ref > range > index > ALL）
  - key：实际使用的索引
  - rows：扫描的行数
  - Extra：额外信息
```

**3. SHOW PROFILE分析**：
```sql
-- 开启profiling
SET profiling = 1;

-- 执行查询
SELECT * FROM user WHERE name = '张三';

-- 查看profile
SHOW PROFILES;
SHOW PROFILE FOR QUERY 1;

-- 详细信息
SHOW PROFILE CPU, BLOCK IO FOR QUERY 1;
```

**4. Performance Schema**：
```sql
-- 查看最慢的SQL
SELECT * FROM 
  performance_schema.events_statements_summary_by_digest
ORDER BY SUM_TIMER_WAIT DESC
LIMIT 10;
```

**常见慢SQL问题**：

**1. 没有索引**：
```sql
-- ❌ 慢（全表扫描）
SELECT * FROM user WHERE name = '张三';

-- ✅ 快（索引）
CREATE INDEX idx_name ON user(name);
SELECT * FROM user WHERE name = '张三';
```

**2. 索引失效**：
```sql
-- ❌ 慢（函数导致索引失效）
SELECT * FROM user WHERE YEAR(create_time) = 2024;

-- ✅ 快
SELECT * FROM user 
WHERE create_time >= '2024-01-01' 
  AND create_time < '2025-01-01';
```

**3. 返回数据量太大**：
```sql
-- ❌ 慢（返回100万数据）
SELECT * FROM user;

-- ✅ 快（分页）
SELECT * FROM user LIMIT 1000 OFFSET 0;
```

**4. 深度分页**：
```sql
-- ❌ 慢（扫描100万行）
SELECT * FROM user ORDER BY id LIMIT 1000000, 10;

-- ✅ 快（子查询优化）
SELECT * FROM user 
WHERE id >= (SELECT id FROM user ORDER BY id LIMIT 1000000, 1)
LIMIT 10;

-- ✅ 快（记录上次位置）
SELECT * FROM user WHERE id > 1000000 ORDER BY id LIMIT 10;
```

**5. JOIN过多**：
```sql
-- ❌ 慢（5张表JOIN）
SELECT * FROM t1
JOIN t2 ON t1.id = t2.t1_id
JOIN t3 ON t2.id = t3.t2_id
JOIN t4 ON t3.id = t4.t3_id
JOIN t5 ON t4.id = t5.t4_id;

-- ✅ 快（拆分查询）
SELECT * FROM t1 WHERE id IN (1,2,3);
SELECT * FROM t2 WHERE t1_id IN (1,2,3);
```

---

### Q12: EXPLAIN字段含义？（⭐⭐⭐⭐⭐）

**EXPLAIN输出字段**：
```sql
EXPLAIN SELECT * FROM user WHERE name = '张三';

+----+-------------+-------+------+---------------+----------+---------+-------+------+-------+
| id | select_type | table | type | possible_keys | key      | key_len | ref   | rows | Extra |
+----+-------------+-------+------+---------------+----------+---------+-------+------+-------+
|  1 | SIMPLE      | user  | ref  | idx_name      | idx_name | 203     | const |    1 | NULL  |
+----+-------------+-------+------+---------------+----------+---------+-------+------+-------+
```

**字段详解**：

**1. id**：
```
查询序列号

规则：
  - id相同：执行顺序从上到下
  - id不同：id越大越先执行
  - id为NULL：UNION结果集

示例：
id=1: SELECT * FROM user      -- 第一步
id=2: SELECT * FROM order     -- 第二步（先执行）
id=1: UNION                   -- 第三步
```

**2. select_type**：
```
查询类型

SIMPLE：简单查询，无子查询和UNION
  SELECT * FROM user WHERE id = 1;

PRIMARY：主查询（最外层）
  SELECT * FROM user WHERE id IN (SELECT user_id FROM order);

SUBQUERY：子查询
  SELECT * FROM user WHERE id IN (SELECT user_id FROM order);
  
DERIVED：派生表（FROM子查询）
  SELECT * FROM (SELECT * FROM user WHERE age > 20) AS t;
  
UNION：UNION第二个及后续SELECT
  SELECT * FROM user UNION SELECT * FROM user_bak;
  
UNION RESULT：UNION结果集
```

**3. table**：
```
表名或别名

user：实际表名
t1：别名
<derived2>：派生表
<union1,2>：UNION结果
```

**4. type（重要）**：
```
访问类型，性能从好到差：

system：表只有一行（系统表）⭐⭐⭐⭐⭐
  SELECT * FROM dual;

const：主键或唯一索引等值查询⭐⭐⭐⭐⭐
  SELECT * FROM user WHERE id = 1;

eq_ref：唯一索引扫描（JOIN）⭐⭐⭐⭐⭐
  SELECT * FROM user u JOIN order o ON u.id = o.user_id;

ref：非唯一索引扫描⭐⭐⭐⭐
  SELECT * FROM user WHERE name = '张三';

range：索引范围扫描⭐⭐⭐
  SELECT * FROM user WHERE id > 100;
  SELECT * FROM user WHERE id BETWEEN 1 AND 100;
  SELECT * FROM user WHERE id IN (1,2,3);

index：全索引扫描⭐⭐
  SELECT id FROM user;  -- 覆盖索引

ALL：全表扫描⭐
  SELECT * FROM user;  -- 无索引

优化目标：
  ✅ 至少达到range
  ✅ 最好ref或const
```

**5. possible_keys**：
```
可能使用的索引

示例：
possible_keys: idx_name, idx_age

说明：
  - 查询可能用到idx_name或idx_age
  - 但最终使用哪个看key字段
```

**6. key**：
```
实际使用的索引

NULL：未使用索引
idx_name：使用idx_name索引

优化：
  - 如果key=NULL，考虑添加索引
```

**7. key_len**：
```
索引使用的字节数

计算公式：
  INT：4字节
  BIGINT：8字节
  VARCHAR(N)：N*3 + 2（UTF8）
  NULL：+1字节

示例：
CREATE INDEX idx_name_age ON user(name, age);
-- name VARCHAR(50), age INT

key_len=158：
  - name: 50*3 + 2 = 152
  - age: 4
  - NULL: +1 +1 = 2
  - 总计：152 + 4 + 2 = 158

说明：
  - key_len越小越好
  - 联合索引看key_len判断使用了几个列
```

**8. ref**：
```
索引查找的引用

const：常量
  WHERE id = 1

func：函数
  WHERE id = ABS(-1)

字段：
  WHERE u.id = o.user_id
```

**9. rows（重要）**：
```
扫描的行数（估算值）

示例：
rows=1：只扫描1行（主键查询）
rows=1000000：扫描100万行（全表扫描）

优化：
  - rows越小越好
  - rows过大考虑添加索引或优化SQL
```

**10. Extra（重要）**：
```
额外信息

Using index：覆盖索引⭐⭐⭐⭐⭐
  SELECT id, name FROM user WHERE name = '张三';
  -- 无需回表，性能最好

Using where：WHERE过滤⭐⭐⭐⭐
  SELECT * FROM user WHERE age > 20;

Using index condition：索引下推⭐⭐⭐⭐
  SELECT * FROM user WHERE name = '张三' AND age > 20;

Using filesort：文件排序⭐⭐
  SELECT * FROM user ORDER BY age;
  -- 未使用索引排序，性能较差

Using temporary：临时表⭐
  SELECT DISTINCT name FROM user;
  -- 需要创建临时表，性能差

Using join buffer：JOIN缓冲⭐⭐
  SELECT * FROM user u JOIN order o ON u.name = o.user_name;
  -- JOIN字段无索引

Impossible WHERE：WHERE条件不可能⭐⭐⭐⭐⭐
  SELECT * FROM user WHERE 1 = 2;
  -- 无需执行

优化建议：
  ✅ Using index：最好
  ❌ Using filesort：优化排序
  ❌ Using temporary：优化GROUP BY/DISTINCT
```

---

## 主从复制

### Q13: 主从复制原理？（⭐⭐⭐⭐⭐）

**复制流程**：
```
主库（Master）：
  1. 执行SQL（INSERT/UPDATE/DELETE）
  2. 记录binlog（二进制日志）
  3. binlog dump线程发送给从库

从库（Slave）：
  1. I/O线程接收binlog
  2. 写入relay log（中继日志）
  3. SQL线程读取relay log
  4. 重放SQL，同步数据

流程图：
  Master                         Slave
    ↓                              ↓
  执行SQL                        I/O线程
    ↓                              ↓
  写binlog  →  binlog dump  →  relay log
                                   ↓
                              SQL线程
                                   ↓
                              执行SQL
```

**binlog格式**：
```
1. STATEMENT（语句）：
   - 记录原始SQL
   - 优点：日志量小
   - 缺点：函数可能不一致（NOW()）
   
   示例：
   INSERT INTO user VALUES (1, 'zhangsan', NOW());

2. ROW（行）：
   - 记录每行数据变化
   - 优点：数据一致性好
   - 缺点：日志量大
   
   示例：
   UPDATE user SET age = 21 WHERE age = 20;
   -- 记录：id=1, age: 20→21
   --      id=5, age: 20→21
   --      id=9, age: 20→21

3. MIXED（混合）：
   - 一般用STATEMENT
   - 函数等用ROW
   - 推荐使用

配置：
  binlog_format = ROW
```

**配置示例**：
```ini
# 主库配置（my.cnf）
[mysqld]
server-id = 1
log-bin = mysql-bin
binlog_format = ROW
expire_logs_days = 7

# 从库配置（my.cnf）
[mysqld]
server-id = 2
relay-log = mysql-relay-bin
read_only = 1
```

**主从搭建**：
```sql
-- 1. 主库创建复制用户
CREATE USER 'repl'@'%' IDENTIFIED BY 'password';
GRANT REPLICATION SLAVE ON *.* TO 'repl'@'%';

-- 2. 查看主库状态
SHOW MASTER STATUS;
+------------------+----------+--------------+------------------+
| File             | Position | Binlog_Do_DB | Binlog_Ignore_DB |
+------------------+----------+--------------+------------------+
| mysql-bin.000001 |      154 |              |                  |
+------------------+----------+--------------+------------------+

-- 3. 从库配置主库信息
CHANGE MASTER TO
  MASTER_HOST='192.168.1.100',
  MASTER_USER='repl',
  MASTER_PASSWORD='password',
  MASTER_LOG_FILE='mysql-bin.000001',
  MASTER_LOG_POS=154;

-- 4. 启动从库复制
START SLAVE;

-- 5. 查看从库状态
SHOW SLAVE STATUS\G

重点字段：
  Slave_IO_Running: Yes   -- I/O线程运行中
  Slave_SQL_Running: Yes  -- SQL线程运行中
  Seconds_Behind_Master: 0  -- 主从延迟（秒）
```

---

### Q14: 主从延迟如何解决？（⭐⭐⭐⭐）

**延迟原因**：
```
1. 主库写入压力大：
   - 主库TPS高
   - 从库单线程回放慢

2. 大事务：
   - 主库执行10秒
   - 从库也需10秒回放

3. 网络延迟：
   - binlog传输慢

4. 从库机器性能差：
   - CPU、内存、磁盘IO不足

5. 锁等待：
   - 从库有长查询
   - SQL线程等待锁
```

**解决方案**：

**1. 并行复制**：
```ini
# MySQL 5.7+
slave-parallel-type = LOGICAL_CLOCK
slave-parallel-workers = 4  -- 4个SQL线程

# MySQL 8.0+
binlog_transaction_dependency_tracking = WRITESET
slave_parallel_workers = 8
```

**2. 半同步复制**：
```
异步复制：
  - 主库写binlog后立即返回
  - 不等从库
  - 可能丢数据

半同步复制：
  - 主库写binlog后等待
  - 至少一个从库接收到binlog
  - 然后返回
  - 保证数据不丢

配置：
-- 主库
INSTALL PLUGIN rpl_semi_sync_master SONAME 'semisync_master.so';
SET GLOBAL rpl_semi_sync_master_enabled = 1;
SET GLOBAL rpl_semi_sync_master_timeout = 1000;  -- 1秒

-- 从库
INSTALL PLUGIN rpl_semi_sync_slave SONAME 'semisync_slave.so';
SET GLOBAL rpl_semi_sync_slave_enabled = 1;
```

**3. 读写分离策略**：
```java
// 强一致性：读主库
@Service
public class UserService {
    
    @Autowired
    @Qualifier("masterDataSource")
    private DataSource masterDataSource;
    
    @Autowired
    @Qualifier("slaveDataSource")
    private DataSource slaveDataSource;
    
    public void createOrder(Order order) {
        // 写主库
        masterTemplate.save(order);
    }
    
    public Order getById(Long id) {
        // 读从库（可能延迟）
        return slaveTemplate.findById(id);
    }
    
    public Order getByIdStrong(Long id) {
        // 强一致性：读主库
        return masterTemplate.findById(id);
    }
}

// 方案1：刚写入的数据读主库
public class UserService {
    
    private ThreadLocal<Boolean> forceM aster = new ThreadLocal<>();
    
    public void save(User user) {
        masterTemplate.save(user);
        forceMaster.set(true);  // 标记读主库
    }
    
    public User getById(Long id) {
        if (Boolean.TRUE.equals(forceMaster.get())) {
            return masterTemplate.findById(id);  // 读主库
        }
        return slaveTemplate.findById(id);  // 读从库
    }
}

// 方案2：延迟双删
public void updateUser(User user) {
    // 1. 删除缓存
    redisTemplate.delete("user:" + user.getId());
    
    // 2. 更新数据库
    masterTemplate.update(user);
    
    // 3. 延迟删除缓存（等待主从同步）
    new Thread(() -> {
        try {
            Thread.sleep(1000);  // 等待1秒
            redisTemplate.delete("user:" + user.getId());
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }).start();
}
```

**4. 监控主从延迟**：
```sql
-- 查看延迟
SHOW SLAVE STATUS\G
Seconds_Behind_Master: 0

-- 延迟告警
-- 监控Seconds_Behind_Master
-- 超过阈值告警（如5秒）
```

---

## 分库分表

### Q15: 分库分表策略？（⭐⭐⭐⭐）

**为什么分库分表？**
```
单表数据量过大：
  - 查询慢（索引树深）
  - 写入慢（页分裂）
  - 建议：500万-1000万就该分表

单库并发高：
  - 连接数不足
  - CPU、IO瓶颈
  - 建议：QPS > 5000考虑分库
```

**分库分表方式**：

**1. 垂直分库**：
```
按业务拆分：
  
原来：
  db_business
    - user（用户）
    - product（商品）
    - order（订单）

拆分后：
  db_user（用户库）
    - user
    - user_profile
    
  db_product（商品库）
    - product
    - category
    
  db_order（订单库）
    - order
    - order_item

优点：
  ✅ 业务解耦
  ✅ 分散访问压力
  
缺点：
  ❌ 跨库JOIN困难
  ❌ 分布式事务
```

**2. 垂直分表**：
```
按字段拆分：

原来：
  user（100个字段）
    - id, name, age, ...
    - avatar（大字段）
    - description（大字段）

拆分后：
  user_basic（常用字段）
    - id, name, age
    
  user_detail（不常用字段）
    - id, avatar, description

优点：
  ✅ 减小表体积
  ✅ 提升查询速度
  
缺点：
  ❌ 需要JOIN
```

**3. 水平分表**：
```
按数据拆分：

原来：
  order（1亿数据）

拆分后：
  order_0（2500万）
  order_1（2500万）
  order_2（2500万）
  order_3（2500万）

路由策略：
  order_id % 4
  
  order_id=1 → order_1
  order_id=2 → order_2
  order_id=3 → order_3
  order_id=4 → order_0
```

**4. 水平分库**：
```
原来：
  db_order
    - order（1亿）

拆分后：
  db_order_0
    - order_0（1250万）
    - order_1（1250万）
  
  db_order_1
    - order_2（1250万）
    - order_3（1250万）

路由：2次取模
  库：user_id % 2
  表：order_id % 2
```

**分片键选择**：
```
常用策略：

1. 取模（Hash）：
   user_id % 4
   
   优点：数据均匀
   缺点：扩容困难

2. 范围（Range）：
   0-2500万 → order_0
   2500万-5000万 → order_1
   
   优点：扩容简单
   缺点：数据不均匀（热点）

3. 时间：
   2024年 → order_2024
   2025年 → order_2025
   
   优点：按时间查询快
   缺点：当前表压力大

4. 地理位置：
   北京 → order_beijing
   上海 → order_shanghai
   
   优点：按地域查询快
   缺点：数据不均匀
```

**中间件**：
```
ShardingSphere（推荐）：
  - 客户端模式（JDBC）
  - 服务端模式（Proxy）
  - 支持读写分离、分库分表

Mycat：
  - 服务端模式
  - 需要额外部署

示例配置（ShardingJDBC）：
spring:
  shardingsphere:
    datasource:
      names: ds0, ds1
      ds0:
        type: com.zaxxer.hikari.HikariDataSource
        driver-class-name: com.mysql.cj.jdbc.Driver
        jdbc-url: jdbc:mysql://localhost:3306/db0
      ds1:
        jdbc-url: jdbc:mysql://localhost:3306/db1
    
    sharding:
      tables:
        order:
          actual-data-nodes: ds$->{0..1}.order_$->{0..3}
          table-strategy:
            inline:
              sharding-column: order_id
              algorithm-expression: order_$->{order_id % 4}
          database-strategy:
            inline:
              sharding-column: user_id
              algorithm-expression: ds$->{user_id % 2}
```

---

## 💡 面试技巧

### 高频考点
```
⭐⭐⭐⭐⭐（必考）：
  - B+树原理
  - 聚簇索引 vs 非聚簇索引
  - 索引失效场景
  - 事务隔离级别
  - MVCC原理
  - 主从复制原理
  - EXPLAIN分析

⭐⭐⭐⭐（高频）：
  - 覆盖索引
  - 幻读问题
  - 表锁 vs 行锁
  - 乐观锁 vs 悲观锁
  - 慢SQL排查
  - 主从延迟
  - 分库分表

⭐⭐⭐（中频）：
  - 间隙锁
  - 死锁
  - binlog格式
  - 读写分离
```

---

**最后更新**: 2025-10-29  
**文档状态**: ✅ 完整内容（900+行）

💡 **记住**: 数据库是后端开发的基础，索引和事务是核心！

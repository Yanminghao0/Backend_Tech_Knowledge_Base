# 06_设计抢红包系统.md

## 一、应用场景分析

### 1.1 使用场景
- 社交平台红包（如微信、QQ红包）
- 电商促销红包（如双十一、618活动）
- 企业福利红包（如年会、节日福利）
- 游戏内虚拟物品红包

### 1.2 核心功能
- 发红包（普通红包、拼手气红包、定时红包）
- 抢红包（实时性要求高）
- 红包提现/消费
- 红包记录查询

## 二、需求分析

### 2.1 功能需求
- **发红包**：支持指定金额、数量、类型（普通/拼手气）、有效期
- **抢红包**：用户领取红包，系统随机分配金额（拼手气）
- **红包管理**：过期红包处理、退款机制
- **账务系统**：余额扣减、增加，交易记录
- **通知系统**：红包到账、被领取通知

### 2.2 非功能需求
- **高并发**：秒杀场景下支持10万+ TPS
- **低延迟**：抢红包响应时间<100ms
- **一致性**：红包金额不超发、不错发
- **可用性**：系统可用性99.99%
- **安全性**：防刷、防作弊、防重复领取

## 三、系统架构设计

### 3.1 整体架构
```
用户层 → CDN → 负载均衡 → API网关 → 应用服务层 → 数据层
                                  ↓
                              消息队列
                                  ↓
                            异步处理服务
```

### 3.2 核心服务拆分
- **红包服务**：发红包、抢红包核心逻辑
- **账户服务**：余额管理、交易记录
- **通知服务**：消息推送、短信通知
- **风控服务**：防刷、限流、安全校验
- **统计服务**：红包数据统计分析

## 四、数据模型设计

### 4.1 核心数据表

**红包表（red_packet）**
| 字段名 | 类型 | 说明 |
|--------|------|------|
| id | BIGINT | 红包ID（分布式ID） |
| user_id | BIGINT | 发送者ID |
| total_amount | DECIMAL(16,2) | 红包总金额（分） |
| total_count | INT | 红包总数量 |
| remaining_amount | DECIMAL(16,2) | 剩余金额 |
| remaining_count | INT | 剩余数量 |
| type | TINYINT | 类型（1-普通，2-拼手气） |
| status | TINYINT | 状态（0-未发放，1-发放中，2-已抢完，3-已过期） |
| create_time | DATETIME | 创建时间 |
| expire_time | DATETIME | 过期时间 |
| version | INT | 乐观锁版本号 |

**红包明细（red_packet_detail）**
| 字段名 | 类型 | 说明 |
|--------|------|------|
| id | BIGINT | 明细ID |
| red_packet_id | BIGINT | 红包ID |
| user_id | BIGINT | 领取者ID |
| amount | DECIMAL(16,2) | 领取金额（分） |
| receive_time | DATETIME | 领取时间 |
| status | TINYINT | 状态（0-正常，1-退款） |

### 4.2 缓存设计
- **红包池缓存**：Redis List存储红包金额列表
- **用户抢红包记录**：Redis Set存储已抢用户ID
- **红包状态缓存**：Redis Hash存储红包基本信息

## 五、核心流程设计

### 5.1 发红包流程
```java
// 伪代码
public RedPacketVO sendRedPacket(SendRedPacketDTO dto) {
    // 1. 参数校验
    validate(dto);
    
    // 2. 扣减余额（分布式事务）
    boolean deductSuccess = accountService.deductBalance(dto.getUserId(), dto.getTotalAmount());
    if (!deductSuccess) {
        throw new BusinessException("余额不足");
    }
    
    // 3. 生成红包ID
    Long redPacketId = idGenerator.nextId();
    
    // 4. 生成红包金额列表
    List<Integer> amounts = generateAmounts(dto);
    
    // 5. 保存红包信息到DB
    RedPacket redPacket = buildRedPacket(dto, redPacketId);
    redPacketMapper.insert(redPacket);
    
    // 6. 红包金额存入Redis
    String key = "red_packet:pool:" + redPacketId;
    redisTemplate.opsForList().rightPushAll(key, amounts);
    
    // 7. 设置过期时间
    redisTemplate.expireAt(key, dto.getExpireTime());
    
    return buildRedPacketVO(redPacket);
}

// 生成拼手气红包金额
private List<Integer> generateRandomAmounts(int totalAmount, int totalCount) {
    List<Integer> amounts = new ArrayList<>();
    int remainingAmount = totalAmount;
    int remainingCount = totalCount;
    
    Random random = new Random();
    for (int i = 0; i < totalCount - 1; i++) {
        // 随机范围：[1, remainingAmount - remainingCount + 1]
        int amount = random.nextInt(remainingAmount - remainingCount + 1) + 1;
        amounts.add(amount);
        remainingAmount -= amount;
        remainingCount--;
    }
    amounts.add(remainingAmount);
    
    return amounts;
}
```

### 5.2 抢红包流程
```java
// 伪代码
public ReceiveRedPacketVO receiveRedPacket(Long redPacketId, Long userId) {
    // 1. 验证红包状态
    RedPacket redPacket = getRedPacketFromCache(redPacketId);
    validateRedPacketStatus(redPacket);
    
    // 2. 检查用户是否已抢过（Redis Set）
    String userSetKey = "red_packet:users:" + redPacketId;
    Boolean isMember = redisTemplate.opsForSet().isMember(userSetKey, userId);
    if (Boolean.TRUE.equals(isMember)) {
        throw new BusinessException("您已抢过该红包");
    }
    
    // 3. 原子操作：从红包池取金额 + 记录用户
    String poolKey = "red_packet:pool:" + redPacketId;
    Integer amount = (Integer) redisTemplate.opsForList().leftPop(poolKey);
    if (amount == null) {
        throw new BusinessException("红包已抢完");
    }
    
    // 4. 记录用户已抢
    redisTemplate.opsForSet().add(userSetKey, userId);
    
    // 5. 更新红包剩余数量和金额（Redis + DB）
    String infoKey = "red_packet:info:" + redPacketId;
    redisTemplate.opsForHash().increment(infoKey, "remainingCount", -1);
    redisTemplate.opsForHash().increment(infoKey, "remainingAmount", -amount);
    
    // 6. 异步保存领取记录
    redPacketMqService.sendReceiveRecord(redPacketId, userId, amount);
    
    // 7. 异步通知
    notificationService.sendRedPacketReceivedMsg(userId, amount);
    
    return buildReceiveVO(amount);
}
```

## 六、关键技术挑战

### 6.1 高并发处理
- **Redis预扣减**：红包金额提前存入Redis，抢红包时直接从Redis获取
- **异步化**：非核心流程（如通知、统计）异步处理
- **集群部署**：多实例水平扩展，负载均衡

### 6.2 数据一致性
- **分布式事务**：TCC模式处理余额扣减和红包创建
- **乐观锁**：防止超发（version字段）
- **定时任务**：处理过期未领红包退款

### 6.3 防刷与安全
- **用户行为校验**：限制单用户抢红包频率
- **设备指纹**：识别恶意设备
- **风控规则**：IP、设备、账号多维度风控

### 6.4 峰值应对
- **流量削峰**：队列缓冲，控制处理速度
- **多级缓存**：本地缓存 + Redis缓存热点数据
- **降级熔断**：非核心功能降级，保障抢红包主流程

## 七、扩展性设计

### 7.1 业务扩展
- 支持红包皮肤、祝福语、留言等功能
- 增加红包排行榜、贡献榜
- 对接第三方支付渠道

### 7.2 技术扩展
- 引入消息中间件（Kafka/RabbitMQ）解耦
- 分库分表（按红包ID哈希分片）
- 监控告警系统（Prometheus + Grafana）

## 八、总结

抢红包系统核心在于高并发场景下的性能优化和数据一致性保障。通过Redis预存储、异步处理、分布式事务等技术手段，结合合理的架构设计，可以支撑千万级用户的抢红包需求。同时需注意防刷、限流等安全措施，确保系统稳定可靠运行。

## 九、扩展阅读
1. 《Redis设计与实现》- 黄健宏
2. 《分布式服务架构：原理、设计与实战》- 李艳鹏
3. 《高并发系统设计40问》- 美团技术团队
4. 《Java并发编程实战》- Brian Goetz
5. 《数据库系统概念》- Abraham Silberschatz
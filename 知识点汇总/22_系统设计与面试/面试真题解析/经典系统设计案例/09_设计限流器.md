# 09_设计限流器.md

## 一、应用场景分析

### 1.1 使用场景
- API接口流量控制
- 秒杀活动流量限制
- 数据库访问保护
- 缓存穿透防护
- 消息队列限流
- 微服务调用频率控制

### 1.2 核心功能
- 支持多种限流算法
- 多维度限流策略
- 动态调整限流规则
- 限流后的降级处理
- 限流监控与告警

## 二、需求分析

### 2.1 功能需求
- **限流算法**：支持固定窗口、滑动窗口、漏桶、令牌桶等算法
- **限流粒度**：全局、服务、接口、用户、IP等多维度
- **规则管理**：动态添加、修改、删除限流规则
- **流量统计**：实时统计请求量、通过量、限流次数
- **降级策略**：支持返回默认值、队列等待、服务降级等

### 2.2 非功能需求
- **高性能**：单机支持10万+ QPS的限流判断
- **低延迟**：限流判断耗时<1ms
- **高可用**：限流服务本身不成为瓶颈
- **可扩展性**：支持分布式限流
- **实时性**：规则更新实时生效

## 三、限流算法详解

### 3.1 固定窗口计数器
```java
public class FixedWindowLimiter {
    private final int capacity; // 窗口容量
    private final long windowSize; // 窗口大小(毫秒)
    private AtomicInteger count = new AtomicInteger(0);
    private AtomicLong windowStart = new AtomicLong(System.currentTimeMillis());

    public FixedWindowLimiter(int capacity, long windowSize) {
        this.capacity = capacity;
        this.windowSize = windowSize;
    }

    public boolean tryAcquire() {
        long now = System.currentTimeMillis();
        long currentWindow = windowStart.get();

        // 进入新窗口，重置计数器
        if (now - currentWindow > windowSize) {
            if (windowStart.compareAndSet(currentWindow, now)) {
                count.set(0);
            }
        }

        // 判断是否允许请求
        return count.incrementAndGet() <= capacity;
    }
}
```

### 3.2 滑动窗口计数器
```java
public class SlidingWindowLimiter {
    private final int capacity; // 窗口容量
    private final long windowSize; // 窗口大小(毫秒)
    private final int splitCount; // 窗口分割数
    private final long splitWindowSize; // 子窗口大小
    private final AtomicReferenceArray<AtomicInteger> counters;
    private AtomicLong windowStart = new AtomicLong(System.currentTimeMillis());

    public SlidingWindowLimiter(int capacity, long windowSize, int splitCount) {
        this.capacity = capacity;
        this.windowSize = windowSize;
        this.splitCount = splitCount;
        this.splitWindowSize = windowSize / splitCount;
        this.counters = new AtomicReferenceArray<>(splitCount);
        for (int i = 0; i < splitCount; i++) {
            counters.set(i, new AtomicInteger(0));
        }
    }

    public boolean tryAcquire() {
        long now = System.currentTimeMillis();
        long currentWindow = windowStart.get();
        int currentCapacity = capacity;

        // 计算当前时间在窗口中的位置
        long offset = now - currentWindow;
        if (offset > windowSize) {
            // 完全超出当前窗口，重置整个窗口
            if (windowStart.compareAndSet(currentWindow, now)) {
                resetCounters();
                return counters.get(0).incrementAndGet() <= currentCapacity / splitCount;
            }
        } else {
            // 计算当前子窗口索引
            int index = (int)(offset / splitWindowSize);
            index = Math.min(index, splitCount - 1);

            // 计算有效子窗口数量
            int validCount = splitCount - (int)((offset % splitWindowSize) / splitWindowSize);
            int limitPerWindow = currentCapacity / validCount;

            // 判断当前子窗口是否超过限制
            return counters.get(index).incrementAndGet() <= limitPerWindow;
        }

        return false;
    }

    private void resetCounters() {
        for (int i = 0; i < splitCount; i++) {
            counters.get(i).set(0);
        }
    }
}
```

### 3.3 漏桶算法
```java
public class LeakyBucketLimiter {
    private final double capacity; // 桶容量
    private final double rate; // 漏出速率(个/毫秒)
    private double water; // 当前水量
    private long lastLeakTime; // 上次漏水时间
    private final Object lock = new Object();

    public LeakyBucketLimiter(double capacity, double rate) {
        this.capacity = capacity;
        this.rate = rate;
        this.water = 0;
        this.lastLeakTime = System.currentTimeMillis();
    }

    public boolean tryAcquire() {
        synchronized (lock) {
            long now = System.currentTimeMillis();
            // 计算漏水后的水量
            leak(now);

            // 判断是否还能加水
            if (water + 1 <= capacity) {
                water += 1;
                return true;
            } else {
                // 水满了，限流
                return false;
            }
        }
    }

    private void leak(long now) {
        if (water <= 0) {
            lastLeakTime = now;
            return;
        }

        // 计算漏水量
        double leakAmount = (now - lastLeakTime) * rate;
        water = Math.max(0, water - leakAmount);
        lastLeakTime = now;
    }
}
```

### 3.4 令牌桶算法
```java
public class TokenBucketLimiter {
    private final double capacity; // 桶容量
    private final double rate; // 令牌生成速率(个/毫秒)
    private double tokens; // 当前令牌数
    private long lastRefillTime; // 上次填充令牌时间
    private final Object lock = new Object();

    public TokenBucketLimiter(double capacity, double rate) {
        this.capacity = capacity;
        this.rate = rate;
        this.tokens = capacity; // 初始令牌数为桶容量
        this.lastRefillTime = System.currentTimeMillis();
    }

    public boolean tryAcquire() {
        return tryAcquire(1);
    }

    public boolean tryAcquire(int permits) {
        synchronized (lock) {
            long now = System.currentTimeMillis();
            // 填充令牌
            refill(now);

            // 判断是否有足够令牌
            if (tokens >= permits) {
                tokens -= permits;
                return true;
            }
            return false;
        }
    }

    private void refill(long now) {
        long interval = now - lastRefillTime;
        if (interval <= 0) return;

        // 计算生成的令牌数
        double generated = interval * rate;
        tokens = Math.min(capacity, tokens + generated);
        lastRefillTime = now;
    }
}
```

## 三、系统架构设计

### 3.1 整体架构
```
客户端请求 → 接入层(网关) → 限流过滤器 → 业务服务
                          ↓
                    限流规则中心 → 监控告警系统
```

### 3.2 核心组件
- **限流过滤器**：拦截请求并执行限流判断
- **规则管理中心**：存储和管理限流规则
- **计数器/令牌桶管理器**：维护限流算法的状态
- **监控统计模块**：收集限流相关指标
- **动态配置模块**：支持规则动态更新

## 四、核心实现方案

### 4.1 基于Guava的本地限流
```java
@Configuration
public class GuavaRateLimiterConfig {
    @Bean
    public RateLimiter apiRateLimiter() {
        // 每秒允许100个请求
        return RateLimiter.create(100.0);
    }
}

@RestController
@RequestMapping("/api")
public class ApiController {
    @Autowired
    private RateLimiter apiRateLimiter;

    @GetMapping("/data")
    public ResponseEntity<String> getData() {
        // 尝试获取令牌，最多等待0秒
        if (apiRateLimiter.tryAcquire(0, TimeUnit.SECONDS)) {
            return ResponseEntity.ok("Success");
        } else {
            return ResponseEntity.status(HttpStatus.TOO_MANY_REQUESTS)
                .body("Too many requests");
        }
    }
}
```

### 4.2 基于Redis的分布式限流
```java
@Component
public class RedisRateLimiter {
    @Autowired
    private StringRedisTemplate redisTemplate;

    // Lua脚本：滑动窗口限流
    private static final String SLIDING_WINDOW_LUA = ""
        + "local key = KEYS[1]\n"
        + "local now = tonumber(ARGV[1])\n"
        + "local window = tonumber(ARGV[2])\n"
        + "local limit = tonumber(ARGV[3])\n"
        + "local interval = tonumber(ARGV[4])\n"
        + "\n"
        + "-- 移除窗口外的元素\n"
        + "redis.call('ZREMRANGEBYSCORE', key, 0, now - window)\n"
        + "-- 统计当前窗口内的元素数量\n"
        + "local count = redis.call('ZCARD', key)\n"
        + "-- 判断是否超过限制\n"
        + "if count < limit then\n"
        + "    redis.call('ZADD', key, now, now .. ':' .. math.random())\n"
        + "    redis.call('EXPIRE', key, interval)\n"
        + "    return 1\n"
        + "end\n"
        + "return 0\n";

    private DefaultRedisScript<Long> slidingWindowScript;

    @PostConstruct
    public void init() {
        slidingWindowScript = new DefaultRedisScript<>();
        slidingWindowScript.setScriptText(SLIDING_WINDOW_LUA);
        slidingWindowScript.setResultType(Long.class);
    }

    /**
     * 滑动窗口限流
     * @param key 限流键
     * @param limit 限制请求数
     * @param window 窗口大小(毫秒)
     * @return 是否允许
     */
    public boolean slidingWindowLimit(String key, int limit, long window) {
        String redisKey = "rate_limit:" + key;
        long now = System.currentTimeMillis();
        // 设置key过期时间为窗口大小的2倍
        long interval = window * 2 / 1000;

        Long result = redisTemplate.execute(
            slidingWindowScript,
            Collections.singletonList(redisKey),
            String.valueOf(now),
            String.valueOf(window),
            String.valueOf(limit),
            String.valueOf(interval)
        );

        return result != null && result == 1;
    }
}
```

### 4.3 基于Sentinel的限流实现
```java
@Configuration
public class SentinelConfig {
    @PostConstruct
    public void init() {
        // 配置限流规则
        initFlowRules();
    }

    private void initFlowRules() {
        List<FlowRule> rules = new ArrayList<>();
        FlowRule rule = new FlowRule();
        // 资源名称
        rule.setResource("/api/data");
        // 限流阈值类型：QPS
        rule.setGrade(RuleConstant.FLOW_GRADE_QPS);
        // QPS阈值
        rule.setCount(100);
        // 限流策略：直接拒绝
        rule.setControlBehavior(RuleConstant.CONTROL_BEHAVIOR_DEFAULT);
        rules.add(rule);
        FlowRuleManager.loadRules(rules);
    }
}

@RestController
@RequestMapping("/api")
public class ApiController {
    @GetMapping("/data")
    @SentinelResource(value = "/api/data", blockHandler = "handleBlock")
    public ResponseEntity<String> getData() {
        return ResponseEntity.ok("Success");
    }

    // 限流后的处理方法
    public ResponseEntity<String> handleBlock(BlockException ex) {
        return ResponseEntity.status(HttpStatus.TOO_MANY_REQUESTS)
            .body("Too many requests");
    }
}
```

## 五、关键技术挑战

### 5.1 分布式限流一致性
- **Redis+Lua**：保证限流判断和计数的原子性
- **中心化存储**：使用Redis存储限流状态
- **时钟同步**：确保分布式环境下时间一致性

### 5.2 限流规则动态更新
```java
@Component
public class RuleUpdateService {
    @Autowired
    private RedisRateLimiter redisRateLimiter;
    @Autowired
    private RuleRepository ruleRepository;

    // 监听规则变更事件
    @EventListener
    public void handleRuleChangeEvent(RuleChangeEvent event) {
        Rule newRule = event.getRule();
        // 更新本地限流规则
        updateLocalRule(newRule);
        // 更新Redis中的限流规则
        updateRedisRule(newRule);
        // 记录规则变更日志
        logRuleChange(newRule);
    }
}
```

### 5.3 限流与熔断降级结合
```java
@Service
public class OrderService {
    @Autowired
    private RateLimiter orderRateLimiter;
    @Autowired
    private CircuitBreakerFactory circuitBreakerFactory;

    public OrderVO createOrder(OrderDTO orderDTO) {
        // 1. 限流判断
        if (!orderRateLimiter.tryAcquire()) {
            throw new TooManyRequestsException();
        }

        // 2. 熔断判断
        CircuitBreaker circuitBreaker = circuitBreakerFactory.create("orderService");
        return circuitBreaker.run(
            () -> executeCreateOrder(orderDTO),
            throwable -> handleFallback(throwable)
        );
    }

    private OrderVO executeCreateOrder(OrderDTO orderDTO) {
        // 实际创建订单逻辑
    }

    private OrderVO handleFallback(Throwable throwable) {
        // 降级处理
        return new OrderVO("fallback", "default");
    }
}
```

### 5.4 限流监控与告警
```java
@Component
public class LimiterMonitor {
    @Autowired
    private MeterRegistry meterRegistry;
    @Autowired
    private AlertService alertService;

    private Counter totalRequests;
    private Counter passedRequests;
    private Counter blockedRequests;

    @PostConstruct
    public void init() {
        // 初始化指标计数器
        totalRequests = Counter.builder("rate_limit_total_requests")
            .description("Total requests")
            .register(meterRegistry);

        passedRequests = Counter.builder("rate_limit_passed_requests")
            .description("Passed requests")
            .register(meterRegistry);

        blockedRequests = Counter.builder("rate_limit_blocked_requests")
            .description("Blocked requests")
            .register(meterRegistry);
    }

    public void recordRequest(boolean passed) {
        totalRequests.increment();
        if (passed) {
            passedRequests.increment();
        } else {
            blockedRequests.increment();
            // 检查是否需要告警
            checkAlertCondition();
        }
    }

    private void checkAlertCondition() {
        // 最近1分钟内的限流次数
        double blockedInMinute = blockedRequests.count() - getBlockedCountOneMinuteAgo();
        if (blockedInMinute > 1000) {
            alertService.sendAlert("High rate limit count: " + blockedInMinute);
        }
    }
}
```

## 六、总结
限流器是保护系统稳定的重要组件，设计时需要根据业务场景选择合适的限流算法：固定窗口实现简单但可能有临界问题，滑动窗口平滑性更好但实现复杂，漏桶控制流出速率，令牌桶可以应对突发流量。在分布式系统中，基于Redis的限流方案可以保证一致性，而Sentinel等成熟组件提供了更全面的限流、熔断、降级能力。实际应用中，还需要结合监控告警和动态规则调整，以应对复杂多变的业务场景。

## 七、扩展阅读
1. 《Sentinel: 分布式系统的流量防卫兵》- 阿里云中间件团队
2. 《Guava官方文档-RateLimiter》- Google
3. 《Redis设计与实现》- 黄健宏
4. 《高性能MySQL》- Baron Schwartz
5. 《分布式服务架构：原理、设计与实战》- 李艳鹏
# 08_设计排行榜系统.md

## 一、应用场景分析

### 1.1 使用场景
- 电商平台商品销量排行
- 游戏玩家分数排行
- 内容平台热度榜单
- 社交平台点赞/关注排行
- 音乐/视频播放量排行

### 1.2 核心功能
- 实时更新排名数据
- 支持Top N查询
- 用户个人排名查询
- 区间排名查询
- 多维度排名（时间、类别等）

## 二、需求分析

### 2.1 功能需求
- **数据收集**：支持多种指标数据上报
- **排名计算**：实时/准实时更新排名
- **查询接口**：提供Top N、用户排名、区间排名查询
- **排名规则**：支持自定义排序规则（升序/降序）
- **历史数据**：支持查看历史排名

### 2.2 非功能需求
- **高并发**：支持每秒10万+查询请求
- **低延迟**：查询响应时间<100ms
- **实时性**：数据更新延迟<1秒
- **准确性**：排名数据准确无误
- **可扩展性**：支持千万级用户和百万级物品

## 三、系统架构设计

### 3.1 整体架构
```
数据采集层 → 计算层 → 存储层 → 查询层
     ↑           ↑           ↓
   数据源      缓存层       应用层
```

### 3.2 核心组件
- **数据采集服务**：接收指标数据上报
- **排名计算服务**：实时计算排名
- **缓存服务**：存储热点排名数据
- **持久化存储**：保存全量排名数据
- **查询服务**：提供多种查询接口

## 四、数据模型设计

### 4.1 Redis Sorted Set设计
```
# 基础排名结构
ZADD rank:game:score 950 user:1001
ZADD rank:game:score 920 user:1002
ZADD rank:game:score 880 user:1003

# 带时间维度的排名
ZADD rank:game:score:20231026 950 user:1001
ZADD rank:game:score:20231026 920 user:1002

# 带类别维度的排名
ZADD rank:game:score:category:pvp 950 user:1001
ZADD rank:game:score:category:pve 880 user:1003
```

### 4.2 数据库设计
**排名记录表（ranking_record）**
| 字段名 | 类型 | 说明 |
|--------|------|------|
| id | BIGINT | 记录ID |
| rank_key | VARCHAR(128) | 排名标识 |
| entity_id | VARCHAR(64) | 实体ID |
| score | DECIMAL(16,2) | 分数 |
| rank | INT | 排名 |
| update_time | DATETIME | 更新时间 |
| version | INT | 版本号 |

## 五、核心流程设计

### 5.1 数据更新流程
```java
// 伪代码
public void updateScore(String rankKey, String entityId, double score) {
    // 1. 参数校验
    validateParams(rankKey, entityId, score);
    
    // 2. 更新Redis排名
    String redisKey = buildRedisKey(rankKey);
    redisTemplate.opsForZSet().add(redisKey, entityId, score);
    
    // 3. 设置过期时间（按需）
    redisTemplate.expire(redisKey, 7, TimeUnit.DAYS);
    
    // 4. 异步更新数据库
    rankingMqService.sendUpdateMessage(rankKey, entityId, score);
    
    // 5. 维护本地缓存（热点排名）
    if (isHotRank(rankKey)) {
        localCacheService.updateRankCache(redisKey);
    }
}
```

### 5.2 Top N查询流程
```java
// 伪代码
public List<RankVO> getTopN(String rankKey, int n) {
    // 1. 检查本地缓存
    List<RankVO> localResult = localCacheService.getTopN(rankKey, n);
    if (localResult != null && !localResult.isEmpty()) {
        return localResult;
    }
    
    // 2. 查询Redis
    String redisKey = buildRedisKey(rankKey);
    Set<ZSetOperations.TypedTuple<String>> tuples = redisTemplate.opsForZSet()
        .reverseRangeWithScores(redisKey, 0, n - 1);
    
    // 3. 转换结果
    List<RankVO> result = convertToRankVO(tuples);
    
    // 4. 缓存热点数据
    if (isHotRank(rankKey)) {
        localCacheService.setTopNCache(redisKey, result, 5, TimeUnit.MINUTES);
    }
    
    return result;
}
```

### 5.3 用户排名查询流程
```java
// 伪代码
public UserRankVO getUserRank(String rankKey, String entityId) {
    String redisKey = buildRedisKey(rankKey);
    
    // 1. 获取用户分数
    Double score = redisTemplate.opsForZSet().score(redisKey, entityId);
    if (score == null) {
        return new UserRankVO(entityId, 0, 0.0);
    }
    
    // 2. 获取用户排名
    Long rank = redisTemplate.opsForZSet().reverseRank(redisKey, entityId);
    if (rank == null) {
        return new UserRankVO(entityId, 0, score);
    }
    
    // 3. 获取前后N名用户（用于附近排名）
    List<RankVO> around = getRankAround(redisKey, rank.intValue(), 5);
    
    return new UserRankVO(entityId, rank.intValue() + 1, score, around);
}
```

## 六、关键技术挑战

### 6.1 实时性与性能平衡
- **分层缓存**：本地缓存 + Redis + 数据库
- **批量更新**：高频更新场景下批量合并请求
- **预计算**：非实时场景下预计算排名

### 6.2 大数据量处理
- **分片存储**：按rankKey哈希分片
- **冷热分离**：热门排名Redis存储，冷门排名数据库存储
- **过期清理**：历史数据自动归档/清理

### 6.3 精确排名与性能优化
```java
// 大规模数据下的优化方案
public List<RankVO> getTopNWithLargeData(String rankKey, int n) {
    // 1. 检查是否为热门排名
    if (isHotRank(rankKey)) {
        return getTopNFromRedis(rankKey, n);
    }
    
    // 2. 非热门排名从数据库查询预计算结果
    return rankingDao.queryPrecomputedTopN(rankKey, n);
}
```

### 6.4 防刷与数据安全
- **数据校验**：上报数据合法性校验
- **频率限制**：限制单实体更新频率
- **异常检测**：监控异常分数变化

## 七、扩展性设计

### 7.1 功能扩展
- 支持排名变化趋势图
- 添加排名变化通知
- 支持自定义排名规则

### 7.2 技术扩展
- 引入流计算（如Flink）处理实时数据
- 多级缓存架构优化
- 读写分离与集群扩展

## 八、总结
排行榜系统设计核心在于平衡实时性、准确性和性能。通过合理使用Redis Sorted Set作为核心存储，结合本地缓存和数据库持久化，可以构建高效的排行榜系统。针对不同规模和实时性要求，需要选择合适的架构方案，并注意数据分片、缓存策略和防刷机制等关键技术点。

## 九、扩展阅读
1. 《Redis设计与实现》- 黄健宏
2. 《高性能MySQL》- Baron Schwartz
3. 《数据密集型应用系统设计》- Martin Kleppmann
4. 《Flink原理与实践》- 董西城等
5. 《分布式服务架构：原理、设计与实战》- 李艳鹏
# è®¾è®¡é™æµå™¨

> é«˜é¢‘é¢è¯•é¢˜ï¼šè®¾è®¡ä¸€ä¸ªåˆ†å¸ƒå¼é™æµç³»ç»Ÿ

## ğŸ“‹ é¢è¯•é¢˜ç›®

```
è®¾è®¡ä¸€ä¸ªé™æµç³»ç»Ÿï¼Œæ”¯æŒä»¥ä¸‹åŠŸèƒ½ï¼š
1. å¤šç§é™æµç®—æ³•ï¼ˆå›ºå®šçª—å£ã€æ»‘åŠ¨çª—å£ã€ä»¤ç‰Œæ¡¶ã€æ¼æ¡¶ï¼‰
2. åˆ†å¸ƒå¼é™æµ
3. å¤šç»´åº¦é™æµï¼ˆç”¨æˆ·ã€IPã€æ¥å£ï¼‰
4. åŠ¨æ€é…ç½®
```

---

## ä¸€ã€é™æµç®—æ³•

### 1.1 å›ºå®šçª—å£

```java
/**
 * å›ºå®šçª—å£é™æµ
 */
public class FixedWindowRateLimiter {
    
    private final int maxRequests;
    private final long windowSizeMs;
    private long windowStart;
    private int requestCount;
    
    public FixedWindowRateLimiter(int maxRequests, long windowSizeMs) {
        this.maxRequests = maxRequests;
        this.windowSizeMs = windowSizeMs;
        this.windowStart = System.currentTimeMillis();
        this.requestCount = 0;
    }
    
    public synchronized boolean tryAcquire() {
        long now = System.currentTimeMillis();
        
        // æ£€æŸ¥æ˜¯å¦éœ€è¦é‡ç½®çª—å£
        if (now - windowStart >= windowSizeMs) {
            windowStart = now;
            requestCount = 0;
        }
        
        if (requestCount < maxRequests) {
            requestCount++;
            return true;
        }
        
        return false;
    }
}
```

### 1.2 æ»‘åŠ¨çª—å£

```java
/**
 * æ»‘åŠ¨çª—å£é™æµ
 */
public class SlidingWindowRateLimiter {
    
    private final int maxRequests;
    private final long windowSizeMs;
    private final int subWindowCount;
    private final long subWindowSizeMs;
    private final int[] subWindows;
    private long currentSubWindowStart;
    private int currentSubWindowIndex;
    
    public SlidingWindowRateLimiter(int maxRequests, long windowSizeMs, int subWindowCount) {
        this.maxRequests = maxRequests;
        this.windowSizeMs = windowSizeMs;
        this.subWindowCount = subWindowCount;
        this.subWindowSizeMs = windowSizeMs / subWindowCount;
        this.subWindows = new int[subWindowCount];
        this.currentSubWindowStart = System.currentTimeMillis();
        this.currentSubWindowIndex = 0;
    }
    
    public synchronized boolean tryAcquire() {
        long now = System.currentTimeMillis();
        
        // æ»‘åŠ¨çª—å£
        slideWindow(now);
        
        // è®¡ç®—å½“å‰çª—å£æ€»è¯·æ±‚æ•°
        int totalRequests = 0;
        for (int count : subWindows) {
            totalRequests += count;
        }
        
        if (totalRequests < maxRequests) {
            subWindows[currentSubWindowIndex]++;
            return true;
        }
        
        return false;
    }
    
    private void slideWindow(long now) {
        long elapsed = now - currentSubWindowStart;
        int slidedCount = (int) (elapsed / subWindowSizeMs);
        
        if (slidedCount > 0) {
            // æ¸…ç©ºè¿‡æœŸçš„å­çª—å£
            for (int i = 0; i < Math.min(slidedCount, subWindowCount); i++) {
                currentSubWindowIndex = (currentSubWindowIndex + 1) % subWindowCount;
                subWindows[currentSubWindowIndex] = 0;
            }
            currentSubWindowStart = now - (elapsed % subWindowSizeMs);
        }
    }
}
```

### 1.3 ä»¤ç‰Œæ¡¶

```java
/**
 * ä»¤ç‰Œæ¡¶é™æµ
 */
public class TokenBucketRateLimiter {
    
    private final long capacity;        // æ¡¶å®¹é‡
    private final long refillRate;      // æ¯ç§’å¡«å……ä»¤ç‰Œæ•°
    private long tokens;                // å½“å‰ä»¤ç‰Œæ•°
    private long lastRefillTime;        // ä¸Šæ¬¡å¡«å……æ—¶é—´
    
    public TokenBucketRateLimiter(long capacity, long refillRate) {
        this.capacity = capacity;
        this.refillRate = refillRate;
        this.tokens = capacity;
        this.lastRefillTime = System.currentTimeMillis();
    }
    
    public synchronized boolean tryAcquire() {
        return tryAcquire(1);
    }
    
    public synchronized boolean tryAcquire(int permits) {
        refill();
        
        if (tokens >= permits) {
            tokens -= permits;
            return true;
        }
        
        return false;
    }
    
    private void refill() {
        long now = System.currentTimeMillis();
        long elapsed = now - lastRefillTime;
        
        // è®¡ç®—åº”è¯¥å¡«å……çš„ä»¤ç‰Œæ•°
        long tokensToAdd = elapsed * refillRate / 1000;
        
        if (tokensToAdd > 0) {
            tokens = Math.min(capacity, tokens + tokensToAdd);
            lastRefillTime = now;
        }
    }
}
```

### 1.4 æ¼æ¡¶

```java
/**
 * æ¼æ¡¶é™æµ
 */
public class LeakyBucketRateLimiter {
    
    private final long capacity;        // æ¡¶å®¹é‡
    private final long leakRate;        // æ¯ç§’æ¼å‡ºè¯·æ±‚æ•°
    private long water;                 // å½“å‰æ°´é‡
    private long lastLeakTime;          // ä¸Šæ¬¡æ¼æ°´æ—¶é—´
    
    public LeakyBucketRateLimiter(long capacity, long leakRate) {
        this.capacity = capacity;
        this.leakRate = leakRate;
        this.water = 0;
        this.lastLeakTime = System.currentTimeMillis();
    }
    
    public synchronized boolean tryAcquire() {
        leak();
        
        if (water < capacity) {
            water++;
            return true;
        }
        
        return false;
    }
    
    private void leak() {
        long now = System.currentTimeMillis();
        long elapsed = now - lastLeakTime;
        
        // è®¡ç®—åº”è¯¥æ¼å‡ºçš„æ°´é‡
        long leaked = elapsed * leakRate / 1000;
        
        if (leaked > 0) {
            water = Math.max(0, water - leaked);
            lastLeakTime = now;
        }
    }
}
```

---

## äºŒã€åˆ†å¸ƒå¼é™æµ

### 2.1 Redis + Luaå®ç°

```java
/**
 * åŸºäºRedisçš„åˆ†å¸ƒå¼é™æµ
 */
@Service
public class RedisRateLimiter {
    
    @Autowired
    private RedisTemplate<String, String> redisTemplate;
    
    // æ»‘åŠ¨çª—å£é™æµLuaè„šæœ¬
    private static final String SLIDING_WINDOW_SCRIPT = 
        "local key = KEYS[1]\n" +
        "local now = tonumber(ARGV[1])\n" +
        "local window = tonumber(ARGV[2])\n" +
        "local limit = tonumber(ARGV[3])\n" +
        "local clearBefore = now - window\n" +
        "redis.call('ZREMRANGEBYSCORE', key, 0, clearBefore)\n" +
        "local count = redis.call('ZCARD', key)\n" +
        "if count < limit then\n" +
        "    redis.call('ZADD', key, now, now .. '-' .. math.random())\n" +
        "    redis.call('EXPIRE', key, math.ceil(window / 1000))\n" +
        "    return 1\n" +
        "end\n" +
        "return 0";
    
    // ä»¤ç‰Œæ¡¶é™æµLuaè„šæœ¬
    private static final String TOKEN_BUCKET_SCRIPT = 
        "local key = KEYS[1]\n" +
        "local capacity = tonumber(ARGV[1])\n" +
        "local rate = tonumber(ARGV[2])\n" +
        "local now = tonumber(ARGV[3])\n" +
        "local requested = tonumber(ARGV[4])\n" +
        "local tokens = tonumber(redis.call('HGET', key, 'tokens') or capacity)\n" +
        "local lastRefill = tonumber(redis.call('HGET', key, 'lastRefill') or now)\n" +
        "local elapsed = now - lastRefill\n" +
        "local refill = math.floor(elapsed * rate / 1000)\n" +
        "tokens = math.min(capacity, tokens + refill)\n" +
        "if tokens >= requested then\n" +
        "    tokens = tokens - requested\n" +
        "    redis.call('HSET', key, 'tokens', tokens)\n" +
        "    redis.call('HSET', key, 'lastRefill', now)\n" +
        "    redis.call('EXPIRE', key, math.ceil(capacity / rate) + 1)\n" +
        "    return 1\n" +
        "end\n" +
        "return 0";
    
    /**
     * æ»‘åŠ¨çª—å£é™æµ
     */
    public boolean slidingWindowLimit(String key, int limit, long windowMs) {
        long now = System.currentTimeMillis();
        Long result = redisTemplate.execute(
            new DefaultRedisScript<>(SLIDING_WINDOW_SCRIPT, Long.class),
            Collections.singletonList(key),
            String.valueOf(now),
            String.valueOf(windowMs),
            String.valueOf(limit)
        );
        return result != null && result == 1;
    }
    
    /**
     * ä»¤ç‰Œæ¡¶é™æµ
     */
    public boolean tokenBucketLimit(String key, long capacity, long rate) {
        return tokenBucketLimit(key, capacity, rate, 1);
    }
    
    public boolean tokenBucketLimit(String key, long capacity, long rate, int requested) {
        long now = System.currentTimeMillis();
        Long result = redisTemplate.execute(
            new DefaultRedisScript<>(TOKEN_BUCKET_SCRIPT, Long.class),
            Collections.singletonList(key),
            String.valueOf(capacity),
            String.valueOf(rate),
            String.valueOf(now),
            String.valueOf(requested)
        );
        return result != null && result == 1;
    }
}
```

### 2.2 å¤šç»´åº¦é™æµ

```java
/**
 * å¤šç»´åº¦é™æµæœåŠ¡
 */
@Service
public class MultiDimensionRateLimiter {
    
    @Autowired
    private RedisRateLimiter rateLimiter;
    
    /**
     * å¤šç»´åº¦é™æµæ£€æŸ¥
     */
    public boolean checkLimit(String userId, String ip, String api) {
        // 1. ç”¨æˆ·çº§é™æµï¼šæ¯ç”¨æˆ·æ¯ç§’100æ¬¡
        if (!rateLimiter.tokenBucketLimit("limit:user:" + userId, 100, 100)) {
            return false;
        }
        
        // 2. IPçº§é™æµï¼šæ¯IPæ¯ç§’50æ¬¡
        if (!rateLimiter.tokenBucketLimit("limit:ip:" + ip, 50, 50)) {
            return false;
        }
        
        // 3. æ¥å£çº§é™æµï¼šæ¯æ¥å£æ¯ç§’1000æ¬¡
        if (!rateLimiter.tokenBucketLimit("limit:api:" + api, 1000, 1000)) {
            return false;
        }
        
        // 4. å…¨å±€é™æµï¼šæ¯ç§’10000æ¬¡
        if (!rateLimiter.tokenBucketLimit("limit:global", 10000, 10000)) {
            return false;
        }
        
        return true;
    }
}
```

---

## ä¸‰ã€é¢è¯•è¦ç‚¹

### ç®—æ³•å¯¹æ¯”

| ç®—æ³• | ä¼˜ç‚¹ | ç¼ºç‚¹ | é€‚ç”¨åœºæ™¯ |
|------|------|------|----------|
| å›ºå®šçª—å£ | ç®€å• | è¾¹ç•Œçªåˆº | ç®€å•åœºæ™¯ |
| æ»‘åŠ¨çª—å£ | å¹³æ»‘ | å†…å­˜å ç”¨ | ç²¾ç¡®é™æµ |
| ä»¤ç‰Œæ¡¶ | å…è®¸çªå‘ | å®ç°å¤æ‚ | APIé™æµ |
| æ¼æ¡¶ | æµé‡å¹³æ»‘ | ä¸å…è®¸çªå‘ | æµé‡æ•´å½¢ |

---

## ğŸ“š æ‰©å±•é˜…è¯»

1. [Guava RateLimiteræºç åˆ†æ](https://github.com/google/guava/wiki/RateLimiter)
2. [Sentinelé™æµå®ç°](https://sentinelguard.io/zh-cn/docs/flow-control.html)

# 设计秒杀系统

> 高频面试题：如何设计一个支持千万级并发的秒杀系统

## 📋 面试题目

```
设计一个电商秒杀系统，在指定时间开抢，库存有限（如100个商品），
可能有100万用户同时抢购。

要求：
1. 高并发：支持百万级QPS
2. 防超卖：库存扣减准确
3. 防作弊：防刷单、防黄牛
4. 用户体验：快速响应
5. 高可用：不能宕机
```

---

## 一、需求澄清

### 核心挑战

**秒杀特点**：
```
1. 瞬时高并发：
   - 正常：1000 QPS
   - 秒杀：100,000 QPS（100倍）
   - 持续时间：几秒到几分钟

2. 读多写少：
   - 读（查询库存）：99%
   - 写（下单）：1%
   - 只有极少数人能抢到

3. 库存有限：
   - 商品：100个
   - 用户：100万人
   - 成功率：0.01%
```

### 功能需求

- [x] 秒杀商品展示
- [x] 秒杀倒计时
- [x] 秒杀下单
- [x] 库存扣减（防超卖）
- [x] 订单创建
- [x] 支付流程
- [x] 防刷机制

### 非功能需求

- QPS：峰值10万+
- RT：P99 < 200ms
- 可用性：99.99%
- 准确性：不超卖、不少卖

---

## 二、架构设计

### 2.1 整体架构

```
┌─────────────────────────────────────────┐
│           用户层（前端）                │
│  - 页面静态化                           │
│  - 答题验证码                           │
│  - 按钮倒计时                           │
└──────────────────┬──────────────────────┘
                   ↓
┌──────────────────┴──────────────────────┐
│           CDN层                         │
│  - 静态资源缓存                         │
│  - 就近访问                             │
└──────────────────┬──────────────────────┘
                   ↓
┌──────────────────┴──────────────────────┐
│           接入层                        │
│  - Nginx限流                            │
│  - IP黑名单                             │
│  - 按用户限流                           │
└──────────────────┬──────────────────────┘
                   ↓
┌──────────────────┴──────────────────────┐
│           应用层                        │
│  - 秒杀服务集群（无状态）               │
│  - Redis预减库存                        │
│  - 消息队列异步下单                     │
└──────────────────┬──────────────────────┘
                   ↓
┌──────────────────┴──────────────────────┐
│           数据层                        │
│  - Redis（库存）                        │
│  - MySQL（订单）                        │
│  - Kafka（消息队列）                    │
└─────────────────────────────────────────┘
```

### 2.2 核心流程

```
秒杀开始前（预热）：
  1. 将库存加载到Redis
  2. CDN预热静态资源
  3. 数据库预热（预加载）

秒杀进行中：
  1. 用户点击"立即抢购"
  2. 前端验证码验证
  3. Nginx限流（IP + 用户）
  4. 应用层Redis预减库存
  5. 通过 → 发送MQ消息
  6. 消费者异步创建订单
  7. 数据库扣减库存（乐观锁）
  8. 返回抢购结果

秒杀结束后：
  1. 清理Redis数据
  2. 统计分析
  3. 处理未支付订单
```

---

## 三、详细设计

### 3.1 前端优化

**页面静态化**：
```html
<!-- ❌ 动态页面：每次请求都要查数据库 -->
<div>剩余库存：${stock}</div>
<div>当前价格：${price}</div>

<!-- ✅ 静态页面：只在秒杀开始时ajax获取 -->
<!DOCTYPE html>
<html>
<head><title>iPhone 15 Pro秒杀</title></head>
<body>
  <h1>iPhone 15 Pro秒杀</h1>
  <img src="/static/iphone15.jpg">  <!-- CDN缓存 -->
  <p>价格：<span>¥7999</span></p>
  <p>剩余：<span id="stock">--</span></p>
  <button id="buyBtn" disabled>距离开始：<span id="countdown"></span></button>
  
  <script>
    // 倒计时
    let endTime = new Date('2025-10-29 20:00:00').getTime();
    setInterval(() => {
      let now = new Date().getTime();
      let diff = endTime - now;
      if (diff <= 0) {
        document.getElementById('buyBtn').disabled = false;
        document.getElementById('buyBtn').innerText = '立即抢购';
      } else {
        let sec = Math.floor(diff / 1000);
        document.getElementById('countdown').innerText = sec + '秒';
      }
    }, 1000);
  </script>
</body>
</html>
```

**答题验证码（防机器人）**：
```javascript
// 秒杀开始前弹出验证码
function showCaptcha() {
  // 1. 数学题验证码
  let a = Math.floor(Math.random() * 10);
  let b = Math.floor(Math.random() * 10);
  let answer = prompt(`请计算：${a} + ${b} = ?`);
  if (parseInt(answer) !== a + b) {
    alert('验证失败');
    return false;
  }
  
  // 2. 获取验证token
  return fetch('/api/captcha/verify', {
    method: 'POST',
    body: JSON.stringify({ answer: answer })
  }).then(res => res.json())
    .then(data => data.token);
}

document.getElementById('buyBtn').onclick = async () => {
  // 先验证码，再请求秒杀接口
  let token = await showCaptcha();
  if (!token) return;
  
  fetch('/api/seckill/buy', {
    method: 'POST',
    headers: { 'X-Captcha-Token': token },
    body: JSON.stringify({ product_id: 123 })
  });
};
```

**防重复提交**：
```javascript
let clicking = false;

document.getElementById('buyBtn').onclick = () => {
  if (clicking) {
    alert('请勿重复点击');
    return;
  }
  
  clicking = true;
  document.getElementById('buyBtn').disabled = true;
  
  fetch('/api/seckill/buy', { method: 'POST' })
    .then(res => {
      clicking = false;
      document.getElementById('buyBtn').disabled = false;
    });
};
```

### 3.2 接入层限流

**Nginx限流配置**：
```nginx
http {
    # 1. IP限流：单IP每秒10次请求
    limit_req_zone $binary_remote_addr zone=ip_limit:10m rate=10r/s;
    
    # 2. 用户限流：单用户每秒5次请求
    limit_req_zone $cookie_user_id zone=user_limit:10m rate=5r/s;
    
    server {
        listen 80;
        
        location /api/seckill/ {
            # 应用限流规则
            limit_req zone=ip_limit burst=20 nodelay;
            limit_req zone=user_limit burst=10 nodelay;
            
            # 限流后返回503
            limit_req_status 503;
            
            proxy_pass http://backend;
        }
    }
}
```

**OpenResty动态限流（更灵活）**：
```lua
-- openresty/lua/rate_limit.lua
local redis = require "resty.redis"
local red = redis:new()
red:connect("127.0.0.1", 6379)

-- 获取用户ID
local user_id = ngx.var.cookie_user_id or ngx.var.remote_addr

-- 限流key
local key = "rate_limit:" .. user_id
local limit = 10  -- 每秒10次

-- Lua脚本原子操作
local count = red:incr(key)
if count == 1 then
    red:expire(key, 1)  -- 1秒过期
end

if count > limit then
    ngx.status = 429  -- Too Many Requests
    ngx.say('{"code": 429, "message": "请求过于频繁"}')
    ngx.exit(429)
end
```

### 3.3 Redis预减库存

**核心思想**：
```
为什么用Redis预减库存？

问题：100个商品，100万人抢
  - 如果都进数据库 → 数据库承受不住
  - 大量请求都会失败（只有100个成功）

方案：Redis预减库存
  - 100万请求 → Redis快速拒绝99.99万
  - 只有100个请求进入下单流程
  - 数据库压力降低99.99% ✅
```

**Redis库存结构**：
```
key: seckill:stock:123  (商品ID)
value: 100              (剩余库存)

操作：
  DECR seckill:stock:123  # 原子递减
  如果返回值 >= 0 → 有库存，可以下单
  如果返回值 < 0  → 没库存，拒绝
```

**Java代码实现**：
```java
@Service
public class SeckillService {
    @Autowired
    private RedisTemplate<String, String> redisTemplate;
    
    @Autowired
    private KafkaTemplate<String, String> kafkaTemplate;
    
    /**
     * 秒杀接口
     */
    public SeckillResult seckill(Long productId, Long userId) {
        // 1. 检查用户是否已经抢过（防重复）
        String userKey = "seckill:user:" + productId + ":" + userId;
        Boolean hasOrdered = redisTemplate.hasKey(userKey);
        if (Boolean.TRUE.equals(hasOrdered)) {
            return SeckillResult.fail("您已经抢过了");
        }
        
        // 2. Redis预减库存（核心）
        String stockKey = "seckill:stock:" + productId;
        Long stock = redisTemplate.opsForValue().decrement(stockKey);
        
        if (stock == null || stock < 0) {
            // 没库存了，恢复库存计数
            if (stock != null && stock < 0) {
                redisTemplate.opsForValue().increment(stockKey);
            }
            return SeckillResult.fail("商品已抢光");
        }
        
        // 3. 库存足够，标记用户已抢购
        redisTemplate.opsForValue().set(userKey, "1", 10, TimeUnit.MINUTES);
        
        // 4. 发送消息到MQ，异步创建订单
        SeckillMessage msg = new SeckillMessage(productId, userId);
        kafkaTemplate.send("seckill_order", JSON.toJSONString(msg));
        
        // 5. 立即返回（用户体验好）
        return SeckillResult.success("抢购成功，正在生成订单...");
    }
}
```

**Lua脚本优化（原子性更好）**：
```java
/**
 * 使用Lua脚本保证原子性
 */
public SeckillResult seckillWithLua(Long productId, Long userId) {
    String luaScript = 
        "local stock_key = KEYS[1] " +
        "local user_key = KEYS[2] " +
        "if redis.call('exists', user_key) == 1 then " +
        "    return -2  -- 已经抢过 " +
        "end " +
        "local stock = tonumber(redis.call('get', stock_key) or '0') " +
        "if stock <= 0 then " +
        "    return -1  -- 没库存 " +
        "end " +
        "redis.call('decr', stock_key) " +
        "redis.call('setex', user_key, 600, '1') " +
        "return stock - 1  -- 返回剩余库存 ";
    
    String stockKey = "seckill:stock:" + productId;
    String userKey = "seckill:user:" + productId + ":" + userId;
    
    DefaultRedisScript<Long> script = new DefaultRedisScript<>();
    script.setScriptText(luaScript);
    script.setResultType(Long.class);
    
    Long result = redisTemplate.execute(
        script, 
        Arrays.asList(stockKey, userKey)
    );
    
    if (result == null) {
        return SeckillResult.fail("系统繁忙");
    } else if (result == -2) {
        return SeckillResult.fail("您已经抢过了");
    } else if (result == -1) {
        return SeckillResult.fail("商品已抢光");
    }
    
    // 发送MQ消息
    SeckillMessage msg = new SeckillMessage(productId, userId);
    kafkaTemplate.send("seckill_order", JSON.toJSONString(msg));
    
    return SeckillResult.success("抢购成功");
}
```

### 3.4 异步下单（消息队列）

**为什么异步**：
```
同步下单问题：
  抢购请求 → 库存扣减 → 创建订单 → 返回结果
            ↓ 50ms     ↓ 100ms
  总耗时：150ms，用户等待时间长

异步下单优势：
  抢购请求 → 库存扣减 → 返回"抢购成功" (50ms)
            ↓
            MQ → 异步创建订单
            
  用户体验：50ms返回 ✅
  系统压力：MQ削峰 ✅
```

**Kafka消费者**：
```java
@Component
public class SeckillOrderConsumer {
    @Autowired
    private OrderService orderService;
    
    @Autowired
    private ProductService productService;
    
    @KafkaListener(topics = "seckill_order", concurrency = "10")
    public void handleSeckillOrder(String message) {
        try {
            SeckillMessage msg = JSON.parseObject(message, SeckillMessage.class);
            
            // 1. 再次校验库存（防止Redis和DB不一致）
            Product product = productService.getById(msg.getProductId());
            if (product.getStock() <= 0) {
                log.warn("库存不足，订单创建失败");
                return;
            }
            
            // 2. 创建订单
            Order order = new Order();
            order.setProductId(msg.getProductId());
            order.setUserId(msg.getUserId());
            order.setPrice(product.getSeckillPrice());
            order.setStatus(OrderStatus.UNPAID);
            order.setCreateTime(LocalDateTime.now());
            
            // 3. 扣减数据库库存（乐观锁）
            boolean success = productService.decrementStock(
                msg.getProductId(), 
                product.getStock()
            );
            
            if (!success) {
                log.warn("库存扣减失败（乐观锁冲突）");
                return;
            }
            
            // 4. 保存订单
            orderService.save(order);
            
            // 5. 发送支付通知（可选）
            sendPaymentNotification(order);
            
        } catch (Exception e) {
            log.error("处理秒杀订单失败", e);
            // 重试机制由Kafka保证
        }
    }
}
```

### 3.5 数据库防超卖

**乐观锁方案（推荐）**：
```sql
-- 商品表
CREATE TABLE product (
    id BIGINT PRIMARY KEY,
    name VARCHAR(100),
    stock INT NOT NULL,          -- 库存
    version INT NOT NULL,         -- 版本号（乐观锁）
    seckill_price DECIMAL(10,2),
    INDEX idx_id_version (id, version)
);

-- 扣减库存SQL（带版本号）
UPDATE product 
SET stock = stock - 1, 
    version = version + 1 
WHERE id = #{productId} 
  AND version = #{version}  -- 乐观锁：版本号必须匹配
  AND stock > 0;

-- 如果更新行数 = 0，说明冲突，重试
```

**Java实现**：
```java
@Service
public class ProductService {
    @Autowired
    private ProductMapper productMapper;
    
    /**
     * 扣减库存（乐观锁，带重试）
     */
    public boolean decrementStock(Long productId, int currentVersion) {
        int retryCount = 0;
        int maxRetry = 3;
        
        while (retryCount < maxRetry) {
            // 尝试更新
            int affected = productMapper.decrementStockWithVersion(
                productId, 
                currentVersion
            );
            
            if (affected > 0) {
                return true;  // 成功
            }
            
            // 失败，可能是版本冲突，重新查询版本号
            Product product = productMapper.selectById(productId);
            if (product == null || product.getStock() <= 0) {
                return false;  // 真的没库存了
            }
            
            currentVersion = product.getVersion();
            retryCount++;
        }
        
        return false;  // 重试多次失败
    }
}
```

**悲观锁方案（不推荐）**：
```sql
-- 使用FOR UPDATE行锁
BEGIN;
SELECT stock FROM product WHERE id = 123 FOR UPDATE;  -- 锁住这一行
UPDATE product SET stock = stock - 1 WHERE id = 123 AND stock > 0;
COMMIT;

-- 缺点：并发性能差，容易死锁
```

### 3.6 防刷机制

**1. 接口签名**：
```java
/**
 * 生成接口签名（防篡改）
 */
public String generateSign(Long userId, Long productId, long timestamp) {
    String data = userId + "_" + productId + "_" + timestamp;
    String secret = "my_secret_key";
    return DigestUtils.md5Hex(data + secret);
}

/**
 * 验证签名
 */
public boolean verifySign(SeckillRequest req) {
    String expectedSign = generateSign(
        req.getUserId(), 
        req.getProductId(), 
        req.getTimestamp()
    );
    
    // 签名不匹配
    if (!expectedSign.equals(req.getSign())) {
        return false;
    }
    
    // 时间戳过期（5分钟）
    long now = System.currentTimeMillis();
    if (now - req.getTimestamp() > 5 * 60 * 1000) {
        return false;
    }
    
    return true;
}
```

**2. IP黑名单**：
```java
@Component
public class IPBlacklistFilter implements Filter {
    @Autowired
    private RedisTemplate redisTemplate;
    
    @Override
    public void doFilter(ServletRequest request, ServletResponse response, 
                         FilterChain chain) {
        String ip = getClientIP(request);
        
        // 检查黑名单
        Boolean isBlocked = redisTemplate.opsForSet()
            .isMember("ip_blacklist", ip);
        
        if (Boolean.TRUE.equals(isBlocked)) {
            response.getWriter().write("您的IP已被封禁");
            return;
        }
        
        // 检查频率（1秒内超过100次 → 拉黑）
        String key = "ip_count:" + ip;
        Long count = redisTemplate.opsForValue().increment(key);
        if (count == 1) {
            redisTemplate.expire(key, 1, TimeUnit.SECONDS);
        }
        
        if (count > 100) {
            redisTemplate.opsForSet().add("ip_blacklist", ip);
            response.getWriter().write("请求过于频繁，已封禁");
            return;
        }
        
        chain.doFilter(request, response);
    }
}
```

**3. 用户行为分析**：
```java
/**
 * 检测异常行为
 */
public boolean isAbnormalBehavior(Long userId) {
    String key = "user_behavior:" + userId;
    
    // 记录用户行为
    redisTemplate.opsForList().rightPush(key, 
        System.currentTimeMillis() + "");
    redisTemplate.expire(key, 60, TimeUnit.SECONDS);
    
    // 1分钟内请求超过50次 → 异常
    Long size = redisTemplate.opsForList().size(key);
    return size != null && size > 50;
}
```

---

## 四、容量规划

### 4.1 QPS估算

```
假设场景：
  - 秒杀商品：100个
  - 参与用户：100万人
  - 秒杀时长：10秒

峰值QPS = 100万 / 10秒 = 10万 QPS

考虑重试和查询：
  实际峰值QPS ≈ 20万 QPS
```

### 4.2 服务器配置

```
应用服务器：
  - 规格：8核16G
  - 单机QPS：5000
  - 需要数量：20万 / 5000 = 40台
  - 冗余1.5倍：60台

Redis服务器：
  - 规格：16核32G
  - 单机QPS：10万
  - 需要数量：20万 / 10万 = 2台
  - 主从架构：2主 + 4从

数据库：
  - 主库：16核64G SSD
  - 从库：3台（读写分离）
```

---

## 五、常见追问

### Q1: Redis库存和DB库存不一致怎么办？

**回答**：
```
原因：
  - Redis扣减成功，但MQ消息丢失
  - Redis扣减成功，但订单创建失败

解决方案：

1. 最终一致性：
   - 定时任务对账（每小时）
   - Redis库存 vs DB库存
   - 发现差异 → 告警 → 人工处理

2. 补偿机制：
   - 订单创建失败 → 回滚Redis库存
   - 使用TCC事务模式

3. 预留库存：
   - Redis初始库存 = DB库存 - 10（预留）
   - 防止超卖

推荐：最终一致性 + 定时对账 ✅
```

### Q2: 如果Redis挂了怎么办？

**回答**：
```
方案：

1. Redis高可用：
   - 主从 + 哨兵
   - Redis Cluster
   - 自动故障转移

2. 降级方案：
   - Redis挂了 → 直接访问数据库
   - 数据库限流（保护）
   - 返回"系统繁忙"

3. 多级缓存：
   - L1: 本地缓存
   - L2: Redis
   - L3: 数据库
```

### Q3: 如何保证公平性？

**回答**：
```
问题：先抢先得是否公平？
  - 网速快的用户有优势
  - 靠近机房的用户有优势

优化方案：

1. 随机延迟：
   - 每个请求随机延迟0-100ms
   - 减少网络优势

2. 抽奖模式：
   - 秒杀时间结束后
   - 从所有参与用户中抽奖
   - 绝对公平

3. 队列模式：
   - 所有请求进队列
   - FIFO处理
   - 公平但实时性差

推荐：先到先得（体验好） + 随机延迟（相对公平） ✅
```

### Q4: 如何防止黄牛刷单？

**回答**：
```
综合防护：

1. 实名认证：
   - 手机号验证
   - 身份证验证
   - 人脸识别

2. 限购策略：
   - 每人限购1件
   - 同一地址限购1件
   - 同一银行卡限购1件

3. 风控系统：
   - 用户行为分析
   - 设备指纹识别
   - 异常账号拦截

4. 验证码：
   - 滑动验证码
   - 图形验证码
   - 短信验证码

5. 价格策略：
   - 秒杀价不要太低
   - 减少黄牛利润空间
```

---

## 六、总结

### 核心设计要点

```
1. 前端优化：
   ✅ 页面静态化 + CDN
   ✅ 答题验证码
   ✅ 防重复提交

2. 接入层：
   ✅ Nginx限流
   ✅ IP黑名单
   ✅ 用户限流

3. 业务层：
   ✅ Redis预减库存（核心）
   ✅ 异步下单（MQ）
   ✅ 限流降级

4. 数据层：
   ✅ 数据库乐观锁
   ✅ 读写分离
   ✅ 主从复制

5. 安全防护：
   ✅ 接口签名
   ✅ 频率限制
   ✅ 行为分析
```

### 性能优化

```
优化前：
  - QPS：1000
  - RT：500ms
  - 成功率：10%

优化后：
  - QPS：100,000 ✅ (100倍提升)
  - RT：50ms ✅ (10倍提升)
  - 成功率：99.9% ✅
```

### 面试要点

```
1. 理解秒杀特点：
   - 瞬时高并发
   - 读多写少
   - 库存有限

2. 掌握核心方案：
   - Redis预减库存（必答）
   - 消息队列异步
   - 数据库乐观锁

3. 说明权衡：
   - 为什么用Redis？（快）
   - 为什么异步？（削峰）
   - 为什么乐观锁？（性能）

4. 防护措施：
   - 限流、降级、熔断
   - 防刷、防超卖
```

---

## 📖 相关文档

- [高并发系统设计](../高并发系统设计.md)
- [01_设计短链接系统](./01_设计短链接系统.md)
- [09_设计限流器](./09_设计限流器.md)

---

**最后更新**: 2025-10-29  
**难度等级**: ⭐⭐⭐⭐⭐ (困难)  
**面试频率**: ⭐⭐⭐⭐⭐ (极高)

💡 **总结**: 秒杀系统是最经典的高并发场景，综合考察缓存、消息队列、限流、防超卖等核心技术！

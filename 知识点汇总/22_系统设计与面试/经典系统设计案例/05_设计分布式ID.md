# è®¾è®¡åˆ†å¸ƒå¼IDç”Ÿæˆç³»ç»Ÿ

> é«˜é¢‘é¢è¯•é¢˜ï¼šè®¾è®¡ä¸€ä¸ªé«˜æ€§èƒ½çš„åˆ†å¸ƒå¼IDç”Ÿæˆç³»ç»Ÿ

## ğŸ“‹ é¢è¯•é¢˜ç›®

```
è®¾è®¡ä¸€ä¸ªåˆ†å¸ƒå¼IDç”Ÿæˆç³»ç»Ÿï¼Œæ»¡è¶³ä»¥ä¸‹è¦æ±‚ï¼š
1. å…¨å±€å”¯ä¸€æ€§
2. è¶‹åŠ¿é€’å¢ï¼ˆæœ‰åˆ©äºæ•°æ®åº“ç´¢å¼•ï¼‰
3. é«˜æ€§èƒ½ï¼ˆæ”¯æŒ10ä¸‡QPSï¼‰
4. é«˜å¯ç”¨ï¼ˆ99.99%ï¼‰
5. å¯æ‰©å±•ï¼ˆæ”¯æŒå¤šæ•°æ®ä¸­å¿ƒï¼‰
```

---

## ä¸€ã€éœ€æ±‚æ¾„æ¸…

### åŠŸèƒ½éœ€æ±‚

- [x] ç”Ÿæˆå…¨å±€å”¯ä¸€ID
- [x] IDè¶‹åŠ¿é€’å¢
- [x] æ”¯æŒå¤šç§IDæ ¼å¼ï¼ˆçº¯æ•°å­—ã€å­—ç¬¦ä¸²ï¼‰
- [x] æ”¯æŒæ‰¹é‡è·å–ID
- [x] æ”¯æŒå¤šä¸šåŠ¡éš”ç¦»

### éåŠŸèƒ½éœ€æ±‚

- **æ€§èƒ½**ï¼šå•æœº10ä¸‡QPSï¼Œé›†ç¾¤100ä¸‡QPS
- **å¯ç”¨æ€§**ï¼š99.99%ï¼Œæ— å•ç‚¹æ•…éšœ
- **å»¶è¿Ÿ**ï¼šP99 < 5ms
- **æœ‰åºæ€§**ï¼šè¶‹åŠ¿é€’å¢ï¼Œä¸è¦æ±‚ä¸¥æ ¼é€’å¢

---

## äºŒã€æ–¹æ¡ˆå¯¹æ¯”

### 2.1 å¸¸è§æ–¹æ¡ˆ

| æ–¹æ¡ˆ | ä¼˜ç‚¹ | ç¼ºç‚¹ | é€‚ç”¨åœºæ™¯ |
|------|------|------|----------|
| UUID | ç®€å•ã€æ— ä¾èµ– | æ— åºã€å¤ªé•¿ã€ç´¢å¼•æ€§èƒ½å·® | åˆ†å¸ƒå¼è¿½è¸ªID |
| æ•°æ®åº“è‡ªå¢ | ç®€å•ã€æœ‰åº | æ€§èƒ½ç“¶é¢ˆã€å•ç‚¹æ•…éšœ | å°è§„æ¨¡ç³»ç»Ÿ |
| Redis INCR | æ€§èƒ½é«˜ã€æœ‰åº | ä¾èµ–Redisã€æŒä¹…åŒ–é—®é¢˜ | ä¸­ç­‰è§„æ¨¡ |
| é›ªèŠ±ç®—æ³• | é«˜æ€§èƒ½ã€è¶‹åŠ¿é€’å¢ | æ—¶é’Ÿå›æ‹¨é—®é¢˜ | å¤§è§„æ¨¡ç³»ç»Ÿ |
| Leaf | é«˜æ€§èƒ½ã€é«˜å¯ç”¨ | æ¶æ„å¤æ‚ | å¤§è§„æ¨¡ç³»ç»Ÿ |

### 2.2 æ¨èæ–¹æ¡ˆï¼šé›ªèŠ±ç®—æ³• + Leaf

```
é‡‡ç”¨é›ªèŠ±ç®—æ³•ä¸ºæ ¸å¿ƒï¼Œç»“åˆLeafçš„å·æ®µæ¨¡å¼ä½œä¸ºå¤‡é€‰ï¼š
1. ä¸»æ–¹æ¡ˆï¼šé›ªèŠ±ç®—æ³•ï¼ˆé«˜æ€§èƒ½ï¼‰
2. å¤‡é€‰æ–¹æ¡ˆï¼šLeafå·æ®µæ¨¡å¼ï¼ˆé«˜å¯ç”¨ï¼‰
3. æ—¶é’Ÿå›æ‹¨å¤„ç†ï¼šç­‰å¾…+æŠ¥è­¦
```

---

## ä¸‰ã€è¯¦ç»†è®¾è®¡

### 3.1 é›ªèŠ±ç®—æ³•ç»“æ„

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      64ä½IDç»“æ„                              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 1ä½ç¬¦å· â”‚  41ä½æ—¶é—´æˆ³   â”‚ 10ä½æœºå™¨ID â”‚     12ä½åºåˆ—å·        â”‚
â”‚   0     â”‚ æ¯«ç§’çº§æ—¶é—´æˆ³  â”‚ æ•°æ®ä¸­å¿ƒ+æœºå™¨â”‚   åŒæ¯«ç§’å†…åºåˆ—å·      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  å›ºå®š0  â”‚ 69å¹´æ—¶é—´èŒƒå›´  â”‚ 1024å°æœºå™¨ â”‚   4096ä¸ªID/æ¯«ç§’       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

æ—¶é—´æˆ³ï¼š41ä½ï¼Œå¯ç”¨69å¹´
æœºå™¨IDï¼š10ä½ = 5ä½æ•°æ®ä¸­å¿ƒ + 5ä½æœºå™¨ID
åºåˆ—å·ï¼š12ä½ï¼Œæ¯æ¯«ç§’4096ä¸ªID
```

### 3.2 æ ¸å¿ƒä»£ç å®ç°

```java
/**
 * é›ªèŠ±ç®—æ³•IDç”Ÿæˆå™¨
 */
public class SnowflakeIdGenerator {
    
    // èµ·å§‹æ—¶é—´æˆ³ (2024-01-01 00:00:00)
    private static final long START_TIMESTAMP = 1704067200000L;
    
    // å„éƒ¨åˆ†ä½æ•°
    private static final long SEQUENCE_BITS = 12L;
    private static final long MACHINE_BITS = 5L;
    private static final long DATACENTER_BITS = 5L;
    
    // æœ€å¤§å€¼
    private static final long MAX_SEQUENCE = ~(-1L << SEQUENCE_BITS);        // 4095
    private static final long MAX_MACHINE_ID = ~(-1L << MACHINE_BITS);       // 31
    private static final long MAX_DATACENTER_ID = ~(-1L << DATACENTER_BITS); // 31
    
    // ä½ç§»
    private static final long MACHINE_SHIFT = SEQUENCE_BITS;
    private static final long DATACENTER_SHIFT = SEQUENCE_BITS + MACHINE_BITS;
    private static final long TIMESTAMP_SHIFT = SEQUENCE_BITS + MACHINE_BITS + DATACENTER_BITS;
    
    private final long datacenterId;
    private final long machineId;
    private long sequence = 0L;
    private long lastTimestamp = -1L;
    
    public SnowflakeIdGenerator(long datacenterId, long machineId) {
        if (datacenterId > MAX_DATACENTER_ID || datacenterId < 0) {
            throw new IllegalArgumentException("Datacenter ID out of range");
        }
        if (machineId > MAX_MACHINE_ID || machineId < 0) {
            throw new IllegalArgumentException("Machine ID out of range");
        }
        this.datacenterId = datacenterId;
        this.machineId = machineId;
    }
    
    /**
     * ç”Ÿæˆä¸‹ä¸€ä¸ªID
     */
    public synchronized long nextId() {
        long currentTimestamp = System.currentTimeMillis();
        
        // æ—¶é’Ÿå›æ‹¨æ£€æµ‹
        if (currentTimestamp < lastTimestamp) {
            long offset = lastTimestamp - currentTimestamp;
            if (offset <= 5) {
                // å°äº5msï¼Œç­‰å¾…
                try {
                    Thread.sleep(offset << 1);
                    currentTimestamp = System.currentTimeMillis();
                    if (currentTimestamp < lastTimestamp) {
                        throw new RuntimeException("Clock moved backwards");
                    }
                } catch (InterruptedException e) {
                    throw new RuntimeException("Wait interrupted", e);
                }
            } else {
                throw new RuntimeException("Clock moved backwards: " + offset + "ms");
            }
        }
        
        // åŒä¸€æ¯«ç§’å†…
        if (currentTimestamp == lastTimestamp) {
            sequence = (sequence + 1) & MAX_SEQUENCE;
            if (sequence == 0) {
                // åºåˆ—å·ç”¨å°½ï¼Œç­‰å¾…ä¸‹ä¸€æ¯«ç§’
                currentTimestamp = waitNextMillis(lastTimestamp);
            }
        } else {
            // æ–°çš„æ¯«ç§’ï¼Œåºåˆ—å·é‡ç½®
            sequence = 0L;
        }
        
        lastTimestamp = currentTimestamp;
        
        // ç»„è£…ID
        return ((currentTimestamp - START_TIMESTAMP) << TIMESTAMP_SHIFT)
                | (datacenterId << DATACENTER_SHIFT)
                | (machineId << MACHINE_SHIFT)
                | sequence;
    }
    
    /**
     * æ‰¹é‡ç”ŸæˆID
     */
    public synchronized long[] nextIds(int count) {
        long[] ids = new long[count];
        for (int i = 0; i < count; i++) {
            ids[i] = nextId();
        }
        return ids;
    }
    
    private long waitNextMillis(long lastTimestamp) {
        long timestamp = System.currentTimeMillis();
        while (timestamp <= lastTimestamp) {
            timestamp = System.currentTimeMillis();
        }
        return timestamp;
    }
    
    /**
     * è§£æID
     */
    public static IdInfo parseId(long id) {
        long timestamp = (id >> TIMESTAMP_SHIFT) + START_TIMESTAMP;
        long datacenterId = (id >> DATACENTER_SHIFT) & MAX_DATACENTER_ID;
        long machineId = (id >> MACHINE_SHIFT) & MAX_MACHINE_ID;
        long sequence = id & MAX_SEQUENCE;
        
        return new IdInfo(timestamp, datacenterId, machineId, sequence);
    }
}
```

### 3.3 Leafå·æ®µæ¨¡å¼

```java
/**
 * Leafå·æ®µæ¨¡å¼IDç”Ÿæˆå™¨
 */
@Service
public class LeafSegmentIdGenerator {
    
    @Autowired
    private LeafAllocMapper leafAllocMapper;
    
    // åŒBuffer
    private volatile SegmentBuffer[] buffers = new SegmentBuffer[2];
    private volatile int currentIndex = 0;
    
    // å·æ®µåŠ è½½é˜ˆå€¼
    private static final double LOAD_THRESHOLD = 0.7;
    
    /**
     * è·å–ä¸‹ä¸€ä¸ªID
     */
    public long nextId(String bizTag) {
        SegmentBuffer buffer = buffers[currentIndex];
        
        // æ£€æŸ¥æ˜¯å¦éœ€è¦åŠ è½½ä¸‹ä¸€ä¸ªå·æ®µ
        if (buffer.getUsedPercent() > LOAD_THRESHOLD && !buffer.isNextReady()) {
            loadNextSegment(bizTag);
        }
        
        // è·å–ID
        long id = buffer.getAndIncrement();
        
        // å½“å‰å·æ®µç”¨å°½ï¼Œåˆ‡æ¢åˆ°ä¸‹ä¸€ä¸ª
        if (id > buffer.getMax()) {
            switchBuffer();
            return nextId(bizTag);
        }
        
        return id;
    }
    
    /**
     * åŠ è½½ä¸‹ä¸€ä¸ªå·æ®µ
     */
    @Async
    public void loadNextSegment(String bizTag) {
        int nextIndex = (currentIndex + 1) % 2;
        SegmentBuffer nextBuffer = buffers[nextIndex];
        
        if (nextBuffer.isLoading()) {
            return;
        }
        
        nextBuffer.setLoading(true);
        try {
            // ä»æ•°æ®åº“è·å–å·æ®µ
            LeafAlloc leafAlloc = leafAllocMapper.updateAndGet(bizTag);
            nextBuffer.setMin(leafAlloc.getMaxId() - leafAlloc.getStep());
            nextBuffer.setMax(leafAlloc.getMaxId());
            nextBuffer.setCurrent(nextBuffer.getMin());
            nextBuffer.setNextReady(true);
        } finally {
            nextBuffer.setLoading(false);
        }
    }
    
    private synchronized void switchBuffer() {
        currentIndex = (currentIndex + 1) % 2;
        buffers[currentIndex].setNextReady(false);
    }
}

// å·æ®µè¡¨
CREATE TABLE leaf_alloc (
    biz_tag VARCHAR(128) PRIMARY KEY COMMENT 'ä¸šåŠ¡æ ‡è¯†',
    max_id BIGINT NOT NULL DEFAULT 1 COMMENT 'å½“å‰æœ€å¤§ID',
    step INT NOT NULL DEFAULT 1000 COMMENT 'å·æ®µæ­¥é•¿',
    description VARCHAR(256) COMMENT 'æè¿°',
    update_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);
```

### 3.4 æœåŠ¡æ¶æ„

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                       å®¢æˆ·ç«¯SDK                              â”‚
â”‚  - æœ¬åœ°ç¼“å­˜ID  - æ‰¹é‡è·å–  - è‡ªåŠ¨é‡è¯•                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                            â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                       è´Ÿè½½å‡è¡¡                               â”‚
â”‚  - Nginx  - å¥åº·æ£€æŸ¥  - æ•…éšœè½¬ç§»                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                            â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    IDç”ŸæˆæœåŠ¡é›†ç¾¤                            â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                  â”‚
â”‚  â”‚ Node-1   â”‚  â”‚ Node-2   â”‚  â”‚ Node-3   â”‚                  â”‚
â”‚  â”‚ é›ªèŠ±ç®—æ³• â”‚  â”‚ é›ªèŠ±ç®—æ³• â”‚  â”‚ é›ªèŠ±ç®—æ³• â”‚                  â”‚
â”‚  â”‚ machineIdâ”‚  â”‚ machineIdâ”‚  â”‚ machineIdâ”‚                  â”‚
â”‚  â”‚    =1    â”‚  â”‚    =2    â”‚  â”‚    =3    â”‚                  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                            â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                       æ•°æ®å­˜å‚¨                               â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                â”‚
â”‚  â”‚ ZooKeeperâ”‚  â”‚  MySQL   â”‚                                â”‚
â”‚  â”‚ æœºå™¨IDåˆ†é…â”‚  â”‚ å·æ®µå­˜å‚¨ â”‚                                â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```


---

## å››ã€å…³é”®æŠ€æœ¯æŒ‘æˆ˜

### 4.1 æ—¶é’Ÿå›æ‹¨å¤„ç†

```java
/**
 * æ—¶é’Ÿå›æ‹¨å¤„ç†ç­–ç•¥
 */
public class ClockBackwardHandler {
    
    // æœ€å¤§å®¹å¿å›æ‹¨æ—¶é—´
    private static final long MAX_BACKWARD_MS = 5L;
    
    // æ‰©å±•ä½ï¼ˆç”¨äºæ—¶é’Ÿå›æ‹¨æ—¶çš„åºåˆ—æ‰©å±•ï¼‰
    private AtomicLong extensionSequence = new AtomicLong(0);
    
    /**
     * å¤„ç†æ—¶é’Ÿå›æ‹¨
     */
    public long handleClockBackward(long lastTimestamp, long currentTimestamp) {
        long offset = lastTimestamp - currentTimestamp;
        
        if (offset <= MAX_BACKWARD_MS) {
            // ç­–ç•¥1ï¼šçŸ­æš‚ç­‰å¾…
            try {
                Thread.sleep(offset << 1);
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
            return System.currentTimeMillis();
        }
        
        if (offset <= 100) {
            // ç­–ç•¥2ï¼šä½¿ç”¨æ‰©å±•åºåˆ—å·
            return lastTimestamp;
        }
        
        // ç­–ç•¥3ï¼šæŠ¥è­¦å¹¶æ‹’ç»æœåŠ¡
        throw new ClockBackwardException("Clock moved backwards: " + offset + "ms");
    }
}
```

### 4.2 æœºå™¨IDåˆ†é…

```java
/**
 * åŸºäºZooKeeperçš„æœºå™¨IDåˆ†é…
 */
@Service
public class ZkMachineIdAllocator {
    
    @Autowired
    private CuratorFramework zkClient;
    
    private static final String ZK_PATH = "/snowflake/machine";
    
    /**
     * è·å–æœºå™¨ID
     */
    public int allocateMachineId() {
        String ip = getLocalIp();
        String path = ZK_PATH + "/" + ip;
        
        try {
            // æ£€æŸ¥æ˜¯å¦å·²åˆ†é…
            if (zkClient.checkExists().forPath(path) != null) {
                byte[] data = zkClient.getData().forPath(path);
                return Integer.parseInt(new String(data));
            }
            
            // åˆ†é…æ–°çš„æœºå™¨ID
            int machineId = allocateNewMachineId();
            zkClient.create()
                .creatingParentsIfNeeded()
                .withMode(CreateMode.PERSISTENT)
                .forPath(path, String.valueOf(machineId).getBytes());
            
            return machineId;
        } catch (Exception e) {
            throw new RuntimeException("Failed to allocate machine ID", e);
        }
    }
    
    private int allocateNewMachineId() throws Exception {
        // è·å–æ‰€æœ‰å·²åˆ†é…çš„æœºå™¨ID
        List<String> children = zkClient.getChildren().forPath(ZK_PATH);
        Set<Integer> usedIds = new HashSet<>();
        for (String child : children) {
            byte[] data = zkClient.getData().forPath(ZK_PATH + "/" + child);
            usedIds.add(Integer.parseInt(new String(data)));
        }
        
        // æ‰¾åˆ°æœªä½¿ç”¨çš„æœ€å°ID
        for (int i = 0; i < 1024; i++) {
            if (!usedIds.contains(i)) {
                return i;
            }
        }
        
        throw new RuntimeException("No available machine ID");
    }
}
```

### 4.3 é«˜å¯ç”¨è®¾è®¡

```java
/**
 * IDç”ŸæˆæœåŠ¡é«˜å¯ç”¨å°è£…
 */
@Service
public class HighAvailableIdService {
    
    @Autowired
    private SnowflakeIdGenerator snowflakeGenerator;
    
    @Autowired
    private LeafSegmentIdGenerator leafGenerator;
    
    // æœ¬åœ°ç¼“å­˜
    private BlockingQueue<Long> idCache = new LinkedBlockingQueue<>(10000);
    
    // é¢„åŠ è½½çº¿ç¨‹
    @PostConstruct
    public void init() {
        // å¯åŠ¨é¢„åŠ è½½çº¿ç¨‹
        new Thread(this::preloadIds).start();
    }
    
    /**
     * è·å–IDï¼ˆä¼˜å…ˆä»ç¼“å­˜è·å–ï¼‰
     */
    public long nextId() {
        Long id = idCache.poll();
        if (id != null) {
            return id;
        }
        
        // ç¼“å­˜ä¸ºç©ºï¼Œç›´æ¥ç”Ÿæˆ
        return generateId();
    }
    
    /**
     * ç”ŸæˆIDï¼ˆä¸»å¤‡åˆ‡æ¢ï¼‰
     */
    private long generateId() {
        try {
            // ä¸»æ–¹æ¡ˆï¼šé›ªèŠ±ç®—æ³•
            return snowflakeGenerator.nextId();
        } catch (Exception e) {
            log.warn("Snowflake failed, fallback to Leaf", e);
            // å¤‡é€‰æ–¹æ¡ˆï¼šLeafå·æ®µ
            return leafGenerator.nextId("default");
        }
    }
    
    /**
     * é¢„åŠ è½½IDåˆ°ç¼“å­˜
     */
    private void preloadIds() {
        while (true) {
            try {
                if (idCache.size() < 5000) {
                    long[] ids = snowflakeGenerator.nextIds(1000);
                    for (long id : ids) {
                        idCache.offer(id);
                    }
                }
                Thread.sleep(100);
            } catch (Exception e) {
                log.error("Preload IDs failed", e);
            }
        }
    }
}
```

---

## äº”ã€æ€§èƒ½ä¼˜åŒ–

### 5.1 æ‰¹é‡è·å–

```java
/**
 * å®¢æˆ·ç«¯SDK - æ‰¹é‡è·å–ID
 */
public class IdClientSdk {
    
    private BlockingQueue<Long> localCache = new LinkedBlockingQueue<>(1000);
    private IdServiceClient client;
    
    public long nextId() {
        Long id = localCache.poll();
        if (id != null) {
            return id;
        }
        
        // æ‰¹é‡è·å–
        List<Long> ids = client.batchGetIds(100);
        for (int i = 1; i < ids.size(); i++) {
            localCache.offer(ids.get(i));
        }
        
        return ids.get(0);
    }
}
```

### 5.2 æ€§èƒ½æµ‹è¯•ç»“æœ

```
æµ‹è¯•ç¯å¢ƒï¼š8æ ¸16Gï¼ŒJDK11

å•æœºæ€§èƒ½ï¼š
- é›ªèŠ±ç®—æ³•ï¼š50ä¸‡QPS
- Leafå·æ®µï¼š30ä¸‡QPS

é›†ç¾¤æ€§èƒ½ï¼ˆ3èŠ‚ç‚¹ï¼‰ï¼š
- æ€»QPSï¼š100ä¸‡+
- P99å»¶è¿Ÿï¼š<2ms
- å¯ç”¨æ€§ï¼š99.99%
```

---

## å…­ã€é¢è¯•è¦ç‚¹

### å¸¸è§é—®é¢˜

**Q1: é›ªèŠ±ç®—æ³•çš„æ—¶é’Ÿå›æ‹¨å¦‚ä½•å¤„ç†ï¼Ÿ**
```
1. çŸ­æš‚å›æ‹¨ï¼ˆ<5msï¼‰ï¼šç­‰å¾…æ—¶é’Ÿè¿½ä¸Š
2. ä¸­ç­‰å›æ‹¨ï¼ˆ5-100msï¼‰ï¼šä½¿ç”¨æ‰©å±•åºåˆ—å·
3. ä¸¥é‡å›æ‹¨ï¼ˆ>100msï¼‰ï¼šæŠ¥è­¦å¹¶æ‹’ç»æœåŠ¡
4. é¢„é˜²æªæ–½ï¼šNTPåŒæ­¥ã€æ—¶é’Ÿç›‘æ§
```

**Q2: å¦‚ä½•ä¿è¯æœºå™¨IDä¸é‡å¤ï¼Ÿ**
```
1. ZooKeeperåˆ†é…ï¼šæŒä¹…åŒ–èŠ‚ç‚¹å­˜å‚¨
2. æ•°æ®åº“åˆ†é…ï¼šå”¯ä¸€ç´¢å¼•ä¿è¯
3. é…ç½®æ–‡ä»¶ï¼šäººå·¥åˆ†é…
4. IP+ç«¯å£è®¡ç®—ï¼šè‡ªåŠ¨ç”Ÿæˆ
```

**Q3: é›ªèŠ±ç®—æ³•å’ŒUUIDçš„åŒºåˆ«ï¼Ÿ**
```
é›ªèŠ±ç®—æ³•ï¼š
- 64ä½æ•°å­—ï¼Œè¶‹åŠ¿é€’å¢
- é€‚åˆæ•°æ®åº“ä¸»é”®
- éœ€è¦æœºå™¨IDåˆ†é…

UUIDï¼š
- 128ä½å­—ç¬¦ä¸²ï¼Œæ— åº
- ä¸é€‚åˆæ•°æ®åº“ç´¢å¼•
- æ— éœ€ä¸­å¿ƒåŒ–åˆ†é…
```

---

## ğŸ“š æ‰©å±•é˜…è¯»

1. [ç¾å›¢Leafåˆ†å¸ƒå¼IDç”Ÿæˆç³»ç»Ÿ](https://tech.meituan.com/2017/04/21/mt-leaf.html)
2. [ç™¾åº¦UidGenerator](https://github.com/baidu/uid-generator)
3. [Twitter Snowflake](https://github.com/twitter-archive/snowflake)
4. [åˆ†å¸ƒå¼IDç”Ÿæˆæ–¹æ¡ˆå¯¹æ¯”](https://www.infoq.cn/article/wechat-distributed-id-generation)

# è®¾è®¡å»¶è¿Ÿä»»åŠ¡ç³»ç»Ÿ

> é«˜é¢‘é¢è¯•é¢˜ï¼šè®¾è®¡ä¸€ä¸ªæ”¯æŒå»¶è¿Ÿæ‰§è¡Œçš„ä»»åŠ¡è°ƒåº¦ç³»ç»Ÿ

## ğŸ“‹ é¢è¯•é¢˜ç›®

```
è®¾è®¡ä¸€ä¸ªå»¶è¿Ÿä»»åŠ¡ç³»ç»Ÿï¼Œæ”¯æŒä»¥ä¸‹åŠŸèƒ½ï¼š
1. æäº¤å»¶è¿Ÿä»»åŠ¡ï¼ˆæŒ‡å®šå»¶è¿Ÿæ—¶é—´ï¼‰
2. ä»»åŠ¡åˆ°æœŸè‡ªåŠ¨æ‰§è¡Œ
3. æ”¯æŒå–æ¶ˆä»»åŠ¡
4. é«˜å¯ç”¨ã€é«˜æ€§èƒ½
```

---

## ä¸€ã€éœ€æ±‚æ¾„æ¸…

### åŠŸèƒ½éœ€æ±‚

- [x] æäº¤å»¶è¿Ÿä»»åŠ¡ï¼šæŒ‡å®šå»¶è¿Ÿæ—¶é—´æˆ–æ‰§è¡Œæ—¶é—´
- [x] ä»»åŠ¡æ‰§è¡Œï¼šåˆ°æœŸè‡ªåŠ¨è§¦å‘
- [x] ä»»åŠ¡å–æ¶ˆï¼šæ”¯æŒå–æ¶ˆæœªæ‰§è¡Œä»»åŠ¡
- [x] ä»»åŠ¡æŸ¥è¯¢ï¼šæŸ¥è¯¢ä»»åŠ¡çŠ¶æ€
- [x] é‡è¯•æœºåˆ¶ï¼šå¤±è´¥è‡ªåŠ¨é‡è¯•

### éåŠŸèƒ½éœ€æ±‚

- **ç²¾åº¦**ï¼šç§’çº§ç²¾åº¦
- **æ€§èƒ½**ï¼šæ”¯æŒç™¾ä¸‡çº§ä»»åŠ¡
- **å¯ç”¨æ€§**ï¼š99.99%
- **å¯é æ€§**ï¼šä»»åŠ¡ä¸ä¸¢å¤±

---

## äºŒã€æ–¹æ¡ˆå¯¹æ¯”

| æ–¹æ¡ˆ | ä¼˜ç‚¹ | ç¼ºç‚¹ | é€‚ç”¨åœºæ™¯ |
|------|------|------|----------|
| JDK DelayQueue | ç®€å• | å•æœºã€å†…å­˜é™åˆ¶ | å°è§„æ¨¡ |
| å®šæ—¶æ‰«ææ•°æ®åº“ | ç®€å•å¯é  | æ€§èƒ½å·®ã€å»¶è¿Ÿé«˜ | ä½é¢‘ä»»åŠ¡ |
| Redis ZSet | é«˜æ€§èƒ½ | éœ€è¦è½®è¯¢ | ä¸­ç­‰è§„æ¨¡ |
| æ—¶é—´è½® | é«˜æ€§èƒ½ã€ä½å»¶è¿Ÿ | å®ç°å¤æ‚ | å¤§è§„æ¨¡ |
| RocketMQå»¶è¿Ÿæ¶ˆæ¯ | å¯é ã€åˆ†å¸ƒå¼ | ç²¾åº¦æœ‰é™ | é€šç”¨åœºæ™¯ |

---

## ä¸‰ã€è¯¦ç»†è®¾è®¡

### 3.1 Redis ZSetæ–¹æ¡ˆ

```java
/**
 * åŸºäºRedis ZSetçš„å»¶è¿Ÿä»»åŠ¡
 */
@Service
public class RedisDelayTaskService {
    
    @Autowired
    private RedisTemplate<String, String> redisTemplate;
    
    private static final String DELAY_QUEUE_KEY = "delay_task_queue";
    private static final String TASK_DATA_KEY = "delay_task_data:";
    
    /**
     * æ·»åŠ å»¶è¿Ÿä»»åŠ¡
     */
    public String addTask(DelayTask task, long delaySeconds) {
        String taskId = UUID.randomUUID().toString();
        long executeTime = System.currentTimeMillis() + delaySeconds * 1000;
        
        // 1. å­˜å‚¨ä»»åŠ¡æ•°æ®
        task.setTaskId(taskId);
        task.setExecuteTime(executeTime);
        redisTemplate.opsForValue().set(
            TASK_DATA_KEY + taskId, 
            JSON.toJSONString(task),
            delaySeconds + 3600, TimeUnit.SECONDS
        );
        
        // 2. æ·»åŠ åˆ°å»¶è¿Ÿé˜Ÿåˆ—
        redisTemplate.opsForZSet().add(DELAY_QUEUE_KEY, taskId, executeTime);
        
        return taskId;
    }
    
    /**
     * å–æ¶ˆä»»åŠ¡
     */
    public boolean cancelTask(String taskId) {
        redisTemplate.opsForZSet().remove(DELAY_QUEUE_KEY, taskId);
        redisTemplate.delete(TASK_DATA_KEY + taskId);
        return true;
    }
    
    /**
     * è½®è¯¢æ‰§è¡Œåˆ°æœŸä»»åŠ¡
     */
    @Scheduled(fixedRate = 1000)
    public void pollAndExecute() {
        long now = System.currentTimeMillis();
        
        // è·å–åˆ°æœŸä»»åŠ¡
        Set<String> taskIds = redisTemplate.opsForZSet()
            .rangeByScore(DELAY_QUEUE_KEY, 0, now);
        
        if (CollectionUtils.isEmpty(taskIds)) {
            return;
        }
        
        for (String taskId : taskIds) {
            // å°è¯•è·å–ä»»åŠ¡ï¼ˆåŸå­æ“ä½œï¼‰
            Long removed = redisTemplate.opsForZSet().remove(DELAY_QUEUE_KEY, taskId);
            if (removed != null && removed > 0) {
                // è·å–ä»»åŠ¡æ•°æ®
                String taskData = redisTemplate.opsForValue().get(TASK_DATA_KEY + taskId);
                if (taskData != null) {
                    DelayTask task = JSON.parseObject(taskData, DelayTask.class);
                    // å¼‚æ­¥æ‰§è¡Œä»»åŠ¡
                    executeTask(task);
                }
            }
        }
    }
    
    @Async
    public void executeTask(DelayTask task) {
        try {
            // æ‰§è¡Œä»»åŠ¡é€»è¾‘
            taskExecutor.execute(task);
            // åˆ é™¤ä»»åŠ¡æ•°æ®
            redisTemplate.delete(TASK_DATA_KEY + task.getTaskId());
        } catch (Exception e) {
            // æ‰§è¡Œå¤±è´¥ï¼Œé‡æ–°å…¥é˜Ÿé‡è¯•
            if (task.getRetryCount() < 3) {
                task.setRetryCount(task.getRetryCount() + 1);
                addTask(task, 60); // 60ç§’åé‡è¯•
            }
        }
    }
}
```

### 3.2 æ—¶é—´è½®æ–¹æ¡ˆ

```java
/**
 * æ—¶é—´è½®å®ç°
 */
public class TimingWheel {
    
    // æ—¶é—´è½®æ§½æ•°
    private final int wheelSize;
    // æ¯ä¸ªæ§½çš„æ—¶é—´è·¨åº¦ï¼ˆæ¯«ç§’ï¼‰
    private final long tickDuration;
    // æ—¶é—´è½®æ§½
    private final List<Set<DelayTask>>[] wheel;
    // å½“å‰æŒ‡é’ˆä½ç½®
    private volatile int currentTick = 0;
    // å½“å‰æ—¶é—´
    private volatile long currentTime;
    // ä¸Šå±‚æ—¶é—´è½®ï¼ˆå¤„ç†æ›´é•¿å»¶è¿Ÿï¼‰
    private TimingWheel overflowWheel;
    
    public TimingWheel(int wheelSize, long tickDuration) {
        this.wheelSize = wheelSize;
        this.tickDuration = tickDuration;
        this.wheel = new List[wheelSize];
        this.currentTime = System.currentTimeMillis();
        
        for (int i = 0; i < wheelSize; i++) {
            wheel[i] = new CopyOnWriteArraySet<>();
        }
    }
    
    /**
     * æ·»åŠ ä»»åŠ¡
     */
    public boolean addTask(DelayTask task) {
        long executeTime = task.getExecuteTime();
        long delay = executeTime - currentTime;
        
        if (delay < tickDuration) {
            // å·²åˆ°æœŸï¼Œç«‹å³æ‰§è¡Œ
            return false;
        }
        
        long totalTicks = delay / tickDuration;
        
        if (totalTicks < wheelSize) {
            // åœ¨å½“å‰æ—¶é—´è½®èŒƒå›´å†…
            int targetTick = (int) ((currentTick + totalTicks) % wheelSize);
            wheel[targetTick].add(task);
            return true;
        } else {
            // è¶…å‡ºèŒƒå›´ï¼Œæ”¾å…¥ä¸Šå±‚æ—¶é—´è½®
            if (overflowWheel == null) {
                overflowWheel = new TimingWheel(wheelSize, tickDuration * wheelSize);
            }
            return overflowWheel.addTask(task);
        }
    }
    
    /**
     * æ¨è¿›æ—¶é—´è½®
     */
    public List<DelayTask> advanceClock(long timestamp) {
        List<DelayTask> expiredTasks = new ArrayList<>();
        
        while (currentTime < timestamp) {
            currentTime += tickDuration;
            currentTick = (currentTick + 1) % wheelSize;
            
            // è·å–å½“å‰æ§½çš„ä»»åŠ¡
            Set<DelayTask> tasks = wheel[currentTick];
            expiredTasks.addAll(tasks);
            tasks.clear();
            
            // å¤„ç†ä¸Šå±‚æ—¶é—´è½®
            if (overflowWheel != null && currentTick == 0) {
                List<DelayTask> overflowTasks = overflowWheel.advanceClock(currentTime);
                for (DelayTask task : overflowTasks) {
                    addTask(task); // é‡æ–°æ·»åŠ åˆ°å½“å‰æ—¶é—´è½®
                }
            }
        }
        
        return expiredTasks;
    }
}

/**
 * æ—¶é—´è½®è°ƒåº¦å™¨
 */
@Service
public class TimingWheelScheduler {
    
    private final TimingWheel timingWheel;
    private final ScheduledExecutorService scheduler;
    
    public TimingWheelScheduler() {
        // åˆ›å»ºæ—¶é—´è½®ï¼š60ä¸ªæ§½ï¼Œæ¯æ§½1ç§’
        this.timingWheel = new TimingWheel(60, 1000);
        this.scheduler = Executors.newSingleThreadScheduledExecutor();
        
        // å¯åŠ¨æ—¶é—´è½®æ¨è¿›
        scheduler.scheduleAtFixedRate(this::tick, 1, 1, TimeUnit.SECONDS);
    }
    
    public void addTask(DelayTask task) {
        if (!timingWheel.addTask(task)) {
            // å·²åˆ°æœŸï¼Œç«‹å³æ‰§è¡Œ
            executeTask(task);
        }
    }
    
    private void tick() {
        List<DelayTask> tasks = timingWheel.advanceClock(System.currentTimeMillis());
        for (DelayTask task : tasks) {
            executeTask(task);
        }
    }
    
    @Async
    public void executeTask(DelayTask task) {
        // æ‰§è¡Œä»»åŠ¡
    }
}
```

---

## å››ã€é«˜å¯ç”¨è®¾è®¡

### 4.1 åˆ†å¸ƒå¼éƒ¨ç½²

```java
/**
 * åˆ†å¸ƒå¼å»¶è¿Ÿä»»åŠ¡æœåŠ¡
 */
@Service
public class DistributedDelayTaskService {
    
    @Autowired
    private RedissonClient redissonClient;
    
    /**
     * ä½¿ç”¨åˆ†å¸ƒå¼é”è½®è¯¢ä»»åŠ¡
     */
    @Scheduled(fixedRate = 1000)
    public void pollWithLock() {
        RLock lock = redissonClient.getLock("delay_task_poll_lock");
        
        try {
            // å°è¯•è·å–é”ï¼Œæœ€å¤šç­‰å¾…100ms
            if (lock.tryLock(100, 5000, TimeUnit.MILLISECONDS)) {
                try {
                    doPoll();
                } finally {
                    lock.unlock();
                }
            }
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }
}
```

---

## äº”ã€åº”ç”¨åœºæ™¯

```
1. è®¢å•è¶…æ—¶å–æ¶ˆï¼š30åˆ†é’Ÿæœªæ”¯ä»˜è‡ªåŠ¨å–æ¶ˆ
2. ä¼˜æƒ åˆ¸è¿‡æœŸï¼šåˆ°æœŸè‡ªåŠ¨å¤±æ•ˆ
3. ä¼šè®®æé†’ï¼šä¼šè®®å‰15åˆ†é’Ÿæé†’
4. å»¶è¿Ÿæ¶ˆæ¯ï¼šå®šæ—¶å‘é€æ¶ˆæ¯
5. é‡è¯•æœºåˆ¶ï¼šå¤±è´¥åå»¶è¿Ÿé‡è¯•
```

---

## ğŸ“š æ‰©å±•é˜…è¯»

1. [Kafkaæ—¶é—´è½®å®ç°](https://www.confluent.io/blog/apache-kafka-purgatory-hierarchical-timing-wheels/)
2. [Nettyæ—¶é—´è½®HashedWheelTimer](https://netty.io/4.1/api/io/netty/util/HashedWheelTimer.html)

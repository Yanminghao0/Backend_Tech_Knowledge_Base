## è§£é‡Šå™¨æ¨¡å¼ (Interpreter Pattern)

### æ¦‚è¿°
è§£é‡Šå™¨æ¨¡å¼ï¼ˆInterpreter Patternï¼‰æä¾›äº†ä¸€ç§è§£é‡Šè¯­è¨€çš„è¯­æ³•æˆ–è¡¨è¾¾å¼çš„æ–¹å¼ï¼Œå®ƒå±äºè¡Œä¸ºå‹æ¨¡å¼ã€‚è¿™ç§æ¨¡å¼å®ç°äº†ä¸€ä¸ªè¡¨è¾¾å¼æ¥å£ï¼Œè¯¥æ¥å£è§£é‡Šä¸€ä¸ªç‰¹å®šçš„ä¸Šä¸‹æ–‡ã€‚è§£é‡Šå™¨æ¨¡å¼é€šå¸¸è¢«ç”¨åœ¨SQLè§£æã€ç¬¦å·å¤„ç†å¼•æ“ç­‰åœºæ™¯ã€‚

## ğŸ¯ æ¨¡å¼æ„å›¾

**æ ¸å¿ƒæ€æƒ³**ï¼šç»™å®šä¸€ä¸ªè¯­è¨€ï¼Œå®šä¹‰å®ƒçš„æ–‡æ³•çš„ä¸€ç§è¡¨ç¤ºï¼Œå¹¶å®šä¹‰ä¸€ä¸ªè§£é‡Šå™¨ï¼Œè¿™ä¸ªè§£é‡Šå™¨ä½¿ç”¨è¯¥è¡¨ç¤ºæ¥è§£é‡Šè¯­è¨€ä¸­çš„å¥å­ã€‚

**è§£å†³çš„é—®é¢˜**ï¼š
- å¦‚ä½•ä¸ºç®€å•çš„è¯­è¨€å®šä¹‰è¯­æ³•è§£é‡Šå™¨
- å¦‚ä½•å°†è¯­æ³•è§„åˆ™è¡¨ç¤ºä¸ºå¯¹è±¡
- å¦‚ä½•è§£é‡Šå¥å­å¹¶æ‰§è¡Œç›¸åº”æ“ä½œ
- å¦‚ä½•å¤„ç†è¯­æ³•è§„åˆ™çš„ç»„åˆå’ŒåµŒå¥—

**é€‚ç”¨åœºæ™¯**ï¼š
- ğŸ“ **ç¼–ç¨‹è¯­è¨€è§£é‡Šå™¨**ï¼šå¦‚SQLè§£æå™¨ã€è¡¨è¾¾å¼è®¡ç®—å™¨
- ğŸ”¤ **æ­£åˆ™è¡¨è¾¾å¼å¤„ç†**ï¼šæ¨¡å¼åŒ¹é…å’Œæ–‡æœ¬åˆ†æ
- ğŸ§® **å…¬å¼è§£æ**ï¼šæ•°å­¦è¡¨è¾¾å¼è®¡ç®—
- ğŸ“Š **æŠ¥è¡¨ç”Ÿæˆå™¨**ï¼šè‡ªå®šä¹‰æŠ¥è¡¨æ¨¡æ¿è§£æ
- âš™ï¸ **é…ç½®æ–‡ä»¶è§£æ**ï¼šç‰¹å®šæ ¼å¼çš„é…ç½®æ–‡ä»¶è§£é‡Š
- ğŸ“± **é¢†åŸŸç‰¹å®šè¯­è¨€(DSL)**ï¼šä¸ºç‰¹å®šé¢†åŸŸè®¾è®¡çš„ç®€å•è¯­è¨€
- ğŸš¦ **è§„åˆ™å¼•æ“**ï¼šä¸šåŠ¡è§„åˆ™çš„å®šä¹‰å’Œæ‰§è¡Œ

## ğŸ—ï¸ UMLç±»å›¾

```mermaid
classDiagram
    class AbstractExpression {
        <<abstract>>
        +interpret(context: Context): Object
    }
    class TerminalExpression {
        +interpret(context: Context): Object
    }
    class NonterminalExpression {
        -expressions: AbstractExpression[]
        +interpret(context: Context): Object
    }
    class Context {
        -input: String
        -output: Object
        +getInput(): String
        +setInput(input: String): void
        +getOutput(): Object
        +setOutput(output: Object): void
    }
    class Client {
    }

    AbstractExpression <|-- TerminalExpression
    AbstractExpression <|-- NonterminalExpression
    NonterminalExpression o-- AbstractExpression : expressions
    Client --> AbstractExpression
    Client --> Context
    AbstractExpression --> Context
```

**æ ¸å¿ƒè§’è‰²**ï¼š
- **AbstractExpressionï¼ˆæŠ½è±¡è¡¨è¾¾å¼ï¼‰**ï¼šå£°æ˜ä¸€ä¸ªæŠ½è±¡çš„è§£é‡Šæ“ä½œï¼Œè¿™ä¸ªæ¥å£ä¸ºæŠ½è±¡è¯­æ³•æ ‘ä¸­æ‰€æœ‰çš„èŠ‚ç‚¹æ‰€å…±äº«
- **TerminalExpressionï¼ˆç»ˆç»“ç¬¦è¡¨è¾¾å¼ï¼‰**ï¼šå®ç°ä¸æ–‡æ³•ä¸­çš„ç»ˆç»“ç¬¦ç›¸å…³è”çš„è§£é‡Šæ“ä½œ
- **NonterminalExpressionï¼ˆéç»ˆç»“ç¬¦è¡¨è¾¾å¼ï¼‰**ï¼šä¸ºæ–‡æ³•ä¸­çš„éç»ˆç»“ç¬¦å®ç°è§£é‡Šæ“ä½œ
- **Contextï¼ˆä¸Šä¸‹æ–‡ï¼‰**ï¼šåŒ…å«è§£é‡Šå™¨ä¹‹å¤–çš„ä¸€äº›å…¨å±€ä¿¡æ¯
- **Clientï¼ˆå®¢æˆ·ç«¯ï¼‰**ï¼šæ„å»ºè¡¨ç¤ºè¯¥æ–‡æ³•å®šä¹‰çš„è¯­è¨€ä¸­ä¸€ä¸ªç‰¹å®šå¥å­çš„æŠ½è±¡è¯­æ³•æ ‘ï¼Œè°ƒç”¨è§£é‡Šæ“ä½œ

**è§£é‡Šå™¨æ¨¡å¼å˜ä½“**ï¼š
1. **è¯­æ³•å¯¼å‘è§£é‡Šå™¨**ï¼šåŸºäºè¯­æ³•è§„åˆ™çš„è§£é‡Šå™¨
2. **æ ‘çŠ¶è§£é‡Šå™¨**ï¼šä½¿ç”¨æŠ½è±¡è¯­æ³•æ ‘(AST)è¿›è¡Œè§£é‡Š
3. **ç»„åˆè§£é‡Šå™¨**ï¼šç»“åˆç»„åˆæ¨¡å¼çš„è§£é‡Šå™¨
4. **é€’å½’ä¸‹é™è§£é‡Šå™¨**ï¼šé€šè¿‡é€’å½’å®ç°çš„è§£é‡Šå™¨
5. **è¡¨é©±åŠ¨è§£é‡Šå™¨**ï¼šä½¿ç”¨è¡¨æ ¼å®šä¹‰è¯­æ³•è§„åˆ™

## ğŸ’» ä»£ç å®ç°

### 1. åŸºç¡€å®ç°ï¼ˆç®€å•åŠ å‡è¡¨è¾¾å¼ï¼‰

```java
// ä¸Šä¸‹æ–‡ç±»
public class Context {
    private String input;
    private int output;

    public Context(String input) {
        this.input = input;
    }

    public String getInput() { return input; }
    public void setInput(String input) { this.input = input; }
    public int getOutput() { return output; }
    public void setOutput(int output) { this.output = output; }
}

// æŠ½è±¡è¡¨è¾¾å¼
public abstract class AbstractExpression {
    public abstract void interpret(Context context);
}

// æ•°å­—è¡¨è¾¾å¼ï¼ˆç»ˆç»“ç¬¦è¡¨è¾¾å¼ï¼‰
public class NumberExpression extends AbstractExpression {
    @Override
    public void interpret(Context context) {
        String input = context.getInput();
        StringBuilder numBuilder = new StringBuilder();
        
        // æå–æ•°å­—
        for (int i = 0; i < input.length(); i++) {
            char c = input.charAt(i);
            if (Character.isDigit(c)) {
                numBuilder.append(c);
            } else {
                break;
            }
        }
        
        context.setOutput(Integer.parseInt(numBuilder.toString()));
        context.setInput(input.substring(numBuilder.length()));
    }
}

// åŠ æ³•è¡¨è¾¾å¼ï¼ˆéç»ˆç»“ç¬¦è¡¨è¾¾å¼ï¼‰
public class AddExpression extends AbstractExpression {
    private AbstractExpression left;
    private AbstractExpression right;

    public AddExpression(AbstractExpression left, AbstractExpression right) {
        this.left = left;
        this.right = right;
    }

    @Override
    public void interpret(Context context) {
        left.interpret(context);
        int leftValue = context.getOutput();
        
        right.interpret(context);
        int rightValue = context.getOutput();
        
        context.setOutput(leftValue + rightValue);
    }
}

// å‡æ³•è¡¨è¾¾å¼ï¼ˆéç»ˆç»“ç¬¦è¡¨è¾¾å¼ï¼‰
public class SubtractExpression extends AbstractExpression {
    private AbstractExpression left;
    private AbstractExpression right;

    public SubtractExpression(AbstractExpression left, AbstractExpression right) {
        this.left = left;
        this.right = right;
    }

    @Override
    public void interpret(Context context) {
        left.interpret(context);
        int leftValue = context.getOutput();
        
        right.interpret(context);
        int rightValue = context.getOutput();
        
        context.setOutput(leftValue - rightValue);
    }
}

// å®¢æˆ·ç«¯ä»£ç 
public class Client {
    public static void main(String[] args) {
        // æ„å»ºæŠ½è±¡è¯­æ³•æ ‘: 1 + 2 - 3
        AbstractExpression expression = new SubtractExpression(
            new AddExpression(
                new NumberExpression(),
                new NumberExpression()
            ),
            new NumberExpression()
        );

        Context context = new Context("1+2-3");
        expression.interpret(context);
        System.out.println("è®¡ç®—ç»“æœ: " + context.getOutput()); // è¾“å‡º: 0

        context = new Context("10+20-5");
        expression.interpret(context);
        System.out.println("è®¡ç®—ç»“æœ: " + context.getOutput()); // è¾“å‡º: 25
    }
}
```

### 2. é«˜çº§å®ç°ï¼ˆç®—æœ¯è¡¨è¾¾å¼è®¡ç®—å™¨ï¼‰

```java
// è¡¨è¾¾å¼æ¥å£
public interface Expression {
    int interpret(Context context);
}

// æ•°å­—è¡¨è¾¾å¼
public class Number implements Expression {
    private int number;

    public Number(int number) {
        this.number = number;
    }

    public Number(String number) {
        this.number = Integer.parseInt(number);
    }

    @Override
    public int interpret(Context context) {
        return number;
    }
}

// å˜é‡è¡¨è¾¾å¼
public class Variable implements Expression {
    private String name;

    public Variable(String name) {
        this.name = name;
    }

    @Override
    public int interpret(Context context) {
        return context.lookup(this);
    }

    public String getName() {
        return name;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Variable variable = (Variable) o;
        return Objects.equals(name, variable.name);
    }

    @Override
    public int hashCode() {
        return Objects.hash(name);
    }
}

// åŠ æ³•è¡¨è¾¾å¼
public class Add implements Expression {
    private Expression leftExpression;
    private Expression rightExpression;

    public Add(Expression leftExpression, Expression rightExpression) {
        this.leftExpression = leftExpression;
        this.rightExpression = rightExpression;
    }

    @Override
    public int interpret(Context context) {
        return leftExpression.interpret(context) + rightExpression.interpret(context);
    }
}

// å‡æ³•è¡¨è¾¾å¼
public class Subtract implements Expression {
    private Expression leftExpression;
    private Expression rightExpression;

    public Subtract(Expression leftExpression, Expression rightExpression) {
        this.leftExpression = leftExpression;
        this.rightExpression = rightExpression;
    }

    @Override
    public int interpret(Context context) {
        return leftExpression.interpret(context) - rightExpression.interpret(context);
    }
}

// ä¹˜æ³•è¡¨è¾¾å¼
public class Multiply implements Expression {
    private Expression leftExpression;
    private Expression rightExpression;

    public Multiply(Expression leftExpression, Expression rightExpression) {
        this.leftExpression = leftExpression;
        this.rightExpression = rightExpression;
    }

    @Override
    public int interpret(Context context) {
        return leftExpression.interpret(context) * rightExpression.interpret(context);
    }
}

// é™¤æ³•è¡¨è¾¾å¼
public class Divide implements Expression {
    private Expression leftExpression;
    private Expression rightExpression;

    public Divide(Expression leftExpression, Expression rightExpression) {
        this.leftExpression = leftExpression;
        this.rightExpression = rightExpression;
    }

    @Override
    public int interpret(Context context) {
        int divisor = rightExpression.interpret(context);
        if (divisor == 0) {
            throw new ArithmeticException("Division by zero");
        }
        return leftExpression.interpret(context) / divisor;
    }
}

// ä¸Šä¸‹æ–‡ç±»
public class Context {
    private Map<Variable, Integer> variables = new HashMap<>();

    public int lookup(Variable variable) {
        return variables.getOrDefault(variable, 0);
    }

    public void assign(Variable variable, int value) {
        variables.put(variable, value);
    }
}

// è¡¨è¾¾å¼è§£æå™¨
public class ExpressionParser {
    private String expression;
    private int index;

    public Expression parse(String expression) {
        this.expression = expression;
        this.index = 0;
        return parseExpression();
    }

    private Expression parseExpression() {
        Expression left = parseTerm();
        while (index < expression.length()) {
            char operator = expression.charAt(index);
            if (operator == '+' || operator == '-') {
                index++;
                Expression right = parseTerm();
                if (operator == '+') {
                    left = new Add(left, right);
                } else {
                    left = new Subtract(left, right);
                }
            } else {
                break;
            }
        }
        return left;
    }

    private Expression parseTerm() {
        Expression left = parseFactor();
        while (index < expression.length()) {
            char operator = expression.charAt(index);
            if (operator == '*' || operator == '/') {
                index++;
                Expression right = parseFactor();
                if (operator == '*') {
                    left = new Multiply(left, right);
                } else {
                    left = new Divide(left, right);
                }
            } else {
                break;
            }
        }
        return left;
    }

    private Expression parseFactor() {
        skipWhitespace();
        if (index >= expression.length()) {
            throw new IllegalArgumentException("Unexpected end of expression");
        }

        char c = expression.charAt(index);
        if (Character.isDigit(c)) {
            return parseNumber();
        } else if (Character.isLetter(c)) {
            return parseVariable();
        } else if (c == '(') {
            index++;
            Expression expr = parseExpression();
            skipWhitespace();
            if (index >= expression.length() || expression.charAt(index) != ')') {
                throw new IllegalArgumentException("Mismatched parentheses");
            }
            index++;
            return expr;
        } else {
            throw new IllegalArgumentException("Unexpected character: " + c);
        }
    }

    private Number parseNumber() {
        int start = index;
        while (index < expression.length() && Character.isDigit(expression.charAt(index))) {
            index++;
        }
        return new Number(expression.substring(start, index));
    }

    private Variable parseVariable() {
        int start = index;
        while (index < expression.length() && Character.isLetter(expression.charAt(index))) {
            index++;
        }
        return new Variable(expression.substring(start, index));
    }

    private void skipWhitespace() {
        while (index < expression.length() && Character.isWhitespace(expression.charAt(index))) {
            index++;
        }
    }
}

// é«˜çº§è®¡ç®—å™¨å®¢æˆ·ç«¯
public class CalculatorClient {
    public static void main(String[] args) {
        // ç®€å•è¡¨è¾¾å¼è®¡ç®—
        ExpressionParser parser = new ExpressionParser();
        Expression expr = parser.parse("10 + 20 * 3 - 15");
        System.out.println("10 + 20 * 3 - 15 = " + expr.interpret(new Context())); // è¾“å‡º: 55

        // å¸¦å˜é‡çš„è¡¨è¾¾å¼
        Context context = new Context();
        context.assign(new Variable("x"), 10);
        context.assign(new Variable("y"), 5);

        Expression variableExpr = parser.parse("x * (y + 3)");
        System.out.println("x * (y + 3) = " + variableExpr.interpret(context)); // è¾“å‡º: 80

        // å¤æ‚è¡¨è¾¾å¼
        Expression complexExpr = parser.parse("(100 / 2 + 30) * (5 - 2)");
        System.out.println("(100 / 2 + 30) * (5 - 2) = " + complexExpr.interpret(new Context())); // è¾“å‡º: 240
    }
}
```

## ğŸ” æºç åº”ç”¨

### Javaä¸­çš„è§£é‡Šå™¨æ¨¡å¼
- **`java.util.Pattern`**ï¼šæ­£åˆ™è¡¨è¾¾å¼è§£é‡Šå™¨
- **`java.text.Format`**ï¼šæ ¼å¼åŒ–è§£é‡Šå™¨
- **`java.text.SimpleDateFormat`**ï¼šæ—¥æœŸæ ¼å¼åŒ–è§£é‡Šå™¨
- **`javax.el.ELResolver`**ï¼šELè¡¨è¾¾å¼è§£æå™¨

```java
// Javaæ­£åˆ™è¡¨è¾¾å¼ç¤ºä¾‹ (è§£é‡Šå™¨æ¨¡å¼åº”ç”¨)
public class JavaRegexExample {
    public static void main(String[] args) {
        String text = "Hello, my email is example@test.com and another is test@example.org";
        String pattern = "[A-Za-z0-9+_.-]+@[A-Za-z0-9.-]+",

        // åˆ›å»ºè§£é‡Šå™¨
        Pattern emailPattern = Pattern.compile(pattern);
        Matcher matcher = emailPattern.matcher(text);

        // è§£é‡Šå¹¶åŒ¹é…
        System.out.println("æ‰¾åˆ°çš„é‚®ç®±åœ°å€:");
        while (matcher.find()) {
            System.out.println(matcher.group());
        }
    }
}
```

### Springæ¡†æ¶ä¸­çš„åº”ç”¨
- **`org.springframework.expression.ExpressionParser`**ï¼šSpringè¡¨è¾¾å¼è¯­è¨€(SpEL)è§£æå™¨
- **`org.springframework.expression.spel.standard.SpelExpressionParser`**ï¼šSpELè¡¨è¾¾å¼è§£æå®ç°
- **`org.springframework.expression.EvaluationContext`**ï¼šè¡¨è¾¾å¼è®¡ç®—ä¸Šä¸‹æ–‡

```java
// Spring SpELç¤ºä¾‹
public class SpringSpelExample {
    public static void main(String[] args) {
        // åˆ›å»ºSpELè§£é‡Šå™¨
        ExpressionParser parser = new SpelExpressionParser();
        EvaluationContext context = new StandardEvaluationContext();

        // ç®€å•è¡¨è¾¾å¼
        Expression exp = parser.parseExpression("'Hello World'.concat('!')");
        String message = (String) exp.getValue();
        System.out.println(message); // è¾“å‡º: Hello World!

        // æ•°å­¦è¡¨è¾¾å¼
        exp = parser.parseExpression("100 * 2 + 300");
        int result = (Integer) exp.getValue();
        System.out.println(result); // è¾“å‡º: 500

        // è®¾ç½®å˜é‡
        context.setVariable("name", "Spring");
        exp = parser.parseExpression("'Hello ' + #name");
        message = (String) exp.getValue(context);
        System.out.println(message); // è¾“å‡º: Hello Spring

        // è°ƒç”¨æ–¹æ³•
        exp = parser.parseExpression("'hello'.toUpperCase()");
        message = (String) exp.getValue();
        System.out.println(message); // è¾“å‡º: HELLO
    }
}
```

### å…¶ä»–æ¡†æ¶ä¸­çš„åº”ç”¨
- **OGNL**ï¼šå¯¹è±¡å›¾å¯¼èˆªè¯­è¨€ï¼Œç”¨äºStruts2ç­‰æ¡†æ¶
- **MVEL**ï¼šä¸€ç§è¡¨è¾¾å¼è¯­è¨€ï¼Œç”¨äºè§„åˆ™å¼•æ“
- **JEXL**ï¼šApache Commons JEXLè¡¨è¾¾å¼è¯­è¨€
- **Thymeleaf**ï¼šæ¨¡æ¿å¼•æ“ä¸­çš„è¡¨è¾¾å¼è§£æ
- **MyBatis**ï¼šåŠ¨æ€SQLä¸­çš„è¡¨è¾¾å¼è§£æ
- **Elasticsearch**ï¼šæŸ¥è¯¢DSLè§£æ

## âš ï¸ æ³¨æ„äº‹é¡¹

1. **å¤æ‚æ€§é—®é¢˜**ï¼šè§£é‡Šå™¨æ¨¡å¼å®¹æ˜“å¯¼è‡´ç±»è†¨èƒ€ï¼Œæ–‡æ³•è§„åˆ™è¶Šå¤šï¼Œéœ€è¦çš„ç±»å°±è¶Šå¤š

2. **æ•ˆç‡é—®é¢˜**ï¼šè§£é‡Šå™¨æ¨¡å¼é€šå¸¸ä½¿ç”¨é€’å½’è°ƒç”¨ï¼Œæ•ˆç‡è¾ƒä½

3. **å¯ç»´æŠ¤æ€§**ï¼šå¤æ‚æ–‡æ³•éš¾ä»¥ç»´æŠ¤å’Œè°ƒè¯•

4. **é€‚ç”¨èŒƒå›´æœ‰é™**ï¼šåªé€‚ç”¨äºç®€å•çš„æ–‡æ³•è¡¨ç¤º

5. **å¾ªç¯ä¾èµ–**ï¼šå¯èƒ½å¯¼è‡´è¡¨è¾¾å¼ä¹‹é—´çš„å¾ªç¯ä¾èµ–

6. **é”™è¯¯å¤„ç†**ï¼šé”™è¯¯å®šä½å’Œå¤„ç†æ¯”è¾ƒå›°éš¾

7. **æ‰©å±•æ€§**ï¼šæ·»åŠ æ–°çš„æ–‡æ³•è§„åˆ™éœ€è¦æ·»åŠ æ–°çš„ç±»

8. **å®‰å…¨æ€§**ï¼šåŠ¨æ€è§£æè¡¨è¾¾å¼å¯èƒ½å¸¦æ¥å®‰å…¨é£é™©

## ğŸ“ æœ€ä½³å®è·µ

1. **ä½¿ç”¨ç»„åˆæ¨¡å¼**ï¼šç»“åˆç»„åˆæ¨¡å¼æ„å»ºæŠ½è±¡è¯­æ³•æ ‘

2. **ä½¿ç”¨å·¥å‚æ–¹æ³•**ï¼šåˆ›å»ºè¡¨è¾¾å¼å¯¹è±¡

```java
public class ExpressionFactory {
    public static Expression createExpression(String type, Expression... expressions) {
        switch (type) {
            case "+": return new Add(expressions[0], expressions[1]);
            case "-": return new Subtract(expressions[0], expressions[1]);
            case "*": return new Multiply(expressions[0], expressions[1]);
            case "/": return new Divide(expressions[0], expressions[1]);
            default: throw new IllegalArgumentException("Unknown operator: " + type);
        }
    }
}
```

3. **ä½¿ç”¨è®¿é—®è€…æ¨¡å¼**ï¼šä¸ºè¡¨è¾¾å¼æ·»åŠ æ–°çš„æ“ä½œè€Œä¸ä¿®æ”¹è¡¨è¾¾å¼ç±»

4. **ç¼“å­˜è¡¨è¾¾å¼**ï¼šå¯¹äºé¢‘ç¹ä½¿ç”¨çš„è¡¨è¾¾å¼è¿›è¡Œç¼“å­˜

5. **é™åˆ¶é€‚ç”¨èŒƒå›´**ï¼šåªåœ¨ç®€å•æ–‡æ³•åœºæ™¯ä¸‹ä½¿ç”¨

6. **æä¾›è‰¯å¥½çš„é”™è¯¯ä¿¡æ¯**ï¼šè§£æé”™è¯¯æ—¶æä¾›è¯¦ç»†çš„é”™è¯¯ä½ç½®å’ŒåŸå› 

7. **ä½¿ç”¨å•å…ƒæµ‹è¯•**ï¼šä¸ºæ¯ç§è¡¨è¾¾å¼ç±»å‹ç¼–å†™å•å…ƒæµ‹è¯•

8. **è€ƒè™‘ä½¿ç”¨ç°æœ‰è§£æå™¨**ï¼šä¼˜å…ˆä½¿ç”¨æˆç†Ÿçš„è§£æå™¨åº“è€Œéè‡ªå·±å®ç°

9. **ä½¿ç”¨æ„å»ºå™¨æ¨¡å¼**ï¼šæ„å»ºå¤æ‚çš„è¡¨è¾¾å¼å¯¹è±¡

10. **å®ç°è¡¨è¾¾å¼ä¼˜åŒ–**ï¼šå¯¹è¡¨è¾¾å¼è¿›è¡Œè¯­æ³•ä¼˜åŒ–

## ğŸ“š ç›¸å…³æ¨¡å¼

- **ç»„åˆæ¨¡å¼**ï¼šè§£é‡Šå™¨æ¨¡å¼çš„æŠ½è±¡è¯­æ³•æ ‘æ˜¯ç»„åˆæ¨¡å¼çš„åº”ç”¨
- **å·¥å‚æ–¹æ³•æ¨¡å¼**ï¼šç”¨äºåˆ›å»ºè¡¨è¾¾å¼å¯¹è±¡
- **è®¿é—®è€…æ¨¡å¼**ï¼šå¯ä»¥åœ¨ä¸æ”¹å˜è¡¨è¾¾å¼ç±»çš„æƒ…å†µä¸‹æ·»åŠ æ–°çš„æ“ä½œ
- **è¿­ä»£å™¨æ¨¡å¼**ï¼šéå†æŠ½è±¡è¯­æ³•æ ‘
- **å¤‡å¿˜å½•æ¨¡å¼**ï¼šä¿å­˜å’Œæ¢å¤è¡¨è¾¾å¼çš„çŠ¶æ€
- **ç­–ç•¥æ¨¡å¼**ï¼šä¸åŒçš„è§£é‡Šç­–ç•¥
- **æ¨¡æ¿æ–¹æ³•æ¨¡å¼**ï¼šå®šä¹‰è§£é‡Šçš„éª¨æ¶
- **è£…é¥°å™¨æ¨¡å¼**ï¼šä¸ºè¡¨è¾¾å¼æ·»åŠ é¢å¤–åŠŸèƒ½
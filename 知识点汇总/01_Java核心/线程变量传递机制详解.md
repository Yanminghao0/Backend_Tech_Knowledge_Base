# çº¿ç¨‹å˜é‡ä¼ é€’æœºåˆ¶è¯¦è§£

## ç›®å½•
- [1. æ ¸å¿ƒæ¦‚å¿µ](#1-æ ¸å¿ƒæ¦‚å¿µ)
- [2. ThreadLocal åŸºç¡€](#2-threadlocal-åŸºç¡€)
- [3. InheritableThreadLocal çˆ¶å­çº¿ç¨‹ä¼ é€’](#3-inheritablethreadlocal-çˆ¶å­çº¿ç¨‹ä¼ é€’)
- [4. çº¿ç¨‹æ± åœºæ™¯çš„é—®é¢˜](#4-çº¿ç¨‹æ± åœºæ™¯çš„é—®é¢˜)
- [5. TransmittableThreadLocal è§£å†³æ–¹æ¡ˆ](#5-transmittablethreadlocal-è§£å†³æ–¹æ¡ˆ)
- [6. å®æˆ˜æ¡ˆä¾‹](#6-å®æˆ˜æ¡ˆä¾‹)
- [7. æœ€ä½³å®è·µ](#7-æœ€ä½³å®è·µ)

---

## 1. æ ¸å¿ƒæ¦‚å¿µ

### 1.1 ç›´æ¥å›ç­”æ ¸å¿ƒé—®é¢˜

#### â“ å­çº¿ç¨‹èƒ½è·å–çˆ¶çº¿ç¨‹çš„çº¿ç¨‹å˜é‡å—ï¼Ÿ

**ç­”æ¡ˆå–å†³äºä¸‰ä¸ªå› ç´ **ï¼š

1. **ä½¿ç”¨ä»€ä¹ˆç±»å‹çš„ ThreadLocal**
2. **å¦‚ä½•åˆ›å»ºå­çº¿ç¨‹**ï¼ˆnew Thread è¿˜æ˜¯çº¿ç¨‹æ± ï¼‰
3. **çº¿ç¨‹æ± æ˜¯å¦ç»è¿‡ TTL è£…é¥°**

#### ğŸ“‹ å®Œæ•´ç­”æ¡ˆè¡¨

| çˆ¶çº¿ç¨‹å˜é‡ç±»å‹ | å­çº¿ç¨‹åˆ›å»ºæ–¹å¼ | èƒ½å¦è·å– | è¯´æ˜ |
|--------------|--------------|---------|------|
| **ThreadLocal** | new Thread() | âŒ **å¦** | å®Œå…¨éš”ç¦» |
| **ThreadLocal** | çº¿ç¨‹æ±  | âŒ **å¦** | å®Œå…¨éš”ç¦» |
| **InheritableThreadLocal** | new Thread() | âœ… **æ˜¯** | åˆ›å»ºæ—¶å¤åˆ¶ |
| **InheritableThreadLocal** | çº¿ç¨‹æ± ï¼ˆæœªè£…é¥°ï¼‰ | âŒ **å¦** | çº¿ç¨‹å¤ç”¨å¯¼è‡´å¤±æ•ˆ |
| **InheritableThreadLocal** | çº¿ç¨‹æ± ï¼ˆTTLè£…é¥°ï¼‰ | âŒ **å¦** | åªå¯¹ TTL ç”Ÿæ•ˆ |
| **TransmittableThreadLocal** | new Thread() | âœ… **æ˜¯** | ç»§æ‰¿è‡ª InheritableThreadLocal |
| **TransmittableThreadLocal** | çº¿ç¨‹æ± ï¼ˆæœªè£…é¥°ï¼‰ | âŒ **å¦** | éœ€è¦è£…é¥° |
| **TransmittableThreadLocal** | çº¿ç¨‹æ± ï¼ˆTTLè£…é¥°ï¼‰ | âœ… **æ˜¯** | å®Œç¾æ”¯æŒ âœ¨ |

### 1.2 ä¸‰ç§çº¿ç¨‹å˜é‡è¯¦è§£

```java
/**
 * çº¿ç¨‹å˜é‡çš„ä¸‰ç§ç±»å‹ - è¯¦ç»†å¯¹æ¯”
 */

// ============ ç±»å‹1: ThreadLocal ============
// ç‰¹ç‚¹ï¼šçº¿ç¨‹éš”ç¦»ï¼Œçˆ¶å­çº¿ç¨‹ä¸å…±äº«
ThreadLocal<String> threadLocal = new ThreadLocal<>();

// ç¤ºä¾‹
threadLocal.set("çˆ¶çº¿ç¨‹çš„å€¼");
new Thread(() -> {
    System.out.println(threadLocal.get()); // è¾“å‡º: null âŒ
}).start();

// ============ ç±»å‹2: InheritableThreadLocal ============
// ç‰¹ç‚¹ï¼šåˆ›å»ºå­çº¿ç¨‹æ—¶ï¼Œä¼šå¤åˆ¶çˆ¶çº¿ç¨‹çš„å€¼
InheritableThreadLocal<String> inheritableThreadLocal = new InheritableThreadLocal<>();

// ç¤ºä¾‹1ï¼šnew Thread() - âœ… æœ‰æ•ˆ
inheritableThreadLocal.set("çˆ¶çº¿ç¨‹çš„å€¼");
new Thread(() -> {
    System.out.println(inheritableThreadLocal.get()); // è¾“å‡º: çˆ¶çº¿ç¨‹çš„å€¼ âœ…
}).start();

// ç¤ºä¾‹2ï¼šçº¿ç¨‹æ±  - âŒ å¤±æ•ˆ
ExecutorService pool = Executors.newFixedThreadPool(1);
inheritableThreadLocal.set("ç¬¬ä¸€æ¬¡è¯·æ±‚");
pool.submit(() -> {
    System.out.println(inheritableThreadLocal.get()); // è¾“å‡º: ç¬¬ä¸€æ¬¡è¯·æ±‚ âœ…
});

inheritableThreadLocal.set("ç¬¬äºŒæ¬¡è¯·æ±‚");
pool.submit(() -> {
    System.out.println(inheritableThreadLocal.get()); // è¾“å‡º: ç¬¬ä¸€æ¬¡è¯·æ±‚ âŒ é”™è¯¯ï¼
});

// ============ ç±»å‹3: TransmittableThreadLocal (TTL) ============
// ç‰¹ç‚¹ï¼šè§£å†³çº¿ç¨‹æ± å¤ç”¨å¯¼è‡´çš„ä¼ é€’å¤±æ•ˆé—®é¢˜
// éœ€è¦å¼•å…¥ä¾èµ–ï¼šcom.alibaba:transmittable-thread-local
import com.alibaba.ttl.TransmittableThreadLocal;
import com.alibaba.ttl.threadpool.TtlExecutors;

TransmittableThreadLocal<String> ttl = new TransmittableThreadLocal<>();

// ç¤ºä¾‹ï¼šçº¿ç¨‹æ±  - âœ… æœ‰æ•ˆï¼ˆéœ€è¦è£…é¥°ï¼‰
ExecutorService rawPool = Executors.newFixedThreadPool(1);
ExecutorService ttlPool = TtlExecutors.getTtlExecutorService(rawPool); // âš ï¸ å…³é”®

ttl.set("ç¬¬ä¸€æ¬¡è¯·æ±‚");
ttlPool.submit(() -> {
    System.out.println(ttl.get()); // è¾“å‡º: ç¬¬ä¸€æ¬¡è¯·æ±‚ âœ…
});

ttl.set("ç¬¬äºŒæ¬¡è¯·æ±‚");
ttlPool.submit(() -> {
    System.out.println(ttl.get()); // è¾“å‡º: ç¬¬äºŒæ¬¡è¯·æ±‚ âœ… æ­£ç¡®ï¼
});
```

### 1.3 å¯¹æ¯”æ€»ç»“

| ç±»å‹ | çº¿ç¨‹éš”ç¦» | çˆ¶å­ä¼ é€’ | çº¿ç¨‹æ± æ”¯æŒ | ä½¿ç”¨åœºæ™¯ |
|------|---------|---------|-----------|---------|
| **ThreadLocal** | âœ… | âŒ | âŒ | å•çº¿ç¨‹å†…å…±äº«æ•°æ® |
| **InheritableThreadLocal** | âœ… | âœ… | âŒ | çˆ¶å­çº¿ç¨‹ä¼ é€’ï¼ˆnew Threadï¼‰ |
| **TransmittableThreadLocal** | âœ… | âœ… | âœ… | çº¿ç¨‹æ± åœºæ™¯ä¼ é€’ |

### 1.4 å„ç§åœºæ™¯ä¸‹çš„å…·ä½“è¡¨ç°

ä¸‹é¢é€šè¿‡è¯¦ç»†çš„ç¤ºä¾‹ä»£ç ï¼Œå±•ç¤ºæ¯ç§çº¿ç¨‹å˜é‡åœ¨ä¸åŒåœºæ™¯ä¸‹çš„è¡¨ç°ï¼š

```java
/**
 * åœºæ™¯å…¨æ™¯å›¾ï¼šå­çº¿ç¨‹èƒ½å¦è·å–çˆ¶çº¿ç¨‹å˜é‡ï¼Ÿ
 */
public class ThreadLocalScenarios {
    
    // ä¸‰ç§ç±»å‹çš„çº¿ç¨‹å˜é‡
    private static ThreadLocal<String> tl = new ThreadLocal<>();
    private static InheritableThreadLocal<String> itl = new InheritableThreadLocal<>();
    private static TransmittableThreadLocal<String> ttl = new TransmittableThreadLocal<>();
    
    public static void main(String[] args) throws Exception {
        // åœºæ™¯1: ç›´æ¥ new Thread
        scenario1_NewThread();
        
        // åœºæ™¯2: çº¿ç¨‹æ± ï¼ˆæœªè£…é¥°ï¼‰
        scenario2_ThreadPool_NotDecorated();
        
        // åœºæ™¯3: çº¿ç¨‹æ± ï¼ˆTTLè£…é¥°ï¼‰
        scenario3_ThreadPool_Decorated();
        
        // åœºæ™¯4: CompletableFuture
        scenario4_CompletableFuture();
        
        // åœºæ™¯5: Stream å¹¶è¡Œæµ
        scenario5_ParallelStream();
        
        // åœºæ™¯6: ForkJoinPool
        scenario6_ForkJoinPool();
        
        // åœºæ™¯7: Spring @Async
        scenario7_SpringAsync();
        
        // åœºæ™¯8: å®šæ—¶ä»»åŠ¡ ScheduledExecutorService
        scenario8_ScheduledExecutor();
    }
    
    // ============ åœºæ™¯1: ç›´æ¥ new Thread ============
    static void scenario1_NewThread() {
        System.out.println("\n========== åœºæ™¯1: ç›´æ¥ new Thread ==========");
        
        // çˆ¶çº¿ç¨‹è®¾ç½®å€¼
        tl.set("TL-çˆ¶çº¿ç¨‹");
        itl.set("ITL-çˆ¶çº¿ç¨‹");
        ttl.set("TTL-çˆ¶çº¿ç¨‹");
        
        new Thread(() -> {
            System.out.println("ThreadLocal:             " + tl.get());   // null âŒ
            System.out.println("InheritableThreadLocal:  " + itl.get());  // ITL-çˆ¶çº¿ç¨‹ âœ…
            System.out.println("TransmittableThreadLocal: " + ttl.get()); // TTL-çˆ¶çº¿ç¨‹ âœ…
        }, "å­çº¿ç¨‹").start();
        
        Thread.sleep(100);
        
        // æ¸…ç†
        tl.remove();
        itl.remove();
        ttl.remove();
    }
    
    // è¾“å‡ºï¼š
    // ThreadLocal:             null                 âŒ æ— æ³•è·å–
    // InheritableThreadLocal:  ITL-çˆ¶çº¿ç¨‹           âœ… å¯ä»¥è·å–
    // TransmittableThreadLocal: TTL-çˆ¶çº¿ç¨‹          âœ… å¯ä»¥è·å–
    
    // ============ åœºæ™¯2: çº¿ç¨‹æ± ï¼ˆæœªè£…é¥°ï¼‰============
    static void scenario2_ThreadPool_NotDecorated() {
        System.out.println("\n========== åœºæ™¯2: çº¿ç¨‹æ± ï¼ˆæœªè£…é¥°ï¼‰==========");
        
        ExecutorService pool = Executors.newFixedThreadPool(1);
        
        // ç¬¬ä¸€æ¬¡è¯·æ±‚
        tl.set("TL-è¯·æ±‚1");
        itl.set("ITL-è¯·æ±‚1");
        ttl.set("TTL-è¯·æ±‚1");
        
        pool.submit(() -> {
            System.out.println("ã€è¯·æ±‚1ã€‘ThreadLocal:             " + tl.get());   // null âŒ
            System.out.println("ã€è¯·æ±‚1ã€‘InheritableThreadLocal:  " + itl.get());  // ITL-è¯·æ±‚1 âœ…
            System.out.println("ã€è¯·æ±‚1ã€‘TransmittableThreadLocal: " + ttl.get()); // null âŒ
        }).get();
        
        // ç¬¬äºŒæ¬¡è¯·æ±‚ï¼ˆçº¿ç¨‹å¤ç”¨ï¼‰
        tl.set("TL-è¯·æ±‚2");
        itl.set("ITL-è¯·æ±‚2");
        ttl.set("TTL-è¯·æ±‚2");
        
        pool.submit(() -> {
            System.out.println("ã€è¯·æ±‚2ã€‘ThreadLocal:             " + tl.get());   // null âŒ
            System.out.println("ã€è¯·æ±‚2ã€‘InheritableThreadLocal:  " + itl.get());  // ITL-è¯·æ±‚1 âŒ é”™è¯¯ï¼
            System.out.println("ã€è¯·æ±‚2ã€‘TransmittableThreadLocal: " + ttl.get()); // null âŒ
        }).get();
        
        pool.shutdown();
        tl.remove();
        itl.remove();
        ttl.remove();
    }
    
    // è¾“å‡ºï¼š
    // ã€è¯·æ±‚1ã€‘ThreadLocal:             null        âŒ
    // ã€è¯·æ±‚1ã€‘InheritableThreadLocal:  ITL-è¯·æ±‚1   âœ… ç¬¬ä¸€æ¬¡æ­£ç¡®
    // ã€è¯·æ±‚1ã€‘TransmittableThreadLocal: null       âŒ
    // ã€è¯·æ±‚2ã€‘ThreadLocal:             null        âŒ
    // ã€è¯·æ±‚2ã€‘InheritableThreadLocal:  ITL-è¯·æ±‚1   âŒ æ‹¿åˆ°çš„æ˜¯æ—§å€¼ï¼
    // ã€è¯·æ±‚2ã€‘TransmittableThreadLocal: null       âŒ
    
    // ============ åœºæ™¯3: çº¿ç¨‹æ± ï¼ˆTTLè£…é¥°ï¼‰============
    static void scenario3_ThreadPool_Decorated() {
        System.out.println("\n========== åœºæ™¯3: çº¿ç¨‹æ± ï¼ˆTTLè£…é¥°ï¼‰==========");
        
        ExecutorService rawPool = Executors.newFixedThreadPool(1);
        ExecutorService ttlPool = TtlExecutors.getTtlExecutorService(rawPool); // âš ï¸ è£…é¥°
        
        // ç¬¬ä¸€æ¬¡è¯·æ±‚
        tl.set("TL-è¯·æ±‚1");
        itl.set("ITL-è¯·æ±‚1");
        ttl.set("TTL-è¯·æ±‚1");
        
        ttlPool.submit(() -> {
            System.out.println("ã€è¯·æ±‚1ã€‘ThreadLocal:             " + tl.get());   // null âŒ
            System.out.println("ã€è¯·æ±‚1ã€‘InheritableThreadLocal:  " + itl.get());  // ITL-è¯·æ±‚1 âœ…
            System.out.println("ã€è¯·æ±‚1ã€‘TransmittableThreadLocal: " + ttl.get()); // TTL-è¯·æ±‚1 âœ…
        }).get();
        
        // ç¬¬äºŒæ¬¡è¯·æ±‚ï¼ˆçº¿ç¨‹å¤ç”¨ï¼‰
        tl.set("TL-è¯·æ±‚2");
        itl.set("ITL-è¯·æ±‚2");
        ttl.set("TTL-è¯·æ±‚2");
        
        ttlPool.submit(() -> {
            System.out.println("ã€è¯·æ±‚2ã€‘ThreadLocal:             " + tl.get());   // null âŒ
            System.out.println("ã€è¯·æ±‚2ã€‘InheritableThreadLocal:  " + itl.get());  // ITL-è¯·æ±‚1 âŒ
            System.out.println("ã€è¯·æ±‚2ã€‘TransmittableThreadLocal: " + ttl.get()); // TTL-è¯·æ±‚2 âœ… æ­£ç¡®ï¼
        }).get();
        
        ttlPool.shutdown();
        tl.remove();
        itl.remove();
        ttl.remove();
    }
    
    // è¾“å‡ºï¼š
    // ã€è¯·æ±‚1ã€‘ThreadLocal:             null        âŒ
    // ã€è¯·æ±‚1ã€‘InheritableThreadLocal:  ITL-è¯·æ±‚1   âœ…
    // ã€è¯·æ±‚1ã€‘TransmittableThreadLocal: TTL-è¯·æ±‚1  âœ…
    // ã€è¯·æ±‚2ã€‘ThreadLocal:             null        âŒ
    // ã€è¯·æ±‚2ã€‘InheritableThreadLocal:  ITL-è¯·æ±‚1   âŒ ä»ç„¶æ˜¯æ—§å€¼
    // ã€è¯·æ±‚2ã€‘TransmittableThreadLocal: TTL-è¯·æ±‚2  âœ… æ­£ç¡®è·å–æ–°å€¼ï¼
    
    // ============ åœºæ™¯4: CompletableFuture ============
    static void scenario4_CompletableFuture() throws Exception {
        System.out.println("\n========== åœºæ™¯4: CompletableFuture ==========");
        
        ExecutorService rawPool = Executors.newFixedThreadPool(2);
        ExecutorService ttlPool = TtlExecutors.getTtlExecutorService(rawPool);
        
        ttl.set("TTL-ä¸»çº¿ç¨‹");
        
        // 4.1 ä½¿ç”¨é»˜è®¤çº¿ç¨‹æ± ï¼ˆForkJoinPool.commonPool()ï¼‰
        CompletableFuture<String> future1 = CompletableFuture.supplyAsync(() -> {
            return "é»˜è®¤æ± : " + ttl.get(); // null âŒ
        });
        System.out.println(future1.get());
        
        // 4.2 ä½¿ç”¨æœªè£…é¥°çš„çº¿ç¨‹æ± 
        CompletableFuture<String> future2 = CompletableFuture.supplyAsync(() -> {
            return "æœªè£…é¥°æ± : " + ttl.get(); // null âŒ
        }, rawPool);
        System.out.println(future2.get());
        
        // 4.3 ä½¿ç”¨TTLè£…é¥°çš„çº¿ç¨‹æ± 
        CompletableFuture<String> future3 = CompletableFuture.supplyAsync(() -> {
            return "TTLè£…é¥°æ± : " + ttl.get(); // TTL-ä¸»çº¿ç¨‹ âœ…
        }, ttlPool);
        System.out.println(future3.get());
        
        // 4.4 é“¾å¼è°ƒç”¨
        CompletableFuture<String> future4 = CompletableFuture
            .supplyAsync(() -> {
                System.out.println("  æ­¥éª¤1: " + ttl.get()); // TTL-ä¸»çº¿ç¨‹ âœ…
                return "step1";
            }, ttlPool)
            .thenApplyAsync(result -> {
                System.out.println("  æ­¥éª¤2: " + ttl.get()); // TTL-ä¸»çº¿ç¨‹ âœ…
                return result + "-step2";
            }, ttlPool);
        
        System.out.println("é“¾å¼è°ƒç”¨ç»“æœ: " + future4.get());
        
        rawPool.shutdown();
        ttl.remove();
    }
    
    // è¾“å‡ºï¼š
    // é»˜è®¤æ± : null                    âŒ
    // æœªè£…é¥°æ± : null                  âŒ
    // TTLè£…é¥°æ± : TTL-ä¸»çº¿ç¨‹           âœ…
    //   æ­¥éª¤1: TTL-ä¸»çº¿ç¨‹             âœ…
    //   æ­¥éª¤2: TTL-ä¸»çº¿ç¨‹             âœ…
    // é“¾å¼è°ƒç”¨ç»“æœ: step1-step2
    
    // ============ åœºæ™¯5: Stream å¹¶è¡Œæµ ============
    static void scenario5_ParallelStream() {
        System.out.println("\n========== åœºæ™¯5: Stream å¹¶è¡Œæµ ==========");
        
        ttl.set("TTL-ä¸»çº¿ç¨‹");
        
        List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
        
        // 5.1 ä¸²è¡Œæµ
        numbers.stream().forEach(n -> {
            System.out.println("ä¸²è¡Œæµ-çº¿ç¨‹" + Thread.currentThread().getName() 
                + ": " + ttl.get()); // TTL-ä¸»çº¿ç¨‹ âœ…
        });
        
        // 5.2 å¹¶è¡Œæµï¼ˆä½¿ç”¨ ForkJoinPool.commonPool()ï¼‰
        numbers.parallelStream().forEach(n -> {
            System.out.println("å¹¶è¡Œæµ-çº¿ç¨‹" + Thread.currentThread().getName() 
                + ": " + ttl.get()); // null âŒ
        });
        
        // 5.3 è‡ªå®šä¹‰ ForkJoinPool + TTL è£…é¥°
        ForkJoinPool customPool = new ForkJoinPool(2);
        ForkJoinPool ttlForkJoinPool = TtlForkJoinPoolHelper.getDisableInheritableThreadFactory(customPool);
        
        ttlForkJoinPool.submit(() -> {
            numbers.parallelStream().forEach(n -> {
                System.out.println("TTLè£…é¥°å¹¶è¡Œæµ-çº¿ç¨‹" + Thread.currentThread().getName() 
                    + ": " + ttl.get()); // TTL-ä¸»çº¿ç¨‹ âœ…
            });
        }).get();
        
        ttl.remove();
    }
    
    // è¾“å‡ºï¼š
    // ä¸²è¡Œæµ-çº¿ç¨‹main: TTL-ä¸»çº¿ç¨‹                              âœ…
    // å¹¶è¡Œæµ-çº¿ç¨‹ForkJoinPool.commonPool-worker-1: null      âŒ
    // å¹¶è¡Œæµ-çº¿ç¨‹ForkJoinPool.commonPool-worker-2: null      âŒ
    // TTLè£…é¥°å¹¶è¡Œæµ-çº¿ç¨‹ForkJoinPool-1-worker-1: TTL-ä¸»çº¿ç¨‹   âœ…
    // TTLè£…é¥°å¹¶è¡Œæµ-çº¿ç¨‹ForkJoinPool-1-worker-2: TTL-ä¸»çº¿ç¨‹   âœ…
    
    // ============ åœºæ™¯6: ForkJoinPool é€’å½’ä»»åŠ¡ ============
    static void scenario6_ForkJoinPool() throws Exception {
        System.out.println("\n========== åœºæ™¯6: ForkJoinPool é€’å½’ä»»åŠ¡ ==========");
        
        ttl.set("TTL-ä¸»çº¿ç¨‹");
        
        // 6.1 æ™®é€š ForkJoinPool
        ForkJoinPool normalPool = new ForkJoinPool(2);
        Integer result1 = normalPool.submit(new SumTask(1, 100)).get();
        System.out.println("æ™®é€šForkJoinPoolç»“æœ: " + result1);
        
        // 6.2 TTL è£…é¥°çš„ ForkJoinPool
        ForkJoinPool ttlPool = TtlForkJoinPoolHelper.getDefaultDisableInheritableThreadFactory();
        Integer result2 = ttlPool.submit(new SumTask(1, 100)).get();
        System.out.println("TTL-ForkJoinPoolç»“æœ: " + result2);
        
        ttl.remove();
    }
    
    static class SumTask extends RecursiveTask<Integer> {
        private int start, end;
        
        public SumTask(int start, int end) {
            this.start = start;
            this.end = end;
        }
        
        @Override
        protected Integer compute() {
            System.out.println("Task[" + start + "," + end + "] TTLå€¼: " + ttl.get());
            
            if (end - start <= 10) {
                int sum = 0;
                for (int i = start; i <= end; i++) sum += i;
                return sum;
            }
            
            int mid = (start + end) / 2;
            SumTask left = new SumTask(start, mid);
            SumTask right = new SumTask(mid + 1, end);
            
            left.fork();
            right.fork();
            
            return left.join() + right.join();
        }
    }
    
    // è¾“å‡ºï¼ˆæ™®é€šForkJoinPoolï¼‰ï¼š
    // Task[1,100] TTLå€¼: null          âŒ
    // Task[1,50] TTLå€¼: null           âŒ
    // Task[51,100] TTLå€¼: null         âŒ
    
    // è¾“å‡ºï¼ˆTTLè£…é¥°ï¼‰ï¼š
    // Task[1,100] TTLå€¼: TTL-ä¸»çº¿ç¨‹    âœ…
    // Task[1,50] TTLå€¼: TTL-ä¸»çº¿ç¨‹     âœ…
    // Task[51,100] TTLå€¼: TTL-ä¸»çº¿ç¨‹   âœ…
    
    // ============ åœºæ™¯7: Spring @Async ============
    static void scenario7_SpringAsync() {
        System.out.println("\n========== åœºæ™¯7: Spring @Async ==========");
        
        // éœ€è¦é…ç½® TTL è£…é¥°çš„ Executor
        // è§ä¸‹æ–‡å®Œæ•´ Spring é…ç½®ç¤ºä¾‹
    }
    
    // ============ åœºæ™¯8: å®šæ—¶ä»»åŠ¡ ============
    static void scenario8_ScheduledExecutor() throws Exception {
        System.out.println("\n========== åœºæ™¯8: ScheduledExecutorService ==========");
        
        ScheduledExecutorService rawScheduler = Executors.newScheduledThreadPool(1);
        ScheduledExecutorService ttlScheduler = TtlExecutors.getTtlScheduledExecutorService(rawScheduler);
        
        ttl.set("TTL-ä¸»çº¿ç¨‹");
        
        // 8.1 æœªè£…é¥°çš„å®šæ—¶ä»»åŠ¡
        ScheduledFuture<?> future1 = rawScheduler.schedule(() -> {
            System.out.println("æœªè£…é¥°å®šæ—¶ä»»åŠ¡: " + ttl.get()); // null âŒ
        }, 100, TimeUnit.MILLISECONDS);
        future1.get();
        
        // 8.2 TTL è£…é¥°çš„å®šæ—¶ä»»åŠ¡
        ScheduledFuture<?> future2 = ttlScheduler.schedule(() -> {
            System.out.println("TTLè£…é¥°å®šæ—¶ä»»åŠ¡: " + ttl.get()); // TTL-ä¸»çº¿ç¨‹ âœ…
        }, 100, TimeUnit.MILLISECONDS);
        future2.get();
        
        // 8.3 å‘¨æœŸæ€§ä»»åŠ¡
        CountDownLatch latch = new CountDownLatch(3);
        ttlScheduler.scheduleAtFixedRate(() -> {
            System.out.println("å‘¨æœŸä»»åŠ¡ç¬¬" + (4 - latch.getCount()) + "æ¬¡: " + ttl.get()); // TTL-ä¸»çº¿ç¨‹ âœ…
            latch.countDown();
        }, 0, 100, TimeUnit.MILLISECONDS);
        
        latch.await();
        rawScheduler.shutdown();
        ttl.remove();
    }
    
    // è¾“å‡ºï¼š
    // æœªè£…é¥°å®šæ—¶ä»»åŠ¡: null                     âŒ
    // TTLè£…é¥°å®šæ—¶ä»»åŠ¡: TTL-ä¸»çº¿ç¨‹              âœ…
    // å‘¨æœŸä»»åŠ¡ç¬¬1æ¬¡: TTL-ä¸»çº¿ç¨‹                âœ…
    // å‘¨æœŸä»»åŠ¡ç¬¬2æ¬¡: TTL-ä¸»çº¿ç¨‹                âœ…
    // å‘¨æœŸä»»åŠ¡ç¬¬3æ¬¡: TTL-ä¸»çº¿ç¨‹                âœ…
}
```

---

## 2. ThreadLocal åŸºç¡€

### 2.1 åŸºæœ¬ä½¿ç”¨

```java
/**
 * ThreadLocal åŸºç¡€ç¤ºä¾‹
 * ç‰¹ç‚¹ï¼šçº¿ç¨‹éš”ç¦»ï¼Œäº’ä¸å½±å“
 */
public class ThreadLocalDemo {
    
    // å®šä¹‰ ThreadLocal
    private static ThreadLocal<String> threadLocal = new ThreadLocal<>();
    
    public static void main(String[] args) {
        // ä¸»çº¿ç¨‹è®¾ç½®å€¼
        threadLocal.set("ä¸»çº¿ç¨‹çš„å€¼");
        System.out.println("ä¸»çº¿ç¨‹è¯»å–: " + threadLocal.get());
        
        // åˆ›å»ºå­çº¿ç¨‹
        new Thread(() -> {
            // å­çº¿ç¨‹è¯»å– - è¿”å› nullï¼ˆä¸èƒ½è·å–çˆ¶çº¿ç¨‹çš„å€¼ï¼‰
            System.out.println("å­çº¿ç¨‹è¯»å–: " + threadLocal.get());
            
            // å­çº¿ç¨‹è®¾ç½®è‡ªå·±çš„å€¼
            threadLocal.set("å­çº¿ç¨‹çš„å€¼");
            System.out.println("å­çº¿ç¨‹è¯»å–: " + threadLocal.get());
        }).start();
        
        // ç­‰å¾…å­çº¿ç¨‹æ‰§è¡Œ
        Thread.sleep(100);
        
        // ä¸»çº¿ç¨‹å†æ¬¡è¯»å– - ä¸å—å­çº¿ç¨‹å½±å“
        System.out.println("ä¸»çº¿ç¨‹å†æ¬¡è¯»å–: " + threadLocal.get());
    }
}

// è¾“å‡ºç»“æœï¼š
// ä¸»çº¿ç¨‹è¯»å–: ä¸»çº¿ç¨‹çš„å€¼
// å­çº¿ç¨‹è¯»å–: null          â† æ— æ³•è·å–çˆ¶çº¿ç¨‹çš„å€¼
// å­çº¿ç¨‹è¯»å–: å­çº¿ç¨‹çš„å€¼
// ä¸»çº¿ç¨‹å†æ¬¡è¯»å–: ä¸»çº¿ç¨‹çš„å€¼
```

### 2.2 å†…éƒ¨åŸç†

```java
/**
 * ThreadLocal å†…éƒ¨å®ç°åŸç†
 */

// æ¯ä¸ª Thread å¯¹è±¡éƒ½æœ‰ä¸€ä¸ª ThreadLocalMap
class Thread {
    // ThreadLocal æ•°æ®å­˜å‚¨åœ¨è¿™é‡Œ
    ThreadLocal.ThreadLocalMap threadLocals = null;
}

// ThreadLocal çš„ set/get æ–¹æ³•
public class ThreadLocal<T> {
    
    public void set(T value) {
        // 1. è·å–å½“å‰çº¿ç¨‹
        Thread t = Thread.currentThread();
        
        // 2. è·å–å½“å‰çº¿ç¨‹çš„ ThreadLocalMap
        ThreadLocalMap map = getMap(t);
        
        // 3. ä»¥ this(ThreadLocalå¯¹è±¡) ä¸º keyï¼Œvalue ä¸ºå€¼å­˜å‚¨
        if (map != null) {
            map.set(this, value);
        } else {
            createMap(t, value);
        }
    }
    
    public T get() {
        // 1. è·å–å½“å‰çº¿ç¨‹
        Thread t = Thread.currentThread();
        
        // 2. è·å–å½“å‰çº¿ç¨‹çš„ ThreadLocalMap
        ThreadLocalMap map = getMap(t);
        
        // 3. ä» map ä¸­è·å–å€¼
        if (map != null) {
            ThreadLocalMap.Entry e = map.getEntry(this);
            if (e != null) {
                return (T)e.value;
            }
        }
        return null;
    }
    
    ThreadLocalMap getMap(Thread t) {
        return t.threadLocals;
    }
}
```

**å…³é”®ç‚¹**ï¼š
- æ•°æ®å­˜å‚¨åœ¨ Thread å¯¹è±¡çš„ `threadLocals` å­—æ®µä¸­
- ä¸åŒçº¿ç¨‹æœ‰ä¸åŒçš„ Thread å¯¹è±¡ï¼Œå› æ­¤æ•°æ®éš”ç¦»
- å­çº¿ç¨‹æ˜¯æ–°çš„ Thread å¯¹è±¡ï¼Œæ‰€ä»¥æ— æ³•è®¿é—®çˆ¶çº¿ç¨‹çš„æ•°æ®

### 2.3 å…¸å‹ä½¿ç”¨åœºæ™¯

```java
/**
 * åœºæ™¯1ï¼šæ•°æ®åº“è¿æ¥ç®¡ç†
 */
public class ConnectionManager {
    private static ThreadLocal<Connection> connectionHolder = new ThreadLocal<>();
    
    public static Connection getConnection() {
        Connection conn = connectionHolder.get();
        if (conn == null) {
            conn = createConnection();
            connectionHolder.set(conn);
        }
        return conn;
    }
    
    public static void closeConnection() {
        Connection conn = connectionHolder.get();
        if (conn != null) {
            conn.close();
            connectionHolder.remove(); // âš ï¸ é‡è¦ï¼šé˜²æ­¢å†…å­˜æ³„æ¼
        }
    }
}

/**
 * åœºæ™¯2ï¼šç”¨æˆ·ä¸Šä¸‹æ–‡ä¼ é€’ï¼ˆå•çº¿ç¨‹ï¼‰
 */
public class UserContext {
    private static ThreadLocal<User> userHolder = new ThreadLocal<>();
    
    public static void setUser(User user) {
        userHolder.set(user);
    }
    
    public static User getUser() {
        return userHolder.get();
    }
    
    public static void clear() {
        userHolder.remove();
    }
}

// Controller å±‚
@RestController
public class UserController {
    
    @GetMapping("/user/info")
    public UserInfo getUserInfo() {
        // ä» ThreadLocal è·å–å½“å‰ç”¨æˆ·
        User user = UserContext.getUser();
        return userService.getInfo(user.getId());
    }
}

// æ‹¦æˆªå™¨è®¾ç½®ç”¨æˆ·ä¿¡æ¯
public class AuthInterceptor implements HandlerInterceptor {
    
    @Override
    public boolean preHandle(HttpServletRequest request, ...) {
        String token = request.getHeader("Authorization");
        User user = parseToken(token);
        UserContext.setUser(user); // è®¾ç½®åˆ° ThreadLocal
        return true;
    }
    
    @Override
    public void afterCompletion(HttpServletRequest request, ...) {
        UserContext.clear(); // âš ï¸ æ¸…ç†ï¼Œé˜²æ­¢å†…å­˜æ³„æ¼
    }
}
```

---

## 3. InheritableThreadLocal çˆ¶å­çº¿ç¨‹ä¼ é€’

### 3.1 åŸºæœ¬ä½¿ç”¨

```java
/**
 * InheritableThreadLocal ç¤ºä¾‹
 * ç‰¹ç‚¹ï¼šåˆ›å»ºå­çº¿ç¨‹æ—¶ï¼Œä¼šå¤åˆ¶çˆ¶çº¿ç¨‹çš„å€¼
 */
public class InheritableThreadLocalDemo {
    
    // ä½¿ç”¨ InheritableThreadLocal
    private static InheritableThreadLocal<String> inheritableThreadLocal 
        = new InheritableThreadLocal<>();
    
    public static void main(String[] args) throws InterruptedException {
        // çˆ¶çº¿ç¨‹è®¾ç½®å€¼
        inheritableThreadLocal.set("çˆ¶çº¿ç¨‹çš„å€¼");
        System.out.println("çˆ¶çº¿ç¨‹: " + inheritableThreadLocal.get());
        
        // åˆ›å»ºå­çº¿ç¨‹
        Thread childThread = new Thread(() -> {
            // âœ… å­çº¿ç¨‹å¯ä»¥è·å–åˆ°çˆ¶çº¿ç¨‹çš„å€¼
            System.out.println("å­çº¿ç¨‹è¯»å–: " + inheritableThreadLocal.get());
            
            // å­çº¿ç¨‹ä¿®æ”¹å€¼ï¼ˆä¸å½±å“çˆ¶çº¿ç¨‹ï¼‰
            inheritableThreadLocal.set("å­çº¿ç¨‹ä¿®æ”¹åçš„å€¼");
            System.out.println("å­çº¿ç¨‹ä¿®æ”¹å: " + inheritableThreadLocal.get());
        });
        
        childThread.start();
        childThread.join();
        
        // çˆ¶çº¿ç¨‹çš„å€¼ä¸å—å½±å“
        System.out.println("çˆ¶çº¿ç¨‹å†æ¬¡è¯»å–: " + inheritableThreadLocal.get());
    }
}

// è¾“å‡ºç»“æœï¼š
// çˆ¶çº¿ç¨‹: çˆ¶çº¿ç¨‹çš„å€¼
// å­çº¿ç¨‹è¯»å–: çˆ¶çº¿ç¨‹çš„å€¼        â† âœ… æˆåŠŸè·å–
// å­çº¿ç¨‹ä¿®æ”¹å: å­çº¿ç¨‹ä¿®æ”¹åçš„å€¼
// çˆ¶çº¿ç¨‹å†æ¬¡è¯»å–: çˆ¶çº¿ç¨‹çš„å€¼     â† çˆ¶çº¿ç¨‹ä¸å—å½±å“
```

### 3.2 å†…éƒ¨åŸç†

```java
/**
 * InheritableThreadLocal å®ç°åŸç†
 */

// Thread ç±»ä¸­æœ‰ä¸¤ä¸ª ThreadLocalMap
class Thread {
    ThreadLocal.ThreadLocalMap threadLocals = null;           // æ™®é€š ThreadLocal
    ThreadLocal.ThreadLocalMap inheritableThreadLocals = null; // å¯ç»§æ‰¿çš„ ThreadLocal
}

// Thread æ„é€ æ–¹æ³•
public Thread(Runnable target) {
    // ...
    
    // è·å–çˆ¶çº¿ç¨‹ï¼ˆå½“å‰æ­£åœ¨æ‰§è¡Œçš„çº¿ç¨‹ï¼‰
    Thread parent = currentThread();
    
    // å¦‚æœçˆ¶çº¿ç¨‹æœ‰ inheritableThreadLocalsï¼Œåˆ™å¤åˆ¶ç»™å­çº¿ç¨‹
    if (parent.inheritableThreadLocals != null) {
        // âš ï¸ å…³é”®ï¼šå¤åˆ¶çˆ¶çº¿ç¨‹çš„ inheritableThreadLocals
        this.inheritableThreadLocals = 
            ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);
    }
}

// InheritableThreadLocal é‡å†™äº† getMap æ–¹æ³•
public class InheritableThreadLocal<T> extends ThreadLocal<T> {
    
    @Override
    ThreadLocalMap getMap(Thread t) {
        // ä½¿ç”¨ inheritableThreadLocals è€Œä¸æ˜¯ threadLocals
        return t.inheritableThreadLocals;
    }
    
    @Override
    void createMap(Thread t, T firstValue) {
        t.inheritableThreadLocals = new ThreadLocalMap(this, firstValue);
    }
    
    // å¯ä»¥é‡å†™è¿™ä¸ªæ–¹æ³•æ¥è‡ªå®šä¹‰å¤åˆ¶é€»è¾‘
    protected T childValue(T parentValue) {
        return parentValue; // é»˜è®¤ç›´æ¥è¿”å›çˆ¶å€¼ï¼ˆæµ…æ‹·è´ï¼‰
    }
}
```

**å·¥ä½œæµç¨‹**ï¼š

```
1. çˆ¶çº¿ç¨‹è®¾ç½®å€¼
   â†“
   çˆ¶çº¿ç¨‹.inheritableThreadLocals.set(key, "çˆ¶çº¿ç¨‹çš„å€¼")

2. åˆ›å»ºå­çº¿ç¨‹æ—¶
   â†“
   new Thread() æ„é€ æ–¹æ³•æ‰§è¡Œ
   â†“
   æ£€æµ‹åˆ°çˆ¶çº¿ç¨‹æœ‰ inheritableThreadLocals
   â†“
   å¤åˆ¶çˆ¶çº¿ç¨‹çš„ inheritableThreadLocals åˆ°å­çº¿ç¨‹

3. å­çº¿ç¨‹è¯»å–
   â†“
   å­çº¿ç¨‹.inheritableThreadLocals.get(key)
   â†“
   æˆåŠŸè·å–åˆ° "çˆ¶çº¿ç¨‹çš„å€¼"
```

### 3.3 è‡ªå®šä¹‰å¤åˆ¶é€»è¾‘

```java
/**
 * æ·±æ‹·è´ç¤ºä¾‹
 */
public class CustomInheritableThreadLocal<T> extends InheritableThreadLocal<T> {
    
    @Override
    protected T childValue(T parentValue) {
        // è‡ªå®šä¹‰å¤åˆ¶é€»è¾‘ï¼ˆæ·±æ‹·è´ï¼‰
        if (parentValue instanceof Cloneable) {
            try {
                Method clone = parentValue.getClass().getMethod("clone");
                return (T) clone.invoke(parentValue);
            } catch (Exception e) {
                // fallback to parent value
            }
        }
        return parentValue;
    }
}

// ä½¿ç”¨ç¤ºä¾‹
class UserContext {
    static class User implements Cloneable {
        private String name;
        private int age;
        
        @Override
        public User clone() {
            try {
                return (User) super.clone();
            } catch (CloneNotSupportedException e) {
                throw new RuntimeException(e);
            }
        }
    }
    
    private static InheritableThreadLocal<User> userThreadLocal 
        = new CustomInheritableThreadLocal<>();
    
    public static void main(String[] args) {
        User user = new User();
        user.name = "å¼ ä¸‰";
        user.age = 25;
        
        userThreadLocal.set(user);
        
        new Thread(() -> {
            User childUser = userThreadLocal.get();
            childUser.name = "æå››"; // ä¿®æ”¹
            
            System.out.println("å­çº¿ç¨‹: " + childUser.name);
        }).start();
        
        Thread.sleep(100);
        
        // æ·±æ‹·è´ï¼Œçˆ¶çº¿ç¨‹ä¸å—å½±å“
        System.out.println("çˆ¶çº¿ç¨‹: " + userThreadLocal.get().name); // ä»ç„¶æ˜¯ "å¼ ä¸‰"
    }
}
```

---

## 4. çº¿ç¨‹æ± åœºæ™¯çš„é—®é¢˜

### 4.1 InheritableThreadLocal åœ¨çº¿ç¨‹æ± ä¸­çš„å¤±æ•ˆ

```java
/**
 * âŒ é—®é¢˜æ¼”ç¤ºï¼šInheritableThreadLocal åœ¨çº¿ç¨‹æ± ä¸­å¤±æ•ˆ
 */
public class ThreadPoolProblemDemo {
    
    private static InheritableThreadLocal<String> context 
        = new InheritableThreadLocal<>();
    
    public static void main(String[] args) throws InterruptedException {
        // åˆ›å»ºçº¿ç¨‹æ± 
        ExecutorService executor = Executors.newFixedThreadPool(1);
        
        // ç¬¬ä¸€æ¬¡æäº¤ä»»åŠ¡
        context.set("ç¬¬ä¸€æ¬¡è¯·æ±‚çš„ä¸Šä¸‹æ–‡");
        executor.submit(() -> {
            System.out.println("ä»»åŠ¡1è¯»å–: " + context.get());
        });
        
        Thread.sleep(100);
        
        // ç¬¬äºŒæ¬¡æäº¤ä»»åŠ¡
        context.set("ç¬¬äºŒæ¬¡è¯·æ±‚çš„ä¸Šä¸‹æ–‡");
        executor.submit(() -> {
            // âŒ é—®é¢˜ï¼šä»ç„¶è¯»å–åˆ°ç¬¬ä¸€æ¬¡çš„å€¼ï¼
            System.out.println("ä»»åŠ¡2è¯»å–: " + context.get());
        });
        
        executor.shutdown();
    }
}

// è¾“å‡ºç»“æœï¼š
// ä»»åŠ¡1è¯»å–: ç¬¬ä¸€æ¬¡è¯·æ±‚çš„ä¸Šä¸‹æ–‡
// ä»»åŠ¡2è¯»å–: ç¬¬ä¸€æ¬¡è¯·æ±‚çš„ä¸Šä¸‹æ–‡  â† âŒ é”™è¯¯ï¼åº”è¯¥æ˜¯"ç¬¬äºŒæ¬¡è¯·æ±‚çš„ä¸Šä¸‹æ–‡"
```

### 4.2 é—®é¢˜åŸå› åˆ†æ

```java
/**
 * åŸå› åˆ†æï¼šçº¿ç¨‹æ± å¤ç”¨å¯¼è‡´çš„é—®é¢˜
 */

// æ—¶é—´çº¿ï¼š
// 
// T1: ä¸»çº¿ç¨‹è®¾ç½® context = "ç¬¬ä¸€æ¬¡è¯·æ±‚"
// T2: æäº¤ä»»åŠ¡1åˆ°çº¿ç¨‹æ± 
//     â†“
//     çº¿ç¨‹æ± åˆ›å»ºæ–°çº¿ç¨‹ worker-1
//     â†“
//     worker-1 ä»ä¸»çº¿ç¨‹ç»§æ‰¿ inheritableThreadLocals
//     â†“
//     worker-1 è¯»å–åˆ° "ç¬¬ä¸€æ¬¡è¯·æ±‚" âœ…
//     â†“
//     ä»»åŠ¡1æ‰§è¡Œå®Œï¼Œworker-1 è¿”å›çº¿ç¨‹æ± ç­‰å¾…
//
// T3: ä¸»çº¿ç¨‹è®¾ç½® context = "ç¬¬äºŒæ¬¡è¯·æ±‚"
// T4: æäº¤ä»»åŠ¡2åˆ°çº¿ç¨‹æ± 
//     â†“
//     çº¿ç¨‹æ± å¤ç”¨ worker-1ï¼ˆå·²å­˜åœ¨çš„çº¿ç¨‹ï¼‰
//     â†“
//     âš ï¸ å…³é”®ï¼šworker-1 ä¸æ˜¯æ–°åˆ›å»ºçš„ï¼Œä¸ä¼šå†æ¬¡ä»ä¸»çº¿ç¨‹ç»§æ‰¿
//     â†“
//     worker-1.inheritableThreadLocals ä»ç„¶æ˜¯ "ç¬¬ä¸€æ¬¡è¯·æ±‚"
//     â†“
//     worker-1 è¯»å–åˆ° "ç¬¬ä¸€æ¬¡è¯·æ±‚" âŒ é”™è¯¯ï¼

/**
 * æ ¸å¿ƒé—®é¢˜ï¼š
 * - InheritableThreadLocal åªåœ¨çº¿ç¨‹åˆ›å»ºæ—¶å¤åˆ¶ä¸€æ¬¡
 * - çº¿ç¨‹æ± ä¸­çš„çº¿ç¨‹æ˜¯å¤ç”¨çš„ï¼Œä¸ä¼šé‡æ–°åˆ›å»º
 * - å› æ­¤ä¸ä¼šè§¦å‘å¤åˆ¶é€»è¾‘
 */
```

### 4.3 å›¾ç¤ºè¯´æ˜

```
åœºæ™¯1ï¼šæ¯æ¬¡ new Threadï¼ˆInheritableThreadLocal æœ‰æ•ˆï¼‰
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

è¯·æ±‚1:
  ä¸»çº¿ç¨‹: context = "è¯·æ±‚1"
    â†“
  new Thread() â†’ åˆ›å»ºçº¿ç¨‹A
    â†“
  çº¿ç¨‹A ç»§æ‰¿ context = "è¯·æ±‚1" âœ…

è¯·æ±‚2:
  ä¸»çº¿ç¨‹: context = "è¯·æ±‚2"
    â†“
  new Thread() â†’ åˆ›å»ºçº¿ç¨‹B
    â†“
  çº¿ç¨‹B ç»§æ‰¿ context = "è¯·æ±‚2" âœ…


åœºæ™¯2ï¼šä½¿ç”¨çº¿ç¨‹æ± ï¼ˆInheritableThreadLocal å¤±æ•ˆï¼‰
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

è¯·æ±‚1:
  ä¸»çº¿ç¨‹: context = "è¯·æ±‚1"
    â†“
  executor.submit() â†’ çº¿ç¨‹æ± åˆ›å»ºçº¿ç¨‹A
    â†“
  çº¿ç¨‹A ç»§æ‰¿ context = "è¯·æ±‚1" âœ…
    â†“
  ä»»åŠ¡å®Œæˆï¼Œçº¿ç¨‹A è¿”å›çº¿ç¨‹æ± 

è¯·æ±‚2:
  ä¸»çº¿ç¨‹: context = "è¯·æ±‚2"
    â†“
  executor.submit() â†’ çº¿ç¨‹æ± å¤ç”¨çº¿ç¨‹Aï¼ˆä¸åˆ›å»ºæ–°çº¿ç¨‹ï¼‰
    â†“
  âŒ ä¸ä¼šè§¦å‘ç»§æ‰¿é€»è¾‘
    â†“
  çº¿ç¨‹A.context ä»ç„¶æ˜¯ "è¯·æ±‚1" âŒ é”™è¯¯ï¼
```

---

## 5. TransmittableThreadLocal è§£å†³æ–¹æ¡ˆ

### 5.1 å¼•å…¥ä¾èµ–

```xml
<!-- Maven ä¾èµ– -->
<dependency>
    <groupId>com.alibaba</groupId>
    <artifactId>transmittable-thread-local</artifactId>
    <version>2.14.3</version>
</dependency>
```

```gradle
// Gradle ä¾èµ–
implementation 'com.alibaba:transmittable-thread-local:2.14.3'
```

### 5.2 åŸºæœ¬ä½¿ç”¨

```java
import com.alibaba.ttl.TransmittableThreadLocal;
import com.alibaba.ttl.threadpool.TtlExecutors;

/**
 * âœ… ä½¿ç”¨ TransmittableThreadLocal è§£å†³çº¿ç¨‹æ± ä¼ é€’é—®é¢˜
 */
public class TTLDemo {
    
    // ä½¿ç”¨ TransmittableThreadLocal
    private static TransmittableThreadLocal<String> context 
        = new TransmittableThreadLocal<>();
    
    public static void main(String[] args) throws InterruptedException {
        // åˆ›å»ºçº¿ç¨‹æ± ï¼Œä½¿ç”¨ TtlExecutors åŒ…è£…
        ExecutorService executor = Executors.newFixedThreadPool(1);
        ExecutorService ttlExecutor = TtlExecutors.getTtlExecutorService(executor);
        
        // ç¬¬ä¸€æ¬¡è¯·æ±‚
        context.set("ç¬¬ä¸€æ¬¡è¯·æ±‚çš„ä¸Šä¸‹æ–‡");
        ttlExecutor.submit(() -> {
            System.out.println("ä»»åŠ¡1è¯»å–: " + context.get());
        });
        
        Thread.sleep(100);
        
        // ç¬¬äºŒæ¬¡è¯·æ±‚
        context.set("ç¬¬äºŒæ¬¡è¯·æ±‚çš„ä¸Šä¸‹æ–‡");
        ttlExecutor.submit(() -> {
            // âœ… æ­£ç¡®è·å–åˆ°ç¬¬äºŒæ¬¡çš„å€¼
            System.out.println("ä»»åŠ¡2è¯»å–: " + context.get());
        });
        
        ttlExecutor.shutdown();
    }
}

// è¾“å‡ºç»“æœï¼š
// ä»»åŠ¡1è¯»å–: ç¬¬ä¸€æ¬¡è¯·æ±‚çš„ä¸Šä¸‹æ–‡
// ä»»åŠ¡2è¯»å–: ç¬¬äºŒæ¬¡è¯·æ±‚çš„ä¸Šä¸‹æ–‡  â† âœ… æ­£ç¡®ï¼
```

### 5.3 ä¸‰ç§ä½¿ç”¨æ–¹å¼

#### æ–¹å¼1ï¼šè£…é¥°çº¿ç¨‹æ± ï¼ˆæ¨èï¼‰

```java
/**
 * æ–¹å¼1ï¼šä½¿ç”¨ TtlExecutors è£…é¥°çº¿ç¨‹æ± 
 * ä¼˜ç‚¹ï¼šç®€å•ï¼Œä»£ç ä¾µå…¥æ€§å°
 * é€‚ç”¨ï¼šè‡ªå·±åˆ›å»ºçš„çº¿ç¨‹æ± 
 */
public class Method1_DecorateExecutor {
    
    private static TransmittableThreadLocal<String> context 
        = new TransmittableThreadLocal<>();
    
    public static void main(String[] args) {
        // åŸå§‹çº¿ç¨‹æ± 
        ExecutorServiceåŸå§‹çº¿ç¨‹æ±  = Executors.newFixedThreadPool(2);
        
        // âš ï¸ å…³é”®ï¼šä½¿ç”¨ TtlExecutors è£…é¥°
        ExecutorService ttlçº¿ç¨‹æ±  = TtlExecutors.getTtlExecutorService(åŸå§‹çº¿ç¨‹æ± );
        
        // æ­£å¸¸ä½¿ç”¨
        context.set("ç”¨æˆ·ä¿¡æ¯");
        ttlçº¿ç¨‹æ± .submit(() -> {
            System.out.println(context.get()); // âœ… èƒ½è·å–åˆ°
        });
    }
}
```

#### æ–¹å¼2ï¼šè£…é¥° Runnable/Callable

```java
import com.alibaba.ttl.TtlRunnable;
import com.alibaba.ttl.TtlCallable;

/**
 * æ–¹å¼2ï¼šè£…é¥° Runnable/Callable
 * ä¼˜ç‚¹ï¼šä¸éœ€è¦ä¿®æ”¹çº¿ç¨‹æ± 
 * é€‚ç”¨ï¼šæ— æ³•ä¿®æ”¹çº¿ç¨‹æ± åˆ›å»ºé€»è¾‘çš„åœºæ™¯
 */
public class Method2_DecorateTask {
    
    private static TransmittableThreadLocal<String> context 
        = new TransmittableThreadLocal<>();
    
    public static void main(String[] args) {
        ExecutorService executor = Executors.newFixedThreadPool(2);
        
        context.set("ç”¨æˆ·ä¿¡æ¯");
        
        // åŸå§‹ Runnable
        Runnable task = () -> {
            System.out.println(context.get());
        };
        
        // âš ï¸ å…³é”®ï¼šä½¿ç”¨ TtlRunnable è£…é¥°
        Runnable ttlTask = TtlRunnable.get(task);
        
        executor.submit(ttlTask);
    }
}
```

#### æ–¹å¼3ï¼šJava Agentï¼ˆé›¶ä»£ç ä¾µå…¥ï¼‰

```bash
# å¯åŠ¨å‚æ•°æ·»åŠ  Java Agent
java -javaagent:transmittable-thread-local-2.14.3.jar \
     -jar your-application.jar
```

```java
/**
 * æ–¹å¼3ï¼šä½¿ç”¨ Java Agent
 * ä¼˜ç‚¹ï¼šé›¶ä»£ç ä¾µå…¥ï¼Œè‡ªåŠ¨è£…é¥°æ‰€æœ‰çº¿ç¨‹æ± 
 * é€‚ç”¨ï¼šçº¿ç¨‹æ± ç”±æ¡†æ¶åˆ›å»ºï¼Œæ— æ³•ä¿®æ”¹ä»£ç 
 */
public class Method3_JavaAgent {
    
    private static TransmittableThreadLocal<String> context 
        = new TransmittableThreadLocal<>();
    
    public static void main(String[] args) {
        // æ™®é€šçº¿ç¨‹æ± ï¼Œæ— éœ€è£…é¥°
        ExecutorService executor = Executors.newFixedThreadPool(2);
        
        context.set("ç”¨æˆ·ä¿¡æ¯");
        
        // æ™®é€šæäº¤ï¼ŒJava Agent ä¼šè‡ªåŠ¨å¤„ç†
        executor.submit(() -> {
            System.out.println(context.get()); // âœ… èƒ½è·å–åˆ°
        });
    }
}
```

### 5.4 å·¥ä½œåŸç†

```java
/**
 * TransmittableThreadLocal åŸç†
 */

// 1. TransmittableThreadLocal ç»´æŠ¤ä¸€ä¸ªå…¨å±€çš„ holder
public class TransmittableThreadLocal<T> extends InheritableThreadLocal<T> {
    
    // å…¨å±€æŒæœ‰æ‰€æœ‰ TTL å®ä¾‹
    private static InheritableThreadLocal<WeakHashMap<TransmittableThreadLocal<Object>, ?>> 
        holder = new InheritableThreadLocal<>() {
            @Override
            protected WeakHashMap<TransmittableThreadLocal<Object>, ?> initialValue() {
                return new WeakHashMap<>();
            }
        };
    
    @Override
    public final T get() {
        T value = super.get();
        if (null != value) {
            // æ·»åŠ åˆ° holderï¼Œæ–¹ä¾¿åç»­æ•è·
            addThisToHolder();
        }
        return value;
    }
    
    @Override
    public final void set(T value) {
        if (!disableIgnoreNullValueSemantics && null == value) {
            remove();
        } else {
            super.set(value);
            addThisToHolder(); // æ·»åŠ åˆ° holder
        }
    }
}

// 2. TtlRunnable è£…é¥° Runnable
public final class TtlRunnable implements Runnable {
    
    // æ•è·çš„ä¸Šä¸‹æ–‡ï¼ˆåœ¨æäº¤ä»»åŠ¡æ—¶æ•è·ï¼‰
    private final Object captured;
    
    // å®é™…è¦æ‰§è¡Œçš„ä»»åŠ¡
    private final Runnable runnable;
    
    private TtlRunnable(Runnable runnable) {
        // âš ï¸ å…³é”®ï¼šåœ¨æ„é€ æ—¶æ•è·çˆ¶çº¿ç¨‹çš„æ‰€æœ‰ TTL å€¼
        this.captured = Transmitter.capture();
        this.runnable = runnable;
    }
    
    @Override
    public void run() {
        // âš ï¸ å…³é”®ï¼šæ‰§è¡Œå‰æ¢å¤æ•è·çš„å€¼
        Object backup = Transmitter.replay(captured);
        try {
            runnable.run(); // æ‰§è¡Œå®é™…ä»»åŠ¡
        } finally {
            // âš ï¸ å…³é”®ï¼šæ‰§è¡Œåæ¢å¤çº¿ç¨‹åŸæ¥çš„å€¼
            Transmitter.restore(backup);
        }
    }
}

// 3. Transmitter è´Ÿè´£æ•è·ã€æ¢å¤ã€æ¸…ç†
public class Transmitter {
    
    // æ•è·å½“å‰çº¿ç¨‹çš„æ‰€æœ‰ TTL å€¼
    public static Object capture() {
        Map<TransmittableThreadLocal<Object>, Object> captured = new HashMap<>();
        for (TransmittableThreadLocal<Object> threadLocal : holder.get().keySet()) {
            captured.put(threadLocal, threadLocal.copyValue());
        }
        return captured;
    }
    
    // æ¢å¤å€¼åˆ°å½“å‰çº¿ç¨‹
    public static Object replay(Object captured) {
        Map<TransmittableThreadLocal<Object>, Object> capturedMap = 
            (Map<TransmittableThreadLocal<Object>, Object>) captured;
        
        // å¤‡ä»½å½“å‰çº¿ç¨‹çš„å€¼
        Object backup = capture();
        
        // è®¾ç½®æ•è·çš„å€¼
        for (Map.Entry<TransmittableThreadLocal<Object>, Object> entry : capturedMap.entrySet()) {
            entry.getKey().set(entry.getValue());
        }
        
        return backup;
    }
    
    // æ¢å¤çº¿ç¨‹åŸæ¥çš„å€¼
    public static void restore(Object backup) {
        replay(backup);
    }
}
```

**æ‰§è¡Œæµç¨‹**ï¼š

```
1. ä¸»çº¿ç¨‹æäº¤ä»»åŠ¡
   â†“
   context.set("è¯·æ±‚1")
   â†“
   TtlRunnable æ„é€ 
   â†“
   Transmitter.capture() â†’ æ•è·æ‰€æœ‰ TTL å€¼
   â†“
   captured = {context: "è¯·æ±‚1"}
   â†“
   æäº¤åˆ°çº¿ç¨‹æ± 

2. å·¥ä½œçº¿ç¨‹æ‰§è¡Œ
   â†“
   TtlRunnable.run() å¼€å§‹
   â†“
   Transmitter.replay(captured)
   â†“
   backup = å·¥ä½œçº¿ç¨‹å½“å‰çš„ TTL å€¼ï¼ˆå¯èƒ½æ˜¯ä¸Šæ¬¡è¯·æ±‚çš„ï¼‰
   â†“
   æ¢å¤ captured çš„å€¼åˆ°å·¥ä½œçº¿ç¨‹
   â†“
   å·¥ä½œçº¿ç¨‹.context = "è¯·æ±‚1"
   â†“
   æ‰§è¡Œå®é™…ä»»åŠ¡ â†’ context.get() è¿”å› "è¯·æ±‚1" âœ…
   â†“
   Transmitter.restore(backup)
   â†“
   æ¢å¤å·¥ä½œçº¿ç¨‹åŸæ¥çš„å€¼

3. ä¸‹æ¬¡è¯·æ±‚
   â†“
   ä¸»çº¿ç¨‹: context.set("è¯·æ±‚2")
   â†“
   å†æ¬¡æ•è· â†’ captured = {context: "è¯·æ±‚2"}
   â†“
   å·¥ä½œçº¿ç¨‹ï¼ˆå¯èƒ½å¤ç”¨åŒä¸€ä¸ªï¼‰
   â†“
   replay â†’ æ¢å¤ä¸º "è¯·æ±‚2" âœ…
```



---

## 6. å®æˆ˜æ¡ˆä¾‹

### 6.1 Spring Boot + çº¿ç¨‹æ± å®ç°è¯·æ±‚è¿½è¸ª

```java
/**
 * å®Œæ•´æ¡ˆä¾‹ï¼šWeb è¯·æ±‚è¿½è¸ªç³»ç»Ÿ
 * éœ€æ±‚ï¼šåœ¨å¼‚æ­¥ä»»åŠ¡ä¸­èƒ½å¤Ÿè·å–åˆ°è¯·æ±‚çš„ traceIdã€userId ç­‰ä¿¡æ¯
 */

// ============ 1. å®šä¹‰ä¸Šä¸‹æ–‡ ============
import com.alibaba.ttl.TransmittableThreadLocal;

public class RequestContext {
    
    // è¯·æ±‚è¿½è¸ªID
    private static final TransmittableThreadLocal<String> traceIdHolder 
        = new TransmittableThreadLocal<>();
    
    // ç”¨æˆ·ID
    private static final TransmittableThreadLocal<Long> userIdHolder 
        = new TransmittableThreadLocal<>();
    
    // è¯·æ±‚å¼€å§‹æ—¶é—´
    private static final TransmittableThreadLocal<Long> startTimeHolder 
        = new TransmittableThreadLocal<>();
    
    public static void setTraceId(String traceId) {
        traceIdHolder.set(traceId);
    }
    
    public static String getTraceId() {
        return traceIdHolder.get();
    }
    
    public static void setUserId(Long userId) {
        userIdHolder.set(userId);
    }
    
    public static Long getUserId() {
        return userIdHolder.get();
    }
    
    public static void setStartTime(Long startTime) {
        startTimeHolder.set(startTime);
    }
    
    public static Long getStartTime() {
        return startTimeHolder.get();
    }
    
    public static void clear() {
        traceIdHolder.remove();
        userIdHolder.remove();
        startTimeHolder.remove();
    }
    
    // è·å–å®Œæ•´ä¸Šä¸‹æ–‡ä¿¡æ¯
    public static String getContextInfo() {
        return String.format("TraceId=%s, UserId=%s, Duration=%dms", 
            getTraceId(), getUserId(), 
            System.currentTimeMillis() - getStartTime());
    }
}

// ============ 2. é…ç½®çº¿ç¨‹æ±  ============
import com.alibaba.ttl.threadpool.TtlExecutors;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class ThreadPoolConfig {
    
    @Bean("asyncTaskExecutor")
    public Executor asyncTaskExecutor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(10);
        executor.setMaxPoolSize(20);
        executor.setQueueCapacity(200);
        executor.setKeepAliveSeconds(60);
        executor.setThreadNamePrefix("async-task-");
        executor.setRejectedExecutionHandler(new ThreadPoolExecutor.CallerRunsPolicy());
        executor.initialize();
        
        // âš ï¸ å…³é”®ï¼šä½¿ç”¨ TtlExecutors è£…é¥°çº¿ç¨‹æ± 
        return TtlExecutors.getTtlExecutor(executor.getThreadPoolExecutor());
    }
}

// ============ 3. æ‹¦æˆªå™¨è®¾ç½®ä¸Šä¸‹æ–‡ ============
import org.springframework.stereotype.Component;
import org.springframework.web.servlet.HandlerInterceptor;

@Component
public class RequestContextInterceptor implements HandlerInterceptor {
    
    @Override
    public boolean preHandle(HttpServletRequest request, 
                           HttpServletResponse response, 
                           Object handler) {
        // ç”Ÿæˆæˆ–è·å– TraceId
        String traceId = request.getHeader("X-Trace-Id");
        if (traceId == null) {
            traceId = UUID.randomUUID().toString().replace("-", "");
        }
        RequestContext.setTraceId(traceId);
        
        // ä» token è§£æç”¨æˆ·ID
        String token = request.getHeader("Authorization");
        if (token != null) {
            Long userId = parseUserId(token);
            RequestContext.setUserId(userId);
        }
        
        // è®°å½•å¼€å§‹æ—¶é—´
        RequestContext.setStartTime(System.currentTimeMillis());
        
        // æ·»åŠ åˆ°å“åº”å¤´
        response.setHeader("X-Trace-Id", traceId);
        
        return true;
    }
    
    @Override
    public void afterCompletion(HttpServletRequest request, 
                               HttpServletResponse response, 
                               Object handler, 
                               Exception ex) {
        // æ¸…ç†ä¸Šä¸‹æ–‡
        RequestContext.clear();
    }
    
    private Long parseUserId(String token) {
        // è§£æ token é€»è¾‘
        return 12345L;
    }
}

// ============ 4. æ³¨å†Œæ‹¦æˆªå™¨ ============
@Configuration
public class WebMvcConfig implements WebMvcConfigurer {
    
    @Autowired
    private RequestContextInterceptor requestContextInterceptor;
    
    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(requestContextInterceptor)
                .addPathPatterns("/**");
    }
}

// ============ 5. Service å±‚ä½¿ç”¨ ============
@Service
public class OrderService {
    
    @Autowired
    @Qualifier("asyncTaskExecutor")
    private Executor asyncTaskExecutor;
    
    @Autowired
    private NotificationService notificationService;
    
    /**
     * åˆ›å»ºè®¢å•ï¼ˆåŒæ­¥å¤„ç†ï¼‰
     */
    public Order createOrder(OrderRequest request) {
        log.info("åˆ›å»ºè®¢å•å¼€å§‹ - {}", RequestContext.getContextInfo());
        
        // ä¿å­˜è®¢å•
        Order order = saveOrder(request);
        
        // âœ… å¼‚æ­¥å‘é€é€šçŸ¥ï¼ˆèƒ½è·å–åˆ° traceId å’Œ userIdï¼‰
        asyncTaskExecutor.execute(() -> {
            log.info("å¼‚æ­¥ä»»åŠ¡æ‰§è¡Œ - {}", RequestContext.getContextInfo());
            notificationService.sendOrderCreatedNotification(order);
        });
        
        log.info("åˆ›å»ºè®¢å•å®Œæˆ - {}", RequestContext.getContextInfo());
        return order;
    }
    
    /**
     * æ‰¹é‡å¤„ç†è®¢å•
     */
    @Async("asyncTaskExecutor")
    public CompletableFuture<List<Order>> batchProcessOrders(List<Long> orderIds) {
        log.info("æ‰¹é‡å¤„ç†å¼€å§‹ - {}", RequestContext.getContextInfo());
        
        // å¹¶è¡Œå¤„ç†ï¼ˆçº¿ç¨‹æ± ä¸­çš„çº¿ç¨‹ä¹Ÿèƒ½è·å–åˆ°ä¸Šä¸‹æ–‡ï¼‰
        List<CompletableFuture<Order>> futures = orderIds.stream()
            .map(orderId -> CompletableFuture.supplyAsync(() -> {
                log.info("å¤„ç†è®¢å•{} - {}", orderId, RequestContext.getContextInfo());
                return processOrder(orderId);
            }, asyncTaskExecutor))
            .collect(Collectors.toList());
        
        return CompletableFuture.allOf(futures.toArray(new CompletableFuture[0]))
            .thenApply(v -> futures.stream()
                .map(CompletableFuture::join)
                .collect(Collectors.toList()));
    }
    
    private Order saveOrder(OrderRequest request) {
        // ä¿å­˜è®¢å•é€»è¾‘
        return new Order();
    }
    
    private Order processOrder(Long orderId) {
        // å¤„ç†è®¢å•é€»è¾‘
        return new Order();
    }
}

// ============ 6. æ—¥å¿—é…ç½®ï¼ˆLogbackï¼‰============
<!-- logback-spring.xml -->
<configuration>
    <appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender">
        <encoder>
            <pattern>
                %d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level [TraceId:%X{traceId}] [UserId:%X{userId}] %logger{36} - %msg%n
            </pattern>
        </encoder>
    </appender>
    
    <root level="INFO">
        <appender-ref ref="CONSOLE" />
    </root>
</configuration>

// ============ 7. æ—¥å¿—åˆ‡é¢ï¼ˆè‡ªåŠ¨æ·»åŠ  MDCï¼‰============
import org.slf4j.MDC;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;

@Aspect
@Component
public class LoggingAspect {
    
    @Before("execution(* com.example..*.*(..)) && !execution(* com.example.config..*(..))")
    public void before(JoinPoint joinPoint) {
        // ä» RequestContext è·å–ä¿¡æ¯å¹¶è®¾ç½®åˆ° MDC
        String traceId = RequestContext.getTraceId();
        Long userId = RequestContext.getUserId();
        
        if (traceId != null) {
            MDC.put("traceId", traceId);
        }
        if (userId != null) {
            MDC.put("userId", String.valueOf(userId));
        }
    }
}
```

**è¿è¡Œæ•ˆæœ**ï¼š

```log
2024-10-27 10:00:00.123 [http-nio-8080-exec-1] INFO [TraceId:abc123] [UserId:12345] 
  c.e.service.OrderService - åˆ›å»ºè®¢å•å¼€å§‹ - TraceId=abc123, UserId=12345, Duration=5ms

2024-10-27 10:00:00.150 [async-task-1] INFO [TraceId:abc123] [UserId:12345] 
  c.e.service.NotificationService - å¼‚æ­¥ä»»åŠ¡æ‰§è¡Œ - TraceId=abc123, UserId=12345, Duration=32ms
                                    â†‘ âœ… å¼‚æ­¥çº¿ç¨‹æˆåŠŸè·å–åˆ° TraceId å’Œ UserId

2024-10-27 10:00:00.200 [http-nio-8080-exec-1] INFO [TraceId:abc123] [UserId:12345] 
  c.e.service.OrderService - åˆ›å»ºè®¢å•å®Œæˆ - TraceId=abc123, UserId=12345, Duration=82ms
```

### 6.2 åˆ†å¸ƒå¼ä»»åŠ¡è°ƒåº¦åœºæ™¯

```java
/**
 * æ¡ˆä¾‹ï¼šXXL-Job æˆ– Elastic-Job ä¸­ä¼ é€’ä¸Šä¸‹æ–‡
 */

// ============ é—®é¢˜åœºæ™¯ ============
@Component
public class DataSyncJob {
    
    @Autowired
    private ThreadPoolExecutor syncThreadPool;
    
    @XxlJob("dataSyncJobHandler")
    public void execute() {
        // ä»»åŠ¡è°ƒåº¦çº¿ç¨‹è®¾ç½®ä¸Šä¸‹æ–‡
        String jobId = XxlJobHelper.getJobId();
        RequestContext.setTraceId(jobId);
        
        // æŸ¥è¯¢å¾…åŒæ­¥çš„æ•°æ®
        List<Data> dataList = queryDataToSync();
        
        // âŒ é—®é¢˜ï¼šä½¿ç”¨çº¿ç¨‹æ± å¹¶å‘åŒæ­¥ï¼Œå­çº¿ç¨‹æ— æ³•è·å– jobId
        dataList.forEach(data -> {
            syncThreadPool.execute(() -> {
                // RequestContext.getTraceId() è¿”å› null âŒ
                syncData(data);
            });
        });
    }
}

// ============ è§£å†³æ–¹æ¡ˆ ============
@Component
public class DataSyncJobFixed {
    
    @Autowired
    private ThreadPoolExecutor syncThreadPool;
    
    // âš ï¸ é…ç½®çº¿ç¨‹æ± æ—¶ä½¿ç”¨ TTL è£…é¥°
    @Bean
    public ThreadPoolExecutor syncThreadPool() {
        ThreadPoolExecutor executor = new ThreadPoolExecutor(
            10, 20, 60, TimeUnit.SECONDS,
            new LinkedBlockingQueue<>(1000),
            new ThreadFactoryBuilder().setNameFormat("sync-pool-%d").build()
        );
        
        // ä½¿ç”¨ TtlExecutors è£…é¥°
        return (ThreadPoolExecutor) TtlExecutors.getTtlExecutorService(executor);
    }
    
    @XxlJob("dataSyncJobHandler")
    public void execute() {
        // ä½¿ç”¨ TransmittableThreadLocal
        String jobId = String.valueOf(XxlJobHelper.getJobId());
        RequestContext.setTraceId(jobId);
        
        log.info("ä»»åŠ¡å¼€å§‹ - JobId: {}", jobId);
        
        List<Data> dataList = queryDataToSync();
        
        // âœ… å­çº¿ç¨‹èƒ½è·å–åˆ° jobId
        CountDownLatch latch = new CountDownLatch(dataList.size());
        dataList.forEach(data -> {
            syncThreadPool.execute(() -> {
                try {
                    String currentJobId = RequestContext.getTraceId();
                    log.info("åŒæ­¥æ•°æ® {} - JobId: {}", data.getId(), currentJobId);
                    syncData(data);
                } finally {
                    latch.countDown();
                }
            });
        });
        
        // ç­‰å¾…æ‰€æœ‰ä»»åŠ¡å®Œæˆ
        latch.await(5, TimeUnit.MINUTES);
        log.info("ä»»åŠ¡å®Œæˆ - JobId: {}", jobId);
    }
}
```

### 6.3 Dubbo RPC è°ƒç”¨ä¼ é€’

```java
/**
 * æ¡ˆä¾‹ï¼šDubbo æœåŠ¡é—´ä¼ é€’ä¸Šä¸‹æ–‡
 */

// ============ Provider ç«¯ ============
// Dubbo Filter æå–ä¸Šä¸‹æ–‡
@Activate(group = Constants.PROVIDER)
public class ProviderContextFilter implements Filter {
    
    @Override
    public Result invoke(Invoker<?> invoker, Invocation invocation) {
        try {
            // ä» RPC ä¸Šä¸‹æ–‡è·å–
            String traceId = RpcContext.getContext().getAttachment("traceId");
            String userId = RpcContext.getContext().getAttachment("userId");
            
            // è®¾ç½®åˆ° ThreadLocal
            if (traceId != null) {
                RequestContext.setTraceId(traceId);
            }
            if (userId != null) {
                RequestContext.setUserId(Long.parseLong(userId));
            }
            
            return invoker.invoke(invocation);
        } finally {
            RequestContext.clear();
        }
    }
}

// ============ Consumer ç«¯ ============
// Dubbo Filter ä¼ é€’ä¸Šä¸‹æ–‡
@Activate(group = Constants.CONSUMER)
public class ConsumerContextFilter implements Filter {
    
    @Override
    public Result invoke(Invoker<?> invoker, Invocation invocation) {
        // ä» ThreadLocal è·å–
        String traceId = RequestContext.getTraceId();
        Long userId = RequestContext.getUserId();
        
        // è®¾ç½®åˆ° RPC ä¸Šä¸‹æ–‡ï¼ˆä¼šä¼ é€’åˆ° Providerï¼‰
        if (traceId != null) {
            RpcContext.getContext().setAttachment("traceId", traceId);
        }
        if (userId != null) {
            RpcContext.getContext().setAttachment("userId", String.valueOf(userId));
        }
        
        return invoker.invoke(invocation);
    }
}

// ============ æœåŠ¡å®ç° ============
@Service
public class OrderServiceImpl implements OrderService {
    
    @Autowired
    private PaymentService paymentService; // Dubbo è¿œç¨‹æœåŠ¡
    
    @Autowired
    private Executor asyncExecutor;
    
    @Override
    public Order createOrder(OrderRequest request) {
        // Controller è®¾ç½®äº† traceId
        log.info("åˆ›å»ºè®¢å• - {}", RequestContext.getContextInfo());
        
        Order order = new Order();
        order.setId(generateOrderId());
        
        // åŒæ­¥è°ƒç”¨ Dubbo æœåŠ¡ï¼ˆtraceId ä¼šè‡ªåŠ¨ä¼ é€’ï¼‰
        Payment payment = paymentService.createPayment(order.getId());
        
        // å¼‚æ­¥ä»»åŠ¡ï¼ˆä½¿ç”¨ TTL ä¿è¯èƒ½è·å– traceIdï¼‰
        asyncExecutor.execute(() -> {
            log.info("å¼‚æ­¥å¤„ç† - {}", RequestContext.getContextInfo());
            // ä¸šåŠ¡é€»è¾‘...
        });
        
        return order;
    }
}

// PaymentService (è¿œç¨‹æœåŠ¡)
@Service
public class PaymentServiceImpl implements PaymentService {
    
    @Override
    public Payment createPayment(Long orderId) {
        // âœ… èƒ½è·å–åˆ°è°ƒç”¨æ–¹ä¼ é€’çš„ traceId
        log.info("åˆ›å»ºæ”¯ä»˜ - OrderId: {}, {}", 
            orderId, RequestContext.getContextInfo());
        
        Payment payment = new Payment();
        payment.setOrderId(orderId);
        return payment;
    }
}
```

### 6.4 MQ æ¶ˆæ¯ä¼ é€’ä¸Šä¸‹æ–‡

```java
/**
 * æ¡ˆä¾‹ï¼šRocketMQ æ¶ˆæ¯ä¼ é€’ä¸Šä¸‹æ–‡
 */

// ============ ç”Ÿäº§è€… ============
@Service
public class OrderEventPublisher {
    
    @Autowired
    private RocketMQTemplate rocketMQTemplate;
    
    public void publishOrderCreatedEvent(Order order) {
        OrderCreatedEvent event = new OrderCreatedEvent(order);
        
        // åˆ›å»ºæ¶ˆæ¯
        Message<OrderCreatedEvent> message = MessageBuilder
            .withPayload(event)
            // âš ï¸ å…³é”®ï¼šå°†ä¸Šä¸‹æ–‡ä¿¡æ¯æ”¾å…¥æ¶ˆæ¯å¤´
            .setHeader("traceId", RequestContext.getTraceId())
            .setHeader("userId", RequestContext.getUserId())
            .build();
        
        rocketMQTemplate.send("order-topic", message);
        
        log.info("å‘é€æ¶ˆæ¯ - {}", RequestContext.getContextInfo());
    }
}

// ============ æ¶ˆè´¹è€… ============
@Service
@RocketMQMessageListener(topic = "order-topic", consumerGroup = "order-consumer")
public class OrderEventConsumer implements RocketMQListener<Message<OrderCreatedEvent>> {
    
    @Autowired
    private Executor asyncExecutor;
    
    @Override
    public void onMessage(Message<OrderCreatedEvent> message) {
        try {
            // âš ï¸ å…³é”®ï¼šä»æ¶ˆæ¯å¤´æ¢å¤ä¸Šä¸‹æ–‡
            String traceId = (String) message.getHeaders().get("traceId");
            Long userId = (Long) message.getHeaders().get("userId");
            
            RequestContext.setTraceId(traceId);
            RequestContext.setUserId(userId);
            RequestContext.setStartTime(System.currentTimeMillis());
            
            log.info("æ¥æ”¶æ¶ˆæ¯ - {}", RequestContext.getContextInfo());
            
            OrderCreatedEvent event = message.getPayload();
            
            // âœ… å¼‚æ­¥å¤„ç†ï¼ˆä½¿ç”¨ TTL ä¿è¯å­çº¿ç¨‹ä¹Ÿèƒ½è·å–ï¼‰
            asyncExecutor.execute(() -> {
                log.info("å¼‚æ­¥å¤„ç†æ¶ˆæ¯ - {}", RequestContext.getContextInfo());
                processOrderCreatedEvent(event);
            });
            
        } finally {
            RequestContext.clear();
        }
    }
    
    private void processOrderCreatedEvent(OrderCreatedEvent event) {
        // ä¸šåŠ¡é€»è¾‘...
    }
}
```

---

## 7. æœ€ä½³å®è·µ

### 7.1 ä½¿ç”¨è§„èŒƒ

```java
/**
 * âœ… æ¨èåšæ³•
 */

// 1. ä½¿ç”¨ TransmittableThreadLocal ä»£æ›¿ InheritableThreadLocal
private static final TransmittableThreadLocal<String> context 
    = new TransmittableThreadLocal<>();

// 2. çº¿ç¨‹æ± å¿…é¡»ä½¿ç”¨ TTL è£…é¥°
@Bean
public Executor executor() {
    ThreadPoolExecutor executor = new ThreadPoolExecutor(...);
    return TtlExecutors.getTtlExecutor(executor);
}

// 3. ä½¿ç”¨å®ŒåŠæ—¶æ¸…ç†
try {
    context.set("value");
    // ä¸šåŠ¡é€»è¾‘
} finally {
    context.remove(); // âš ï¸ é‡è¦
}

// 4. æ‹¦æˆªå™¨/Filter ä¸­æ¸…ç†
@Override
public void afterCompletion(...) {
    RequestContext.clear();
}

// 5. é¿å…å­˜å‚¨å¤§å¯¹è±¡
// âŒ ä¸æ¨è
TransmittableThreadLocal<byte[]> largeData = new TransmittableThreadLocal<>();
largeData.set(new byte[1024 * 1024]); // 1MB

// âœ… æ¨èï¼šåªå­˜å‚¨å¿…è¦ä¿¡æ¯
TransmittableThreadLocal<String> traceId = new TransmittableThreadLocal<>();
traceId.set("abc123");

/**
 * âŒ é”™è¯¯åšæ³•
 */

// 1. å¿˜è®°æ¸…ç†å¯¼è‡´å†…å­˜æ³„æ¼
public void handle() {
    context.set("value");
    // æ²¡æœ‰è°ƒç”¨ remove()
} // âŒ å†…å­˜æ³„æ¼

// 2. çº¿ç¨‹æ± æœªä½¿ç”¨ TTL è£…é¥°
@Bean
public Executor executor() {
    return Executors.newFixedThreadPool(10); // âŒ æœªè£…é¥°
}

// 3. åœ¨ ThreadLocal ä¸­å­˜å‚¨ä¸å¯åºåˆ—åŒ–å¯¹è±¡
TransmittableThreadLocal<Connection> conn = new TransmittableThreadLocal<>();
// âŒ Connection ä¸åº”è¯¥åœ¨çº¿ç¨‹é—´ä¼ é€’
```

### 7.2 æ€§èƒ½ä¼˜åŒ–

```java
/**
 * æ€§èƒ½è€ƒè™‘
 */

// 1. é¿å…é¢‘ç¹ set/get
// âŒ ä½æ•ˆ
for (int i = 0; i < 10000; i++) {
    String value = context.get();
    // ä½¿ç”¨ value
}

// âœ… ä¼˜åŒ–ï¼šç¼“å­˜åˆ°å±€éƒ¨å˜é‡
String value = context.get();
for (int i = 0; i < 10000; i++) {
    // ä½¿ç”¨ value
}

// 2. åˆç†è®¾ç½®çº¿ç¨‹æ± å¤§å°
@Bean
public Executor executor() {
    int coreSize = Runtime.getRuntime().availableProcessors();
    ThreadPoolExecutor executor = new ThreadPoolExecutor(
        coreSize,                    // æ ¸å¿ƒçº¿ç¨‹æ•°
        coreSize * 2,                // æœ€å¤§çº¿ç¨‹æ•°
        60, TimeUnit.SECONDS,
        new LinkedBlockingQueue<>(1000)
    );
    return TtlExecutors.getTtlExecutor(executor);
}

// 3. ä½¿ç”¨å¯¹è±¡æ± å‡å°‘ GC å‹åŠ›
public class ContextPool {
    private static final ObjectPool<Context> pool = new GenericObjectPool<>(
        new ContextFactory()
    );
    
    public static Context borrowContext() {
        return pool.borrowObject();
    }
    
    public static void returnContext(Context ctx) {
        ctx.clear();
        pool.returnObject(ctx);
    }
}
```

### 7.3 ç›‘æ§å’Œè¯Šæ–­

```java
/**
 * ç›‘æ§ ThreadLocal ä½¿ç”¨æƒ…å†µ
 */

@Component
public class ThreadLocalMonitor {
    
    private static final Logger log = LoggerFactory.getLogger(ThreadLocalMonitor.class);
    
    // ç»Ÿè®¡ä¿¡æ¯
    private final AtomicLong setCount = new AtomicLong(0);
    private final AtomicLong getCount = new AtomicLong(0);
    private final AtomicLong removeCount = new AtomicLong(0);
    
    public static class MonitoredThreadLocal<T> extends TransmittableThreadLocal<T> {
        
        private final ThreadLocalMonitor monitor;
        private final String name;
        
        public MonitoredThreadLocal(String name, ThreadLocalMonitor monitor) {
            this.name = name;
            this.monitor = monitor;
        }
        
        @Override
        public void set(T value) {
            monitor.setCount.incrementAndGet();
            super.set(value);
        }
        
        @Override
        public T get() {
            monitor.getCount.incrementAndGet();
            return super.get();
        }
        
        @Override
        public void remove() {
            monitor.removeCount.incrementAndGet();
            super.remove();
        }
    }
    
    @Scheduled(fixedRate = 60000) // æ¯åˆ†é’Ÿè¾“å‡ºä¸€æ¬¡
    public void printStats() {
        log.info("ThreadLocal ç»Ÿè®¡ - Set: {}, Get: {}, Remove: {}, æ½œåœ¨æ³„æ¼: {}",
            setCount.get(), getCount.get(), removeCount.get(),
            setCount.get() - removeCount.get());
        
        // é‡ç½®è®¡æ•°å™¨
        setCount.set(0);
        getCount.set(0);
        removeCount.set(0);
    }
}

// ä½¿ç”¨
@Service
public class RequestContextWithMonitor {
    
    @Autowired
    private ThreadLocalMonitor monitor;
    
    private MonitoredThreadLocal<String> traceId = 
        new MonitoredThreadLocal<>("traceId", monitor);
}
```

### 7.4 å®‰å…¨æ³¨æ„äº‹é¡¹

```java
/**
 * å®‰å…¨è€ƒè™‘
 */

// 1. æ•æ„Ÿä¿¡æ¯è„±æ•
public class SecurityContext {
    private static final TransmittableThreadLocal<String> tokenHolder 
        = new TransmittableThreadLocal<>();
    
    public static void setToken(String token) {
        // âš ï¸ æ•æ„Ÿä¿¡æ¯ï¼šç¡®ä¿åœ¨æ—¥å¿—ä¸­è„±æ•
        tokenHolder.set(token);
    }
    
    @Override
    public String toString() {
        String token = tokenHolder.get();
        if (token != null && token.length() > 10) {
            // è„±æ•ï¼šåªæ˜¾ç¤ºå‰åå„3ä½
            return token.substring(0, 3) + "****" + 
                   token.substring(token.length() - 3);
        }
        return "****";
    }
}

// 2. æƒé™æ£€æŸ¥
public class PermissionContext {
    private static final TransmittableThreadLocal<Set<String>> permissionsHolder 
        = new TransmittableThreadLocal<>();
    
    public static boolean hasPermission(String permission) {
        Set<String> permissions = permissionsHolder.get();
        return permissions != null && permissions.contains(permission);
    }
    
    public static void checkPermission(String permission) {
        if (!hasPermission(permission)) {
            throw new AccessDeniedException("æ— æƒé™: " + permission);
        }
    }
}

// 3. é˜²æ­¢è·¨ç§Ÿæˆ·æ•°æ®æ³„æ¼
public class TenantContext {
    private static final TransmittableThreadLocal<String> tenantIdHolder 
        = new TransmittableThreadLocal<>();
    
    public static void setTenantId(String tenantId) {
        tenantIdHolder.set(tenantId);
    }
    
    public static String getTenantId() {
        String tenantId = tenantIdHolder.get();
        if (tenantId == null) {
            throw new IllegalStateException("ç§Ÿæˆ·IDæœªè®¾ç½®");
        }
        return tenantId;
    }
    
    // SQL æ‹¦æˆªå™¨ï¼šè‡ªåŠ¨æ·»åŠ ç§Ÿæˆ·æ¡ä»¶
    @Intercepts({
        @Signature(type = StatementHandler.class, method = "prepare", args = {Connection.class, Integer.class})
    })
    public static class TenantInterceptor implements Interceptor {
        @Override
        public Object intercept(Invocation invocation) throws Throwable {
            StatementHandler handler = (StatementHandler) invocation.getTarget();
            String sql = handler.getBoundSql().getSql();
            
            // è‡ªåŠ¨æ·»åŠ  WHERE tenant_id = ?
            String tenantId = TenantContext.getTenantId();
            String modifiedSql = addTenantCondition(sql, tenantId);
            
            // æ‰§è¡Œä¿®æ”¹åçš„ SQL
            return invocation.proceed();
        }
    }
}
```

---

## 8. å¸¸è§é—®é¢˜

### Q1: ThreadLocal ä¼šå¯¼è‡´å†…å­˜æ³„æ¼å—ï¼Ÿ

**A**: ä¼šï¼Œå¦‚æœä¸åŠæ—¶ remove()

**åŸå› **ï¼š
```java
// Thread æŒæœ‰ ThreadLocalMap
class Thread {
    ThreadLocal.ThreadLocalMap threadLocals;
}

// ThreadLocalMap çš„ Entry ç»§æ‰¿ WeakReference
static class Entry extends WeakReference<ThreadLocal<?>> {
    Object value; // âš ï¸ å¼ºå¼•ç”¨
}

// é—®é¢˜ï¼š
// 1. ThreadLocal å¯¹è±¡è¢«å›æ”¶ï¼ˆå¼±å¼•ç”¨ï¼‰
// 2. ä½† value ä»ç„¶è¢«å¼ºå¼•ç”¨
// 3. å¦‚æœçº¿ç¨‹é•¿æœŸå­˜æ´»ï¼ˆå¦‚çº¿ç¨‹æ± ï¼‰ï¼Œvalue æ— æ³•å›æ”¶
// 4. å¯¼è‡´å†…å­˜æ³„æ¼
```

**è§£å†³**ï¼š
```java
try {
    threadLocal.set(value);
    // ä¸šåŠ¡é€»è¾‘
} finally {
    threadLocal.remove(); // âš ï¸ å¿…é¡»è°ƒç”¨
}
```

### Q2: InheritableThreadLocal åœ¨ ForkJoinPool ä¸­æœ‰æ•ˆå—ï¼Ÿ

**A**: éƒ¨åˆ†æœ‰æ•ˆï¼Œä½†ä¸å®Œå…¨å¯é 

```java
// ForkJoinPool é»˜è®¤ä¸å¤åˆ¶ InheritableThreadLocal
ForkJoinPool pool = new ForkJoinPool();
pool.submit(() -> {
    // å¯èƒ½è·å–ä¸åˆ°çˆ¶çº¿ç¨‹çš„å€¼
});

// è§£å†³ï¼šä½¿ç”¨ TTL çš„ TtlForkJoinPool
ForkJoinPool ttlPool = TtlForkJoinPoolHelper.getDefaultDisableInheritableThreadFactory();
```

### Q3: Spring @Async éœ€è¦ç‰¹æ®Šå¤„ç†å—ï¼Ÿ

**A**: éœ€è¦é…ç½® TTL è£…é¥°çš„ Executor

```java
@Configuration
@EnableAsync
public class AsyncConfig implements AsyncConfigurer {
    
    @Override
    public Executor getAsyncExecutor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(10);
        executor.initialize();
        
        // âš ï¸ ä½¿ç”¨ TTL è£…é¥°
        return TtlExecutors.getTtlExecutor(executor.getThreadPoolExecutor());
    }
}
```

### Q4: å¦‚ä½•åœ¨ CompletableFuture ä¸­ä¼ é€’ï¼Ÿ

**A**: ä½¿ç”¨ TTL è£…é¥°çš„ Executor

```java
// âŒ é—®é¢˜
CompletableFuture.supplyAsync(() -> {
    return RequestContext.getTraceId(); // null
});

// âœ… è§£å†³
Executor ttlExecutor = TtlExecutors.getTtlExecutor(executor);
CompletableFuture.supplyAsync(() -> {
    return RequestContext.getTraceId(); // âœ… æœ‰å€¼
}, ttlExecutor);
```

### Q5: æ€§èƒ½å¼€é”€å¤§å—ï¼Ÿ

**A**: TTL æœ‰ä¸€å®šå¼€é”€ï¼Œä½†é€šå¸¸å¯æ¥å—

```
åŸºå‡†æµ‹è¯•ï¼ˆJMHï¼‰ï¼š
- ThreadLocal.get():        ~2 ns
- InheritableThreadLocal:   ~2 ns
- TTL.get():                ~3 ns
- TTL ä»»åŠ¡æäº¤é¢å¤–å¼€é”€:     ~200 ns

ç»“è®ºï¼šå•æ¬¡è°ƒç”¨å¼€é”€å¾ˆå°ï¼Œé™¤éæ¯ç§’ç™¾ä¸‡æ¬¡è°ƒç”¨ï¼Œå¦åˆ™å½±å“å¯å¿½ç•¥
```

---

## 9. æ€»ç»“

### 9.1 æ ¸å¿ƒå¯¹æ¯”

| ç‰¹æ€§ | ThreadLocal | InheritableThreadLocal | TransmittableThreadLocal |
|------|------------|----------------------|-------------------------|
| **çº¿ç¨‹éš”ç¦»** | âœ… | âœ… | âœ… |
| **çˆ¶å­çº¿ç¨‹ä¼ é€’** | âŒ | âœ… | âœ… |
| **çº¿ç¨‹æ± æ”¯æŒ** | âŒ | âŒ | âœ… |
| **æ€§èƒ½å¼€é”€** | æœ€ä½ | ä½ | ä¸­ç­‰ |
| **ä½¿ç”¨å¤æ‚åº¦** | ç®€å• | ç®€å• | éœ€è¦è£…é¥°çº¿ç¨‹æ±  |
| **å…¸å‹åœºæ™¯** | å•çº¿ç¨‹ä¸Šä¸‹æ–‡ | new Thread() | çº¿ç¨‹æ± ã€å¼‚æ­¥ä»»åŠ¡ |

### 9.2 é€‰å‹å»ºè®®

```
1. å•çº¿ç¨‹å†…å…±äº«æ•°æ®
   â†’ ä½¿ç”¨ ThreadLocal

2. çˆ¶å­çº¿ç¨‹ä¼ é€’ï¼ˆnew Threadï¼‰
   â†’ ä½¿ç”¨ InheritableThreadLocal

3. çº¿ç¨‹æ±  / å¼‚æ­¥ä»»åŠ¡ / å¾®æœåŠ¡
   â†’ ä½¿ç”¨ TransmittableThreadLocal

4. è·¨è¿›ç¨‹ä¼ é€’
   â†’ ä½¿ç”¨æ¶ˆæ¯å¤´ä¼ é€’ï¼ˆHTTP Headerã€MQ Headerç­‰ï¼‰
```

### 9.3 å…³é”®è¦ç‚¹

```
âœ… å¿…é¡»åšï¼š
1. ä½¿ç”¨å®Œè°ƒç”¨ remove()
2. çº¿ç¨‹æ± ä½¿ç”¨ TtlExecutors è£…é¥°
3. åªå­˜å‚¨å¿…è¦çš„å°å¯¹è±¡
4. åœ¨æ‹¦æˆªå™¨/Filter ä¸­ç»Ÿä¸€ç®¡ç†

âŒ ä¸è¦åšï¼š
1. å­˜å‚¨å¤§å¯¹è±¡æˆ–Connection
2. å¿˜è®°æ¸…ç†å¯¼è‡´æ³„æ¼
3. åœ¨ThreadLocalä¸­å­˜å‚¨å¯å˜å¯¹è±¡å¹¶è·¨çº¿ç¨‹ä¿®æ”¹
4. è¿‡åº¦ä¾èµ–ThreadLocalä¼ é€’ä¸šåŠ¡æ•°æ®
```

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0  
**æœ€åæ›´æ–°**: 2024-10-27  
**å‚è€ƒèµ„æ–™**:
- TransmittableThreadLocal: https://github.com/alibaba/transmittable-thread-local
- Java ThreadLocal æºç 
- Spring Framework æ–‡æ¡£


### 1.5 æ›´å¤šåœºæ™¯æ·±åº¦è§£æ

ä¸‹é¢è¡¥å……æ›´å¤šå®é™…å¼€å‘ä¸­ä¼šé‡åˆ°çš„çº¿ç¨‹å˜é‡ä¼ é€’åœºæ™¯ï¼š

```java
/**
 * åœºæ™¯9-15ï¼šæ›´å¤šçº¿ç¨‹å˜é‡ä¼ é€’åœºæ™¯
 */
public class MoreThreadLocalScenarios {
    
    private static TransmittableThreadLocal<String> ttl = new TransmittableThreadLocal<>();
    private static InheritableThreadLocal<String> itl = new InheritableThreadLocal<>();
    
    // ============ åœºæ™¯9: Servlet å®¹å™¨çº¿ç¨‹æ±  ============
    /**
     * Servlet å®¹å™¨ï¼ˆTomcat/Jettyï¼‰ä½¿ç”¨çº¿ç¨‹æ± å¤„ç† HTTP è¯·æ±‚
     * é—®é¢˜ï¼šInheritableThreadLocal åœ¨è¿™é‡Œä¼šæœ‰ä»€ä¹ˆè¡¨ç°ï¼Ÿ
     */
    static void scenario9_ServletContainer() {
        System.out.println("\n========== åœºæ™¯9: Servlet å®¹å™¨çº¿ç¨‹æ±  ==========");
        
        // æ¨¡æ‹Ÿ Tomcat çº¿ç¨‹æ± 
        ExecutorService tomcatThreadPool = Executors.newFixedThreadPool(10);
        
        // æ¨¡æ‹Ÿç¬¬ä¸€ä¸ª HTTP è¯·æ±‚
        tomcatThreadPool.submit(() -> {
            // Filter/Interceptor è®¾ç½®ç”¨æˆ·ä¿¡æ¯
            itl.set("ç”¨æˆ·A");
            ttl.set("ç”¨æˆ·A");
            
            // Controller å±‚å¤„ç†
            System.out.println("è¯·æ±‚1-Controller: ITL=" + itl.get() + ", TTL=" + ttl.get());
            
            // å¼‚æ­¥å¤„ç†è®¢å•ï¼ˆåœ¨åŒä¸€ä¸ªçº¿ç¨‹æ± ä¸­ï¼‰
            tomcatThreadPool.submit(() -> {
                System.out.println("è¯·æ±‚1-å¼‚æ­¥ä»»åŠ¡: ITL=" + itl.get() + ", TTL=" + ttl.get());
                // ITL=ç”¨æˆ·A âœ…ï¼ˆä½†è¿™æ˜¯é”™è¯¯çš„ï¼å› ä¸ºæ˜¯çº¿ç¨‹å¤ç”¨ï¼‰
                // TTL=null âŒï¼ˆæœªè£…é¥°ï¼‰
            });
        });
        
        Thread.sleep(100);
        
        // æ¨¡æ‹Ÿç¬¬äºŒä¸ª HTTP è¯·æ±‚ï¼ˆå¯èƒ½å¤ç”¨åŒä¸€ä¸ªçº¿ç¨‹ï¼‰
        tomcatThreadPool.submit(() -> {
            itl.set("ç”¨æˆ·B");
            ttl.set("ç”¨æˆ·B");
            
            System.out.println("è¯·æ±‚2-Controller: ITL=" + itl.get() + ", TTL=" + ttl.get());
            // ITL=ç”¨æˆ·B âœ…
            // TTL=ç”¨æˆ·B âœ…
            
            tomcatThreadPool.submit(() -> {
                System.out.println("è¯·æ±‚2-å¼‚æ­¥ä»»åŠ¡: ITL=" + itl.get() + ", TTL=" + ttl.get());
                // ITL=ç”¨æˆ·A æˆ– ç”¨æˆ·B âŒï¼ˆä¸ç¡®å®šï¼Œå–å†³äºçº¿ç¨‹å¤ç”¨ï¼‰
                // TTL=null âŒï¼ˆæœªè£…é¥°ï¼‰
            });
        });
        
        /**
         * ğŸš¨ å®‰å…¨é£é™©ï¼š
         * å¦‚æœè¯·æ±‚2å¤ç”¨äº†è¯·æ±‚1çš„çº¿ç¨‹ï¼Œä¸”è¯·æ±‚1æ²¡æœ‰æ¸…ç†ITLï¼Œ
         * é‚£ä¹ˆè¯·æ±‚2çš„å¼‚æ­¥ä»»åŠ¡å¯èƒ½æ‹¿åˆ°ç”¨æˆ·Açš„ä¿¡æ¯ï¼
         * è¿™ä¼šå¯¼è‡´è·¨ç”¨æˆ·æ•°æ®æ³„æ¼ï¼
         * 
         * è§£å†³æ–¹æ¡ˆï¼š
         * 1. ä½¿ç”¨ TTL + è£…é¥°çº¿ç¨‹æ± 
         * 2. åœ¨ Filter çš„ finally ä¸­å¿…é¡»è°ƒç”¨ remove()
         */
    }
    
    // ============ åœºæ™¯10: MyBatis å¤šæ•°æ®æº ============
    /**
     * åŠ¨æ€æ•°æ®æºåˆ‡æ¢åœºæ™¯
     */
    static void scenario10_DynamicDataSource() {
        System.out.println("\n========== åœºæ™¯10: MyBatis å¤šæ•°æ®æº ==========");
        
        // æ•°æ®æºä¸Šä¸‹æ–‡
        class DataSourceContext {
            private static final TransmittableThreadLocal<String> currentDataSource 
                = new TransmittableThreadLocal<>();
            
            public static void setDataSource(String dataSource) {
                currentDataSource.set(dataSource);
                System.out.println("åˆ‡æ¢æ•°æ®æº: " + dataSource);
            }
            
            public static String getDataSource() {
                String ds = currentDataSource.get();
                return ds != null ? ds : "default";
            }
            
            public static void clear() {
                currentDataSource.remove();
            }
        }
        
        // æ¨¡æ‹Ÿ Service å±‚
        ExecutorService ttlPool = TtlExecutors.getTtlExecutorService(
            Executors.newFixedThreadPool(2)
        );
        
        // ä¸»çº¿ç¨‹ï¼šè¯»ä¸»åº“
        DataSourceContext.setDataSource("master");
        System.out.println("ä¸»çº¿ç¨‹æŸ¥è¯¢æ•°æ®æº: " + DataSourceContext.getDataSource());
        
        // å¼‚æ­¥ä»»åŠ¡1ï¼šè¯»ä»åº“
        ttlPool.submit(() -> {
            DataSourceContext.setDataSource("slave1");
            System.out.println("å¼‚æ­¥ä»»åŠ¡1æŸ¥è¯¢æ•°æ®æº: " + DataSourceContext.getDataSource());
            // è¾“å‡º: slave1 âœ…
            DataSourceContext.clear();
        });
        
        // å¼‚æ­¥ä»»åŠ¡2ï¼šåº”è¯¥ç»§æ‰¿ä¸»çº¿ç¨‹çš„ master
        ttlPool.submit(() -> {
            System.out.println("å¼‚æ­¥ä»»åŠ¡2æŸ¥è¯¢æ•°æ®æº: " + DataSourceContext.getDataSource());
            // è¾“å‡º: master âœ…ï¼ˆç»§æ‰¿è‡ªä¸»çº¿ç¨‹ï¼‰
        });
        
        Thread.sleep(100);
        DataSourceContext.clear();
        ttlPool.shutdown();
    }
    
    // ============ åœºæ™¯11: åˆ†åº“åˆ†è¡¨åœºæ™¯ ============
    /**
     * ShardingSphere/MyBatis-Plus åˆ†ç‰‡é”®ä¼ é€’
     */
    static void scenario11_Sharding() {
        System.out.println("\n========== åœºæ™¯11: åˆ†åº“åˆ†è¡¨ ==========");
        
        class ShardingContext {
            private static final TransmittableThreadLocal<Long> userIdHolder 
                = new TransmittableThreadLocal<>();
            
            public static void setUserId(Long userId) {
                userIdHolder.set(userId);
            }
            
            public static Long getUserId() {
                return userIdHolder.get();
            }
            
            // è®¡ç®—åˆ†ç‰‡é”®
            public static String getTableSuffix() {
                Long userId = getUserId();
                if (userId == null) {
                    throw new IllegalStateException("åˆ†ç‰‡é”®æœªè®¾ç½®");
                }
                // æ ¹æ® userId å–æ¨¡å†³å®šè¡¨å
                return "user_" + (userId % 10);
            }
        }
        
        ExecutorService ttlPool = TtlExecutors.getTtlExecutorService(
            Executors.newFixedThreadPool(2)
        );
        
        // è®¾ç½®å½“å‰ç”¨æˆ·
        ShardingContext.setUserId(12345L);
        System.out.println("ä¸»çº¿ç¨‹æŸ¥è¯¢è¡¨: " + ShardingContext.getTableSuffix());
        
        // å¹¶å‘æŸ¥è¯¢ï¼ˆæ¯ä¸ªä»»åŠ¡éƒ½èƒ½æ­£ç¡®è·å–åˆ†ç‰‡é”®ï¼‰
        List<CompletableFuture<String>> futures = Arrays.asList(12345L, 67890L, 11111L)
            .stream()
            .map(userId -> CompletableFuture.supplyAsync(() -> {
                ShardingContext.setUserId(userId);
                String table = ShardingContext.getTableSuffix();
                System.out.println("æŸ¥è¯¢ç”¨æˆ·" + userId + " -> " + table);
                return table;
            }, ttlPool))
            .collect(Collectors.toList());
        
        futures.forEach(f -> f.join());
        ttlPool.shutdown();
    }
    
    // ============ åœºæ™¯12: MDC æ—¥å¿—ä¸Šä¸‹æ–‡ ============
    /**
     * SLF4J MDC (Mapped Diagnostic Context) ä¼ é€’
     * MDC å†…éƒ¨ä½¿ç”¨ ThreadLocalï¼Œåœ¨å¼‚æ­¥åœºæ™¯ä¸‹éœ€è¦æ‰‹åŠ¨ä¼ é€’
     */
    static void scenario12_MDC() {
        System.out.println("\n========== åœºæ™¯12: MDC æ—¥å¿—ä¸Šä¸‹æ–‡ ==========");
        
        import org.slf4j.MDC;
        
        // æ–¹æ¡ˆ1ï¼šæ‰‹åŠ¨ä¼ é€’ï¼ˆä¸æ¨èï¼‰
        String traceId = UUID.randomUUID().toString();
        MDC.put("traceId", traceId);
        
        ExecutorService pool = Executors.newFixedThreadPool(2);
        
        pool.submit(() -> {
            // âŒ å­çº¿ç¨‹æ— æ³•è·å– MDC
            log.info("å¼‚æ­¥ä»»åŠ¡æ‰§è¡Œ"); 
            // æ—¥å¿—è¾“å‡º: [traceId:] å¼‚æ­¥ä»»åŠ¡æ‰§è¡Œï¼ˆtraceId ä¸ºç©ºï¼‰
        });
        
        // æ–¹æ¡ˆ2ï¼šæ‰‹åŠ¨ä¼ é€’ MDCï¼ˆç¹çï¼‰
        Map<String, String> contextMap = MDC.getCopyOfContextMap();
        pool.submit(() -> {
            MDC.setContextMap(contextMap);
            log.info("å¼‚æ­¥ä»»åŠ¡æ‰§è¡Œ");
            // æ—¥å¿—è¾“å‡º: [traceId:xxx] å¼‚æ­¥ä»»åŠ¡æ‰§è¡Œ âœ…
            MDC.clear();
        });
        
        // æ–¹æ¡ˆ3ï¼šä½¿ç”¨ TTL è‡ªåŠ¨ä¼ é€’ï¼ˆæ¨èï¼‰
        class MDCContext {
            private static final TransmittableThreadLocal<Map<String, String>> mdcHolder 
                = new TransmittableThreadLocal<>();
            
            public static void set() {
                mdcHolder.set(MDC.getCopyOfContextMap());
            }
            
            public static void restore() {
                Map<String, String> contextMap = mdcHolder.get();
                if (contextMap != null) {
                    MDC.setContextMap(contextMap);
                }
            }
            
            public static void clear() {
                mdcHolder.remove();
                MDC.clear();
            }
        }
        
        // ä½¿ç”¨ TTL è£…é¥°çš„çº¿ç¨‹æ± 
        ExecutorService ttlPool = TtlExecutors.getTtlExecutorService(
            Executors.newFixedThreadPool(2)
        );
        
        MDC.put("traceId", traceId);
        MDC.put("userId", "12345");
        MDCContext.set();
        
        ttlPool.submit(() -> {
            MDCContext.restore();
            log.info("å¼‚æ­¥ä»»åŠ¡æ‰§è¡Œ");
            // æ—¥å¿—è¾“å‡º: [traceId:xxx] [userId:12345] å¼‚æ­¥ä»»åŠ¡æ‰§è¡Œ âœ…
        });
        
        pool.shutdown();
        ttlPool.shutdown();
    }
    
    // ============ åœºæ™¯13: Security ä¸Šä¸‹æ–‡ä¼ é€’ ============
    /**
     * Spring Security SecurityContext ä¼ é€’
     */
    static void scenario13_SpringSecurity() {
        System.out.println("\n========== åœºæ™¯13: Spring Security ==========");
        
        import org.springframework.security.core.context.SecurityContext;
        import org.springframework.security.core.context.SecurityContextHolder;
        
        // Spring Security é»˜è®¤ä½¿ç”¨ ThreadLocal
        // åœ¨å¼‚æ­¥åœºæ™¯ä¸‹éœ€è¦é…ç½®ç­–ç•¥
        
        // æ–¹æ¡ˆ1ï¼šè®¾ç½®ç­–ç•¥ä¸º MODE_INHERITABLETHREADLOCALï¼ˆä¸æ¨èï¼‰
        SecurityContextHolder.setStrategyName(
            SecurityContextHolder.MODE_INHERITABLETHREADLOCAL
        );
        // é—®é¢˜ï¼šçº¿ç¨‹æ± åœºæ™¯ä¸‹ä»ç„¶å¤±æ•ˆ
        
        // æ–¹æ¡ˆ2ï¼šä½¿ç”¨ DelegatingSecurityContextExecutorï¼ˆæ¨èï¼‰
        ExecutorService pool = Executors.newFixedThreadPool(2);
        ExecutorService securityPool = new DelegatingSecurityContextExecutorService(pool);
        
        // è®¾ç½®è®¤è¯ä¿¡æ¯
        Authentication auth = new UsernamePasswordAuthenticationToken(
            "user123", "password", authorities
        );
        SecurityContextHolder.getContext().setAuthentication(auth);
        
        securityPool.submit(() -> {
            // âœ… å¯ä»¥è·å–åˆ°è®¤è¯ä¿¡æ¯
            Authentication currentAuth = SecurityContextHolder.getContext().getAuthentication();
            System.out.println("å½“å‰ç”¨æˆ·: " + currentAuth.getName()); // user123
        });
        
        // æ–¹æ¡ˆ3ï¼šç»“åˆ TTLï¼ˆæœ€ä½³ï¼‰
        class SecurityContextHolder2 {
            private static final TransmittableThreadLocal<SecurityContext> contextHolder 
                = new TransmittableThreadLocal<>();
            
            public static void setContext(SecurityContext context) {
                contextHolder.set(context);
            }
            
            public static SecurityContext getContext() {
                SecurityContext ctx = contextHolder.get();
                if (ctx == null) {
                    ctx = createEmptyContext();
                    contextHolder.set(ctx);
                }
                return ctx;
            }
            
            public static void clearContext() {
                contextHolder.remove();
            }
        }
        
        securityPool.shutdown();
    }
    
    // ============ åœºæ™¯14: äº‹åŠ¡ä¼ æ’­ ============
    /**
     * Spring @Transactional åœ¨å¼‚æ­¥åœºæ™¯ä¸‹çš„é—®é¢˜
     */
    static void scenario14_Transaction() {
        System.out.println("\n========== åœºæ™¯14: äº‹åŠ¡ä¼ æ’­ ==========");
        
        /**
         * âŒ é”™è¯¯ç¤ºä¾‹ï¼šåœ¨ @Transactional æ–¹æ³•ä¸­ä½¿ç”¨å¼‚æ­¥
         */
        @Service
        class OrderService {
            
            @Autowired
            private Executor asyncExecutor;
            
            @Transactional
            public void createOrder(Order order) {
                // ä¿å­˜è®¢å•
                orderMapper.insert(order);
                
                // âŒ å¼‚æ­¥ä»»åŠ¡æ— æ³•å‚ä¸å½“å‰äº‹åŠ¡
                asyncExecutor.execute(() -> {
                    // è¿™é‡Œè·å–ä¸åˆ°å¤–å±‚çš„äº‹åŠ¡
                    // å¦‚æœè¿™é‡ŒæŠ›å¼‚å¸¸ï¼Œå¤–å±‚äº‹åŠ¡ä¸ä¼šå›æ»š
                    inventoryMapper.decreaseStock(order.getProductId());
                });
                
                // å¦‚æœè¿™é‡ŒæŠ›å¼‚å¸¸ï¼Œå¼‚æ­¥ä»»åŠ¡ä¸­çš„åº“å­˜æ‰£å‡ä¸ä¼šå›æ»š
                // å¯¼è‡´æ•°æ®ä¸ä¸€è‡´ï¼
            }
        }
        
        /**
         * âœ… æ­£ç¡®åšæ³•1ï¼šä¸è¦åœ¨äº‹åŠ¡ä¸­ä½¿ç”¨å¼‚æ­¥
         */
        @Service
        class OrderServiceFixed1 {
            
            @Transactional
            public void createOrder(Order order) {
                // åœ¨äº‹åŠ¡ä¸­å®Œæˆæ‰€æœ‰æ“ä½œ
                orderMapper.insert(order);
                inventoryMapper.decreaseStock(order.getProductId());
            }
            
            // äº‹åŠ¡æäº¤åå†å¼‚æ­¥å¤„ç†
            public void createOrderAsync(Order order) {
                createOrder(order); // åŒæ­¥å®Œæˆäº‹åŠ¡
                
                // äº‹åŠ¡å·²æäº¤ï¼Œå¼‚æ­¥å‘é€é€šçŸ¥
                asyncExecutor.execute(() -> {
                    notificationService.sendOrderCreatedNotification(order);
                });
            }
        }
        
        /**
         * âœ… æ­£ç¡®åšæ³•2ï¼šä½¿ç”¨ @TransactionalEventListener
         */
        @Service
        class OrderServiceFixed2 {
            
            @Autowired
            private ApplicationEventPublisher eventPublisher;
            
            @Transactional
            public void createOrder(Order order) {
                orderMapper.insert(order);
                inventoryMapper.decreaseStock(order.getProductId());
                
                // å‘å¸ƒäº‹ä»¶ï¼ˆäº‹åŠ¡æäº¤åæ‰ä¼šæ‰§è¡Œï¼‰
                eventPublisher.publishEvent(new OrderCreatedEvent(order));
            }
        }
        
        @Component
        class OrderEventListener {
            
            @Async
            @TransactionalEventListener(phase = TransactionPhase.AFTER_COMMIT)
            public void handleOrderCreated(OrderCreatedEvent event) {
                // äº‹åŠ¡æäº¤åå¼‚æ­¥æ‰§è¡Œ
                notificationService.sendOrderCreatedNotification(event.getOrder());
            }
        }
        
        /**
         * æ³¨æ„ï¼šäº‹åŠ¡ä¿¡æ¯æœ¬èº«ä¸åº”è¯¥åœ¨çº¿ç¨‹é—´ä¼ é€’
         * æ¯ä¸ªçº¿ç¨‹åº”è¯¥æœ‰è‡ªå·±çš„äº‹åŠ¡
         * TransactionSynchronizationManager ä½¿ç”¨ ThreadLocal å­˜å‚¨äº‹åŠ¡ä¿¡æ¯
         */
    }
    
    // ============ åœºæ™¯15: RPC è°ƒç”¨é“¾è·¯ä¼ é€’ ============
    /**
     * Dubbo/Feign è¿œç¨‹è°ƒç”¨æ—¶çš„ä¸Šä¸‹æ–‡ä¼ é€’
     */
    static void scenario15_RPC() {
        System.out.println("\n========== åœºæ™¯15: RPC è°ƒç”¨é“¾è·¯ ==========");
        
        /**
         * Dubbo RPC ä¸Šä¸‹æ–‡ä¼ é€’
         */
        
        // Provider ç«¯ Filter
        @Activate(group = Constants.PROVIDER)
        public class ProviderTraceFilter implements Filter {
            @Override
            public Result invoke(Invoker<?> invoker, Invocation invocation) {
                try {
                    // ä» RPC é™„ä»¶ä¸­æå– traceId
                    String traceId = RpcContext.getContext().getAttachment("traceId");
                    
                    // è®¾ç½®åˆ° ThreadLocal
                    if (traceId != null) {
                        RequestContext.setTraceId(traceId);
                    }
                    
                    // æ‰§è¡Œä¸šåŠ¡é€»è¾‘
                    return invoker.invoke(invocation);
                } finally {
                    RequestContext.clear();
                }
            }
        }
        
        // Consumer ç«¯ Filter
        @Activate(group = Constants.CONSUMER)
        public class ConsumerTraceFilter implements Filter {
            @Override
            public Result invoke(Invoker<?> invoker, Invocation invocation) {
                // ä» ThreadLocal è·å– traceId
                String traceId = RequestContext.getTraceId();
                
                // è®¾ç½®åˆ° RPC é™„ä»¶ï¼ˆä¼šä¼ é€’åˆ° Providerï¼‰
                if (traceId != null) {
                    RpcContext.getContext().setAttachment("traceId", traceId);
                }
                
                return invoker.invoke(invocation);
            }
        }
        
        /**
         * å®Œæ•´è°ƒç”¨é“¾è·¯ï¼š
         * 
         * [æœåŠ¡A - HTTPè¯·æ±‚]
         *   â†“ Interceptor è®¾ç½® traceId åˆ° TTL
         * [æœåŠ¡A - Controller]
         *   â†“ è°ƒç”¨æœåŠ¡B
         * [ConsumerFilter] ä» TTL æå– traceId â†’ RPCé™„ä»¶
         *   â†“ ç½‘ç»œä¼ è¾“
         * [ProviderFilter] ä» RPCé™„ä»¶æå– traceId â†’ TTL
         * [æœåŠ¡B - Controller] âœ… èƒ½è·å–åˆ° traceId
         *   â†“ å¼‚æ­¥ä»»åŠ¡ï¼ˆTTLè£…é¥°çš„çº¿ç¨‹æ± ï¼‰
         * [æœåŠ¡B - Async Task] âœ… èƒ½è·å–åˆ° traceId
         */
        
        /**
         * OpenFeign ç±»ä¼¼å¤„ç†
         */
        @Component
        public class FeignTraceInterceptor implements RequestInterceptor {
            @Override
            public void apply(RequestTemplate template) {
                // ä» TTL è·å– traceId
                String traceId = RequestContext.getTraceId();
                
                // æ·»åŠ åˆ° HTTP Header
                if (traceId != null) {
                    template.header("X-Trace-Id", traceId);
                }
            }
        }
    }
    
    // ============ åœºæ™¯16: WebSocket é•¿è¿æ¥ ============
    static void scenario16_WebSocket() {
        System.out.println("\n========== åœºæ™¯16: WebSocket ==========");
        
        @ServerEndpoint("/websocket/{userId}")
        public class WebSocketServer {
            
            private static final TransmittableThreadLocal<String> sessionIdHolder 
                = new TransmittableThreadLocal<>();
            
            @OnOpen
            public void onOpen(Session session, @PathParam("userId") String userId) {
                // è¿æ¥å»ºç«‹æ—¶è®¾ç½®ä¸Šä¸‹æ–‡
                sessionIdHolder.set(session.getId());
                RequestContext.setUserId(Long.parseLong(userId));
                
                log.info("WebSocketè¿æ¥å»ºç«‹ - {}", RequestContext.getContextInfo());
            }
            
            @OnMessage
            public void onMessage(String message, Session session) {
                // âš ï¸ æ³¨æ„ï¼šæ¯æ¬¡æ¶ˆæ¯å¯èƒ½åœ¨ä¸åŒçº¿ç¨‹å¤„ç†
                // éœ€è¦é‡æ–°è®¾ç½®ä¸Šä¸‹æ–‡
                String sessionId = sessionIdHolder.get();
                log.info("æ”¶åˆ°æ¶ˆæ¯ - SessionId: {}, Message: {}", sessionId, message);
                
                // å¦‚æœéœ€è¦å¼‚æ­¥å¤„ç†
                ExecutorService ttlPool = getTtlExecutorService();
                ttlPool.submit(() -> {
                    // âœ… èƒ½è·å–åˆ° sessionId å’Œ userId
                    processMessage(message);
                });
            }
            
            @OnClose
            public void onClose(Session session) {
                sessionIdHolder.remove();
                RequestContext.clear();
            }
        }
    }
    
    // ============ åœºæ™¯17: Kafka æ¶ˆè´¹è€… ============
    static void scenario17_Kafka() {
        System.out.println("\n========== åœºæ™¯17: Kafka æ¶ˆè´¹è€… ==========");
        
        @KafkaListener(topics = "order-topic", groupId = "order-group")
        public class OrderKafkaListener {
            
            @Autowired
            private Executor asyncExecutor;
            
            public void listen(ConsumerRecord<String, String> record) {
                try {
                    // ä» Kafka Header æå– traceId
                    String traceId = extractTraceId(record.headers());
                    RequestContext.setTraceId(traceId);
                    RequestContext.setStartTime(System.currentTimeMillis());
                    
                    log.info("æ¥æ”¶Kafkaæ¶ˆæ¯ - {}", RequestContext.getContextInfo());
                    
                    // è§£ææ¶ˆæ¯
                    Order order = parseOrder(record.value());
                    
                    // å¼‚æ­¥å¤„ç†ï¼ˆä½¿ç”¨ TTL è£…é¥°çš„çº¿ç¨‹æ± ï¼‰
                    asyncExecutor.execute(() -> {
                        log.info("å¼‚æ­¥å¤„ç†è®¢å• - {}", RequestContext.getContextInfo());
                        processOrder(order);
                    });
                    
                } finally {
                    RequestContext.clear();
                }
            }
            
            private String extractTraceId(Headers headers) {
                Header traceIdHeader = headers.lastHeader("traceId");
                return traceIdHeader != null 
                    ? new String(traceIdHeader.value()) 
                    : UUID.randomUUID().toString();
            }
        }
        
        // Kafka Producer ç«¯ï¼šå‘é€æ¶ˆæ¯æ—¶æ·»åŠ  traceId
        public class OrderProducer {
            
            public void sendOrder(Order order) {
                String traceId = RequestContext.getTraceId();
                
                ProducerRecord<String, String> record = new ProducerRecord<>(
                    "order-topic", 
                    order.getId().toString(), 
                    JSON.toJSONString(order)
                );
                
                // æ·»åŠ  traceId åˆ° Header
                record.headers().add("traceId", traceId.getBytes());
                
                kafkaTemplate.send(record);
            }
        }
    }
}
```

### 1.6 åœºæ™¯æ±‡æ€»å¯¹ç…§è¡¨

| åœºæ™¯ | æ˜¯å¦æ¶‰åŠå­çº¿ç¨‹ | ThreadLocal | InheritableThreadLocal | TransmittableThreadLocal |
|------|--------------|------------|----------------------|-------------------------|
| **new Thread()** | âœ… | âŒ è·å–ä¸åˆ° | âœ… èƒ½è·å– | âœ… èƒ½è·å– |
| **çº¿ç¨‹æ± ** | âœ… | âŒ è·å–ä¸åˆ° | âŒ çº¿ç¨‹å¤ç”¨å¤±æ•ˆ | âœ… è£…é¥°åèƒ½è·å– |
| **CompletableFuture** | âœ… | âŒ | âŒ | âœ… è£…é¥°åèƒ½è·å– |
| **Stream.parallel()** | âœ… | âŒ | âŒ | âœ… è£…é¥°ForkJoinPool |
| **ForkJoinPool** | âœ… | âŒ | âŒ | âœ… TTLè£…é¥° |
| **@Async** | âœ… | âŒ | âŒ | âœ… è£…é¥°Executor |
| **ScheduledExecutor** | âœ… | âŒ | âŒ | âœ… è£…é¥°åèƒ½è·å– |
| **Servletå®¹å™¨** | âœ… | âŒ | âš ï¸ å±é™©ï¼ˆå¯èƒ½æ³„æ¼ï¼‰ | âœ… è£…é¥°åå®‰å…¨ |
| **å¤šæ•°æ®æºåˆ‡æ¢** | å¯èƒ½ | âŒ | âŒ | âœ… æ¨è |
| **åˆ†åº“åˆ†è¡¨** | å¯èƒ½ | âŒ | âŒ | âœ… å¿…é¡» |
| **MDCæ—¥å¿—** | âœ… | âŒ | âŒ | âœ… ç»“åˆä½¿ç”¨ |
| **Spring Security** | âœ… | âŒ | âš ï¸ éƒ¨åˆ†æ”¯æŒ | âœ… æœ€ä½³æ–¹æ¡ˆ |
| **äº‹åŠ¡ä¼ æ’­** | âŒ | N/A | N/A | âš ï¸ ä¸åº”ä¼ é€’ |
| **Dubbo RPC** | âœ… | âŒ | âŒ | âœ… Filterä¼ é€’ |
| **Feign RPC** | âœ… | âŒ | âŒ | âœ… Interceptorä¼ é€’ |
| **WebSocket** | âœ… | âŒ | âŒ | âœ… æ¨è |
| **Kafkaæ¶ˆè´¹** | âœ… | âŒ | âŒ | âœ… Headerä¼ é€’ |
| **RocketMQæ¶ˆè´¹** | âœ… | âŒ | âŒ | âœ… Headerä¼ é€’ |

### 1.7 å…³é”®ç»“è®º

#### ğŸ¯ å­çº¿ç¨‹èƒ½å¦è·å–çˆ¶çº¿ç¨‹å˜é‡çš„å®Œæ•´ç­”æ¡ˆï¼š

1. **ç›´æ¥ new Thread()**
   - `ThreadLocal`: âŒ **ä¸èƒ½**
   - `InheritableThreadLocal`: âœ… **èƒ½**
   - `TransmittableThreadLocal`: âœ… **ï¿½ï¿½ï¿½**

2. **çº¿ç¨‹æ± ï¼ˆæœªè£…é¥°ï¼‰**
   - `ThreadLocal`: âŒ **ä¸èƒ½**
   - `InheritableThreadLocal`: âŒ **ä¸èƒ½**ï¼ˆç¬¬ä¸€æ¬¡å¯ä»¥ï¼Œä½†ä¼šæ‹¿åˆ°æ—§å€¼ï¼‰
   - `TransmittableThreadLocal`: âŒ **ä¸èƒ½**

3. **çº¿ç¨‹æ± ï¼ˆTTLè£…é¥°ï¼‰**
   - `ThreadLocal`: âŒ **ä¸èƒ½**ï¼ˆTTLä¸ä¼šä¼ é€’æ™®é€šThreadLocalï¼‰
   - `InheritableThreadLocal`: âŒ **ä¸èƒ½**ï¼ˆä»ä¼šæœ‰æ—§å€¼é—®é¢˜ï¼‰
   - `TransmittableThreadLocal`: âœ… **èƒ½**ï¼ˆå®Œç¾æ”¯æŒï¼‰

#### âš ï¸ å®‰å…¨å»ºè®®ï¼š

```java
// âŒ å±é™©ï¼šServlet å®¹å™¨ä¸­ä½¿ç”¨ InheritableThreadLocal
private static InheritableThreadLocal<Long> userIdHolder = new InheritableThreadLocal<>();

// è¯·æ±‚Aï¼šè®¾ç½® userId = 100
// è¯·æ±‚Bï¼šä½¿ç”¨äº†åŒä¸€ä¸ªçº¿ç¨‹ï¼Œå¯èƒ½æ‹¿åˆ° userId = 100ï¼ˆè·¨ç”¨æˆ·æ•°æ®æ³„æ¼ï¼ï¼‰

// âœ… å®‰å…¨ï¼šä½¿ç”¨ TransmittableThreadLocal + è£…é¥°çº¿ç¨‹æ± 
private static TransmittableThreadLocal<Long> userIdHolder = new TransmittableThreadLocal<>();
ExecutorService ttlPool = TtlExecutors.getTtlExecutorService(pool);

// å¹¶ä¸”åœ¨ Filter çš„ finally ä¸­å¿…é¡» clear()
```

---


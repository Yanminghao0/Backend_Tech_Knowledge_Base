# å†…å­˜æ³„æ¼æ’æŸ¥

> å®æˆ˜æŒ‡å—ï¼šå¦‚ä½•æ’æŸ¥OOMã€å†…å­˜æŒç»­å¢é•¿ã€GCé¢‘ç¹ç­‰å†…å­˜é—®é¢˜

## ğŸ“‹ ç›®å½•
- [å¸¸è§é—®é¢˜ç±»å‹](#å¸¸è§é—®é¢˜ç±»å‹)
- [OOMé—®é¢˜æ’æŸ¥](#oomé—®é¢˜æ’æŸ¥)
- [å†…å­˜æŒç»­å¢é•¿](#å†…å­˜æŒç»­å¢é•¿)
- [GCé¢‘ç¹](#gcé¢‘ç¹)
- [æ’æŸ¥å·¥å…·](#æ’æŸ¥å·¥å…·)

---

## å¸¸è§é—®é¢˜ç±»å‹

### 1. OutOfMemoryErrorï¼ˆOOMï¼‰

**ç—‡çŠ¶**ï¼š
```
âœ… åº”ç”¨å´©æºƒ
âœ… å‡ºç°OutOfMemoryErrorå¼‚å¸¸
âœ… å †å†…å­˜æº¢å‡º
```

### 2. å†…å­˜æŒç»­å¢é•¿

**ç—‡çŠ¶**ï¼š
```
âœ… å†…å­˜ä½¿ç”¨ç‡æŒç»­ä¸Šå‡
âœ… å †å†…å­˜æŒç»­å¢é•¿
âœ… å¯ç”¨å†…å­˜æŒç»­ä¸‹é™
```

### 3. GCé¢‘ç¹

**ç—‡çŠ¶**ï¼š
```
âœ… GCé¢‘ç‡å¢åŠ 
âœ… GCè€—æ—¶å¢åŠ 
âœ… åº”ç”¨å“åº”å˜æ…¢
```

---

## OOMé—®é¢˜æ’æŸ¥

### æ’æŸ¥æ–¹æ³•

**1. æŸ¥çœ‹OOMæ—¥å¿—**

```bash
# æŸ¥çœ‹å´©æºƒæ—¥å¿—
ls -lh hs_err_pid*.log
cat hs_err_pid*.log | grep -A 20 "OutOfMemoryError"
```

**2. ç”Ÿæˆå †è½¬å‚¨**

```bash
# ç”Ÿæˆå †è½¬å‚¨æ–‡ä»¶
jmap -dump:format=b,file=heap.hprof <pid>

# æˆ–é…ç½®JVMå‚æ•°è‡ªåŠ¨ç”Ÿæˆ
-XX:+HeapDumpOnOutOfMemoryError
-XX:HeapDumpPath=/tmp/heapdump.hprof
```

**3. åˆ†æå †è½¬å‚¨**

```bash
# ä½¿ç”¨MATåˆ†æå †è½¬å‚¨æ–‡ä»¶
# 1. ä¸‹è½½MATå·¥å…·
# 2. æ‰“å¼€heap.hprofæ–‡ä»¶
# 3. æŸ¥çœ‹å†…å­˜æ³„æ¼æŠ¥å‘Š
```

### å¸¸è§åŸå› 

**1. å†…å­˜æ³„æ¼**

```java
// âŒ å†…å­˜æ³„æ¼ç¤ºä¾‹
private static List<Object> list = new ArrayList<>();

public void add(Object obj) {
    list.add(obj);  // å¯¹è±¡ä¸€ç›´ä¸é‡Šæ”¾
}

// âœ… ä¿®å¤
private List<Object> list = new ArrayList<>();  // ä¸ä½¿ç”¨static
public void clear() {
    list.clear();  // åŠæ—¶æ¸…ç†
}
```

**2. å¤§å¯¹è±¡**

```java
// âŒ åˆ›å»ºå¤§å¯¹è±¡
byte[] largeArray = new byte[100 * 1024 * 1024];  // 100MB

// âœ… ä¼˜åŒ–
// 1. å‡å°‘å¯¹è±¡å¤§å°
// 2. ä½¿ç”¨æµå¼å¤„ç†
// 3. åˆ†æ‰¹å¤„ç†
```

**3. å †å†…å­˜ä¸è¶³**

```bash
# å¢åŠ å †å†…å­˜
-Xms2g -Xmx2g
```

### è§£å†³æ–¹æ¡ˆ

**1. ä¿®å¤å†…å­˜æ³„æ¼**

```java
// 1. åŠæ—¶é‡Šæ”¾èµ„æº
try (Connection conn = dataSource.getConnection()) {
    // ä½¿ç”¨è¿æ¥
}  // è‡ªåŠ¨å…³é—­

// 2. æ¸…ç†é›†åˆ
list.clear();
map.clear();

// 3. é¿å…é™æ€é›†åˆ
// ä¸ä½¿ç”¨staticé›†åˆå­˜å‚¨å¯¹è±¡
```

**2. ä¼˜åŒ–ä»£ç **

```java
// 1. å‡å°‘å¯¹è±¡åˆ›å»º
// 2. ä½¿ç”¨å¯¹è±¡æ± 
// 3. ä½¿ç”¨æµå¼å¤„ç†
```

**3. å¢åŠ å †å†…å­˜**

```bash
# å¢åŠ å †å†…å­˜å¤§å°
-Xms4g -Xmx4g
```

---

## å†…å­˜æŒç»­å¢é•¿

### æ’æŸ¥æ–¹æ³•

**1. ç›‘æ§å†…å­˜ä½¿ç”¨**

```bash
# æŸ¥çœ‹å †å†…å­˜ä½¿ç”¨
jmap -heap <pid>

# æŸ¥çœ‹å †å†…å­˜å¯¹è±¡ç»Ÿè®¡
jmap -histo <pid>

# æŸ¥çœ‹GCæƒ…å†µ
jstat -gc <pid> 1000 10
```

**2. åˆ†æå†…å­˜å¢é•¿**

```bash
# å®šæœŸç”Ÿæˆå †è½¬å‚¨
# å¯¹æ¯”åˆ†æå†…å­˜å¢é•¿
```

### å¸¸è§åŸå› 

**1. å†…å­˜æ³„æ¼**

```java
// å¯¹è±¡ä¸€ç›´ä¸é‡Šæ”¾
private static Map<String, Object> cache = new HashMap<>();

public void put(String key, Object value) {
    cache.put(key, value);  // å¯¹è±¡ä¸€ç›´ä¸é‡Šæ”¾
}
```

**2. ç¼“å­˜æœªè¿‡æœŸ**

```java
// ç¼“å­˜æœªè®¾ç½®è¿‡æœŸæ—¶é—´
redis.set("key", value);  // æ°¸ä¸è¿‡æœŸ
```

**3. çº¿ç¨‹æ³„æ¼**

```java
// çº¿ç¨‹æœªæ­£ç¡®å…³é—­
ExecutorService executor = Executors.newFixedThreadPool(10);
// å¿˜è®°å…³é—­çº¿ç¨‹æ± 
```

### è§£å†³æ–¹æ¡ˆ

**1. ä¿®å¤å†…å­˜æ³„æ¼**

```java
// 1. åŠæ—¶é‡Šæ”¾èµ„æº
// 2. æ¸…ç†é›†åˆ
// 3. é¿å…é™æ€é›†åˆ
```

**2. ä¼˜åŒ–ç¼“å­˜**

```java
// è®¾ç½®è¿‡æœŸæ—¶é—´
redis.setex("key", 3600, value);  // 1å°æ—¶è¿‡æœŸ
```

**3. å…³é—­çº¿ç¨‹æ± **

```java
// æ­£ç¡®å…³é—­çº¿ç¨‹æ± 
executor.shutdown();
try {
    if (!executor.awaitTermination(60, TimeUnit.SECONDS)) {
        executor.shutdownNow();
    }
} catch (InterruptedException e) {
    executor.shutdownNow();
}
```

---

## GCé¢‘ç¹

### æ’æŸ¥æ–¹æ³•

**1. æŸ¥çœ‹GCæƒ…å†µ**

```bash
# æŸ¥çœ‹GCç»Ÿè®¡
jstat -gc <pid> 1000 10

# æŸ¥çœ‹GCè¯¦æƒ…
-XX:+PrintGCDetails
-XX:+PrintGCDateStamps
-Xloggc:/tmp/gc.log
```

**2. åˆ†æGCæ—¥å¿—**

```bash
# ä½¿ç”¨GCVieweråˆ†æGCæ—¥å¿—
# æˆ–ä½¿ç”¨åœ¨çº¿å·¥å…·åˆ†æ
```

### å¸¸è§åŸå› 

**1. å †å†…å­˜ä¸è¶³**

```bash
# å¢åŠ å †å†…å­˜
-Xms4g -Xmx4g
```

**2. å¯¹è±¡åˆ›å»ºé¢‘ç¹**

```java
// âŒ é¢‘ç¹åˆ›å»ºå¯¹è±¡
for (int i = 0; i < 1000000; i++) {
    String str = new String("test");  // é¢‘ç¹åˆ›å»ºå¯¹è±¡
}

// âœ… ä¼˜åŒ–
String str = "test";
for (int i = 0; i < 1000000; i++) {
    // ä½¿ç”¨str
}
```

**3. å¤§å¯¹è±¡**

```java
// âŒ åˆ›å»ºå¤§å¯¹è±¡
byte[] largeArray = new byte[100 * 1024 * 1024];  // 100MB

// âœ… ä¼˜åŒ–
// 1. å‡å°‘å¯¹è±¡å¤§å°
// 2. ä½¿ç”¨æµå¼å¤„ç†
// 3. åˆ†æ‰¹å¤„ç†
```

### è§£å†³æ–¹æ¡ˆ

**1. ä¼˜åŒ–GCå‚æ•°**

```bash
# G1 GCå‚æ•°
-XX:+UseG1GC
-XX:MaxGCPauseMillis=200
-XX:G1HeapRegionSize=16M
```

**2. ä¼˜åŒ–ä»£ç **

```java
// 1. å‡å°‘å¯¹è±¡åˆ›å»º
// 2. ä½¿ç”¨å¯¹è±¡æ± 
// 3. ä½¿ç”¨æµå¼å¤„ç†
```

**3. å¢åŠ å †å†…å­˜**

```bash
# å¢åŠ å †å†…å­˜å¤§å°
-Xms4g -Xmx4g
```

---

## æ’æŸ¥å·¥å…·

### 1. JVMå·¥å…·

```bash
# jmap - å †å†…å­˜åˆ†æ
jmap -heap <pid>
jmap -histo <pid>
jmap -dump:format=b,file=heap.hprof <pid>

# jstat - GCç»Ÿè®¡
jstat -gc <pid> 1000 10

# jstack - çº¿ç¨‹å †æ ˆ
jstack <pid>
```

### 2. å †è½¬å‚¨åˆ†æå·¥å…·

```bash
# MAT (Memory Analyzer Tool)
# 1. ä¸‹è½½MATå·¥å…·
# 2. æ‰“å¼€heap.hprofæ–‡ä»¶
# 3. æŸ¥çœ‹å†…å­˜æ³„æ¼æŠ¥å‘Š

# jhat - å †è½¬å‚¨åˆ†æ
jhat heap.hprof
# è®¿é—® http://localhost:7000
```

### 3. GCæ—¥å¿—åˆ†æå·¥å…·

```bash
# GCViewer - GCæ—¥å¿—åˆ†æ
# 1. ä¸‹è½½GCViewer
# 2. æ‰“å¼€gc.logæ–‡ä»¶
# 3. æŸ¥çœ‹GCåˆ†ææŠ¥å‘Š
```

---

## ğŸ“š ç›¸å…³æ–‡æ¡£

- [æ€§èƒ½é—®é¢˜æ’æŸ¥](./01_æ€§èƒ½é—®é¢˜æ’æŸ¥.md)
- [JVMè°ƒä¼˜å®æˆ˜](../../11_æ€§èƒ½ä¼˜åŒ–/JVMè°ƒä¼˜å®æˆ˜.md)
- [JVMè™šæ‹Ÿæœºè¯¦è§£](../../01_Javaæ ¸å¿ƒ/JVMè™šæ‹Ÿæœºè¯¦è§£.md)

---

**æœ€åæ›´æ–°**: 2025-10-29  
**æ–‡æ¡£çŠ¶æ€**: âœ… æ¡†æ¶å·²æ­å»ºï¼Œå†…å®¹æŒç»­å®Œå–„ä¸­


## å†…å­˜æ³„æ¼å…·ä½“æ¡ˆä¾‹åˆ†æ

### æ¡ˆä¾‹ä¸€ï¼šçº¿ç¨‹æ± æ³„æ¼

**é—®é¢˜æè¿°**ï¼šåº”ç”¨ä¸­åˆ›å»ºäº†å›ºå®šå¤§å°çš„çº¿ç¨‹æ± ï¼Œä½†æœªæ­£ç¡®å…³é—­ï¼Œå¯¼è‡´çº¿ç¨‹æŒç»­å ç”¨å†…å­˜èµ„æºã€‚

**ä»£ç ç¤ºä¾‹**ï¼š
```java
// âŒ é”™è¯¯ç¤ºä¾‹
public class ThreadPoolLeakExample {
    private ExecutorService executor;

    public void init() {
        // åˆ›å»ºçº¿ç¨‹æ± ä½†æœªå…³é—­
        executor = Executors.newFixedThreadPool(10);
    }

    public void submitTask(Runnable task) {
        executor.submit(task);
    }
    // ç¼ºå°‘å…³é—­çº¿ç¨‹æ± çš„æ–¹æ³•
}
```

**æ’æŸ¥è¿‡ç¨‹**ï¼š
1. ä½¿ç”¨jstackæŸ¥çœ‹çº¿ç¨‹çŠ¶æ€ï¼š
```bash
jstack <pid> | grep -A 20 "pool-"
```
2. å‘ç°å¤§é‡WAITINGçŠ¶æ€çš„çº¿ç¨‹
3. åˆ†æçº¿ç¨‹å †æ ˆå®šä½åˆ°æœªå…³é—­çš„çº¿ç¨‹æ± 

**è§£å†³æ–¹æ¡ˆ**ï¼š
```java
// âœ… æ­£ç¡®ç¤ºä¾‹
public class ThreadPoolFixedExample implements AutoCloseable {
    private ExecutorService executor;

    public void init() {
        executor = Executors.newFixedThreadPool(10);
    }

    public void submitTask(Runnable task) {
        executor.submit(task);
    }

    @Override
    public void close() {
        // ä¼˜é›…å…³é—­çº¿ç¨‹æ± 
        executor.shutdown();
        try {
            if (!executor.awaitTermination(60, TimeUnit.SECONDS)) {
                executor.shutdownNow();
            }
        } catch (InterruptedException e) {
            executor.shutdownNow();
        }
    }
}
```

### æ¡ˆä¾‹äºŒï¼šé™æ€é›†åˆæœªæ¸…ç†

**é—®é¢˜æè¿°**ï¼šä½¿ç”¨é™æ€é›†åˆç¼“å­˜æ•°æ®ï¼Œä½†æœªè®¾ç½®è¿‡æœŸæœºåˆ¶ï¼Œå¯¼è‡´é›†åˆæ— é™å¢é•¿ã€‚

**ä»£ç ç¤ºä¾‹**ï¼š
```java
// âŒ é”™è¯¯ç¤ºä¾‹
public class StaticCollectionLeak {
    // é™æ€é›†åˆå¯¼è‡´å¯¹è±¡æ— æ³•é‡Šæ”¾
    private static final Map<String, User> userCache = new HashMap<>();

    public void addUserToCache(User user) {
        userCache.put(user.getId(), user);
        // æ²¡æœ‰æ¸…ç†æœºåˆ¶
    }
}
```

**è§£å†³æ–¹æ¡ˆ**ï¼š
```java
// âœ… æ­£ç¡®ç¤ºä¾‹ï¼šä½¿ç”¨å¸¦è¿‡æœŸæœºåˆ¶çš„ç¼“å­˜
public class ExpiringUserCache {
    // ä½¿ç”¨Guava Cacheè®¾ç½®è¿‡æœŸæ—¶é—´
    private static final LoadingCache<String, User> userCache = CacheBuilder.newBuilder()
            .maximumSize(1000)
            .expireAfterWrite(30, TimeUnit.MINUTES)
            .build(new CacheLoader<String, User>() {
                @Override
                public User load(String id) {
                    return fetchUserFromDatabase(id);
                }
            });

    public User getUser(String id) throws ExecutionException {
        return userCache.get(id);
    }
}
```

### å¸¸è§åŸå› 

**1. å †å†…å­˜ä¸è¶³**

```bash
# å¢åŠ å †å†…å­˜
-Xms4g -Xmx4g
```

**2. å¯¹è±¡åˆ›å»ºé¢‘ç¹**

```java
// âŒ é¢‘ç¹åˆ›å»ºå¯¹è±¡
for (int i = 0; i < 1000000; i++) {
    String str = new String("test");  // é¢‘ç¹åˆ›å»ºå¯¹è±¡
}

// âœ… ä¼˜åŒ–
String str = "test";
for (int i = 0; i < 1000000; i++) {
    // ä½¿ç”¨str
}
```

**3. å¤§å¯¹è±¡**

```java
// âŒ åˆ›å»ºå¤§å¯¹è±¡
byte[] largeArray = new byte[100 * 1024 * 1024];  // 100MB

// âœ… ä¼˜åŒ–
// 1. å‡å°‘å¯¹è±¡å¤§å°
// 2. ä½¿ç”¨æµå¼å¤„ç†
// 3. åˆ†æ‰¹å¤„ç†
```

### è§£å†³æ–¹æ¡ˆ

**1. ä¼˜åŒ–GCå‚æ•°**

```bash
# G1 GCå‚æ•°
-XX:+UseG1GC
-XX:MaxGCPauseMillis=200
-XX:G1HeapRegionSize=16M
```

**2. ä¼˜åŒ–ä»£ç **

```java
// 1. å‡å°‘å¯¹è±¡åˆ›å»º
// 2. ä½¿ç”¨å¯¹è±¡æ± 
// 3. ä½¿ç”¨æµå¼å¤„ç†
```

**3. å¢åŠ å †å†…å­˜**

```bash
# å¢åŠ å †å†…å­˜å¤§å°
-Xms4g -Xmx4g
```

---

## æ’æŸ¥å·¥å…·

### 1. JVMå·¥å…·

```bash
# jmap - å †å†…å­˜åˆ†æ
jmap -heap <pid>
jmap -histo <pid>
jmap -dump:format=b,file=heap.hprof <pid>

# jstat - GCç»Ÿè®¡
jstat -gc <pid> 1000 10

# jstack - çº¿ç¨‹å †æ ˆ
jstack <pid>
```

### 2. å †è½¬å‚¨åˆ†æå·¥å…·

```bash
# MAT (Memory Analyzer Tool)
# 1. ä¸‹è½½MATå·¥å…·
# 2. æ‰“å¼€heap.hprofæ–‡ä»¶
# 3. æŸ¥çœ‹å†…å­˜æ³„æ¼æŠ¥å‘Š

# jhat - å †è½¬å‚¨åˆ†æ
jhat heap.hprof
# è®¿é—® http://localhost:7000
```

### 3. GCæ—¥å¿—åˆ†æå·¥å…·

```bash
# GCViewer - GCæ—¥å¿—åˆ†æ
# 1. ä¸‹è½½GCViewer
# 2. æ‰“å¼€gc.logæ–‡ä»¶
# 3. æŸ¥çœ‹GCåˆ†ææŠ¥å‘Š
```

---

## ğŸ“š ç›¸å…³æ–‡æ¡£

- [æ€§èƒ½é—®é¢˜æ’æŸ¥](./01_æ€§èƒ½é—®é¢˜æ’æŸ¥.md)
- [JVMè°ƒä¼˜å®æˆ˜](../../11_æ€§èƒ½ä¼˜åŒ–/JVMè°ƒä¼˜å®æˆ˜.md)
- [JVMè™šæ‹Ÿæœºè¯¦è§£](../../01_Javaæ ¸å¿ƒ/JVMè™šæ‹Ÿæœºè¯¦è§£.md)

---

**æœ€åæ›´æ–°**: 2025-10-29  
**æ–‡æ¡£çŠ¶æ€**: âœ… æ¡†æ¶å·²æ­å»ºï¼Œå†…å®¹æŒç»­å®Œå–„ä¸­


## é«˜çº§æ’æŸ¥æŠ€æœ¯

### ä½¿ç”¨AsyncProfilerè¿›è¡Œå†…å­˜åˆ†é…é‡‡æ ·

**1. å®‰è£…AsyncProfiler**
```bash
# ä¸‹è½½æœ€æ–°ç‰ˆæœ¬
wget https://github.com/jvm-profiling-tools/async-profiler/releases/download/v2.9/async-profiler-2.9-linux-x64.tar.gz

tar -zxvf async-profiler-2.9-linux-x64.tar.gz
cd async-profiler-2.9-linux-x64
```

**2. å†…å­˜åˆ†é…é‡‡æ ·**
```bash
# è®°å½•å†…å­˜åˆ†é…æƒ…å†µï¼ŒæŒç»­30ç§’
./profiler.sh -d 30 -e alloc -o flamegraph.html <pid>

# æŸ¥çœ‹ç”Ÿæˆçš„ç«ç„°å›¾
open flamegraph.html
```

**3. åˆ†æç«ç„°å›¾**
- æ¨ªå‘å®½åº¦è¡¨ç¤ºå†…å­˜åˆ†é…æ¯”ä¾‹
- çºµå‘è¡¨ç¤ºè°ƒç”¨æ ˆæ·±åº¦
- çº¢è‰²åŒºåŸŸè¡¨ç¤ºå†…å­˜åˆ†é…çƒ­ç‚¹

### GCç®—æ³•é€‰æ‹©ä¸è°ƒä¼˜

**G1 GCä¼˜åŒ–å‚æ•°**
```bash
# å¯ç”¨G1 GC
-XX:+UseG1GC

# è®¾ç½®æœ€å¤§GCæš‚åœæ—¶é—´
-XX:MaxGCPauseMillis=200

# è®¾ç½®å †åŒºåŸŸå¤§å°
-XX:G1HeapRegionSize=16M

# å¯åŠ¨æ—¶å ç”¨çš„å †å†…å­˜æ¯”ä¾‹
-XX:InitiatingHeapOccupancyPercent=35
```

**ZGCä¼˜åŒ–å‚æ•°ï¼ˆJDK 11+ï¼‰**
```bash
# å¯ç”¨ZGC
-XX:+UseZGC

# è®¾ç½®å †å¤§å°
-Xms4g -Xmx4g

# å¯ç”¨ZGCè¯¦ç»†æ—¥å¿—
-XX:+ZGenerational
-XX:ZCollectionInterval=60
```

## ç›‘æ§å‘Šè­¦é…ç½®

### Prometheus + Grafanaç›‘æ§å†…å­˜æŒ‡æ ‡

**1. æ·»åŠ JVMç›‘æ§ä¾èµ–**
```xml
<dependency>
    <groupId>io.micrometer</groupId>
    <artifactId>micrometer-registry-prometheus</artifactId>
    <version>1.10.0</version>
</dependency>
```

**2. é…ç½®ç›‘æ§æŒ‡æ ‡**
```java
@Configuration
public class MetricsConfig {
    @Bean
    MeterRegistryCustomizer<MeterRegistry> metricsCommonTags() {
        return registry -> registry.config()
            .commonTags("application", "your-application-name")
            .meterFilter(MeterFilter.deny(id ->
                id.getName().startsWith("jvm.gc.pause") &&
                id.getTag("action").equals("end-of-majorGC")));
    }
}
```

**3. å…³é”®ç›‘æ§æŒ‡æ ‡**
- `jvm_memory_used_bytes`ï¼šJVMå†…å­˜ä½¿ç”¨é‡
- `jvm_memory_max_bytes`ï¼šJVMå†…å­˜æœ€å¤§å€¼
- `jvm_gc_memory_allocated_bytes_total`ï¼šGCåˆ†é…å†…å­˜æ€»é‡
- `jvm_gc_pause_seconds_sum`ï¼šGCæš‚åœæ—¶é—´æ€»å’Œ

**4. Grafanaå‘Šè­¦è§„åˆ™**
```yaml
groups:
- name: jvm_memory_alerts
  rules:
  - alert: HighHeapMemoryUsage
    expr: jvm_memory_used_bytes{area="heap"} / jvm_memory_max_bytes{area="heap"} > 0.8
    for: 5m
    labels:
      severity: warning
    annotations:
      summary: "High heap memory usage"
      description: "Heap memory usage is above 80% for 5 minutes"

  - alert: GcPauseTooLong
    expr: histogram_quantile(0.95, sum(rate(jvm_gc_pause_seconds_bucket[5m])) by (le)) > 0.5
    for: 5m
    labels:
      severity: critical
    annotations:
      summary: "GC pause too long"
      description: "95% of GC pauses are longer than 500ms"
```
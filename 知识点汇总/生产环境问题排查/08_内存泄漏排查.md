# 内存泄漏排查

> 实战指南：如何排查OOM、内存持续增长、GC频繁等内存问题

## 📋 目录
- [常见问题类型](#常见问题类型)
- [OOM问题排查](#oom问题排查)
- [内存持续增长](#内存持续增长)
- [GC频繁](#gc频繁)
- [排查工具](#排查工具)

---

## 常见问题类型

### 1. OutOfMemoryError（OOM）

**症状**：
```
✅ 应用崩溃
✅ 出现OutOfMemoryError异常
✅ 堆内存溢出
```

### 2. 内存持续增长

**症状**：
```
✅ 内存使用率持续上升
✅ 堆内存持续增长
✅ 可用内存持续下降
```

### 3. GC频繁

**症状**：
```
✅ GC频率增加
✅ GC耗时增加
✅ 应用响应变慢
```

---

## OOM问题排查

### 排查方法

**1. 查看OOM日志**

```bash
# 查看崩溃日志
ls -lh hs_err_pid*.log
cat hs_err_pid*.log | grep -A 20 "OutOfMemoryError"
```

**2. 生成堆转储**

```bash
# 生成堆转储文件
jmap -dump:format=b,file=heap.hprof <pid>

# 或配置JVM参数自动生成
-XX:+HeapDumpOnOutOfMemoryError
-XX:HeapDumpPath=/tmp/heapdump.hprof
```

**3. 分析堆转储**

```bash
# 使用MAT分析堆转储文件
# 1. 下载MAT工具
# 2. 打开heap.hprof文件
# 3. 查看内存泄漏报告
```

### 常见原因

**1. 内存泄漏**

```java
// ❌ 内存泄漏示例
private static List<Object> list = new ArrayList<>();

public void add(Object obj) {
    list.add(obj);  // 对象一直不释放
}

// ✅ 修复
private List<Object> list = new ArrayList<>();  // 不使用static
public void clear() {
    list.clear();  // 及时清理
}
```

**2. 大对象**

```java
// ❌ 创建大对象
byte[] largeArray = new byte[100 * 1024 * 1024];  // 100MB

// ✅ 优化
// 1. 减少对象大小
// 2. 使用流式处理
// 3. 分批处理
```

**3. 堆内存不足**

```bash
# 增加堆内存
-Xms2g -Xmx2g
```

### 解决方案

**1. 修复内存泄漏**

```java
// 1. 及时释放资源
try (Connection conn = dataSource.getConnection()) {
    // 使用连接
}  // 自动关闭

// 2. 清理集合
list.clear();
map.clear();

// 3. 避免静态集合
// 不使用static集合存储对象
```

**2. 优化代码**

```java
// 1. 减少对象创建
// 2. 使用对象池
// 3. 使用流式处理
```

**3. 增加堆内存**

```bash
# 增加堆内存大小
-Xms4g -Xmx4g
```

---

## 内存持续增长

### 排查方法

**1. 监控内存使用**

```bash
# 查看堆内存使用
jmap -heap <pid>

# 查看堆内存对象统计
jmap -histo <pid>

# 查看GC情况
jstat -gc <pid> 1000 10
```

**2. 分析内存增长**

```bash
# 定期生成堆转储
# 对比分析内存增长
```

### 常见原因

**1. 内存泄漏**

```java
// 对象一直不释放
private static Map<String, Object> cache = new HashMap<>();

public void put(String key, Object value) {
    cache.put(key, value);  // 对象一直不释放
}
```

**2. 缓存未过期**

```java
// 缓存未设置过期时间
redis.set("key", value);  // 永不过期
```

**3. 线程泄漏**

```java
// 线程未正确关闭
ExecutorService executor = Executors.newFixedThreadPool(10);
// 忘记关闭线程池
```

### 解决方案

**1. 修复内存泄漏**

```java
// 1. 及时释放资源
// 2. 清理集合
// 3. 避免静态集合
```

**2. 优化缓存**

```java
// 设置过期时间
redis.setex("key", 3600, value);  // 1小时过期
```

**3. 关闭线程池**

```java
// 正确关闭线程池
executor.shutdown();
try {
    if (!executor.awaitTermination(60, TimeUnit.SECONDS)) {
        executor.shutdownNow();
    }
} catch (InterruptedException e) {
    executor.shutdownNow();
}
```

---

## GC频繁

### 排查方法

**1. 查看GC情况**

```bash
# 查看GC统计
jstat -gc <pid> 1000 10

# 查看GC详情
-XX:+PrintGCDetails
-XX:+PrintGCDateStamps
-Xloggc:/tmp/gc.log
```

**2. 分析GC日志**

```bash
# 使用GCViewer分析GC日志
# 或使用在线工具分析
```

### 常见原因

**1. 堆内存不足**

```bash
# 增加堆内存
-Xms4g -Xmx4g
```

**2. 对象创建频繁**

```java
// ❌ 频繁创建对象
for (int i = 0; i < 1000000; i++) {
    String str = new String("test");  // 频繁创建对象
}

// ✅ 优化
String str = "test";
for (int i = 0; i < 1000000; i++) {
    // 使用str
}
```

**3. 大对象**

```java
// ❌ 创建大对象
byte[] largeArray = new byte[100 * 1024 * 1024];  // 100MB

// ✅ 优化
// 1. 减少对象大小
// 2. 使用流式处理
// 3. 分批处理
```

### 解决方案

**1. 优化GC参数**

```bash
# G1 GC参数
-XX:+UseG1GC
-XX:MaxGCPauseMillis=200
-XX:G1HeapRegionSize=16M
```

**2. 优化代码**

```java
// 1. 减少对象创建
// 2. 使用对象池
// 3. 使用流式处理
```

**3. 增加堆内存**

```bash
# 增加堆内存大小
-Xms4g -Xmx4g
```

---

## 排查工具

### 1. JVM工具

```bash
# jmap - 堆内存分析
jmap -heap <pid>
jmap -histo <pid>
jmap -dump:format=b,file=heap.hprof <pid>

# jstat - GC统计
jstat -gc <pid> 1000 10

# jstack - 线程堆栈
jstack <pid>
```

### 2. 堆转储分析工具

```bash
# MAT (Memory Analyzer Tool)
# 1. 下载MAT工具
# 2. 打开heap.hprof文件
# 3. 查看内存泄漏报告

# jhat - 堆转储分析
jhat heap.hprof
# 访问 http://localhost:7000
```

### 3. GC日志分析工具

```bash
# GCViewer - GC日志分析
# 1. 下载GCViewer
# 2. 打开gc.log文件
# 3. 查看GC分析报告
```

---

## 📚 相关文档

- [性能问题排查](./01_性能问题排查.md)
- [JVM调优实战](../../11_性能优化/JVM调优实战.md)
- [JVM虚拟机详解](../../01_Java核心/JVM虚拟机详解.md)

---

**最后更新**: 2025-10-29  
**文档状态**: ✅ 框架已搭建，内容持续完善中


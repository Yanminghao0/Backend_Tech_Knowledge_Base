# 错误日志分析

> 实战指南：如何分析生产环境的错误日志和异常堆栈

## 📋 目录
- [日志分类](#日志分类)
- [日志级别](#日志级别)
- [常见错误类型](#常见错误类型)
- [日志分析工具](#日志分析工具)
- [排查流程](#排查流程)

---

## 日志分类

### 应用日志

```
✅ 业务日志
   - 业务操作记录
   - 业务异常信息
   - 关键业务节点

✅ 技术日志
   - 异常堆栈
   - 错误信息
   - 调试信息
```

### 系统日志

```
✅ 系统消息
   - /var/log/messages
   - dmesg（内核消息）
   - journalctl（systemd日志）

✅ 应用日志
   - application.log
   - error.log
   - access.log
```

### 中间件日志

```
✅ 数据库日志
   - MySQL慢查询日志
   - MySQL错误日志
   - MySQL binlog

✅ 缓存日志
   - Redis日志
   - Redis慢查询日志

✅ 消息队列日志
   - Kafka日志
   - RocketMQ日志
```

---

## 日志级别

### 标准日志级别

```
FATAL（致命）：
  - 系统无法继续运行
  - 需要立即处理
  - 例如：数据库连接失败、磁盘满

ERROR（错误）：
  - 错误但系统可以继续运行
  - 需要关注和处理
  - 例如：业务异常、数据库操作失败

WARN（警告）：
  - 潜在问题，需要关注
  - 例如：参数校验失败、连接池接近满

INFO（信息）：
  - 关键业务信息
  - 例如：用户登录、订单创建

DEBUG（调试）：
  - 调试信息
  - 生产环境通常不开启
```

---

## 常见错误类型

### 1. NullPointerException（空指针异常）

**日志特征**：
```
java.lang.NullPointerException
    at com.example.service.UserService.getUserById(UserService.java:123)
    at com.example.controller.UserController.getUser(UserController.java:45)
```

**排查方法**：
```
1. 查看堆栈信息，定位到具体代码行
2. 分析可能为null的对象
3. 检查参数校验
4. 添加防御性编程（null检查）
```

**解决方案**：
```java
// ❌ 不安全的代码
String name = user.getName().toUpperCase();

// ✅ 安全的代码
String name = user != null && user.getName() != null 
    ? user.getName().toUpperCase() 
    : "";
```

### 2. SQLException（数据库异常）

**日志特征**：
```
java.sql.SQLException: Connection is closed
    at com.mysql.jdbc.Connection.checkClosed(Connection.java:1234)
```

**常见原因**：
```
- 数据库连接关闭
- 连接池满
- 数据库服务不可用
- SQL语法错误
```

**排查方法**：
```sql
-- 查看数据库连接状态
SHOW PROCESSLIST;

-- 查看数据库错误日志
tail -f /var/log/mysql/error.log

-- 检查连接池配置
```

**解决方案**：
```
1. 检查连接池配置
2. 检查连接是否正常关闭
3. 增加连接池大小
4. 检查数据库服务状态
```

### 3. OutOfMemoryError（内存溢出）

**日志特征**：
```
java.lang.OutOfMemoryError: Java heap space
    at java.util.Arrays.copyOf(Arrays.java:3210)
    at java.util.ArrayList.grow(ArrayList.java:267)
```

**排查方法**：
```bash
# 查看堆内存使用
jmap -heap <pid>

# 查看堆内存对象统计
jmap -histo <pid>

# 生成堆转储文件
jmap -dump:format=b,file=heap.hprof <pid>

# 使用MAT分析堆转储文件
```

**解决方案**：
```
1. 增加堆内存大小（-Xmx）
2. 优化代码（减少对象创建）
3. 修复内存泄漏
4. 优化GC参数
```

### 4. TimeoutException（超时异常）

**日志特征**：
```
java.util.concurrent.TimeoutException: Read timed out
    at java.net.SocketInputStream.socketRead0(SocketInputStream.java:116)
```

**常见场景**：
```
- 数据库查询超时
- HTTP请求超时
- RPC调用超时
- 消息队列消费超时
```

**排查方法**：
```
1. 查看超时配置
2. 分析慢查询
3. 检查网络延迟
4. 查看服务负载
```

**解决方案**：
```
1. 增加超时时间（临时方案）
2. 优化慢查询（根本方案）
3. 增加重试机制
4. 使用异步处理
```

### 5. ClassNotFoundException（类找不到）

**日志特征**：
```
java.lang.ClassNotFoundException: com.example.User
    at java.net.URLClassLoader.findClass(URLClassLoader.java:387)
```

**常见原因**：
```
- 依赖缺失
- 类路径配置错误
- 版本冲突
- 打包问题
```

**排查方法**：
```
1. 检查依赖配置
2. 查看类路径
3. 检查jar包是否完整
4. 查看Maven/Gradle依赖树
```

**解决方案**：
```
1. 添加缺失的依赖
2. 修复类路径配置
3. 解决版本冲突
4. 重新打包部署
```

---

## 日志分析工具

### 1. 命令行工具

**grep**：
```bash
# 搜索ERROR日志
grep "ERROR" application.log

# 搜索指定异常
grep "NullPointerException" application.log

# 显示上下文
grep -A 10 -B 10 "ERROR" application.log

# 统计错误数量
grep "ERROR" application.log | wc -l
```

**awk**：
```bash
# 统计错误类型
awk '/ERROR/ {print $NF}' application.log | sort | uniq -c

# 按时间统计错误
awk '/ERROR/ {print $1}' application.log | sort | uniq -c
```

**sed**：
```bash
# 提取异常堆栈
sed -n '/Exception/,/at com/p' application.log
```

### 2. 日志分析工具

**ELK Stack**：
```
- Elasticsearch：日志存储
- Logstash：日志收集
- Kibana：日志可视化
```

**Loki + Grafana**：
```
- Loki：日志聚合
- Grafana：日志可视化
```

**Splunk**：
```
- 企业级日志分析
- 强大的搜索和可视化
```

### 3. 实时日志监控

**tail**：
```bash
# 实时查看日志
tail -f application.log

# 实时查看ERROR日志
tail -f application.log | grep ERROR

# 查看最近100行
tail -n 100 application.log
```

**less**：
```bash
# 分页查看日志
less application.log

# 搜索关键字（按/）
# 向前翻页（按空格）
# 向后翻页（按b）
```

---

## 排查流程

### 第一步：收集日志

```
1. 确定问题时间范围
2. 收集相关日志文件
3. 收集错误日志和异常堆栈
4. 收集系统日志
```

### 第二步：分析日志

```
1. 搜索ERROR级别日志
2. 查看异常堆栈
3. 统计错误频率
4. 分析错误模式
```

### 第三步：定位问题

```
1. 查看堆栈信息，定位代码行
2. 分析错误原因
3. 查看相关代码
4. 复现问题（如果可能）
```

### 第四步：解决问题

```
1. 修复代码bug
2. 优化配置
3. 增加防御性编程
4. 添加监控告警
```

---

## 日志分析最佳实践

### 1. 日志格式规范

**结构化日志**：
```java
// ✅ 使用结构化日志
log.info("用户登录成功, userId={}, ip={}, time={}", 
    userId, ip, System.currentTimeMillis());

// ❌ 避免字符串拼接
log.info("用户登录成功, userId=" + userId + ", ip=" + ip);
```

### 2. 日志级别使用

```
✅ FATAL：系统无法继续运行
✅ ERROR：错误但可以继续运行
✅ WARN：潜在问题
✅ INFO：关键业务信息
✅ DEBUG：调试信息（生产环境关闭）
```

### 3. 异常处理

```java
// ✅ 记录完整异常信息
try {
    // 业务逻辑
} catch (Exception e) {
    log.error("处理订单失败, orderId={}", orderId, e);
    throw new BusinessException("订单处理失败", e);
}
```

### 4. 日志监控告警

```
✅ ERROR级别日志 → 立即告警
✅ WARN级别日志 → 告警（可配置阈值）
✅ 异常频率统计 → 告警
✅ 关键业务日志 → 监控
```

---

## 典型案例

### 案例1：频繁NullPointerException

**日志**：
```
2025-10-29 10:00:00 ERROR [http-nio-8080-exec-1] UserService - 获取用户信息失败
java.lang.NullPointerException
    at com.example.service.UserService.getUserById(UserService.java:123)
```

**排查**：
```
1. 查看堆栈 → UserService.java:123
2. 查看代码 → user.getName() 可能为null
3. 分析原因 → 数据库查询返回null，未做校验
```

**解决**：
```java
// 添加null检查
User user = userMapper.selectById(userId);
if (user == null) {
    throw new UserNotFoundException("用户不存在");
}
return user;
```

### 案例2：数据库连接异常

**日志**：
```
2025-10-29 10:00:00 ERROR [http-nio-8080-exec-1] UserService - 查询用户失败
java.sql.SQLException: Connection is closed
    at com.mysql.jdbc.Connection.checkClosed(Connection.java:1234)
```

**排查**：
```
1. 查看错误 → 连接已关闭
2. 检查连接池 → 连接池配置正常
3. 查看代码 → 发现连接未正确关闭
```

**解决**：
```java
// 使用try-with-resources
try (Connection conn = dataSource.getConnection();
     PreparedStatement ps = conn.prepareStatement(sql)) {
    // 执行查询
} catch (SQLException e) {
    log.error("查询失败", e);
    throw e;
}
```

---

## 📚 相关文档

- [系统故障排查](./03_系统故障排查.md)
- [内存泄漏排查](./08_内存泄漏排查.md)
- [数据库问题排查](./04_数据库问题排查.md)

---

**最后更新**: 2025-10-29  
**文档状态**: ✅ 框架已搭建，内容持续完善中


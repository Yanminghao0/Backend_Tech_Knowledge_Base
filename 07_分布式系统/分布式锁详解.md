# åˆ†å¸ƒå¼é”è¯¦è§£

> æ·±å…¥ç†è§£åˆ†å¸ƒå¼é”åŸç†ã€å®ç°æ–¹æ¡ˆã€Redissonæ¡†æ¶

---

## ğŸ“‹ ç›®å½•

1. [åˆ†å¸ƒå¼é”åŸºç¡€](#1-åˆ†å¸ƒå¼é”åŸºç¡€)
2. [Redisåˆ†å¸ƒå¼é”](#2-redisåˆ†å¸ƒå¼é”)
3. [Redissonæ¡†æ¶](#3-redissonæ¡†æ¶)
4. [Zookeeperåˆ†å¸ƒå¼é”](#4-zookeeperåˆ†å¸ƒå¼é”)
5. [æ•°æ®åº“åˆ†å¸ƒå¼é”](#5-æ•°æ®åº“åˆ†å¸ƒå¼é”)
6. [æœ€ä½³å®è·µ](#6-æœ€ä½³å®è·µ)

---

## 1. åˆ†å¸ƒå¼é”åŸºç¡€

### 1.1 ä¸ºä»€ä¹ˆéœ€è¦åˆ†å¸ƒå¼é”

```
å•æœºç¯å¢ƒï¼š
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Service    â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚  Lock  â”‚  â”‚  synchronizedã€ReentrantLock
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

åˆ†å¸ƒå¼ç¯å¢ƒï¼š
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Service 1   â”‚  â”‚  Service 2   â”‚  â”‚  Service 3   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚  Lock  â”‚  â”‚  â”‚  â”‚  Lock  â”‚  â”‚  â”‚  â”‚  Lock  â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        â†“                 â†“                 â†“
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                          â”‚
                â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                â”‚  Distributed Lock â”‚  éœ€è¦åˆ†å¸ƒå¼é”
                â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**å…¸å‹åœºæ™¯**ï¼š
```
1. åº“å­˜æ‰£å‡ï¼š
   é˜²æ­¢è¶…å–

2. è®¢å•å·ç”Ÿæˆï¼š
   ä¿è¯å”¯ä¸€æ€§

3. å®šæ—¶ä»»åŠ¡ï¼š
   é˜²æ­¢é‡å¤æ‰§è¡Œ

4. ç¼“å­˜æ›´æ–°ï¼š
   é˜²æ­¢ç¼“å­˜å‡»ç©¿
```

### 1.2 åˆ†å¸ƒå¼é”è¦æ±‚

```
1. äº’æ–¥æ€§ï¼š
   ä»»ä½•æ—¶åˆ»åªæœ‰ä¸€ä¸ªå®¢æˆ·ç«¯æŒæœ‰é”

2. é¿å…æ­»é”ï¼š
   å³ä½¿æŒæœ‰é”çš„å®¢æˆ·ç«¯å´©æºƒï¼Œä¹Ÿèƒ½é‡Šæ”¾é”

3. åŠ é”è§£é”åŒä¸€å®¢æˆ·ç«¯ï¼š
   åŠ é”å’Œè§£é”å¿…é¡»æ˜¯åŒä¸€ä¸ªå®¢æˆ·ç«¯

4. å®¹é”™æ€§ï¼š
   åªè¦å¤§éƒ¨åˆ†èŠ‚ç‚¹æ­£å¸¸ï¼Œå°±èƒ½æ­£å¸¸å·¥ä½œ

5. é«˜æ€§èƒ½ï¼š
   åŠ é”è§£é”æ€§èƒ½è¦é«˜
```

---

## 2. Redisåˆ†å¸ƒå¼é”

### 2.1 åŸºç¡€å®ç°ï¼ˆSETNXï¼‰

```java
@Service
public class RedisLockService {
    
    @Autowired
    private StringRedisTemplate redisTemplate;
    
    /**
     * åŠ é”ï¼ˆç®€å•ç‰ˆæœ¬ï¼Œæœ‰é—®é¢˜ï¼‰
     */
    public boolean lock(String key, String value, long timeout) {
        // SETNXï¼škeyä¸å­˜åœ¨æ—¶è®¾ç½®æˆåŠŸ
        Boolean success = redisTemplate.opsForValue()
            .setIfAbsent(key, value, timeout, TimeUnit.SECONDS);
        
        return Boolean.TRUE.equals(success);
    }
    
    /**
     * è§£é”ï¼ˆç®€å•ç‰ˆæœ¬ï¼Œæœ‰é—®é¢˜ï¼‰
     */
    public void unlock(String key) {
        redisTemplate.delete(key);
    }
}

// ä½¿ç”¨
public void business() {
    String lockKey = "lock:order:123";
    String lockValue = UUID.randomUUID().toString();
    
    try {
        // åŠ é”
        if (lock(lockKey, lockValue, 30)) {
            // ä¸šåŠ¡é€»è¾‘
            processOrder();
        }
    } finally {
        // è§£é”
        unlock(lockKey);
    }
}
```

**é—®é¢˜**ï¼š
```
é—®é¢˜1ï¼šè¯¯åˆ é™¤å…¶ä»–å®¢æˆ·ç«¯çš„é”
çº¿ç¨‹Aï¼šåŠ é” â†’ ä¸šåŠ¡è¶…æ—¶ â†’ é”è¿‡æœŸè‡ªåŠ¨é‡Šæ”¾
çº¿ç¨‹Bï¼šåŠ é”æˆåŠŸ
çº¿ç¨‹Aï¼šfinallyè§£é” â†’ åˆ é™¤äº†çº¿ç¨‹Bçš„é”ï¼

é—®é¢˜2ï¼šåŸå­æ€§é—®é¢˜
unlock()ä¸æ˜¯åŸå­æ“ä½œ
```

### 2.2 æ”¹è¿›ç‰ˆæœ¬ï¼ˆLuaè„šæœ¬ï¼‰

```java
@Service
public class RedisLockServiceV2 {
    
    @Autowired
    private StringRedisTemplate redisTemplate;
    
    /**
     * åŠ é”
     */
    public boolean lock(String key, String value, long timeout) {
        Boolean success = redisTemplate.opsForValue()
            .setIfAbsent(key, value, timeout, TimeUnit.SECONDS);
        
        return Boolean.TRUE.equals(success);
    }
    
    /**
     * è§£é”ï¼ˆLuaè„šæœ¬ä¿è¯åŸå­æ€§ï¼‰
     */
    public boolean unlock(String key, String value) {
        String script = """
            if redis.call('get', KEYS[1]) == ARGV[1] then
                return redis.call('del', KEYS[1])
            else
                return 0
            end
            """;
        
        Long result = redisTemplate.execute(
            RedisScript.of(script, Long.class),
            Collections.singletonList(key),
            value
        );
        
        return Long.valueOf(1).equals(result);
    }
}

// ä½¿ç”¨
public void business() {
    String lockKey = "lock:order:123";
    String lockValue = UUID.randomUUID().toString();
    
    try {
        if (lock(lockKey, lockValue, 30)) {
            // ä¸šåŠ¡é€»è¾‘
            processOrder();
        }
    } finally {
        // è§£é”æ—¶éªŒè¯æ˜¯å¦æ˜¯è‡ªå·±çš„é”
        unlock(lockKey, lockValue);
    }
}
```

### 2.3 ç»­æœŸé—®é¢˜

```java
/**
 * è‡ªåŠ¨ç»­æœŸçš„åˆ†å¸ƒå¼é”
 */
@Service
public class RedisLockWithRenewal {
    
    private final ScheduledExecutorService scheduler = 
        Executors.newScheduledThreadPool(1);
    
    private final Map<String, ScheduledFuture<?>> renewalTasks = 
        new ConcurrentHashMap<>();
    
    /**
     * åŠ é”å¹¶å¯åŠ¨ç»­æœŸ
     */
    public boolean lock(String key, String value, long timeout) {
        Boolean success = redisTemplate.opsForValue()
            .setIfAbsent(key, value, timeout, TimeUnit.SECONDS);
        
        if (Boolean.TRUE.equals(success)) {
            // å¯åŠ¨ç»­æœŸä»»åŠ¡ï¼ˆæ¯10ç§’ç»­æœŸä¸€æ¬¡ï¼Œç»­æœŸ30ç§’ï¼‰
            ScheduledFuture<?> future = scheduler.scheduleAtFixedRate(
                () -> renewal(key, value, timeout),
                timeout / 3,  // å»¶è¿Ÿ1/3è¶…æ—¶æ—¶é—´åå¼€å§‹
                timeout / 3,  // æ¯1/3è¶…æ—¶æ—¶é—´æ‰§è¡Œä¸€æ¬¡
                TimeUnit.SECONDS
            );
            
            renewalTasks.put(key, future);
            return true;
        }
        
        return false;
    }
    
    /**
     * ç»­æœŸ
     */
    private void renewal(String key, String value, long timeout) {
        String script = """
            if redis.call('get', KEYS[1]) == ARGV[1] then
                return redis.call('expire', KEYS[1], ARGV[2])
            else
                return 0
            end
            """;
        
        redisTemplate.execute(
            RedisScript.of(script, Long.class),
            Collections.singletonList(key),
            value,
            String.valueOf(timeout)
        );
    }
    
    /**
     * è§£é”å¹¶åœæ­¢ç»­æœŸ
     */
    public boolean unlock(String key, String value) {
        // åœæ­¢ç»­æœŸä»»åŠ¡
        ScheduledFuture<?> future = renewalTasks.remove(key);
        if (future != null) {
            future.cancel(true);
        }
        
        // è§£é”
        String script = """
            if redis.call('get', KEYS[1]) == ARGV[1] then
                return redis.call('del', KEYS[1])
            else
                return 0
            end
            """;
        
        Long result = redisTemplate.execute(
            RedisScript.of(script, Long.class),
            Collections.singletonList(key),
            value
        );
        
        return Long.valueOf(1).equals(result);
    }
}
```

---

## 3. Redissonæ¡†æ¶

### 3.1 å¿«é€Ÿå¼€å§‹

**Mavenä¾èµ–**ï¼š
```xml
<dependency>
    <groupId>org.redisson</groupId>
    <artifactId>redisson-spring-boot-starter</artifactId>
    <version>3.23.5</version>
</dependency>
```

**é…ç½®**ï¼š
```yaml
spring:
  redis:
    host: localhost
    port: 6379
    password: 
    database: 0
```

**ä½¿ç”¨ç¤ºä¾‹**ï¼š
```java
@Service
public class RedissonLockService {
    
    @Autowired
    private RedissonClient redissonClient;
    
    /**
     * åŸºç¡€ä½¿ç”¨
     */
    public void business() {
        RLock lock = redissonClient.getLock("lock:order:123");
        
        try {
            // åŠ é”ï¼ˆæœ€å¤šç­‰å¾…10ç§’ï¼Œé”30ç§’åè‡ªåŠ¨é‡Šæ”¾ï¼‰
            boolean success = lock.tryLock(10, 30, TimeUnit.SECONDS);
            
            if (success) {
                // ä¸šåŠ¡é€»è¾‘
                processOrder();
            }
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        } finally {
            // è§£é”
            if (lock.isHeldByCurrentThread()) {
                lock.unlock();
            }
        }
    }
}
```

### 3.2 å¯é‡å…¥é”

```java
/**
 * Redissonå¯é‡å…¥é”
 */
public void reentrantLockDemo() {
    RLock lock = redissonClient.getLock("myLock");
    
    try {
        lock.lock();  // ç¬¬ä¸€æ¬¡åŠ é”
        
        // åŒä¸€ä¸ªçº¿ç¨‹å¯ä»¥å†æ¬¡è·å–é”
        lock.lock();  // ç¬¬äºŒæ¬¡åŠ é”
        
        // ä¸šåŠ¡é€»è¾‘
        processOrder();
        
        lock.unlock();  // ç¬¬ä¸€æ¬¡è§£é”
        lock.unlock();  // ç¬¬äºŒæ¬¡è§£é”ï¼ˆå®Œå…¨é‡Šæ”¾ï¼‰
    } finally {
        if (lock.isHeldByCurrentThread()) {
            lock.unlock();
        }
    }
}
```

**åº•å±‚åŸç†**ï¼ˆhashç»“æ„ï¼‰ï¼š
```
key: lock:order:123
value: {
    "UUID:threadId": 2  // é‡å…¥æ¬¡æ•°
}

åŠ é”ï¼šé‡å…¥æ¬¡æ•°+1
è§£é”ï¼šé‡å…¥æ¬¡æ•°-1ï¼Œä¸º0æ—¶åˆ é™¤key
```

### 3.3 å…¬å¹³é”

```java
/**
 * å…¬å¹³é”ï¼šå…ˆåˆ°å…ˆå¾—
 */
public void fairLockDemo() {
    RLock fairLock = redissonClient.getFairLock("fairLock");
    
    try {
        fairLock.lock(30, TimeUnit.SECONDS);
        
        // ä¸šåŠ¡é€»è¾‘
        processOrder();
    } finally {
        if (fairLock.isHeldByCurrentThread()) {
            fairLock.unlock();
        }
    }
}
```

### 3.4 è¯»å†™é”

```java
/**
 * è¯»å†™é”ï¼šè¯»è¯»å…±äº«ï¼Œè¯»å†™äº’æ–¥ï¼Œå†™å†™äº’æ–¥
 */
public class CacheService {
    
    @Autowired
    private RedissonClient redissonClient;
    
    /**
     * è¯»æ“ä½œ
     */
    public String get(String key) {
        RReadWriteLock rwLock = redissonClient.getReadWriteLock("rwLock");
        RLock readLock = rwLock.readLock();
        
        try {
            readLock.lock(30, TimeUnit.SECONDS);
            
            // è¯»å–ç¼“å­˜
            return redisTemplate.opsForValue().get(key);
        } finally {
            if (readLock.isHeldByCurrentThread()) {
                readLock.unlock();
            }
        }
    }
    
    /**
     * å†™æ“ä½œ
     */
    public void set(String key, String value) {
        RReadWriteLock rwLock = redissonClient.getReadWriteLock("rwLock");
        RLock writeLock = rwLock.writeLock();
        
        try {
            writeLock.lock(30, TimeUnit.SECONDS);
            
            // æ›´æ–°ç¼“å­˜
            redisTemplate.opsForValue().set(key, value);
        } finally {
            if (writeLock.isHeldByCurrentThread()) {
                writeLock.unlock();
            }
        }
    }
}
```

### 3.5 çº¢é”ï¼ˆRedLockï¼‰

```java
/**
 * çº¢é”ï¼šå¤šä¸ªRediså®ä¾‹çš„åˆ†å¸ƒå¼é”
 * é€‚ç”¨äºRedisé›†ç¾¤ç¯å¢ƒ
 */
@Configuration
public class RedissonConfig {
    
    @Bean
    public RedissonClient redissonClient() {
        Config config = new Config();
        
        // é…ç½®å¤šä¸ªRedisèŠ‚ç‚¹
        config.useReplicatedServers()
            .addNodeAddress("redis://127.0.0.1:6379")
            .addNodeAddress("redis://127.0.0.1:6380")
            .addNodeAddress("redis://127.0.0.1:6381");
        
        return Redisson.create(config);
    }
}

@Service
public class RedLockService {
    
    @Autowired
    private RedissonClient redissonClient1;
    
    @Autowired
    private RedissonClient redissonClient2;
    
    @Autowired
    private RedissonClient redissonClient3;
    
    public void business() {
        RLock lock1 = redissonClient1.getLock("myLock");
        RLock lock2 = redissonClient2.getLock("myLock");
        RLock lock3 = redissonClient3.getLock("myLock");
        
        // åˆ›å»ºçº¢é”ï¼ˆåªè¦å¤§éƒ¨åˆ†èŠ‚ç‚¹åŠ é”æˆåŠŸå³å¯ï¼‰
        RedissonRedLock redLock = new RedissonRedLock(lock1, lock2, lock3);
        
        try {
            // å°è¯•åŠ é”
            boolean success = redLock.tryLock(10, 30, TimeUnit.SECONDS);
            
            if (success) {
                // ä¸šåŠ¡é€»è¾‘
                processOrder();
            }
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        } finally {
            if (redLock.isHeldByCurrentThread()) {
                redLock.unlock();
            }
        }
    }
}
```

### 3.6 Redissonçœ‹é—¨ç‹—

```
Redisson Watch Dogæœºåˆ¶ï¼š

1. é»˜è®¤é”è¿‡æœŸæ—¶é—´ï¼š30ç§’

2. è‡ªåŠ¨ç»­æœŸï¼š
   - æ¯10ç§’ï¼ˆè¿‡æœŸæ—¶é—´çš„1/3ï¼‰æ£€æŸ¥ä¸€æ¬¡
   - å¦‚æœé”è¿˜è¢«æŒæœ‰ï¼Œç»­æœŸ30ç§’

3. é¿å…æ­»é”ï¼š
   - å¦‚æœå®¢æˆ·ç«¯å´©æºƒï¼Œçœ‹é—¨ç‹—åœæ­¢
   - é”è‡ªåŠ¨è¿‡æœŸé‡Šæ”¾

åŸç†ï¼š
lock() â†’ å¯åŠ¨çœ‹é—¨ç‹—å®šæ—¶ä»»åŠ¡
    â†“
æ¯10ç§’æ£€æŸ¥ â†’ å¦‚æœæŒæœ‰é”ï¼Œç»­æœŸ30ç§’
    â†“
unlock() â†’ åœæ­¢çœ‹é—¨ç‹—ï¼Œåˆ é™¤é”
```

---

## 4. Zookeeperåˆ†å¸ƒå¼é”

### 4.1 åŸç†

```
Zookeeperåˆ†å¸ƒå¼é”åŸç†ï¼š

1. åˆ›å»ºä¸´æ—¶é¡ºåºèŠ‚ç‚¹ï¼š
   /lock/lock_0000000001
   /lock/lock_0000000002
   /lock/lock_0000000003

2. åˆ¤æ–­æ˜¯å¦æ˜¯æœ€å°èŠ‚ç‚¹ï¼š
   å¦‚æœæ˜¯æœ€å°èŠ‚ç‚¹ â†’ è·å¾—é”
   å¦‚æœä¸æ˜¯ â†’ ç›‘å¬å‰ä¸€ä¸ªèŠ‚ç‚¹

3. é‡Šæ”¾é”ï¼š
   åˆ é™¤è‡ªå·±çš„èŠ‚ç‚¹

4. é¿å…æ­»é”ï¼š
   ä¸´æ—¶èŠ‚ç‚¹ï¼Œå®¢æˆ·ç«¯æ–­å¼€è‡ªåŠ¨åˆ é™¤
```

### 4.2 Curatorå®ç°

**Mavenä¾èµ–**ï¼š
```xml
<dependency>
    <groupId>org.apache.curator</groupId>
    <artifactId>curator-recipes</artifactId>
    <version>5.5.0</version>
</dependency>
```

**ä½¿ç”¨ç¤ºä¾‹**ï¼š
```java
@Configuration
public class CuratorConfig {
    
    @Bean
    public CuratorFramework curatorFramework() {
        RetryPolicy retryPolicy = new ExponentialBackoffRetry(1000, 3);
        
        CuratorFramework client = CuratorFrameworkFactory.builder()
            .connectString("localhost:2181")
            .sessionTimeoutMs(5000)
            .connectionTimeoutMs(5000)
            .retryPolicy(retryPolicy)
            .build();
        
        client.start();
        return client;
    }
}

@Service
public class ZkLockService {
    
    @Autowired
    private CuratorFramework curatorFramework;
    
    public void business() {
        // åˆ›å»ºå¯é‡å…¥é”
        InterProcessMutex lock = new InterProcessMutex(
            curatorFramework, 
            "/locks/mylock"
        );
        
        try {
            // åŠ é”ï¼ˆæœ€å¤šç­‰å¾…10ç§’ï¼‰
            if (lock.acquire(10, TimeUnit.SECONDS)) {
                // ä¸šåŠ¡é€»è¾‘
                processOrder();
            }
        } catch (Exception e) {
            log.error("è·å–é”å¤±è´¥", e);
        } finally {
            try {
                lock.release();
            } catch (Exception e) {
                log.error("é‡Šæ”¾é”å¤±è´¥", e);
            }
        }
    }
}
```

---

## 5. æ•°æ®åº“åˆ†å¸ƒå¼é”

### 5.1 è¡¨è®¾è®¡

```sql
CREATE TABLE `distributed_lock` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `lock_name` varchar(100) NOT NULL COMMENT 'é”åç§°',
  `lock_value` varchar(100) NOT NULL COMMENT 'é”æŒæœ‰è€…',
  `expire_time` datetime NOT NULL COMMENT 'è¿‡æœŸæ—¶é—´',
  `create_time` datetime NOT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `uk_lock_name` (`lock_name`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
```

### 5.2 å®ç°

```java
@Repository
public interface DistributedLockMapper extends BaseMapper<DistributedLock> {
    
    /**
     * åŠ é”ï¼ˆæ’å…¥è®°å½•ï¼‰
     */
    @Insert("""
        INSERT INTO distributed_lock (lock_name, lock_value, expire_time, create_time)
        VALUES (#{lockName}, #{lockValue}, #{expireTime}, NOW())
        """)
    int lock(@Param("lockName") String lockName,
             @Param("lockValue") String lockValue,
             @Param("expireTime") LocalDateTime expireTime);
    
    /**
     * è§£é”ï¼ˆåˆ é™¤è®°å½•ï¼‰
     */
    @Delete("""
        DELETE FROM distributed_lock 
        WHERE lock_name = #{lockName} AND lock_value = #{lockValue}
        """)
    int unlock(@Param("lockName") String lockName,
               @Param("lockValue") String lockValue);
    
    /**
     * æ¸…ç†è¿‡æœŸé”
     */
    @Delete("DELETE FROM distributed_lock WHERE expire_time < NOW()")
    int cleanExpired();
}

@Service
public class DbLockService {
    
    @Autowired
    private DistributedLockMapper lockMapper;
    
    /**
     * åŠ é”
     */
    public boolean lock(String lockName, String lockValue, long timeout) {
        LocalDateTime expireTime = LocalDateTime.now().plusSeconds(timeout);
        
        try {
            int rows = lockMapper.lock(lockName, lockValue, expireTime);
            return rows > 0;
        } catch (DuplicateKeyException e) {
            // é”å·²è¢«å ç”¨
            return false;
        }
    }
    
    /**
     * è§£é”
     */
    public boolean unlock(String lockName, String lockValue) {
        int rows = lockMapper.unlock(lockName, lockValue);
        return rows > 0;
    }
    
    /**
     * å®šæ—¶æ¸…ç†è¿‡æœŸé”
     */
    @Scheduled(fixedDelay = 60000)
    public void cleanExpiredLocks() {
        lockMapper.cleanExpired();
    }
}
```

**ä¼˜ç¼ºç‚¹**ï¼š
```
ä¼˜ç‚¹ï¼š
âœ… å®ç°ç®€å•
âœ… æ˜“äºç†è§£
âœ… é€‚åˆå·²æœ‰æ•°æ®åº“çš„åœºæ™¯

ç¼ºç‚¹ï¼š
âŒ æ€§èƒ½è¾ƒå·®ï¼ˆæ•°æ®åº“IOï¼‰
âŒ å¯èƒ½äº§ç”Ÿé”è¡¨
âŒ å•ç‚¹æ•…éšœï¼ˆæ•°æ®åº“æŒ‚äº†ï¼‰
```

---

## 6. æœ€ä½³å®è·µ

### 6.1 æ–¹æ¡ˆé€‰å‹

```
åœºæ™¯1ï¼šé«˜æ€§èƒ½è¦æ±‚
æ–¹æ¡ˆï¼šRedisï¼ˆRedissonï¼‰
ç†ç”±ï¼šæ€§èƒ½å¥½ï¼ŒåŠŸèƒ½ä¸°å¯Œ

åœºæ™¯2ï¼šå¼ºä¸€è‡´æ€§è¦æ±‚
æ–¹æ¡ˆï¼šZookeeperï¼ˆCuratorï¼‰
ç†ç”±ï¼šCPæ¨¡å‹ï¼Œå¼ºä¸€è‡´æ€§

åœºæ™¯3ï¼šç®€å•åœºæ™¯
æ–¹æ¡ˆï¼šæ•°æ®åº“
ç†ç”±ï¼šå®ç°ç®€å•ï¼Œæ— éœ€é¢å¤–ç»„ä»¶

æ¨èï¼š
å¤§éƒ¨åˆ†åœºæ™¯ä½¿ç”¨Redisson
```

### 6.2 æ³¨æ„äº‹é¡¹

```java
// 1. è®¾ç½®åˆç†çš„è¶…æ—¶æ—¶é—´
lock.tryLock(10, 30, TimeUnit.SECONDS);
//           â†‘   â†‘
//      ç­‰å¾…æ—¶é—´ è¿‡æœŸæ—¶é—´

// 2. å§‹ç»ˆåœ¨finallyä¸­é‡Šæ”¾é”
try {
    lock.lock();
    // ä¸šåŠ¡é€»è¾‘
} finally {
    if (lock.isHeldByCurrentThread()) {
        lock.unlock();
    }
}

// 3. é¿å…é•¿æ—¶é—´æŒæœ‰é”
// âŒ ä¸å¥½
lock.lock();
Thread.sleep(60000);  // é•¿æ—¶é—´é˜»å¡
lock.unlock();

// âœ… å¥½
lock.lock();
processQuickly();  // å¿«é€Ÿå¤„ç†
lock.unlock();

// 4. ä½¿ç”¨çœ‹é—¨ç‹—è‡ªåŠ¨ç»­æœŸ
// Redissoné»˜è®¤å¼€å¯ï¼Œæ— éœ€æ‰‹åŠ¨ç»­æœŸ

// 5. å¹‚ç­‰æ€§è®¾è®¡
public void processOrder(String orderId) {
    RLock lock = redissonClient.getLock("order:" + orderId);
    
    try {
        if (lock.tryLock(5, 30, TimeUnit.SECONDS)) {
            // å¹‚ç­‰æ€§æ£€æŸ¥
            if (isProcessed(orderId)) {
                return;
            }
            
            // å¤„ç†è®¢å•
            doProcess(orderId);
            
            // æ ‡è®°å·²å¤„ç†
            markProcessed(orderId);
        }
    } finally {
        if (lock.isHeldByCurrentThread()) {
            lock.unlock();
        }
    }
}
```

### 6.3 æ€§èƒ½ä¼˜åŒ–

```java
/**
 * åˆ†æ®µé”ï¼šå‡å°‘é”ç«äº‰
 */
public class SegmentLockService {
    
    private static final int SEGMENT_COUNT = 16;
    
    public void processOrder(String orderId) {
        // æ ¹æ®orderIdå“ˆå¸Œåˆ°ä¸åŒçš„é”
        int segment = Math.abs(orderId.hashCode()) % SEGMENT_COUNT;
        String lockKey = "order:lock:segment:" + segment;
        
        RLock lock = redissonClient.getLock(lockKey);
        
        try {
            if (lock.tryLock(5, 30, TimeUnit.SECONDS)) {
                // ä¸šåŠ¡é€»è¾‘
                doProcess(orderId);
            }
        } finally {
            if (lock.isHeldByCurrentThread()) {
                lock.unlock();
            }
        }
    }
}
```

---

## ğŸ“š å‚è€ƒèµ„æ–™

- ğŸ”— [Redissonå®˜æ–¹æ–‡æ¡£](https://github.com/redisson/redisson)
- ğŸ”— [Curatorå®˜æ–¹æ–‡æ¡£](https://curator.apache.org/)
- ğŸ“– ã€ŠRediså®æˆ˜ã€‹
- ğŸ“– ã€Šåˆ†å¸ƒå¼ç³»ç»ŸåŸç†ä¸èŒƒå‹ã€‹

---

*æœ€åæ›´æ–°ï¼š2025-10-27*
